<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Yt's Blog]]></title>
  <subtitle><![CDATA[Valar Morghulis]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://ytlvy.com//"/>
  <updated>2015-08-22T13:13:17.000Z</updated>
  <id>http://ytlvy.com//</id>
  
  <author>
    <name><![CDATA[Yt]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[iOS Version Number Auto Increase]]></title>
    <link href="http://ytlvy.com/2015/08/22/iOS-Version-Number-Auto-Increase/"/>
    <id>http://ytlvy.com/2015/08/22/iOS-Version-Number-Auto-Increase/</id>
    <published>2015-08-22T13:13:08.000Z</published>
    <updated>2015-08-22T13:13:17.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Build号_自动增长">Build号 自动增长</h2><p>在 iOS 应用的 <code>Info.plist</code> 中有两个版本号，即 Version 和 Build，对应键值为 <code>CFBundleShortVersionString</code> 和 <code>CFBundleVersion</code>。 一个是应用程序本身发布时的版本号，一个是表示这个发布版的二进制代码是第几次编译得到的。在 iOS8 之前由于苹果并没有约束这两者的关系，本人一般就把两个填一样的，如 2.1.4 等，也一直没出过问题，但是 最近由于苹果加入了测试功能，所有上传的 Build 都会保存，然后第一个因为某原因审核不过，再上传第 二个就出现了 Build 号冲突的问题。于是想到这才是 Build 的正确使用方法，它本应该是个整数， 在 Version 保持不变，Build 应该是要随着编译次数增长的！</p>
<h3 id="自动增长">自动增长</h3><p>那么如何让 Build 号自动增加呢？很早前搜到过一段代码，现在可以用上了：</p>
<ol>
<li>在 XCode 中选中项目，打开 Build Phases，如下图：</li>
</ol>
<p><img src="http://rickytan.cn/images/run-script.png" alt=""></p>
<ol>
<li>点 “+” 增加一个过程，选择“Run Script”，移到“Link Binary With Libraries”之后，并贴入以下代码：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># xcode-build-bump.sh</span><br><span class="line"># @desc Auto-increment the build number every time the project is run. </span><br><span class="line"># @usage</span><br><span class="line"># 1. <span class="operator"><span class="keyword">Select</span>: your Target <span class="keyword">in</span> Xcode</span><br><span class="line"># <span class="number">2.</span> <span class="keyword">Select</span>: Build Phases Tab</span><br><span class="line"># <span class="number">3.</span> <span class="keyword">Select</span>: <span class="keyword">Add</span> Build Phase -&gt; <span class="keyword">Add</span> Run Script</span><br><span class="line"># <span class="number">4.</span> Paste code below <span class="keyword">in</span> <span class="keyword">to</span> new <span class="string">"Run Script"</span> <span class="keyword">section</span></span><br><span class="line"># <span class="number">5.</span> Drag the <span class="string">"Run Script"</span> below <span class="string">"Link Binaries With Libraries"</span></span><br><span class="line"># <span class="number">6.</span> Insure that your <span class="keyword">starting</span> build <span class="built_in">number</span> <span class="keyword">is</span> <span class="keyword">set</span> <span class="keyword">to</span> a whole <span class="built_in">integer</span> <span class="keyword">and</span> <span class="keyword">not</span> a <span class="built_in">float</span> (e.g. <span class="number">1</span>, <span class="keyword">not</span> <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line">buildNumber=$(/usr/libexec/PlistBuddy -c <span class="string">"Print CFBundleVersion"</span> <span class="string">"$&#123;PROJECT_DIR&#125;/$&#123;INFOPLIST_FILE&#125;"</span>)</span><br><span class="line">buildNumber=$(($buildNumber + <span class="number">1</span>))</span><br><span class="line">/usr/libexec/PlistBuddy -c <span class="string">"Set :CFBundleVersion $buildNumber"</span> <span class="string">"$&#123;PROJECT_DIR&#125;/$&#123;INFOPLIST_FILE&#125;"</span></span></span><br></pre></td></tr></table></figure>
<ol>
<li>For Version </li>
</ol>
<figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># xcode-version-bump.sh</span></span><br><span class="line"><span class="comment"># @desc Auto-increment the version number (only) when a project is archived for export. </span></span><br><span class="line"><span class="comment"># @usage</span></span><br><span class="line"><span class="comment"># 1. Select: your Target in Xcode</span></span><br><span class="line"><span class="comment"># 2. Select: Build Phases Tab</span></span><br><span class="line"><span class="comment"># 3. Select: Add Build Phase -&gt; Add Run Script</span></span><br><span class="line"><span class="comment"># 4. Paste code below in to new "Run Script" section</span></span><br><span class="line"><span class="comment"># 5. Check the checkbox "Run script only when installing"</span></span><br><span class="line"><span class="comment"># 6. Drag the "Run Script" below "Link Binaries With Libraries"</span></span><br><span class="line"><span class="comment"># 7. Insure your starting version number is in SemVer format (e.g. 1.0.0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This splits a two-decimal version string, such as "0.45.123", allowing us to increment the third position.</span></span><br><span class="line">VERSIONNUM=$(/usr/libexec/PlistBuddy -c <span class="string">"Print CFBundleShortVersionString"</span> <span class="string">"<span class="constant">$&#123;PROJECT_DIR&#125;</span>/<span class="constant">$&#123;INFOPLIST_FILE&#125;</span>"</span>)</span><br><span class="line">NEWSUBVERSION=`echo <span class="variable">$VERSIONNUM</span> | awk -F <span class="string">"."</span> '&#123;<span class="literal">print</span> <span class="variable">$3</span>&#125;'`</span><br><span class="line">NEWSUBVERSION=$((<span class="variable">$NEWSUBVERSION</span> + <span class="number">1</span>))</span><br><span class="line">NEWVERSIONSTRING=`echo <span class="variable">$VERSIONNUM</span> | awk -F <span class="string">"."</span> '&#123;<span class="literal">print</span> <span class="variable">$1</span> <span class="string">"."</span> <span class="variable">$2</span> <span class="string">".'<span class="variable">$NEWSUBVERSION</span>'"</span> &#125;'`</span><br><span class="line">/usr/libexec/PlistBuddy -c <span class="string">"Set :CFBundleShortVersionString <span class="variable">$NEWVERSIONSTRING</span>"</span> <span class="string">"<span class="constant">$&#123;PROJECT_DIR&#125;</span>/<span class="constant">$&#123;INFOPLIST_FILE&#125;</span>"</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Build号_自动增长">Build号 自动增长</h2><p>在 iOS 应用的 <code>Info.plist</code> 中有两个版本号，即 Version 和 Build，对应键值为 <code>CFBundleShortVersionString</]]>
    </summary>
    
      <category term="IOS" scheme="http://ytlvy.com/tags/IOS/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SDWebimage pitfall]]></title>
    <link href="http://ytlvy.com/2015/08/22/SDWebimage-pitfall/"/>
    <id>http://ytlvy.com/2015/08/22/SDWebimage-pitfall/</id>
    <published>2015-08-22T13:11:19.000Z</published>
    <updated>2015-08-22T13:11:50.000Z</updated>
    <content type="html"><![CDATA[<p>@charset “UTF-8”;<br>/**</p>
<ul>
<li></li>
<li>@authors yanjie Guo (ytlvy2008@gmail.com)</li>
<li>@date    2015-08-22 20:50:22</li>
<li>@version 0.0.1</li>
<li>Copyright (c) 2015年 Guo yanjie. All rights reserved.<br>*/</li>
</ul>
<h2 id="SDWebImage_缓存相关用法">SDWebImage 缓存相关用法</h2><h3 id="计算缓存大小的方法：">计算缓存大小的方法：</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSUInteger</span>)getSize &#123;  </span><br><span class="line">    __block <span class="built_in">NSUInteger</span> size = <span class="number">0</span>;  </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span><span class="variable">.ioQueue</span>, ^&#123;  </span><br><span class="line">        <span class="built_in">NSDirectoryEnumerator</span> *fileEnumerator = [_fileManager enumeratorAtPath:<span class="keyword">self</span><span class="variable">.diskCachePath</span>];  </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSString</span> *fileName <span class="keyword">in</span> fileEnumerator) &#123;  </span><br><span class="line">            <span class="built_in">NSString</span> *filePath = [<span class="keyword">self</span><span class="variable">.diskCachePath</span> stringByAppendingPathComponent:fileName];  </span><br><span class="line">            <span class="built_in">NSDictionary</span> *attrs = [[<span class="built_in">NSFileManager</span> defaultManager] attributesOfItemAtPath:filePath error:<span class="literal">nil</span>];  </span><br><span class="line">            size += [attrs fileSize];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line">    <span class="keyword">return</span> size;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="清除缓存">清除缓存</h3><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SDImageCache *imageCache = [SDImageCache sharedImageCache]<span class="comment">;</span></span><br><span class="line">[imageCache clearMemory]<span class="comment">;</span></span><br><span class="line">[imageCache clearDisk]<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h3 id="关闭解压">关闭解压</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr_selector">[[SDImageCache sharedImageCache]</span> <span class="rule"><span class="attribute">setShouldDecompressImages</span>:<span class="value">NO]</span></span>;</span><br><span class="line"><span class="attr_selector">[[SDWebImageDownloader sharedDownloader]</span> <span class="rule"><span class="attribute">setShouldDecompressImages</span>:<span class="value">NO]</span></span>;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>@charset “UTF-8”;<br>/**</p>
<ul>
<li></li>
<li>@authors yanjie Guo (ytlvy2008@gmail.com)</li>
<li>@date    2015-08-22 20:50:22</li>
<li>]]>
    </summary>
    
      <category term="SDWebImage" scheme="http://ytlvy.com/tags/SDWebImage/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS Audio Lockscreen ]]></title>
    <link href="http://ytlvy.com/2015/08/22/iOS-Audio-Lockscreen/"/>
    <id>http://ytlvy.com/2015/08/22/iOS-Audio-Lockscreen/</id>
    <published>2015-08-22T13:09:26.000Z</published>
    <updated>2015-08-22T13:09:58.000Z</updated>
    <content type="html"><![CDATA[<h2 id="iOS音乐后台播放及锁屏相关">iOS音乐后台播放及锁屏相关</h2><h3 id="音乐后台播放">音乐后台播放</h3><ol>
<li>首先修改info.plist </li>
</ol>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Required <span class="attribute">background</span> modes  -- [</span><br><span class="line">  item0   ==&gt; App plays <span class="tag">audio</span> or streams audio/<span class="tag">video</span> using AirPlay</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20150806174938474" alt=""></p>
<ol>
<li>其次引入两个需要的框架</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;AVFoundation/AVFoundation.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;MediaPlayer/MediaPlayer.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<ol>
<li>设置播放器及后台播放</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"><span class="comment">//    设置后台播放</span></span><br><span class="line">    [[<span class="built_in">AVAudioSession</span> sharedInstance] setCategory:<span class="built_in">AVAudioSessionCategoryPlayback</span> error:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//    设置播放器</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> fileURLWithPath:[[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"那些花儿"</span> ofType:<span class="string">@"mp3"</span>] ];</span><br><span class="line">    _player = [[<span class="built_in">AVPlayer</span> alloc] initWithURL:url];</span><br><span class="line">    [_player play];</span><br><span class="line">    _isPlayingNow = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后台播放显示信息设置</span></span><br><span class="line">    [<span class="keyword">self</span> setPlayingInfo];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<ol>
<li>设置后台播放时显示的东西，例如歌曲名字，图片等</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setPlayingInfo &#123;</span><br><span class="line"><span class="comment">//    &lt;MediaPlayer/MediaPlayer.h&gt;</span></span><br><span class="line">    <span class="built_in">MPMediaItemArtwork</span> *artWork = [[<span class="built_in">MPMediaItemArtwork</span> alloc] initWithImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"pushu.jpg"</span>]];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSDictionary</span> *dic = @&#123;<span class="built_in">MPMediaItemPropertyTitle</span>:<span class="string">@"那些花儿"</span>,</span><br><span class="line">                          <span class="built_in">MPMediaItemPropertyArtist</span>:<span class="string">@"朴树"</span>,</span><br><span class="line">                          <span class="built_in">MPMediaItemPropertyArtwork</span>:artWork</span><br><span class="line">                          &#125;;</span><br><span class="line">    [[<span class="built_in">MPNowPlayingInfoCenter</span> defaultCenter] setNowPlayingInfo:dic];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>远程控制设置</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidAppear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line"><span class="comment">//    接受远程控制</span></span><br><span class="line">    [<span class="keyword">self</span> becomeFirstResponder];</span><br><span class="line">    [[<span class="built_in">UIApplication</span> sharedApplication] beginReceivingRemoteControlEvents];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidDisappear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line"><span class="comment">//    取消远程控制</span></span><br><span class="line">    [<span class="keyword">self</span> resignFirstResponder];</span><br><span class="line">    [[<span class="built_in">UIApplication</span> sharedApplication] endReceivingRemoteControlEvents];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - 接收方法的设置</span></span><br><span class="line">- (<span class="keyword">void</span>)remoteControlReceivedWithEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="keyword">if</span> (event<span class="variable">.type</span> == <span class="built_in">UIEventTypeRemoteControl</span>) &#123;  <span class="comment">//判断是否为远程控制</span></span><br><span class="line">        <span class="keyword">switch</span> (event<span class="variable">.subtype</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span>  <span class="built_in">UIEventSubtypeRemoteControlPlay</span>:</span><br><span class="line">                <span class="keyword">if</span> (!_isPlayingNow) &#123;</span><br><span class="line">                    [_player play];</span><br><span class="line">                &#125;</span><br><span class="line">                _isPlayingNow = !_isPlayingNow;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlPause</span>:</span><br><span class="line">                <span class="keyword">if</span> (_isPlayingNow) &#123;</span><br><span class="line">                    [_player pause];</span><br><span class="line">                &#125;</span><br><span class="line">                _isPlayingNow = !_isPlayingNow;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlNextTrack</span>:</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"下一首"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlPreviousTrack</span>:</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"上一首 "</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="iOS_锁屏操作">iOS 锁屏操作</h3><p>如果你的App不需要” 喜欢/书签”等功能的话，直接使用RemoteControl就行。<br>对于RemoteCommand，一个SEL只能对应一个command。<br>另外就是RemoteCommand的callback会先于RemoteControl，不过也就几ms的间隔。而且使用RemoteControl更方便。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  ViewController.m</span></span><br><span class="line"><span class="comment">//  mprc</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by BlueCocoa on 15/4/6.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2015年 0xBBC. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"> </span><br><span class="line"><span class="preprocessor">#import <span class="title">"ViewController.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;MediaPlayer/MediaPlayer.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;AVFoundation/AVFoundation.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line">@interfaceViewController ()&lt;<span class="built_in">AVAudioPlayerDelegate</span>&gt;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">AVAudioPlayer</span> * player;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">MPRemoteCommand</span> * mprcNext, * mprcPlay, * mprcPause, * mprcPrevious;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">MPFeedbackCommand</span> * mpfbLike, * mpfbDislike, * mpfbBookMark;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> bookmark;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@synthesize</span> player;</span><br><span class="line"><span class="keyword">@synthesize</span> mprcNext,mprcPlay,mprcPause,mprcPrevious;</span><br><span class="line"><span class="keyword">@synthesize</span> mpfbLike,mpfbDislike,mpfbBookMark;</span><br><span class="line"><span class="keyword">@synthesize</span> bookmark;</span><br><span class="line"> </span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="built_in">NSError</span> *error;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.player</span> = [[<span class="built_in">AVAudioPlayer</span> alloc] initWithContentsOfURL:[<span class="built_in">NSURLfileURLWithPath</span>:[[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"1"</span> ofType:<span class="string">@"m4a"</span>]] error:&amp;error];</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,error);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">AVAudioSession</span> *session = [<span class="built_in">AVAudioSession</span> sharedInstance];</span><br><span class="line">    [session setCategory:<span class="built_in">AVAudioSessionCategoryPlayback</span> error:<span class="literal">nil</span>];</span><br><span class="line">    [session setActive:<span class="literal">YES</span> error:<span class="literal">nil</span>];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.player</span> setDelegate:<span class="keyword">self</span>];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.player</span> prepareToPlay];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.player</span> play];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.player</span> setNumberOfLoops:-<span class="number">1</span>];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.player</span> setVolume:<span class="number">1</span>];</span><br><span class="line">    [[<span class="built_in">UIApplication</span> sharedApplication] beginReceivingRemoteControlEvents];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">self</span><span class="variable">.mprcNext</span> = [<span class="built_in">MPRemoteCommandCenter</span> sharedCommandCenter]<span class="variable">.nextTrackCommand</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mprcNext</span> addTargetWithHandler:^<span class="built_in">MPRemoteCommandHandlerStatus</span>(<span class="built_in">MPRemoteCommandEvent</span> *event) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">MPRemoteCommandHandlerStatusSuccess</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mprcNext</span> setEnabled:<span class="literal">YES</span>];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mprcNext</span> addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(nextTrackCommand:)];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.mprcPlay</span> = [<span class="built_in">MPRemoteCommandCenter</span> sharedCommandCenter]<span class="variable">.playCommand</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mprcPlay</span> addTargetWithHandler:^<span class="built_in">MPRemoteCommandHandlerStatus</span>(<span class="built_in">MPRemoteCommandEvent</span> *event) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">MPRemoteCommandHandlerStatusSuccess</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mprcPlay</span> setEnabled:<span class="literal">YES</span>];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mprcPlay</span> addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(playCommand:)];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.mprcPause</span> = [<span class="built_in">MPRemoteCommandCenter</span> sharedCommandCenter]<span class="variable">.pauseCommand</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mprcPause</span> addTargetWithHandler:^<span class="built_in">MPRemoteCommandHandlerStatus</span>(<span class="built_in">MPRemoteCommandEvent</span> *event) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">MPRemoteCommandHandlerStatusSuccess</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mprcPause</span> setEnabled:<span class="literal">YES</span>];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mprcPause</span> addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(pauseCommand:)];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span><span class="variable">.mprcPrevious</span> = [<span class="built_in">MPRemoteCommandCenter</span> sharedCommandCenter]<span class="variable">.previousTrackCommand</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mprcPrevious</span> addTargetWithHandler:^<span class="built_in">MPRemoteCommandHandlerStatus</span>(<span class="built_in">MPRemoteCommandEvent</span> *event) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">MPRemoteCommandHandlerStatusSuccess</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mprcPrevious</span> setEnabled:<span class="literal">YES</span>];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mprcPrevious</span> addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(previousTrackCommand:)];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.mpfbLike</span> = [<span class="built_in">MPRemoteCommandCenter</span> sharedCommandCenter]<span class="variable">.likeCommand</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mpfbLike</span> addTargetWithHandler:^<span class="built_in">MPRemoteCommandHandlerStatus</span>(<span class="built_in">MPRemoteCommandEvent</span> *event) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">MPRemoteCommandHandlerStatusSuccess</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mpfbLike</span> setEnabled:<span class="literal">YES</span>];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mpfbLike</span> addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(likeCommand:)];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mpfbLike</span> setLocalizedTitle:<span class="string">@"喜欢这首歌"</span>];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mpfbLike</span> setLocalizedShortTitle:<span class="string">@"喜欢"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.mpfbDislike</span> =[<span class="built_in">MPRemoteCommandCenter</span> sharedCommandCenter]<span class="variable">.dislikeCommand</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mpfbDislike</span> addTargetWithHandler:^<span class="built_in">MPRemoteCommandHandlerStatus</span>(<span class="built_in">MPRemoteCommandEvent</span> *event) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">MPRemoteCommandHandlerStatusSuccess</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mpfbDislike</span> addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(dislikeCommand:)];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mpfbDislike</span> setEnabled:<span class="literal">YES</span>];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mpfbDislike</span> setLocalizedTitle:<span class="string">@"不喜欢这首歌"</span>];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mpfbDislike</span> setLocalizedShortTitle:<span class="string">@"不喜欢"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.mpfbBookMark</span> = [<span class="built_in">MPRemoteCommandCenter</span> sharedCommandCenter]<span class="variable">.bookmarkCommand</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mpfbBookMark</span> addTargetWithHandler:^<span class="built_in">MPRemoteCommandHandlerStatus</span>(<span class="built_in">MPRemoteCommandEvent</span> *event) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">MPRemoteCommandHandlerStatusSuccess</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mpfbBookMark</span> setEnabled:<span class="literal">YES</span>];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mpfbBookMark</span> addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(bookmarkCommand:)];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mpfbBookMarksetLocalizedTitle</span>:<span class="string">@"书签"</span>];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mpfbBookMarksetLocalizedShortTitle</span>:<span class="string">@"书签"</span>];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.bookmark</span> = <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)bookmarkCommand:(<span class="built_in">MPFeedbackCommandEvent</span> *)sender</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.bookmark</span> = !<span class="keyword">self</span><span class="variable">.bookmark</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Bookmark"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dislikeCommand:(<span class="built_in">MPFeedbackCommandEvent</span> *)sender</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mpfbDislike</span> setEnabled:<span class="literal">NO</span>];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mpfbLike</span> setEnabled:<span class="literal">YES</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Dislike"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)likeCommand:(<span class="built_in">MPFeedbackCommandEvent</span> *)sender</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mpfbLike</span> setEnabled:<span class="literal">NO</span>];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mpfbDislikesetEnabled</span>:<span class="literal">YES</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Like"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)previousTrackCommand:(<span class="built_in">MPRemoteCommandEvent</span> *)sender</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Previous Track"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)playCommand:(<span class="built_in">MPRemoteCommandEvent</span> *)sender</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Play in MPRemoteCommandEvent"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)pauseCommand:(<span class="built_in">MPRemoteCommandEvent</span> *)sender</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Pause in MPRemoteCommandEvent"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)nextTrackCommand:(<span class="built_in">MPRemoteCommandEvent</span> *)sender</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Next Track"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)remoteControlReceivedWithEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event<span class="variable">.subtype</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlPlay</span>:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Play in RemoteControlEvent"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlPause</span>:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Pause in RemoteControlEvent"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="iOS音乐后台播放及锁屏相关">iOS音乐后台播放及锁屏相关</h2><h3 id="音乐后台播放">音乐后台播放</h3><ol>
<li>首先修改info.plist </li>
</ol>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Required <span class="attribute">background</span> modes  -- [</span><br><span class="line">  item0   ==&gt; App plays <span class="tag">audio</span> or streams audio/<span class="tag">video</span> using AirPlay</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20150806174938474" alt=""></p>
<ol>
<li>其次引入两个需要的框架</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;AVFoundation/AVFoundation.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;MediaPlayer/MediaPlayer.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<ol>
<li>设置播放器及后台播放</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"><span class="comment">//    设置后台播放</span></span><br><span class="line">    [[<span class="built_in">AVAudioSession</span> sharedInstance] setCategory:<span class="built_in">AVAudioSessionCategoryPlayback</span> error:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//    设置播放器</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> fileURLWithPath:[[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"那些花儿"</span> ofType:<span class="string">@"mp3"</span>] ];</span><br><span class="line">    _player = [[<span class="built_in">AVPlayer</span> alloc] initWithURL:url];</span><br><span class="line">    [_player play];</span><br><span class="line">    _isPlayingNow = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后台播放显示信息设置</span></span><br><span class="line">    [<span class="keyword">self</span> setPlayingInfo];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Audio" scheme="http://ytlvy.com/tags/Audio/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C programming -- Precompile]]></title>
    <link href="http://ytlvy.com/2015/08/22/C-programming-Precompile/"/>
    <id>http://ytlvy.com/2015/08/22/C-programming-Precompile/</id>
    <published>2015-08-22T12:46:56.000Z</published>
    <updated>2015-08-22T12:47:27.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/kenshincui/p/3854242.html" target="_blank" rel="external">reference</a></p>
<h2 id="C语言之预处理">C语言之预处理</h2><h3 id="概述">概述</h3><p>大家都知道一个C程序的运行包括编译和链接两个阶段，其实在编译之前预处理器首先要进行预处理操作，将处理完产生的一个新的源文件进行编译。由于预处理指令是在编译之前就进行了，因此很多时候它要比在程序运行时进行操作效率高。在C语言中包括三类预处理指令，今天将一一介绍：</p>
<ul>
<li>宏定义</li>
<li>条件编译</li>
<li>文件包含</li>
</ul>
<h3 id="宏定义">宏定义</h3><p>对于程序中经常用到的一些常量或者简短的函数我们通常使用宏定义来处理，这样做的好处是对于程序中所有的配置我们可以统一在宏定义中进行管理，而且由于宏定义是在程序编译之前进行替换相比定义成全局变量或函数效率更高。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  Pretreatment</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-6-28.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PI 3.14 <span class="comment">//宏定义一般大写</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> R 10</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> S 2*PI*R <span class="comment">//在另一个宏里面引用了上面的宏</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> r=<span class="number">10.5</span>;</span><br><span class="line">    <span class="keyword">double</span> area=PI*r*r;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"area=%.2f\n"</span>,area);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> a=S;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%.2f\n"</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"PI=3.14\n"</span>);<span class="comment">//注意输出结果不是3.14=3.14而是PI=3.14，字符串中的PI并不会被替换</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">undef</span> PI <span class="comment">//强制终止宏定义，否则它的范围一直到文件结束</span></span></span><br><span class="line">    <span class="keyword">int</span> PI=<span class="number">3.1415926</span>;</span><br><span class="line">    <span class="keyword">double</span> area2=PI*r*r;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"area2=%.2f\n"</span>,area2);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>宏定义实际的操作就是在预处理时进行对应替换，这个阶段不管语法是否正确，而且对于字符串中出现的宏名不会进行替换。宏定义的功能事实上是非常强大的，除了简单的常量替换还可以传入参数：</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  1.2.c</span></span><br><span class="line"><span class="comment">//  Pretreatment</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-7-17.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> SUM(a,b) a+b</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> SUB(a,b) (a-b)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MUL (a,b) (a*b) <span class="comment">//这么定义是错误的，预处理器会认为宏名为”MUL“,替换内容为”(a,b) (a*b)“</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">2</span>,b=<span class="number">3</span>,c,d;</span><br><span class="line">    c=SUM(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c=%d\n"</span>,c); <span class="comment">//结果：c=5</span></span><br><span class="line">    d=SUM(a, b)*<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"d=%d\n"</span>); <span class="comment">//结果：8,为什么不是10呢？因为替换后：d=a+b*2也就是2+3*2=8</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> e=SUB(b, a)*<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"(b-a)*2=%d\n"</span>,e); <span class="comment">//结果：2,如果SUB定义时不加括号这里应该是-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面我们可以看出带参数的宏功能很强大，有点类似于函数，同函数不同的是它只是简单的替换，不涉及存储空间分配，参数、返回值等问题，但是由于它在预处理阶段展开，所以一般效率较高。使用带参数的宏需要注意的就是结果最好用括号括起来否则很容易出现问题（在上面的SUM例子中我们应该已经看到了）；还有一点就是带参数的宏定义时名称和参数之间不要有空格。</p>
<h3 id="条件编译">条件编译</h3><p>条件编译其实就是在编译之前预处理器根据预处理指令判断对应的条件，如果条件满足就将对应的代码编译进去，否则代码就根本不进入编译环节（相当于根本就没有这段代码）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  Pretreatment</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-06-28.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> COUNT 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//判断是否定义了 COUNT 宏</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> defined(COUNT) <span class="comment">//等价于：#ifdef COUNT,相反如果判断没有定义过则可以通过#if !defined(COUNT)或者#ifndef COUNT</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"COUNT defined\n"</span>);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//判断宏定义COUNT是否等于1</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> COUNT==1</span></span><br><span class="line">    showMessage(<span class="string">"hello,world!\n"</span>);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">    say();</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="文件包含">文件包含</h3><p>文件包含指令#include在前面也多次使用过，这里再次强调一下。首先使用#include”xxx”包含和使用#include <xxx>包含的不同之处就是使用&lt;&gt;包含时，预处理器会搜索C函数库头文件路径下的文件，而使用””包含时首先搜索程序所在目录，其次搜索系统Path定义目录，如果还是找不到才会搜索C函数库头文件所在目录。</xxx></p>
<p>另外在使用#include的时候我们需要注意包含文件的时候是不能递归包含的，例如a.h文件包含b.h，而b.h就不能再包含a.h了；还有就是重复包含虽然是允许的（这里指的是重复包含头文件）但是这会降低编译性能，不妨看一下下面的例子：</p>
<p><img src="http://images.cnitblog.com/blog/62046/201407/182035388189767.png" alt=""></p>
<p>上面有三段代码，在main.c和person.h中都包含了message.h而main.c自身又包含了person.h,这样程序在预处理阶段会对包含内容进行替换，替换后mian.c中包含了两个#include “message.h”虽然没有报错，但这会影响编译的性能，正确的做法应该是这样的：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="id">#ifndef</span> _PERSON_H_</span><br><span class="line"><span class="hexcolor">#def</span>ine _PERSON_H_</span><br><span class="line"></span><br><span class="line"><span class="id">#include</span> <span class="string">"person.h"</span></span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p><img src="http://images.cnitblog.com/blog/62046/201407/182035402567293.png" alt=""></p>
<p>其实就是用宏定义判断一个宏是否定义了，如果没有定义则会定义这个宏，这样以来如果已经包含过则这个宏定义肯定已经定义过了，即使再包含也不会重新定义了，下面的代码也就不会包含进去。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://www.cnblogs.com/kenshincui/p/3854242.html">reference</a></p>
<h2 id="C语言之预处理">C语言之预处理</h2><h3 id="概述">概述</h3><p>大家都知道一个C程序的运行包括编译和链接两个阶段，其实在编译之前预处理器首先要进行预处理操作，将处理完产生的一个新的源文件进行编译。由于预处理指令是在编译之前就进行了，因此很多时候它要比在程序运行时进行操作效率高。在C语言中包括三类预处理指令，今天将一一介绍：</p>
<ul>
<li>宏定义</li>
<li>条件编译</li>
<li>文件包含</li>
</ul>
<h3 id="宏定义">宏定义</h3><p>对于程序中经常用到的一些常量或者简短的函数我们通常使用宏定义来处理，这样做的好处是对于程序中所有的配置我们可以统一在宏定义中进行管理，而且由于宏定义是在程序编译之前进行替换相比定义成全局变量或函数效率更高。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  Pretreatment</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-6-28.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PI 3.14 <span class="comment">//宏定义一般大写</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> R 10</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> S 2*PI*R <span class="comment">//在另一个宏里面引用了上面的宏</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> r=<span class="number">10.5</span>;</span><br><span class="line">    <span class="keyword">double</span> area=PI*r*r;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"area=%.2f\n"</span>,area);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> a=S;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%.2f\n"</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"PI=3.14\n"</span>);<span class="comment">//注意输出结果不是3.14=3.14而是PI=3.14，字符串中的PI并不会被替换</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">undef</span> PI <span class="comment">//强制终止宏定义，否则它的范围一直到文件结束</span></span></span><br><span class="line">    <span class="keyword">int</span> PI=<span class="number">3.1415926</span>;</span><br><span class="line">    <span class="keyword">double</span> area2=PI*r*r;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"area2=%.2f\n"</span>,area2);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>宏定义实际的操作就是在预处理时进行对应替换，这个阶段不管语法是否正确，而且对于字符串中出现的宏名不会进行替换。宏定义的功能事实上是非常强大的，除了简单的常量替换还可以传入参数：</p>]]>
    
    </summary>
    
      <category term="C" scheme="http://ytlvy.com/tags/C/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C programming -- Struct]]></title>
    <link href="http://ytlvy.com/2015/08/22/C-programming-Struct/"/>
    <id>http://ytlvy.com/2015/08/22/C-programming-Struct/</id>
    <published>2015-08-22T12:45:36.000Z</published>
    <updated>2015-08-22T12:46:06.000Z</updated>
    <content type="html"><![CDATA[<p>@charset “UTF-8”;<br>/**</p>
<ul>
<li></li>
<li>@authors Your Name (you@example.org)</li>
<li>@date    2015-08-16 11:06:45</li>
<li>@version $Id$</li>
<li>Copyright (c) 2015年 Guo yanjie. All rights reserved.<br>*/</li>
</ul>
<p><a href="http://www.cnblogs.com/kenshincui/p/3856543.html" target="_blank" rel="external">reference</a></p>
<h2 id="C语言之构造类型">C语言之构造类型</h2><h3 id="概述">概述</h3><p>在第一节中我们就提到C语言的构造类型，分为：数组、结构体、枚举、共用体，当然前面数组的内容已经说了很多了，这一节将会重点说一下其他三种类型。</p>
<ul>
<li>结构体</li>
<li>枚举</li>
<li>共用体</li>
</ul>
<h3 id="结构体">结构体</h3><p>数组中存储的是一系列相同的数据类型，那么如果想让一个变量存储不同的数据类型就要使用结构体，结构体定义类似于C++、C#、Java等高级语言中类的定义，但事实上它们又有着很大的区别。结构体是一种类型，并非一个变量，只是这种类型可以由其他C语言基本类型共同组成。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  main.c</span><br><span class="line">//  ConstructedType</span><br><span class="line">//</span><br><span class="line">//  Created by Kenshin Cui on 14-7-18.</span><br><span class="line">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">//结构体类型Date</span><br><span class="line">struct Date&#123;</span><br><span class="line">    int year;</span><br><span class="line">    int month;</span><br><span class="line">    int day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct <span class="keyword">Person</span>&#123;</span><br><span class="line">    char *name;</span><br><span class="line">    int age;</span><br><span class="line">    struct Date birthday;//一个结构体中使用了另一个结构体类型，结构体类型变量声明前必须加上struct关键字</span><br><span class="line">    float height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv<span class="comment">[]</span>) &#123;</span><br><span class="line">    struct <span class="keyword">Person</span> p=&#123;<span class="string">"Kenshin"</span>,28,&#123;1986,8,8&#125;,1.72&#125;;</span><br><span class="line">    //定义结构体变量并初始化,不允许先定义再直接初始化，例如：struct <span class="keyword">Person</span> p;p=&#123;<span class="string">"Kenshin"</span>,28,&#123;1986,8,8&#125;,1.72&#125;;是错误的，但是可以分别赋值，例如p.name=<span class="string">"Kenshin"</span></span><br><span class="line">    </span><br><span class="line">    printf(<span class="string">"name=%s,age=%d,birthday=%d-%d-%d,height=%.2f\n"</span>,p.name,p.age,p.birthday.year,p.birthday.month,p.birthday.day,p.height); </span><br><span class="line">    //结果：name=Kenshin,age=28,birthday=1986-8-8,height=1.72，结构体的引用是通过<span class="string">"结构体变量.成员名称"</span>(注意和结构体指针访问结构体成员变量区分，结构体指针使用p-&gt;a的形式访问)</span><br><span class="line">    </span><br><span class="line">    printf(<span class="string">"len(Date)=%lu,len(Person)=%lu\n"</span>,sizeof(struct Date),sizeof(struct <span class="keyword">Person</span>)); </span><br><span class="line">    //结果：len(Date)=12,len(<span class="keyword">Person</span>)=32</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>对于上面的例子需要做出如下说明：</p>
<ul>
<li>可以在定义结构体类型的同时声明结构体变量；</li>
<li>如果定义结构体类型的同时声明结构体变量，此时结构体名称可以省略；</li>
<li>定义结构体类型并不会分配内存，在定义结构体变量的时候才进行内存分配（同基本类型时类似的）；</li>
<li>结构体类型的所占用内存大型等于所有成员占用内存大小之和（如果不考虑内存对齐的前提下）；</li>
</ul>
<p>对第4点需要进行说明，例如上面代码是在64位编译器下运行的结果（int长度4，char长度1，float类型4），Date=4+4+4=12。但是对于Person却没有那么简单了，因为按照正常方式计算Person=8+4+12+4=28，但是从上面代码中给出的结果是32，为什么呢？这里不得不引入一个概念“内存对齐”，关于内存对齐的概念在这里不做详细说明，大家需要了解的是：在Mac OS X中对齐参数默认为8（可以通过在代码中添加#pragma pack(8)改变对齐参数），如果结构体中的类型不大于8，那么结构体长度就是其成员类型之和，但是如果成员变量的长度大于这个对齐参数那么得到的结果就不一定是各个成员变量之和了。Person类型的长度之所以是32，其实主要原因是因为Date类型长度12在存储时其偏移量12不是8的倍数，考虑到内存对齐的原因需要添加4个补齐长度，这里使用表格的形式列出了具体原因：</p>
<p><img src="http://images.cnitblog.com/blog/62046/201407/201858560376210.png" alt=""></p>
<p>接下来看一下结构体数组、指向结构体的指针：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  main.c</span><br><span class="line">//  ConstructedType</span><br><span class="line">//</span><br><span class="line">//  Created by Kenshin Cui on 14-7-18.</span><br><span class="line">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">struct Date&#123;</span><br><span class="line">    int year;</span><br><span class="line">    int month;</span><br><span class="line">    int day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct <span class="keyword">Person</span>&#123;</span><br><span class="line">    char *name;</span><br><span class="line">    int age;</span><br><span class="line">    struct Date birthday;</span><br><span class="line">    float height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void changeValue(struct <span class="keyword">Person</span> <span class="keyword">person</span>)&#123;</span><br><span class="line">    <span class="keyword">person</span>.height=1.80;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv<span class="comment">[]</span>) &#123;</span><br><span class="line">    struct <span class="keyword">Person</span> persons<span class="comment">[]</span>=&#123;</span><br><span class="line">        &#123;<span class="string">"Kenshin"</span>,28,&#123;1986,8,8&#125;,1.72&#125;,</span><br><span class="line">        &#123;<span class="string">"Kaoru"</span>,27,&#123;1987,8,8&#125;,1.60&#125;,</span><br><span class="line">        &#123;<span class="string">"Rosa"</span>,29,&#123;1985,8,8&#125;,1.60&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    for (int i=0; i&lt;3; ++i) &#123;</span><br><span class="line">        printf(<span class="string">"name=%s,age=%d,birthday=%d-%d-%d,height=%.2f\n"</span>,</span><br><span class="line">               persons<span class="comment">[i]</span>.name,</span><br><span class="line">               persons<span class="comment">[i]</span>.age,</span><br><span class="line">               persons<span class="comment">[i]</span>.birthday.year,</span><br><span class="line">               persons<span class="comment">[i]</span>.birthday.month,</span><br><span class="line">               persons<span class="comment">[i]</span>.birthday.day,</span><br><span class="line">               persons<span class="comment">[i]</span>.height);</span><br><span class="line">    &#125;</span><br><span class="line">    /*输出结果：</span><br><span class="line">     name=Kenshin,age=28,birthday=1986-8-8,height=1.72</span><br><span class="line">     name=Kaoru,age=27,birthday=1987-8-8,height=1.60</span><br><span class="line">     name=Rosa,age=29,birthday=1985-8-8,height=1.60</span><br><span class="line">     */</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    struct <span class="keyword">Person</span> <span class="keyword">person</span>=persons<span class="comment">[0]</span>;</span><br><span class="line">    changeValue(<span class="keyword">person</span>);</span><br><span class="line">    printf(<span class="string">"name=%s,age=%d,birthday=%d-%d-%d,height=%.2f\n"</span>,</span><br><span class="line">           persons<span class="comment">[0]</span>.name,</span><br><span class="line">           persons<span class="comment">[0]</span>.age,</span><br><span class="line">           persons<span class="comment">[0]</span>.birthday.year,</span><br><span class="line">           persons<span class="comment">[0]</span>.birthday.month,</span><br><span class="line">           persons<span class="comment">[0]</span>.birthday.day,</span><br><span class="line">           persons<span class="comment">[0]</span>.height);</span><br><span class="line">    /*输出结果：</span><br><span class="line">     name=Kenshin,age=28,birthday=1986-8-8,height=1.72</span><br><span class="line">     */</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    struct <span class="keyword">Person</span> *p=&amp;<span class="keyword">person</span>;</span><br><span class="line">    printf(<span class="string">"name=%s,age=%d,birthday=%d-%d-%d,height=%.2f\n"</span>,</span><br><span class="line">           (*p).name,</span><br><span class="line">           (*p).age,</span><br><span class="line">           (*p).birthday.year,</span><br><span class="line">           (*p).birthday.month,</span><br><span class="line">           (*p).birthday.day,</span><br><span class="line">           (*p).height);</span><br><span class="line">    /*输出结果：</span><br><span class="line">     name=Kenshin,age=28,birthday=1986-8-8,height=1.72</span><br><span class="line">     */</span><br><span class="line">    printf(<span class="string">"name=%s,age=%d,birthday=%d-%d-%d,height=%.2f\n"</span>,</span><br><span class="line">           p-&gt;name,</span><br><span class="line">           p-&gt;age,</span><br><span class="line">           p-&gt;birthday.year,</span><br><span class="line">           p-&gt;birthday.month,</span><br><span class="line">           p-&gt;birthday.day,</span><br><span class="line">           p-&gt;height);</span><br><span class="line">    /*输出结果：</span><br><span class="line">     name=Kenshin,age=28,birthday=1986-8-8,height=1.72</span><br><span class="line">     */</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构体作为函数参数传递的是成员的值（值传递而不是引用传递），对于结构体指针而言可以通过”-&gt;”操作符进行访问。</p>
<h3 id="枚举">枚举</h3><p>枚举类型是比较简单的一种数据类型，事实上在C语言中枚举类型是作为整形常量进行处理的，通常称为“枚举常量”。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  ConstructedType</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-7-18.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Season&#123; <span class="comment">//默认情况下spring=0，summer=1,autumn=2,winter=3</span></span><br><span class="line">    spring,</span><br><span class="line">    summer,</span><br><span class="line">    autumn,</span><br><span class="line">    winter</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> Season season=summer; <span class="comment">//枚举赋值,等价于season=1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"summer=%d\n"</span>,season); <span class="comment">//结果：summer=1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(season=spring;season&lt;=winter;++season)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"element value=%d\n"</span>,season);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*结果：</span><br><span class="line">     element value=0</span><br><span class="line">     element value=1</span><br><span class="line">     element value=2</span><br><span class="line">     element value=3</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是枚举成员默认值从0开始，如果给其中一个成员赋值，其它后面的成员将依次赋值，例如上面如果summer手动指定为8，则autumn=9，winter=10，而sprint还是0。</p>
<h3 id="共用体">共用体</h3><p>共用体又叫联合，因为它的关键字是union（貌似数据库操作经常使用这个关键字），它的使用不像枚举和结构体那么频繁，但是作为C语言中的一种数据类型我们也有必要弄清它的用法。从前面的分析我们知道结构体的总长度等于所有成员的和（当然此时还可能遇到对齐问题），但是和结构体不同的是共用体所有成员共用一块内存，顺序从低地址开始存放，一次只能使用其中一个成员，union最终大小由共用体中最大的成员决定，对某一成员赋值可能会覆盖另一个成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  ConstructedType</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-7-20.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> Type&#123;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">union</span> Type t;</span><br><span class="line">    t.a=<span class="string">'a'</span>;</span><br><span class="line">    t.b=<span class="number">10</span>;</span><br><span class="line">    t.c=<span class="number">65796</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"address(Type)=%x,address(t.a)=%x,address(t.b)=%x,address(t.c)=%x\n"</span>,&amp;t,&amp;t.a,&amp;t.b,&amp;t.c);</span><br><span class="line">    <span class="comment">//结果：address(Type)=5fbff7b8,address(t.a)=5fbff7b8,address(t.b)=5fbff7b8,address(t.c)=5fbff7b8</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"len(Type)=%d\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">union</span> Type));</span><br><span class="line">    <span class="comment">//结果：len(Type)=4</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"t.a=%d,t.b=%d,t.c=%d\n"</span>,t.a,t.b,t.c);</span><br><span class="line">    <span class="comment">//结果:t.a=4,t.b=260,t.c=65796</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要重点解释一个问题：为什么t.a、t.b、t.c输出结果分别是4、260、65796，当然t.c等于65796并不奇怪，但是t.a前面赋值为’a’不应该是97吗，而t.b不应该是10吗？其实如果弄清这个问题共用体的概念基本就清楚了。</p>
<p>根据前面提到的，共用体其实每次只能使用其中一个成员，对于上面的代码经过三次赋值最终使用的其实就是t.c,而通过上面的输出结果我们也确实看到c是有效的。共用体有一个特点就是它的成员存储在同一块内存区域，这块区域的大小需要根据它的成员中长度最大的成员长度而定。由于上面的代码是在64位编译器下编译的，具体长度：char=1，short int=2，int=4，所以得出结论，Type的长度为4，又根据上面输出的地址，可以得到下面的存储信息(注意数据的存储方式：高地址存储高位，低地址存储地位)：</p>
<p><img src="http://images.cnitblog.com/blog/62046/201407/201858575218722.png" alt=""></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当读取c的时候，它的二进制是“<span class="number">00000000</span>  <span class="number">00000001</span>  <span class="number">00000001</span>  <span class="number">00000100</span>”，换算成十进制就是65796；而经过三次赋值后，此时b的存储就已经被c成员的低位数据覆盖，b的长度是二，所以从起始地址取两个字节得到的二进制数据此时是“<span class="number">00000001</span>  <span class="number">00000100</span>”（b原来的数据已经被c低2位数据覆盖，其实此时就是c的低2位数据），换算成十进制就是260；类似的a此时的数据就是c的低一位数据”<span class="number">00000100</span>”,换算成十进制就是4。</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>@charset “UTF-8”;<br>/**</p>
<ul>
<li></li>
<li>@authors Your Name (you@example.org)</li>
<li>@date    2015-08-16 11:06:45</li>
<li>@version $Id$</li>
<li>Copyright (c) 2015年 Guo yanjie. All rights reserved.<br>*/</li>
</ul>
<p><a href="http://www.cnblogs.com/kenshincui/p/3856543.html">reference</a></p>
<h2 id="C语言之构造类型">C语言之构造类型</h2><h3 id="概述">概述</h3><p>在第一节中我们就提到C语言的构造类型，分为：数组、结构体、枚举、共用体，当然前面数组的内容已经说了很多了，这一节将会重点说一下其他三种类型。</p>
<ul>
<li>结构体</li>
<li>枚举</li>
<li>共用体</li>
</ul>
<h3 id="结构体">结构体</h3><p>数组中存储的是一系列相同的数据类型，那么如果想让一个变量存储不同的数据类型就要使用结构体，结构体定义类似于C++、C#、Java等高级语言中类的定义，但事实上它们又有着很大的区别。结构体是一种类型，并非一个变量，只是这种类型可以由其他C语言基本类型共同组成。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  main.c</span><br><span class="line">//  ConstructedType</span><br><span class="line">//</span><br><span class="line">//  Created by Kenshin Cui on 14-7-18.</span><br><span class="line">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">//结构体类型Date</span><br><span class="line">struct Date&#123;</span><br><span class="line">    int year;</span><br><span class="line">    int month;</span><br><span class="line">    int day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct <span class="keyword">Person</span>&#123;</span><br><span class="line">    char *name;</span><br><span class="line">    int age;</span><br><span class="line">    struct Date birthday;//一个结构体中使用了另一个结构体类型，结构体类型变量声明前必须加上struct关键字</span><br><span class="line">    float height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv<span class="comment">[]</span>) &#123;</span><br><span class="line">    struct <span class="keyword">Person</span> p=&#123;<span class="string">"Kenshin"</span>,28,&#123;1986,8,8&#125;,1.72&#125;;</span><br><span class="line">    //定义结构体变量并初始化,不允许先定义再直接初始化，例如：struct <span class="keyword">Person</span> p;p=&#123;<span class="string">"Kenshin"</span>,28,&#123;1986,8,8&#125;,1.72&#125;;是错误的，但是可以分别赋值，例如p.name=<span class="string">"Kenshin"</span></span><br><span class="line">    </span><br><span class="line">    printf(<span class="string">"name=%s,age=%d,birthday=%d-%d-%d,height=%.2f\n"</span>,p.name,p.age,p.birthday.year,p.birthday.month,p.birthday.day,p.height); </span><br><span class="line">    //结果：name=Kenshin,age=28,birthday=1986-8-8,height=1.72，结构体的引用是通过<span class="string">"结构体变量.成员名称"</span>(注意和结构体指针访问结构体成员变量区分，结构体指针使用p-&gt;a的形式访问)</span><br><span class="line">    </span><br><span class="line">    printf(<span class="string">"len(Date)=%lu,len(Person)=%lu\n"</span>,sizeof(struct Date),sizeof(struct <span class="keyword">Person</span>)); </span><br><span class="line">    //结果：len(Date)=12,len(<span class="keyword">Person</span>)=32</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="C" scheme="http://ytlvy.com/tags/C/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C programming -- Array & String]]></title>
    <link href="http://ytlvy.com/2015/08/22/C-programming-Array-String/"/>
    <id>http://ytlvy.com/2015/08/22/C-programming-Array-String/</id>
    <published>2015-08-22T12:44:55.000Z</published>
    <updated>2015-08-22T12:46:18.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/kenshincui/p/3843505.html" target="_blank" rel="external">reference</a></p>
<h2 id="C语言之数组和字符串">C语言之数组和字符串</h2><h3 id="概览">概览</h3><p>数组在C语言中有着特殊的地位，它有很多特性，例如它的存储是连续的，数组的名称就是数组的地址等。而在C语言中是没有String类型的，那么如果要表示一个字符串，就必须使用字符数组。今天主要就介绍如下三个方面：</p>
<ul>
<li>一维数组</li>
<li>多维数组</li>
<li>字符串</li>
</ul>
<h3 id="一维数组">一维数组</h3><p>一维数组操作比较简单，但是需要注意，数组长度必须是固定的，长度不能使用变量进行初始化；如果声明的同时进行赋值则数组长度可以省略，编译器会自动计算数组长度；同时数组不能先声明再一次性赋值（当然可以对每个元素一一赋值）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//int a[len] = &#123; 1, 2&#125;;//错误,不能使变量</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">2</span>];<span class="comment">//正确</span></span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//a[2] = 3;//超过数组长度，但是编译器并不会检查，运行报错</span></span><br><span class="line">    <span class="keyword">int</span> b[<span class="string">'a'</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//'a'=97，所以可以作为数组长度，但是后面的元素没有初始化，其值默认为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">97</span>; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"b[%d]=%d\n"</span>,i,b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> c[<span class="number">2</span> * <span class="number">3</span>];<span class="comment">//2*3是固定值可以作为数组长度</span></span><br><span class="line">    <span class="keyword">int</span> d[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;<span class="comment">//如果初始化的同时赋值则数组长度可以省略，当前个数为3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="扩展—数组的存储">扩展—数组的存储</h3><p>数组在内存中存储在一块连续的空间中，如果知道数组类型（int、float等）和初始地址就可以知道其他元素的地址，同时由于数组名等于数组第一个元素的地址，所以当数组作为参数（作为参数时形参可以省略）其实是引用传递。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span> l = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> a[l] = &#123; <span class="number">1</span>, <span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; ++i)&#123;</span><br><span class="line">        <span class="comment">//由于当前在32位编译器下，int型长度为4个字节，可以判断出三个地址两两相差都是4</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a[%d]=%d,address=%x\n"</span>, i, a[i], &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*当前输出结果：</span><br><span class="line">    a[0] = 1, address = c9f95c</span><br><span class="line">    a[1] = 2, address = c9f960</span><br><span class="line">    a[2] = 3, address = c9f964*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看一下上面定义的数组在内存中存储结构</p>
<p><img src="http://images.cnitblog.com/blog/62046/201407/142058350217075.png" alt=""></p>
<p>再来看一下数组作为参数传递的情况，数组作为参数传递的是数组的地址<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeValue</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123; a[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; <span class="keyword">int</span> a[<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    changeValue(a); <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a[%d]=%d\n"</span>,i,a[i]);</span><br><span class="line">    &#125; <span class="comment">/*打印结果</span><br><span class="line">    a[0]=10</span><br><span class="line">    a[1]=2</span><br><span class="line">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="多维数组">多维数组</h3><p>多维数组其实可以看成是一个特殊的一维数组，只是每个元素又是一个一维数组，下面简单看一下多维数组的初始化和赋值</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int a<span class="comment">[2]</span><span class="comment">[3]</span>;//2行3列，二维数组可以看成是一个特殊的一维数组，只是它的每一个元素又是一个一维数组</span><br><span class="line">    a<span class="comment">[0]</span><span class="comment">[0]</span> = 1;</span><br><span class="line">    a<span class="comment">[0]</span><span class="comment">[1]</span> = 2;</span><br><span class="line">    a<span class="comment">[0]</span><span class="comment">[2]</span> = 3;</span><br><span class="line">    a<span class="comment">[1]</span><span class="comment">[0]</span> = 4;</span><br><span class="line">    a<span class="comment">[1]</span><span class="comment">[1]</span> = 5;</span><br><span class="line">    a<span class="comment">[1]</span><span class="comment">[2]</span> = 6;</span><br><span class="line">    for (int i = 0; i &lt; 2; ++i)&#123;</span><br><span class="line">        for (int j = 0; j &lt; 3; ++j)&#123;</span><br><span class="line">            printf(<span class="string">"a<span class="subst">[%d]</span><span class="subst">[%d]</span>=%d,address=%x\n"</span>, i, j, a<span class="comment">[i]</span><span class="comment">[j]</span>, &amp;a<span class="comment">[i]</span><span class="comment">[j]</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /*打印结果</span><br><span class="line">    a<span class="comment">[0]</span><span class="comment">[0]</span>=1,address=f8fb24</span><br><span class="line">    a<span class="comment">[0]</span><span class="comment">[1]</span>=2,address=f8fb28</span><br><span class="line">    a<span class="comment">[0]</span><span class="comment">[2]</span>=3,address=f8fb2c</span><br><span class="line">    a<span class="comment">[1]</span><span class="comment">[0]</span>=4,address=f8fb30</span><br><span class="line">    a<span class="comment">[1]</span><span class="comment">[1]</span>=5,address=f8fb34</span><br><span class="line">    a<span class="comment">[1]</span><span class="comment">[2]</span>=6,address=f8fb38</span><br><span class="line">    */</span><br><span class="line">    //初始化并直接赋值</span><br><span class="line">    int b<span class="comment">[2]</span><span class="comment">[3]</span> = &#123; &#123; 1, 2, 3 &#125;, &#123; 4, 5, 6 &#125; &#125;;</span><br><span class="line">    //由于数组的赋值顺序是先从第一行第一列，再第一行第二列...然后第二行第一列...，所以我们也可以写成如下形式</span><br><span class="line">    int c<span class="comment">[2]</span><span class="comment">[3]</span> = &#123; 1, 2, 3, 4, 5, 6 &#125;;</span><br><span class="line">    //也可以只初始化部分数据，其余元素默认为0</span><br><span class="line">    int d<span class="comment">[2]</span><span class="comment">[3]</span> = &#123; 1, 2, 3, 4 &#125;;</span><br><span class="line">    for (int i = 0; i &lt; 2; ++i)&#123;</span><br><span class="line">        for (int j = 0; j &lt; 3; ++j)&#123;</span><br><span class="line">            printf(<span class="string">"d<span class="subst">[%d]</span><span class="subst">[%d]</span>=%d\n"</span>, i, j, d<span class="comment">[i]</span><span class="comment">[j]</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /*打印结果</span><br><span class="line">    d<span class="comment">[0]</span><span class="comment">[0]</span>=1</span><br><span class="line">    d<span class="comment">[0]</span><span class="comment">[1]</span>=2</span><br><span class="line">    d<span class="comment">[0]</span><span class="comment">[2]</span>=3</span><br><span class="line">    d<span class="comment">[1]</span><span class="comment">[0]</span>=4</span><br><span class="line">    d<span class="comment">[1]</span><span class="comment">[1]</span>=0</span><br><span class="line">    d<span class="comment">[1]</span><span class="comment">[2]</span>=0</span><br><span class="line">    */</span><br><span class="line">    //当然下面赋值也可以</span><br><span class="line">    int e<span class="comment">[2]</span><span class="comment">[3]</span> = &#123; &#123;&#125;, &#123; 4, 5, 6 &#125; &#125;;</span><br><span class="line">    //可以省略行号,但是绝对不可以省略列号，因为按照上面说的赋值顺序，它无法判断有多少行</span><br><span class="line">    int f<span class="comment">[]</span><span class="comment">[3]</span> = &#123; &#123;1,2,3&#125;,&#123;4,5,6&#125; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="扩展—多维数组的存储">扩展—多维数组的存储</h4><p>以上面a数组为例，它在内存中的结构如下图</p>
<p><img src="http://images.cnitblog.com/blog/62046/201407/142058356937703.png" alt=""></p>
<p>根据上图和一维数组的存储，对于二维数组可以得出如下结论:数组名就是整个二维数组的地址，也等于第一行数组名的地址，还等于第一个元素的地址；第二行数组名等于第二行第一个元素的地址。用表达式表示：</p>
<p>a=a[0]=&amp;a[0][0]<br>a[1]=&amp;a[1][0]</p>
<p>同样可以得出a[i][j]=a[i]+j。关于三维数组、四维数组等多维数组，其实可以以此类推，在此不再赘述。</p>
<h3 id="字符串">字符串</h3><p>在C语言中是没有字符串类型的，如果要表示字符串需要使用char类型的数组，因为字符串本身就是多个字符的组合。但是需要注意的是字符串是一个特殊的数组，在它的结束位置必须要加一个”\0”（ASCII中0是空操作符，表示什么也不做）来表示字符串结束，否则编译器是不知道什么时候字符串已经结束的。当直接使用字符串赋值的时候程序会自动加上”\0”作为结束符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  ArrayAndString</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by KenshinCui on 14-7-06.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> a[] = &#123;<span class="string">'K'</span>,<span class="string">'e'</span>,<span class="string">'n'</span>,<span class="string">'s'</span>,<span class="string">'h'</span>,<span class="string">'i'</span>,<span class="string">'n'</span>,<span class="string">'\0'</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,a); <span class="comment">//结果：Kenshin，注意使用%s输出字符串内容，如果换成整形输出格式其实输出的是a的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"address=%x"</span>, a); <span class="comment">//结果：address=5fbff890</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="comment">//后面的\0绝对不能省略,如果没有\0则会出现如下情况</span></span><br><span class="line">    <span class="keyword">char</span> b[] = &#123; <span class="string">'I'</span>, <span class="string">'a'</span>, <span class="string">'m'</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,b); <span class="comment">//没有按照期望输出，多了一些垃圾数据，在当前环境打印结果：IamKenshin</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"address=%x"</span>,b); <span class="comment">//结果：address=5fbff88d</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="comment">//直接赋值为字符串，此时不需要手动添加\0，编译器会自动添加</span></span><br><span class="line">    <span class="keyword">char</span> c[] = <span class="string">"Kenshin"</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c=%s"</span>,c); <span class="comment">//结果：c=Kenshin</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//二维数组存储多个字符串</span></span><br><span class="line">    <span class="keyword">char</span> d[<span class="number">2</span>][<span class="number">3</span>]=&#123;<span class="string">"Kenshin"</span>,<span class="string">"Kaoru"</span>,<span class="string">"Rose"</span>,<span class="string">"Jack"</span>,<span class="string">"Tom"</span>,<span class="string">"Jerry"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码注释中可以看到打印b的时候不是直接打印出来“Iam”而是打印出了“IamKenshin”，原因就是编译器无法判断字符串是否结束，要解释为什么打印出“IamKenshin”我们需要了解a和b在内存中的存储。</p>
<p><img src="http://images.cnitblog.com/blog/62046/201407/142058363658331.png" alt=""></p>
<p>从图中我们不难发现由于a占用8个字节，而定义完a后直接定义了b，此时分配的空间连续，b占用3个字节，这样当输出b的时候由于输出完“Iam”之后并未遇到”\0”标记，程序继续输出直到遇到数组a中的“\0”才结束，因此输出内容为“IamKenshin”。</p>
<h4 id="扩展—字符串操作常用函数">扩展—字符串操作常用函数</h4><p>下面简单看一下和字符和字符串相关的常用的几个函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  ArrayAndString</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-7-04.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">/*字符操作*/</span></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'a'</span>); <span class="comment">//结果：a，putchar一次只能输出一个字符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">97</span>);<span class="comment">//结果:a</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    a=getchar();<span class="comment">//getchar()一次只能接收一个字符，可以接收空格、tab、回车</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%c"</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*字符串操作*/</span></span><br><span class="line">    <span class="keyword">char</span> b[]=<span class="string">"Kenshin"</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"b=%s"</span>,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(b); <span class="comment">//puts用于输出单个字符串，不能像printf格式化输出，会自动添加换行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,c);<span class="comment">//注意c没必要写成&amp;c，因为c本身就代表了数组的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c=%s\n"</span>,c);<span class="comment">//注意即使你输入的内容大于10，也能正确输出，但是下面的gets()函数却不行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//gets()函数，注意它是不安全的，因为接收的时候不知道它的大小容易造成溢出，建议不要使用</span></span><br><span class="line">    <span class="keyword">char</span> d[<span class="number">10</span>];</span><br><span class="line">    gets(d); <span class="comment">//gets一次只能接收一个字符串，但是scanf可接收多个；scanf不能接收空格、tab，gets则可以</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"d=%s"</span>,d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> e[]=&#123;<span class="string">'K'</span>,<span class="string">'s'</span>,<span class="string">'\0'</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lu"</span>,<span class="built_in">strlen</span>(e)); <span class="comment">//结果是：2，不是3，因为\0不计入长度</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">char</span> f[]=&#123;<span class="string">"Kenshin"</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lu"</span>,<span class="built_in">strlen</span>(f)); <span class="comment">//结果是：7</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> g[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(g,<span class="string">"hello,world!"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,g); <span class="comment">//结果是：hello,即使定义的g长度为5，但是也能完全拷贝进去</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">char</span> h[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">char</span> i[]=&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'\0'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>,<span class="string">'\0'</span>&#125;;</span><br><span class="line">    <span class="built_in">strcpy</span>(h,i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,h); <span class="comment">//结果是：abc,遇到第一个\0则结束</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcat</span>(i,<span class="string">"ghi"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,i); <span class="comment">//结果是：abcghi,注意不是abcdefghi,strcat，从i第一\0开始使用“ghi”覆盖，覆盖完之后加上一个\0,在内存中目前应该是：&#123;'a','b','c','g','h','i','\0','f','\0'&#125;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> j[]=<span class="string">"abc"</span>;</span><br><span class="line">    <span class="keyword">char</span> k[]=<span class="string">"aBc"</span>;</span><br><span class="line">    <span class="keyword">char</span> l[]=<span class="string">"acb"</span>;</span><br><span class="line">    <span class="keyword">char</span> m[]=&#123;<span class="string">'a'</span>,<span class="string">'\0'</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,%d,%d"</span>,<span class="built_in">strcmp</span>(j,k),<span class="built_in">strcmp</span>(k,l),<span class="built_in">strcmp</span>(l,m));<span class="comment">//遇到第一个不相同的字符或\0则返回两者前后之差，结果：32,-33,99</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>1.在Xcode中会提示gets是不安全的，推荐使用fgets()。<br>2.strlen()只用于计算字符串长度，由于在C语言中字符串使用字符数组长度表示，所以它可以计算带有’\0’结尾的字符数组长度，但是它并不能计算其他类型的数组长度。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://www.cnblogs.com/kenshincui/p/3843505.html">reference</a></p>
<h2 id="C语言之数组和字符串">C语言之数组和字符串</h2><h3 id="概览">概览</h3><p>数组在C语言中有着特殊的地位，它有很多特性，例如它的存储是连续的，数组的名称就是数组的地址等。而在C语言中是没有String类型的，那么如果要表示一个字符串，就必须使用字符数组。今天主要就介绍如下三个方面：</p>
<ul>
<li>一维数组</li>
<li>多维数组</li>
<li>字符串</li>
</ul>
<h3 id="一维数组">一维数组</h3><p>一维数组操作比较简单，但是需要注意，数组长度必须是固定的，长度不能使用变量进行初始化；如果声明的同时进行赋值则数组长度可以省略，编译器会自动计算数组长度；同时数组不能先声明再一次性赋值（当然可以对每个元素一一赋值）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//int a[len] = &#123; 1, 2&#125;;//错误,不能使变量</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">2</span>];<span class="comment">//正确</span></span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//a[2] = 3;//超过数组长度，但是编译器并不会检查，运行报错</span></span><br><span class="line">    <span class="keyword">int</span> b[<span class="string">'a'</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//'a'=97，所以可以作为数组长度，但是后面的元素没有初始化，其值默认为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">97</span>; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"b[%d]=%d\n"</span>,i,b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> c[<span class="number">2</span> * <span class="number">3</span>];<span class="comment">//2*3是固定值可以作为数组长度</span></span><br><span class="line">    <span class="keyword">int</span> d[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;<span class="comment">//如果初始化的同时赋值则数组长度可以省略，当前个数为3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="C" scheme="http://ytlvy.com/tags/C/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C programming -- pointer]]></title>
    <link href="http://ytlvy.com/2015/08/22/C-programming-pointer/"/>
    <id>http://ytlvy.com/2015/08/22/C-programming-pointer/</id>
    <published>2015-08-22T12:43:37.000Z</published>
    <updated>2015-08-22T12:44:09.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/kenshincui/p/3848442.html" target="_blank" rel="external">reference</a></p>
<h2 id="C语言之指针">C语言之指针</h2><h3 id="概览">概览</h3><p>指针是C语言的精髓，但是很多初学者往往对于指针的概念并不深刻，以至于学完之后随着时间的推移越来越模糊，感觉指针难以掌握，本文通过简单的例子试图将指针解释清楚，今天的重点有几个方面：</p>
<ul>
<li>什么是指针</li>
<li>数组和指针</li>
<li>函数指针</li>
</ul>
<h3 id="什么是指针">什么是指针</h3><p>存放变量地址的变量我们称之为“指针变量”,简单的说变量p中存储的是变量a的地址,那么p就可以称为是指针变量,或者说p指向a。当我们访问a变量的时候其实是程序先根据a取得a对应的地址，再到这个地址对应的存储空间中拿到a的值，这种方式我们称之为“直接引用”；而当我们通过p取得a的时候首先要先根据p转换成p对应的存储地址，再根据这个地址到其对应的存储空间中拿到存储内容，它的内容其实就是a的地址，然后根据这个地址到对应的存储空间中取得对应的内容，这个内容就是a的值，这种通过p找到a对应地址再取值的方式成为“间接引用”。这里以表格形式列出a和p的存储以帮助大家理解上面说的内容：</p>
<p><img src="http://images.cnitblog.com/blog/62046/201407/161307139741921.png" alt=""></p>
<a id="more"></a>
<p>接下来，看一下指针的赋值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  Point</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-7-05.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    p=&amp;a; <span class="comment">//也可以直接给指针变量赋值：int *p=&amp;a;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"address(a)=%x,address(p)=%x\n"</span>,&amp;a,p); <span class="comment">//结果：address(a)=5fbff81c,address(p)=5fbff81c</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d,p=%d\n"</span>,a,*p); <span class="comment">//结果：a=1,p=1</span></span><br><span class="line">    *p=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d,*p=%d\n"</span>,a,*p); <span class="comment">//结果：a=2,p=2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">8</span>;</span><br><span class="line">    <span class="keyword">char</span> c= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> *q=&amp;c;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"address(b)=%x,address(c)=%x\n"</span>,&amp;b,&amp;c);<span class="comment">//结果：</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c=%d,q=%d\n"</span>, c, *q); <span class="comment">//结果：c=1,q=2049，为什么q的值不是1呢？</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要说明两点：</p>
<p>a. int <em>p;中的</em>只是表示p变量是一个指针变量；而打印<em>p的时候，</em>p中的<em>是操作符，表示p指针指向的变量的存储空间（当前存储就是1），同时我们也看到了</em>p==a；修改了*p也就是修改了p指向的存储空间的内容，也就修改了a，所以第二次打印a=2;</p>
<p>b. 指针所指向的类型必须和定义指针时声明的类型相同；上面指针q定义成了int型而指向了char型，结果输出*q打印出了2049，具体原因见下图（假设在16位编译器下，指针长度为2字节）</p>
<p><img src="http://images.cnitblog.com/blog/62046/201407/161307173968575.png" alt=""></p>
<p>由于局部变量是存储在栈里面的，所以先存储b再存储a、p，当打印<em>p的时候，其实就是以p指向的地址对应的空间开始取两个字节的数据（因为定义p的时候它指向的是int型，在16位编译器下int类型的长度为2），刚好定义的b和c空间连续，所以就取到b的其中一个字节，最后</em>p二进制存储为“0000100000000001”（见上图黄色背景内容），十进制表示就是2049；</p>
<p>c. 指针变量占用的空间和它所指向的变量类型无关，只跟编译器位数有关（准确的说只跟寻址方式有关）；</p>
<h3 id="数组和指针">数组和指针</h3><p>由于数组的存储是连续的，数组名就是数组的地址，这样一来数组和指针就有着很微妙的关系，先看以下例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  Point</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-7-05.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeValue</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line">    a[<span class="number">0</span>]=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeValue2</span><span class="params">(<span class="keyword">int</span> *p)</span></span>&#123;</span><br><span class="line">    p[<span class="number">0</span>]=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *p=&amp;a[<span class="number">0</span>]; <span class="comment">//等价于：*p=a;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"len=%lu\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">//取得int长度为2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//指针加1代表地址向后挪动所指向类型的长度位（这里类型是int，长度为2）</span></span><br><span class="line">    <span class="comment">//也就是说p指向a[0],p+1指向a[1]，以此类推，所以我们通过指针也可以取出数组元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)&#123;</span><br><span class="line">        <span class="comment">//printf("a[%d]=%d\n",i,a[i]);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a[%d]=%d\n"</span>,i,*(p+i));<span class="comment">//由于a就代表数组的地址，其实这里还可以写成*(a+i),但是注意这里*(p+i)可以写成*(p++),但是*(a+i)不能写成*(a++),因为数组名是常量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*输出结果：</span><br><span class="line">     a[0]=1</span><br><span class="line">     a[1]=2</span><br><span class="line">     a[2]=3</span><br><span class="line">     */</span></span><br><span class="line">     </span><br><span class="line">    </span><br><span class="line">    changeValue(p); <span class="comment">//等价于：changeValue(a)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a[%d]=%d\n"</span>,i,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*输出结果：</span><br><span class="line">     a[0]=2</span><br><span class="line">     a[1]=2</span><br><span class="line">     a[2]=3</span><br><span class="line">     */</span></span><br><span class="line">    </span><br><span class="line">    changeValue2(a); <span class="comment">//等价于：changeValue2(p)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a[%d]=%d\n"</span>,i,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*输出结果：</span><br><span class="line">     a[0]=3</span><br><span class="line">     a[1]=2</span><br><span class="line">     a[2]=3</span><br><span class="line">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的例子我们可以得出如下结论：</p>
<ul>
<li>数组名a==&amp;a[0]==*p；</li>
<li>如果p指向一个数组，那么p+1指向数组的下一个元素，同时注意p+1移动的长度并不固定，具体需要根据p指向的数据类型而定；</li>
<li>指针可以写成p++形式，但是数组名不可以，因为数组名是常量</li>
<li>不管函数的形参为数组还是指针，实参都可以使用数组名或指针；</li>
</ul>
<h4 id="扩展—字符串和指针">扩展—字符串和指针</h4><p>由于在C语言中字符串就是字符数组，下面不妨看一下字符串和数组的关系：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  Point</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin on 14-7-05.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[]=<span class="string">"Kenshin"</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%x,%s\n"</span>,a,a);<span class="comment">//结果：5fbff820,Kenshin，同一个变量a是输出字符串还是输出地址，根据格式参数而定</span></span><br><span class="line">    <span class="built_in">printf</span>(a); <span class="comment">//结果：Kenshin</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> b[]=<span class="string">"Kenshin"</span>;</span><br><span class="line">    <span class="keyword">char</span> *p=b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"b=%s,p=%s\n"</span>,b,p);<span class="comment">//结果：b=Kenshin,p=Kenshin</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//指针存储的是地址，而数组名存储的也是地址，既然字符数组可以表示字符串，那么指向字符的指针同样也可以，如下方式可以更简单的定义一个字符串</span></span><br><span class="line">    <span class="keyword">char</span> *c=<span class="string">"Kenshin"</span>; <span class="comment">//等价于char c[]="Kenshin";</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c=%s\n"</span>,c); <span class="comment">//结果：c=Kenshin</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上代码中注释基本已经很清楚了，这里需要指出是为什么printf(a)能够直接输出字符串呢？</p>
<p>我们看一下printf()的定义:int     printf(const char * <strong>restrict, …) </strong>printflike(1, 2);</p>
<p>其实printf的参数要求是指向字符类型的指针，而结合上面的例子和我们之前说的，如果函数形参是指针类型那么可以传入函数名，因此也就能正确输出字符串的内容了。类似的还有上一篇文章中说的strcat()、strcpy()等函数均是如此。</p>
<h3 id="函数指针">函数指针</h3><p>在弄清函数指针的问题之前，我们不妨先来看一下返回指针类型数据的函数，毕竟指针类型也是C语言的数据类型，下面以一个字符串转换为大写字符的程序为例，在这个例子中不仅可以看到返回值为指针类型的函数同时还可以看到前面说到的指针移动操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  Point</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-06-28.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> * toUpper(<span class="keyword">char</span> *a)&#123;</span><br><span class="line">    <span class="keyword">char</span> *b=a; <span class="comment">//保留最初地址，因为后面的循环会改变字符串最初地址</span></span><br><span class="line">    <span class="keyword">int</span> len=<span class="string">'a'</span>-<span class="string">'A'</span>; <span class="comment">//大小写ASCII码差值相等</span></span><br><span class="line">    <span class="keyword">while</span> (*a!=<span class="string">'\0'</span>) &#123; <span class="comment">//字符是否结束</span></span><br><span class="line">        <span class="keyword">if</span>(*a&gt;<span class="string">'a'</span>&amp;&amp;*a&lt;<span class="string">'z'</span>)&#123;<span class="comment">//如果是小写字符</span></span><br><span class="line">            *(a++) -= len; <span class="comment">//*a表示数组对应的字符（-32变为小写），a++代表移动到下一个字符</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">       <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[]=<span class="string">"hello"</span>;</span><br><span class="line">    <span class="keyword">char</span> *p=toUpper(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,p); <span class="comment">//结果：HELLO</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大家都是知道函数只能有一个返回值，如果需要返回多个值，怎么办，其实很简单，只要将指针作为函数参数传递就可以了，在下面的例子中我们再次看到指针作为参数进行传递。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  Point</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-6-28.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operate</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> *c)</span></span>&#123;</span><br><span class="line">    *c=a-b;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>,c,d;</span><br><span class="line">    d=operate(a, b, &amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a+b=%d,a-b=%d\n"</span>,d,c);<span class="comment">//结果：a+b=3,a-b=-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数也是在内存中存储的，当然函数也有一个起始地址（事实上函数名就是函数的起始地址），这里同样需要弄清函数指针的关系。函数指针定义的形式：返回值类型 (*指针变量名)(形参1，形参2)，拿到函数指针其实我们就相当于拿到了这个函数，函数的操作都可以通过指针来完成，而且通过前面的例子可以看到指针作为C语言的数据类型，可以作为参数、作为返回值，那么当然函数指针同样可以作为函数的参数和返回值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  Point</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-6-28.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数指针作为参数进行传递</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operate</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> (*p)</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p(a,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> (*p)(<span class="keyword">int</span> ,<span class="keyword">int</span>)=sum;<span class="comment">//函数名就是函数首地址,等价于：int (*p)(int,int);p=sum;</span></span><br><span class="line">    <span class="keyword">int</span> c=p(a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a+b=%d\n"</span>,c); <span class="comment">//结果：a+b=3</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//函数作为参数传递</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,operate(a, b, sum)); <span class="comment">//结果：3</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,operate(a, b, sub)); <span class="comment">//结果：-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数指针可以作为函数参数进行传递，实在太强大了，是不是想起了C#中的委托？记得C#书籍中经常提到委托类似于函数指针，其实说的就是上面的情况。需要注意的是，普通的指针可以写成p++进行移动，而函数指针写成p++并没有意义。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://www.cnblogs.com/kenshincui/p/3848442.html">reference</a></p>
<h2 id="C语言之指针">C语言之指针</h2><h3 id="概览">概览</h3><p>指针是C语言的精髓，但是很多初学者往往对于指针的概念并不深刻，以至于学完之后随着时间的推移越来越模糊，感觉指针难以掌握，本文通过简单的例子试图将指针解释清楚，今天的重点有几个方面：</p>
<ul>
<li>什么是指针</li>
<li>数组和指针</li>
<li>函数指针</li>
</ul>
<h3 id="什么是指针">什么是指针</h3><p>存放变量地址的变量我们称之为“指针变量”,简单的说变量p中存储的是变量a的地址,那么p就可以称为是指针变量,或者说p指向a。当我们访问a变量的时候其实是程序先根据a取得a对应的地址，再到这个地址对应的存储空间中拿到a的值，这种方式我们称之为“直接引用”；而当我们通过p取得a的时候首先要先根据p转换成p对应的存储地址，再根据这个地址到其对应的存储空间中拿到存储内容，它的内容其实就是a的地址，然后根据这个地址到对应的存储空间中取得对应的内容，这个内容就是a的值，这种通过p找到a对应地址再取值的方式成为“间接引用”。这里以表格形式列出a和p的存储以帮助大家理解上面说的内容：</p>
<p><img src="http://images.cnitblog.com/blog/62046/201407/161307139741921.png" alt=""></p>]]>
    
    </summary>
    
      <category term="C" scheme="http://ytlvy.com/tags/C/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C programming -- memory & scope]]></title>
    <link href="http://ytlvy.com/2015/08/22/C-programming-memory-scope/"/>
    <id>http://ytlvy.com/2015/08/22/C-programming-memory-scope/</id>
    <published>2015-08-22T12:36:41.000Z</published>
    <updated>2015-08-22T12:44:35.000Z</updated>
    <content type="html"><![CDATA[<p>@charset “UTF-8”;<br>/**</p>
<ul>
<li></li>
<li>@authors yanjie Guo (ytlvy2008@gmail.com)</li>
<li>@date    2015-08-15 16:02:00</li>
<li>@version $Id$</li>
<li>Copyright (c) 2015年 Guo yanjie. All rights reserved.</li>
<li>*/</li>
</ul>
<h2 id="概述">概述</h2><p>基本上每种语言都要讨论这个话题，C语言也不例外，因为只有你完全了解每个变量或函数存储方式、作用范围和销毁时间才可能正确的使用这门语言。今天将着重介绍C语言中变量作用范围、存储方式、生命周期、作用域和可访问性。</p>
<ul>
<li>变量作用范围</li>
<li>存储方式</li>
<li>可访问性</li>
</ul>
<h3 id="变量作用范围">变量作用范围</h3><p>在C语言中变量从作用范围包括全局变量和局部变量。全局变量在定义之后所有的函数中均可以使用，只要前面的代码修改了，那么后面的代码中再使用就是修改后的值；局部变量的作用范围一般在一个函数内部（通常在一对大括号{}内），外面的程序无法访问它，它却可以访问外面的变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  ScopeAndLifeCycle</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-7-12.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d\n"</span>,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">1</span>;</span><br><span class="line">    changeValue(); <span class="comment">//结果：a=2</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d,b=%d\n"</span>,a,b); <span class="comment">//结果：a=2,b=1 ，因为changeValue修改了这个全局变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="变量存储方式">变量存储方式</h3><p>C语言的强大之处在于它能直接操作内存（指针），但是要完全熟悉它的操作方式我们必须要弄清它的存储方式。存储变量的位置分为：普通内存(静态存储区)、运行时堆栈（动态存储区）、硬件寄存器（动态存储区），当然这几种存储的效率是从低到高的。而根据存储位置的不同在C语言中又可以将变量依次分为：静态变量、自动变量、寄存器变量。</p>
<h4 id="静态变量">静态变量</h4><p>首先说一下存储在普通内存中的静态变量，全局变量和使用static声明的局部变量都是静态变量，在系统运行过程中只初始化一次（在下面的例子中虽然变量b是局部变量，在外部无法访问，但是他的生命周期一直延续到程序结束，而变量c则在第一次执行完就释放，第二次执行时重新创建）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  2.1.c</span></span><br><span class="line"><span class="comment">//  ScopeAndLifeCycle</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-7-12.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>; <span class="comment">//全局变量存储在静态内存中，只初始化一次</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b=<span class="number">1</span>; <span class="comment">//静态变量存储在静态内存中，第二次调用不会再进行初始化</span></span><br><span class="line">    <span class="keyword">int</span> c=<span class="number">1</span>;</span><br><span class="line">    ++b;</span><br><span class="line">    a+=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d,b=%d,c=%d\n"</span>,a,b,c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    showMessage(); <span class="comment">//结果：a=3,b=2,c=1</span></span><br><span class="line">    showMessage(); <span class="comment">//结果：a=5,b=3,c=1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自动变量">自动变量</h4><p>被关键字auto修饰的局部变量是自动变量，但是auto关键字可以省略，因此可以得出结论：所有没有被static修饰的局部变量都是自动变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  1.3.c</span></span><br><span class="line"><span class="comment">//  ScopeAndLifeCycle</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-7-12.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> <span class="keyword">int</span> b=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d,b=%d\n"</span>,a,b); <span class="comment">//结果：a=1,b=2 ，a和b都是自动变量，auto可以省略</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//需要注意的是，上面的自动变量是存储在栈中，其实还可以存储到堆中</span></span><br><span class="line">    <span class="keyword">char</span> c[] = <span class="string">"hello,world!"</span>;</span><br><span class="line">    <span class="keyword">long</span> len = <span class="built_in">strlen</span>(c) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>) + <span class="number">1</span>;<span class="comment">//之所以加1是因为字符串后面默认有一个\0空操作符不计算在长度内</span></span><br><span class="line">    <span class="keyword">char</span> *p=NULL;<span class="comment">//可以直接写成：char *p;</span></span><br><span class="line">    p=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(len);<span class="comment">//分配指定的字节存放c中字符串，注意由于malloc默认返回“void *”需要转化</span></span><br><span class="line">    <span class="built_in">memset</span>(p,<span class="number">0</span>,len);<span class="comment">//清空指向内存中的存储内容，因为分配的内存是随机的，如果不清空可能会因为垃圾数据产生不必要的麻烦</span></span><br><span class="line">    <span class="built_in">strcpy</span>(p,c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"p=%s\n"</span>,p);<span class="comment">//结果：p=hello,world!</span></span><br><span class="line">    <span class="built_in">free</span>(p);<span class="comment">//释放分配的空间</span></span><br><span class="line">    p=NULL;<span class="comment">//注意让p指向空，否则p将会是一个存储一个无用地址的野指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然存储自动变量的栈和堆其实是两个完全不同的空间（虽然都在运行时有效的空间内）：栈一般是程序自动分配，其存储结果类似于数据结构中的栈，先进后出，程序结束时由编译器自动释放；而堆则是开发人员手动编码分配，如果不进行手动释放就只有等到程序运行完操作系统回收，其存储结构类似于链表。在上面的代码中p变量同样是一个自动变量，同样可以使用auto修饰，只是它所指向的内容放在堆上（p本身存放在栈上）。</p>
<blockquote>
<p>这里说明几点：malloc分配的空间在逻辑上连续，物理上未必连续；p必须手动释放，否则直到程序运行结束它占用的内存将一直被占用；释放p的过程只是把p指向的空间释放掉，p中存放的地址并未释放，需要手动设置为NULL，否则这将是一个无用的野指针</p>
</blockquote>
<h4 id="寄存器变量">寄存器变量</h4><p>默认情况下无论是自动变量还是静态变量它们都在内存中，不同之处就是自动变量放在一块运行时分配的特殊内存中。但是寄存器变量却是在硬件寄存器中，从物理上来说它和内存处在两个完全不同的硬件中。大家都是知道寄存器存储空间很小，但是它的效率很高，那么合理使用寄存器变量就相当重要了。什么是寄存器变量呢？使用register修饰的int或char类型的非静态局部变量是寄存器变量。没错，需要三个条件支撑：register修饰、必须是int或char类型、必须是非静态局部变量。</p>
<p>除了存储位置不同外，寄存器变量完全符合自动变量的条件，因此它的生命周期其实是和自动变量完全一样的，当函数运行结束后它就会被自动释放。由于寄存器空间珍贵，因此我们需要合理使用寄存器变量，只有访问度很高的变量我们才考虑使用寄存器变量，如果过多的定义寄存器变量，当寄存器空间不够用时会自动转化为自动变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  1.3.c</span></span><br><span class="line"><span class="comment">//  ScopeAndLifeCycle</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-7-12.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d\n"</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面我们说到变量的存储类型，其实在C语言中还有两种存储类型：常量存储区和代码存储区，分别用于存储字符串常量、使用const修饰的全局变量以及二进制函数代码。</p>
</blockquote>
<h3 id="可访问性">可访问性</h3><p>在C语言中没有其他高级语言public、private等修饰符，来限定变量和函数的有效范围，但是却有两个类似的关键字能达到类似的效果：extern和static。</p>
<h4 id="extern">extern</h4><h5 id="extern作用于变量">extern作用于变量</h5><p>我们知道在C语言中变量的定义顺序是有严格要求的，要使用变量则必须在使用之前定义，extern用于声明一个已经存在的变量，这样一来即使在后面定义一个变量只要前面声明了，也同样可以使用。具体的细节通过下面的代码相信大家都可以看明白：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  2.1.c</span></span><br><span class="line"><span class="comment">//  ScopeAndLifeCycle</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-7-12.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果在main函数下面定义了一个变量a，如果在main上面不进行声明是无法在main中使用a的；</span></span><br><span class="line"><span class="comment">//同样如果只进行了extern声明不进行定义一样会报错，因为extern并不负责定义变量a而仅仅是声明一个已经定义过的变量；</span></span><br><span class="line"><span class="comment">//当然如果说在main上面定义int a;去掉main下面的定义同样是可以的，相当于在上面定义，但如果两个地方都定义a的话（main上面的extern去掉），则程序认为上面的定义是声明，只是省略了extern关键字；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种情况，在下面定义，不进行声明，报错</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d\n"</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种情况，在上面定义，正确</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d\n"</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种情况，在下面定义在上面声明，正确</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d\n"</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第四种情况，只在上面声明（编译时没有问题，因为上面的声明骗过了编译器，但运行时报错，因为extern只能声明一个已经定义的变量），错误</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d\n"</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第五种情况,上下同时定义（这种方式是正确的，因为上面的定义会被认为是省略了extern的声明），正确</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d\n"</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="comment">//其实下面的情况也是不会出错的</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d\n"</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第六种情况,将全局变量声明为局部变量，但是它的实质还是全局变量，正确</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d\n"</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第七种情况，在函数内部重新定义一个变量a,虽然不会报错，但是两个a不是同一个</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d\n"</span>,a);<span class="comment">//注意这里输出的a其实是内部定义的a，和函数外定义的a没有关系</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a;</span><br></pre></td></tr></table></figure></p>
<p>如果两个文件同时定义一个全局变量，那实质上他们指的是同一个变量。从下面的例子可以看出，在main.c中修改了变量a之后message.c中的变量a值也修改了。</p>
<p><img src="http://images.cnitblog.com/blog/62046/201407/182035555844911.png" alt=""></p>
<p>需要注意，在上面的代码中无论在message.h中将a定义前加上extern，还是在main.h中的a定以前加上extern结果都是一样的，extern同样适用。和在单文件中一样，不能两个定义都添加extern，否则就没有定义了。如果把message.c中a的定义（或声明）去掉呢，那么它能否访问main.c中的全局变量a呢，答案是否定的（这和在一个文件中定义了一个函数在另一个文件不声明就直接用是类似的）。</p>
<h5 id="extern作用于函数">extern作用于函数</h5><p>extern作用于函数就不再是简单的声明函数了，而是将这个函数作为外部函数（当然还有内部函数，下面会说到），在其他文件中也可以访问。但是大家应该已经注意到，在上面的代码中message.c中的showMessage前面并没有添加extern关键字，在main.c中不是照样访问吗？那是因为这个关键字是可以省略的，<strong>默认情况下所有的函数都是外部函数</strong>。</p>
<p><img src="http://images.cnitblog.com/blog/62046/201407/182035567245696.png" alt=""></p>
<p>和作用于变量不同，上面main.c和message.c中的extern都可以省略，在这里extern的作用就是定义或声明一个外部函数。从上面可以看到在不同的文件中可以定义同一个变量，它们被视为同一个变量，但是需要指出的是外部函数在一个程序中是不能重名的，否则会报错。</p>
<h4 id="static">static</h4><h5 id="static作用于变量">static作用于变量</h5><p>其实在前面的例子中我们已经看到static关键字在变量中的使用了，在例子中使用static定了一个局部变量，而且我们强调static局部变量在函数中只被初始化一次。那么如果static作用于全局变量是什么效果呢？如果<strong><em>static作用于全局变量它的作用就是定义一个只能在当前文件访问的全局变量，相等于私有全局变量</em></strong>。</p>
<p><img src="http://images.cnitblog.com/blog/62046/201407/182035581627924.png" alt=""></p>
<p>从上面的输出结果可以看出message.c中的变量a和main.c中的变量a并不是同一个变量，事实上message.c中的变量a只能在message.c中使用，虽然main.c中的变量a是全局变量但是就近原则，message.c会使用自己内部的变量a。当然，上面例子中main.c中的变量a定义成静态全局变量结果也是一样的，只是这样如果还有其他源文件就不能使用a变量了。但是main.c中的a不能声明成extern，因为main.c不能访问message.c中的变量a，这样在main.c中就没变量a的定义了。</p>
<h5 id="static作用于函数">static作用于函数</h5><p>static作用于函数和作用于变量其实是类似的，如果static作用于函数则这个函数就是内部函数，其他文件中的代码不可以访问。下面的代码在运行时会报错，因为mesage.c中的showMessage()函数是私有的，在main.c中尽管进行了声明，可以在编译阶段通过，但是在链接阶段会报错。</p>
<p><img src="http://images.cnitblog.com/blog/62046/201407/182035596461438.png" alt=""></p>
<h3 id="总结">总结</h3><p>最后做一下简单总结一下：</p>
<ol>
<li>extern作用于变量时用于声明一个已经定义的变量，但是并不能定义变量；使用extern你可以在其他文件中使用全局变量（当然此时extern可以省略）；</li>
<li>extern作用于函数时与它作用于全局变量有点类似，声明这个函数是外部函数，其他文件可以访问，但不同的是当它作用于函数时不仅可以声明函数还可以定义函数（用在函数定义前面），不管是定义还是声明都可以省略，C语言默认认为函数定义或声明都是外部函数；</li>
<li>static作用于变量时，该变量只会定义一次，以后在使用时不会重新定义，当static作用于全局变量时说明该变量只能在当前文件可以访问，其他文件中不能访问；</li>
<li>static作用于函数时与作用于全局变量类似，表示声明或定义该函数是内部函数（又叫静态函数），在该函数所在文件外的其他文件中无法访问此函数；</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>@charset “UTF-8”;<br>/**</p>
<ul>
<li></li>
<li>@authors yanjie Guo (ytlvy2008@gmail.com)</li>
<li>@date    2015-08-15 16:02:00</li>
<li>@version $Id$</li>
<li>Copyright (c) 2015年 Guo yanjie. All rights reserved.</li>
<li>*/</li>
</ul>
<h2 id="概述">概述</h2><p>基本上每种语言都要讨论这个话题，C语言也不例外，因为只有你完全了解每个变量或函数存储方式、作用范围和销毁时间才可能正确的使用这门语言。今天将着重介绍C语言中变量作用范围、存储方式、生命周期、作用域和可访问性。</p>
<ul>
<li>变量作用范围</li>
<li>存储方式</li>
<li>可访问性</li>
</ul>
<h3 id="变量作用范围">变量作用范围</h3><p>在C语言中变量从作用范围包括全局变量和局部变量。全局变量在定义之后所有的函数中均可以使用，只要前面的代码修改了，那么后面的代码中再使用就是修改后的值；局部变量的作用范围一般在一个函数内部（通常在一对大括号{}内），外面的程序无法访问它，它却可以访问外面的变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  ScopeAndLifeCycle</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-7-12.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d\n"</span>,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">1</span>;</span><br><span class="line">    changeValue(); <span class="comment">//结果：a=2</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d,b=%d\n"</span>,a,b); <span class="comment">//结果：a=2,b=1 ，因为changeValue修改了这个全局变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="C" scheme="http://ytlvy.com/tags/C/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Big-endian && Little-endian]]></title>
    <link href="http://ytlvy.com/2015/08/22/Big-endian-Little-endian/"/>
    <id>http://ytlvy.com/2015/08/22/Big-endian-Little-endian/</id>
    <published>2015-08-22T12:32:13.000Z</published>
    <updated>2015-08-22T12:33:03.000Z</updated>
    <content type="html"><![CDATA[<h2 id="大端序与小端序">大端序与小端序</h2><h3 id="何为大端序，小端序？">何为大端序，小端序？</h3><p>简单点说，就是字节的存储顺序，如果数据都是单字节的，那怎么存储无所谓了，但是对于多字节数据，比如int，double等，就要考虑存储的顺序了。注意字节序是硬件层面的东西，对于软件来说通常是透明的。再说白一点，字节序通常只和你使用的处理器架构有关，而和编程语言无关，比如常见的Intel x86系列就是小端序。</p>
<h4 id="Big-endian（大端序）">Big-endian（大端序）</h4><p>数据的高位字节存放在地址的低端 低位字节存放在地址高端</p>
<h4 id="Little-endian（小端序）">Little-endian（小端序）</h4><p>数据的高位字节存放在地址的高端 低位字节存放在地址低端</p>
<h4 id="字节的高位与低位">字节的高位与低位</h4><p>举个例子，int a = 0x12345678 ; 那么左边12就是高位字节，右边的78就是低位字节，从左到右，由高到低，（注意，高低乃相对而言，比如56相对于78是高字节，相对于34是低字节）</p>
<p>地址的高端与低端<br>0x00000001<br>0x00000002<br>0x00000003<br>0x00000004<br>从上倒下，由低到高，地址值小的为低端，地址值大的为高端。</p>
<a id="more"></a>
<h3 id="不同字节序如何存储数据？">不同字节序如何存储数据？</h3><p>看看两种方式如何存储数据，假设从地址0x00000001处开始存储十六进制数0x12345678，那么</p>
<p>Bit-endian 如此存放(按原来顺序存储)<br>0x00000001           — 12<br>0x00000002           — 34<br>0x00000003           — 56<br>0x00000004           — 78</p>
<p>Little-endian 如此存放(颠倒顺序储存)<br>0x00000001           — 78<br>0x00000002           — 56<br>0x00000003           — 34<br>0x00000004           — 12</p>
<p>一个很好的记忆方法是，大端序是按照数字的书写顺序进行存储的，而小端序是颠倒书写顺序进行存储的。</p>
<h3 id="编程判断大端序和小端序">编程判断大端序和小端序</h3><p>方法一<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsBigEndian</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a =<span class="number">1</span> ; </span><br><span class="line">    <span class="keyword">if</span>(((<span class="keyword">char</span>*)&amp;a)[<span class="number">3</span>] ==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span> ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>打开VS的内存窗口，看一下a的存储方式，一目了然</p>
<p><img src="http://pic002.cnblogs.com/images/2011/64257/2011042122464910.png" alt=""></p>
<p>由于a是int，所以占四个字节，其值是00000001，存储方式如下。所以a[3]是0，不是大端序。一个更标准的写法是将a[3]替换为a[sizeof(int) - 1]。</p>
<p>0x0012FE88　　01<br>0x0012FE89　　00<br>0x0012FE8A　　00<br>0x0012FE8B　　00</p>
<p>方法二，使用union，原理见后面的面试题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsBigEndian</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">short</span> a ;</span><br><span class="line">        <span class="keyword">char</span> b ;</span><br><span class="line">    &#125; c;</span><br><span class="line"></span><br><span class="line">    c.a =<span class="number">0x0102</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(c.b ==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span> ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="一道面试题">一道面试题</h4><p>来道题巩固一下，下面代码输出什么？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> u &#123;</span><br><span class="line">    <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">char</span> x[<span class="number">2</span>] ;</span><br><span class="line">&#125; a ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    a.x[<span class="number">0</span>] =<span class="string">'1'</span> ;</span><br><span class="line">    a.x[<span class="number">1</span>] =<span class="string">'2'</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.i &lt;&lt; endl ;</span><br><span class="line"></span><br><span class="line">    getchar() ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个题，要看你使用的是什么系列的CPU，姑且假设是Intel系列的。Union是一个特殊的结构，其中所有成员共享结一个内存地址，任意时间只能存储一个成员，上面的Union大小为4个字节，所以上面的代码存储完字符1和2之后，Union的存储貌似应该是0x31320000，31和32分别是字符’1’和’2’的十六进制ASCII码（注意是字符1和2，而不是整数），但是Intel系列的CPU都是按照小端序存储的，所以，正确的顺序是0x00003231，对应的十进制数是12849，你答对了么？</p>
<p>关于字节序的详细内容，请看Wikipedia的介绍 <a href="http://en.wikipedia.org/wiki/Endianness" target="_blank" rel="external">http://en.wikipedia.org/wiki/Endianness</a></p>
<p>== Happy coding ==</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="大端序与小端序">大端序与小端序</h2><h3 id="何为大端序，小端序？">何为大端序，小端序？</h3><p>简单点说，就是字节的存储顺序，如果数据都是单字节的，那怎么存储无所谓了，但是对于多字节数据，比如int，double等，就要考虑存储的顺序了。注意字节序是硬件层面的东西，对于软件来说通常是透明的。再说白一点，字节序通常只和你使用的处理器架构有关，而和编程语言无关，比如常见的Intel x86系列就是小端序。</p>
<h4 id="Big-endian（大端序）">Big-endian（大端序）</h4><p>数据的高位字节存放在地址的低端 低位字节存放在地址高端</p>
<h4 id="Little-endian（小端序）">Little-endian（小端序）</h4><p>数据的高位字节存放在地址的高端 低位字节存放在地址低端</p>
<h4 id="字节的高位与低位">字节的高位与低位</h4><p>举个例子，int a = 0x12345678 ; 那么左边12就是高位字节，右边的78就是低位字节，从左到右，由高到低，（注意，高低乃相对而言，比如56相对于78是高字节，相对于34是低字节）</p>
<p>地址的高端与低端<br>0x00000001<br>0x00000002<br>0x00000003<br>0x00000004<br>从上倒下，由低到高，地址值小的为低端，地址值大的为高端。</p>]]>
    
    </summary>
    
      <category term="BASE" scheme="http://ytlvy.com/tags/BASE/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS NSNull Detect]]></title>
    <link href="http://ytlvy.com/2015/08/11/iOS-NSNull-Detect/"/>
    <id>http://ytlvy.com/2015/08/11/iOS-NSNull-Detect/</id>
    <published>2015-08-11T14:16:33.000Z</published>
    <updated>2015-08-11T14:16:53.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Object-C中nil,_NULL跟NSNull">Object-C中nil, NULL跟NSNull</h2><p>相信不少开发者，都被NSNull坑过，最常见的是服务器返回的json里面，说好的字典、数组、数字，结果返回的是空值。这个时候，NSJSONSerialization 会自动把他们换成 NSNull。当我们再去用dict[@“hello”]的时候，就会出触发exception，导致程序崩溃。</p>
<h3 id="最简单的做法">最简单的做法</h3><p>相信大家都知道，[NSNull null] 并不是一个工厂方法，而是一个单例模式，那么我们直接去判断赋值的这个指针是不是[NSNull null] 就好了。</p>
<p>那么问题来了，编译器会多了一个warning，很烦人。</p>
<p>在<a href="http://www.takingnotes.co/blog/2012/01/06/comparing-to-nsnull/" target="_blank" rel="external">这篇文章</a>里面介绍了各种做法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)someMethod </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">NSString</span> *aString = <span class="string">@"loremipsum"</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// This will complain: "Comparison of distinct pointer types ('NSString *' and 'NSNull *')" </span></span><br><span class="line">    <span class="keyword">if</span> (aString != [<span class="built_in">NSNull</span> null]) </span><br><span class="line">    &#123; </span><br><span class="line"> </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// This works (at least for strings), but isEqual: does different things  </span></span><br><span class="line">    <span class="comment">// for different classes, so it's not ideal </span></span><br><span class="line">    <span class="keyword">if</span> ([aString isEqual:[<span class="built_in">NSNull</span> null]]) </span><br><span class="line">    &#123; </span><br><span class="line"> </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// If you cast it to the class you're comparing against </span></span><br><span class="line">    <span class="comment">// then you're good to go </span></span><br><span class="line">    <span class="keyword">if</span> (aString != (<span class="built_in">NSString</span> *)[<span class="built_in">NSNull</span> null]) </span><br><span class="line">    &#123; </span><br><span class="line"> </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// But we can also just cast it to id and </span></span><br><span class="line">    <span class="comment">// that works generically </span></span><br><span class="line">    <span class="keyword">if</span> (aString != (<span class="keyword">id</span>)[<span class="built_in">NSNull</span> null]) </span><br><span class="line">    &#123; </span><br><span class="line"> </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// The thing that would be really cool, </span></span><br><span class="line">    <span class="comment">// would be [NSNull null] returning </span></span><br><span class="line">    <span class="comment">// id (like in the sample category below). </span></span><br><span class="line">    <span class="comment">// Wouldn't count on that one though. </span></span><br><span class="line">    <span class="keyword">if</span> (aString != [<span class="built_in">NSNull</span> idNull]) </span><br><span class="line">    &#123; </span><br><span class="line"> </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些都不是非常漂亮的解决方案，这篇文章的作者推荐：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSNull</span> (<span class="title">idNull</span>) </span></span><br><span class="line">+ (<span class="keyword">id</span>)idNull; </span><br><span class="line"><span class="keyword">@end</span> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSNull</span> (<span class="title">idNull</span>) </span></span><br><span class="line">+ (<span class="keyword">id</span>)idNull &#123; <span class="keyword">return</span> [<span class="built_in">NSNull</span> null]; &#125; </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>或者呢<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([[NSNull <span class="literal">null</span>] <span class="string">isEqual:</span>aString]) </span><br><span class="line">&#123; </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="最终解决方案">最终解决方案</h3><p>上面的做法，都需要判断一次，还是很不优雅，为什么呢，我们还是不能像NULL，nil一样，直接拿来用，还是需要判断一下，这里推荐一套最漂亮的作法。</p>
<p>陈航提供了一个<a href="https://gist.github.com/cyndibaby905/9828745" target="_blank" rel="external">gist</a><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#define NSNullObjects @[@<span class="title">""</span>,@0,@&#123;&#125;,@[]] </span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSNull</span> (<span class="title">InternalNullExtention</span>) </span></span><br><span class="line"><span class="keyword">@end</span> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSNull</span> (<span class="title">InternalNullExtention</span>) </span></span><br><span class="line"> </span><br><span class="line">- (<span class="built_in">NSMethodSignature</span>*)methodSignatureForSelector:(SEL)selector </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">NSMethodSignature</span>* signature = [<span class="keyword">super</span> methodSignatureForSelector:selector]; </span><br><span class="line">    <span class="keyword">if</span> (!signature) &#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSObject</span> *object <span class="keyword">in</span> <span class="built_in">NSNullObjects</span>) &#123; </span><br><span class="line">            signature = [object methodSignatureForSelector:selector]; </span><br><span class="line">            <span class="keyword">if</span> (signature) &#123; </span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line"> </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> signature; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation </span><br><span class="line">&#123; </span><br><span class="line">    SEL aSelector = [anInvocation selector]; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSObject</span> *object <span class="keyword">in</span> <span class="built_in">NSNullObjects</span>) &#123; </span><br><span class="line">        <span class="keyword">if</span> ([object respondsToSelector:aSelector]) &#123; </span><br><span class="line">            [anInvocation invokeWithTarget:object]; </span><br><span class="line">            <span class="keyword">return</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    [<span class="keyword">self</span> doesNotRecognizeSelector:aSelector]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>这里还提供一个日本人的封装方案：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"NSNull+OVNatural.h"</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSNull</span> (<span class="title">OVNatural</span>) </span></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:[invocation selector]]) &#123; </span><br><span class="line">        [invocation invokeWithTarget:<span class="keyword">self</span>]; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)selector </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *sig = [[<span class="built_in">NSNull</span> class] instanceMethodSignatureForSelector:selector]; </span><br><span class="line">    <span class="keyword">if</span>(sig == <span class="literal">nil</span>) &#123; </span><br><span class="line">        sig = [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="string">"@^v^c"</span>]; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> sig; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<h3 id="nil_判定">nil 判定</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断对象不空</span></span><br><span class="line"><span class="keyword">if</span>(object) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断对象为空</span></span><br><span class="line"><span class="keyword">if</span>(object == <span class="literal">nil</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组初始化，空值结束</span></span><br><span class="line"><span class="built_in">NSArray</span> *pageNames=[[<span class="built_in">NSArray</span> alloc] initWithObjects:<span class="string">@"DocumentList"</span>,<span class="string">@"AdvancedSearch"</span>,<span class="string">@"Statistics"</span>,<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断数组元素是否为空</span></span><br><span class="line"><span class="built_in">UIViewController</span> *controller=[<span class="built_in">NSArray</span> objectAtIndex:i];</span><br><span class="line"><span class="keyword">if</span>((<span class="built_in">NSNull</span> *)controller == [<span class="built_in">NSNull</span> null])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断字典对象的元素是否为空</span></span><br><span class="line"><span class="built_in">NSString</span> *userId=[<span class="built_in">NSDictionary</span> objectForKey:<span class="string">@"UserId"</span>];</span><br><span class="line"><span class="keyword">if</span>(userId == [<span class="built_in">NSNull</span> null])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Object-C中nil,_NULL跟NSNull">Object-C中nil, NULL跟NSNull</h2><p>相信不少开发者，都被NSNull坑过，最常见的是服务器返回的json里面，说好的字典、数组、数字，结果返回的是空值。这个时候，NSJSONSer]]>
    </summary>
    
      <category term="NSNULL" scheme="http://ytlvy.com/tags/NSNULL/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS APP Icon Longpress shake]]></title>
    <link href="http://ytlvy.com/2015/08/11/iOS-APP-Icon-Longpress-shake/"/>
    <id>http://ytlvy.com/2015/08/11/iOS-APP-Icon-Longpress-shake/</id>
    <published>2015-08-11T14:14:48.000Z</published>
    <updated>2015-08-11T14:15:15.000Z</updated>
    <content type="html"><![CDATA[<h2 id="iOS_APP图标长按抖动效果的实现（CAAnimation）">iOS APP图标长按抖动效果的实现（CAAnimation）</h2><p>实现效果:当长按图标时，图标抖动，点击图标以外区域时停止抖动</p>
<p><img src="http://img.blog.csdn.net/20150808181226925" alt=""></p>
<p>工程下载：<a href="https://github.com/Nongchaozhe/iconShakeDemo" target="_blank" rel="external">github工程下载</a></p>
<p>1) 视图代码</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIImageView</span> *imageView;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    imageView = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>)];</span><br><span class="line">    imageView<span class="variable">.center</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.center</span>;</span><br><span class="line">    imageView<span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"icon1"</span>];</span><br><span class="line">    imageView<span class="variable">.userInteractionEnabled</span> = <span class="literal">YES</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addSubview:imageView];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加长按手势</span></span><br><span class="line">    <span class="built_in">UILongPressGestureRecognizer</span> *recognize = [[<span class="built_in">UILongPressGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(longPress)];</span><br><span class="line">    <span class="comment">//长按响应时间</span></span><br><span class="line">    recognize<span class="variable">.minimumPressDuration</span> = <span class="number">1</span>;</span><br><span class="line">    [imageView addGestureRecognizer:recognize];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>2) 手势响应</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)longPress &#123;</span><br><span class="line">    <span class="built_in">CABasicAnimation</span> *animation = (<span class="built_in">CABasicAnimation</span> *)[imageView<span class="variable">.layer</span> animationForKey:<span class="string">@"rotation"</span>];</span><br><span class="line">    <span class="keyword">if</span> (animation == <span class="literal">nil</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> shakeImage];</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> resume];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果点击图标外区域，停止抖动</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="built_in">UITouch</span> *touch = [touches anyObject];</span><br><span class="line">    <span class="built_in">CGPoint</span> point = [touch locationInView:<span class="keyword">self</span><span class="variable">.view</span>];</span><br><span class="line">    <span class="comment">//转换坐标系，判断touch点是否在imageView内，在的话，仍然抖动，否则停止抖动</span></span><br><span class="line">    <span class="built_in">CGPoint</span> p = [<span class="keyword">self</span><span class="variable">.view</span> convertPoint:point toView:imageView];</span><br><span class="line">    <span class="keyword">if</span> (![imageView pointInside:p withEvent:event]) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"xxxxxxx"</span>);</span><br><span class="line">        [<span class="keyword">self</span> pause];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//layer.speed</span></span><br><span class="line"><span class="comment">/* The rate of the layer. Used to scale parent time to local time, e.g.</span><br><span class="line"> * if rate is 2, local time progresses twice as fast as parent time.</span><br><span class="line"> * Defaults to 1. */</span></span><br><span class="line"><span class="comment">//这个参数的理解比较复杂，我的理解是所在layer的时间与父layer的时间的相对速度，为1时两者速度一样，为2那么父layer过了一秒，而所在layer过了两秒（进行两秒动画）,为0则静止。</span></span><br><span class="line">- (<span class="keyword">void</span>)pause &#123;</span><br><span class="line">    imageView<span class="variable">.layer</span><span class="variable">.speed</span> = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)resume &#123;</span><br><span class="line">    imageView<span class="variable">.layer</span><span class="variable">.speed</span> = <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3) 动画设置<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>shakeImage &#123;</span><br><span class="line">    <span class="comment">//创建动画对象,绕Z轴旋转</span></span><br><span class="line">    CABasicAnimation <span class="built_in">*</span>animation = [CABasicAnimation animationWithKeyPath:@<span class="string">"transform.rotation.z"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置属性，周期时长</span></span><br><span class="line">    [animation setDuration:<span class="number">0.08</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//抖动角度</span></span><br><span class="line">    animation.fromValue = @<span class="params">(-M_1_<span class="literal">PI</span>/<span class="number">2</span>)</span>;</span><br><span class="line">    animation.toValue = @<span class="params">(M_1_<span class="literal">PI</span>/<span class="number">2</span>)</span>;</span><br><span class="line">    <span class="comment">//重复次数，无限大</span></span><br><span class="line">    animation.repeatCount = HUGE_VAL;</span><br><span class="line">    <span class="comment">//恢复原样</span></span><br><span class="line">    animation.autoreverses = YES;</span><br><span class="line">    <span class="comment">//锚点设置为图片中心，绕中心抖动</span></span><br><span class="line">    imageView.layer.anchorPoint = CGPointMake<span class="params">(<span class="number">0.5</span>, <span class="number">0.5</span>)</span>;</span><br><span class="line"></span><br><span class="line">    [imageView.layer addAnimation:animation forKey:@<span class="string">"rotation"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="iOS_APP图标长按抖动效果的实现（CAAnimation）">iOS APP图标长按抖动效果的实现（CAAnimation）</h2><p>实现效果:当长按图标时，图标抖动，点击图标以外区域时停止抖动</p>
<p><img src="http://img.blog.csdn.net/20150808181226925" alt=""></p>
<p>工程下载：<a href="https://github.com/Nongchaozhe/iconShakeDemo">github工程下载</a></p>
<p>1) 视图代码</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIImageView</span> *imageView;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    imageView = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>)];</span><br><span class="line">    imageView<span class="variable">.center</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.center</span>;</span><br><span class="line">    imageView<span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"icon1"</span>];</span><br><span class="line">    imageView<span class="variable">.userInteractionEnabled</span> = <span class="literal">YES</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addSubview:imageView];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加长按手势</span></span><br><span class="line">    <span class="built_in">UILongPressGestureRecognizer</span> *recognize = [[<span class="built_in">UILongPressGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(longPress)];</span><br><span class="line">    <span class="comment">//长按响应时间</span></span><br><span class="line">    recognize<span class="variable">.minimumPressDuration</span> = <span class="number">1</span>;</span><br><span class="line">    [imageView addGestureRecognizer:recognize];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Animation" scheme="http://ytlvy.com/tags/Animation/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS Music Background Play And Lock Screen Image]]></title>
    <link href="http://ytlvy.com/2015/08/11/iOS-Music-Background-Play-And-Lock-Screen-Image/"/>
    <id>http://ytlvy.com/2015/08/11/iOS-Music-Background-Play-And-Lock-Screen-Image/</id>
    <published>2015-08-11T14:13:28.000Z</published>
    <updated>2015-08-11T14:14:04.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/zsk_zane/article/details/47320621" target="_blank" rel="external">reference</a></p>
<h2 id="iOS_音乐后台播放及锁屏信息显示">iOS 音乐后台播放及锁屏信息显示</h2><p>实现音乐的后台播放，以及播放时，可以控制其暂停，下一首等操作，以及锁屏图片歌曲名等的显示<br>此实例需要真机调试，效果图如下： </p>
<p><img src="http://img.blog.csdn.net/20150806175143383" alt=""></p>
<p>工程下载：<a href="https://github.com/Nongchaozhe/MusicRemoteControl" target="_blank" rel="external">github工程下载</a></p>
<h3 id="实现步骤：">实现步骤：</h3><p>1) 首先修改info.plist</p>
<p><img src="http://img.blog.csdn.net/20150806174938474" alt=""></p>
<p>2) 其次引入两个需要的框架</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;AVFoundation/AVFoundation.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;MediaPlayer/MediaPlayer.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>3) 设置播放器及后台播放</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"><span class="comment">//    设置后台播放</span></span><br><span class="line">    [[<span class="built_in">AVAudioSession</span> sharedInstance] setCategory:<span class="built_in">AVAudioSessionCategoryPlayback</span> error:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//    设置播放器</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> fileURLWithPath:[[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"那些花儿"</span> ofType:<span class="string">@"mp3"</span>] ];</span><br><span class="line">    _player = [[<span class="built_in">AVPlayer</span> alloc] initWithURL:url];</span><br><span class="line">    [_player play];</span><br><span class="line">    _isPlayingNow = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后台播放显示信息设置</span></span><br><span class="line">    [<span class="keyword">self</span> setPlayingInfo];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - 接收方法的设置</span></span><br><span class="line">- (<span class="keyword">void</span>)remoteControlReceivedWithEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="keyword">if</span> (event<span class="variable">.type</span> == <span class="built_in">UIEventTypeRemoteControl</span>) &#123;  <span class="comment">//判断是否为远程控制</span></span><br><span class="line">        <span class="keyword">switch</span> (event<span class="variable">.subtype</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span>  <span class="built_in">UIEventSubtypeRemoteControlPlay</span>:</span><br><span class="line">                <span class="keyword">if</span> (!_isPlayingNow) &#123;</span><br><span class="line">                    [_player play];</span><br><span class="line">                &#125;</span><br><span class="line">                _isPlayingNow = !_isPlayingNow;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlPause</span>:</span><br><span class="line">                <span class="keyword">if</span> (_isPlayingNow) &#123;</span><br><span class="line">                    [_player pause];</span><br><span class="line">                &#125;</span><br><span class="line">                _isPlayingNow = !_isPlayingNow;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlNextTrack</span>:</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"下一首"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlPreviousTrack</span>:</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"上一首 "</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>4) 设置后台播放时显示的东西，例如歌曲名字，图片等</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setPlayingInfo &#123;</span><br><span class="line"><span class="comment">//    &lt;MediaPlayer/MediaPlayer.h&gt;</span></span><br><span class="line">    <span class="built_in">MPMediaItemArtwork</span> *artWork = [[<span class="built_in">MPMediaItemArtwork</span> alloc] initWithImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"pushu.jpg"</span>]];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSDictionary</span> *dic = @&#123;<span class="built_in">MPMediaItemPropertyTitle</span>:<span class="string">@"那些花儿"</span>,</span><br><span class="line">                          <span class="built_in">MPMediaItemPropertyArtist</span>:<span class="string">@"朴树"</span>,</span><br><span class="line">                          <span class="built_in">MPMediaItemPropertyArtwork</span>:artWork</span><br><span class="line">                          &#125;;</span><br><span class="line">    [[<span class="built_in">MPNowPlayingInfoCenter</span> defaultCenter] setNowPlayingInfo:dic];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5) 远程控制设置</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (void)<span class="tag">viewDidAppear</span>:(BOOL)<span class="tag">animated</span> &#123;</span><br><span class="line"><span class="comment">//    接受远程控制</span></span><br><span class="line">    <span class="attr_selector">[self becomeFirstResponder]</span>;</span><br><span class="line">    <span class="attr_selector">[[UIApplication sharedApplication]</span> <span class="tag">beginReceivingRemoteControlEvents</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">viewDidDisappear</span>:(BOOL)<span class="tag">animated</span> &#123;</span><br><span class="line"><span class="comment">//    取消远程控制</span></span><br><span class="line">    <span class="attr_selector">[self resignFirstResponder]</span>;</span><br><span class="line">    <span class="attr_selector">[[UIApplication sharedApplication]</span> <span class="tag">endReceivingRemoteControlEvents</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://blog.csdn.net/zsk_zane/article/details/47320621">reference</a></p>
<h2 id="iOS_音乐后台播放及锁屏信息显示">iOS 音乐后台播放及锁屏信息显示</h2><p>实现音乐的后台播放，以及播放时，可以控制其暂停，下一首等操作，以及锁屏图片歌曲名等的显示<br>此实例需要真机调试，效果图如下： </p>
<p><img src="http://img.blog.csdn.net/20150806175143383" alt=""></p>
<p>工程下载：<a href="https://github.com/Nongchaozhe/MusicRemoteControl">github工程下载</a></p>
<h3 id="实现步骤：">实现步骤：</h3><p>1) 首先修改info.plist</p>
<p><img src="http://img.blog.csdn.net/20150806174938474" alt=""></p>
<p>2) 其次引入两个需要的框架</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;AVFoundation/AVFoundation.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;MediaPlayer/MediaPlayer.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>3) 设置播放器及后台播放</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"><span class="comment">//    设置后台播放</span></span><br><span class="line">    [[<span class="built_in">AVAudioSession</span> sharedInstance] setCategory:<span class="built_in">AVAudioSessionCategoryPlayback</span> error:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//    设置播放器</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> fileURLWithPath:[[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"那些花儿"</span> ofType:<span class="string">@"mp3"</span>] ];</span><br><span class="line">    _player = [[<span class="built_in">AVPlayer</span> alloc] initWithURL:url];</span><br><span class="line">    [_player play];</span><br><span class="line">    _isPlayingNow = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后台播放显示信息设置</span></span><br><span class="line">    [<span class="keyword">self</span> setPlayingInfo];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - 接收方法的设置</span></span><br><span class="line">- (<span class="keyword">void</span>)remoteControlReceivedWithEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="keyword">if</span> (event<span class="variable">.type</span> == <span class="built_in">UIEventTypeRemoteControl</span>) &#123;  <span class="comment">//判断是否为远程控制</span></span><br><span class="line">        <span class="keyword">switch</span> (event<span class="variable">.subtype</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span>  <span class="built_in">UIEventSubtypeRemoteControlPlay</span>:</span><br><span class="line">                <span class="keyword">if</span> (!_isPlayingNow) &#123;</span><br><span class="line">                    [_player play];</span><br><span class="line">                &#125;</span><br><span class="line">                _isPlayingNow = !_isPlayingNow;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlPause</span>:</span><br><span class="line">                <span class="keyword">if</span> (_isPlayingNow) &#123;</span><br><span class="line">                    [_player pause];</span><br><span class="line">                &#125;</span><br><span class="line">                _isPlayingNow = !_isPlayingNow;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlNextTrack</span>:</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"下一首"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlPreviousTrack</span>:</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"上一首 "</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Audio" scheme="http://ytlvy.com/tags/Audio/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS Crash Bugs]]></title>
    <link href="http://ytlvy.com/2015/08/11/iOS-Crash-Bugs/"/>
    <id>http://ytlvy.com/2015/08/11/iOS-Crash-Bugs/</id>
    <published>2015-08-11T14:12:12.000Z</published>
    <updated>2015-08-11T14:12:45.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Crash_Bug">Crash Bug</h2><p>1) ios7 下没有 <code>ContainString</code> API</p>
<p>2) NSDictionary &amp; NSArray nil insert </p>
<p>3) 数组越界 NSArray <code>out of bounds</code></p>
<p>4) <code>substringwithrange</code> out of bounds</p>
<p>5) <code>GPUImageView presentBufferForDisplay</code> — 内存泄露 或者 app 进入后台</p>
<p>6) <code>locationOfTouch: inView:</code> </p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">if</span> (gestureRecognizer)<span class="tag">numberOfTouches</span> &gt; <span class="tag">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>7) “[NSPlaceholderMutableString initWithString:]: nil argument” - NSString的<code>initWithString:</code>或者<code>stringWithString:</code> 传入了 nil 参数</p>
<p>8) 调用为 nil 的block<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(block)</span> &#123;</span><br><span class="line">    block<span class="comment">()</span>;    <span class="comment">//确定不为空之后才放心地调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>9) 调用了不存在的方法<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">if</span> ([a <span class="attribute">respondsToSelector</span>:<span class="variable">@selector</span>(aaa)]) &#123;</span><br><span class="line">    <span class="attr_selector">[a aaa]</span>;            <span class="comment">//确定有该方法之后才放心地调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>10) 在cellForRowAtIndexPath中返回了nil</p>
<p>出现这种情况的原因有：</p>
<p><code>numberOfRowsInSection</code>返回的数目不正确，导致行数比<code>cellForRowAtIndexPath</code>预期的多，于是<code>cellForRowAtIndexPath</code>就不能正确返回超出预期的cell了。<br><code>cellForRowAtIndexPath</code>中逻辑有误，漏了一些情况，导致有些cell不能正确返回。</p>
<p>11) NSJSONSerialization 识别失败 为 NSNull </p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Crash_Bug">Crash Bug</h2><p>1) ios7 下没有 <code>ContainString</code> API</p>
<p>2) NSDictionary &amp; NSArray nil insert </p>
<p>3) 数组越界 NSArray <code>out of bounds</code></p>
<p>4) <code>substringwithrange</code> out of bounds</p>
<p>5) <code>GPUImageView presentBufferForDisplay</code> — 内存泄露 或者 app 进入后台</p>
<p>6) <code>locationOfTouch: inView:</code> </p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">if</span> (gestureRecognizer)<span class="tag">numberOfTouches</span> &gt; <span class="tag">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Bug" scheme="http://ytlvy.com/tags/Bug/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Audio Basic Knowleage]]></title>
    <link href="http://ytlvy.com/2015/08/11/Audio-Basic-Knowleage/"/>
    <id>http://ytlvy.com/2015/08/11/Audio-Basic-Knowleage/</id>
    <published>2015-08-11T14:00:00.000Z</published>
    <updated>2015-08-11T14:00:26.000Z</updated>
    <content type="html"><![CDATA[<h2 id="音频编码基础知识">音频编码基础知识</h2><p>自然界中的声音非常复杂，波形极其复杂，通常我们采用的是脉冲代码调制编码，即PCM编码。PCM通过抽样、量化、编码三个步骤将连续变化的模拟信号转换为数字编码。</p>
<h3 id="什么是采样率和采样大小（位/bit）。">什么是采样率和采样大小（位/bit）。</h3><p>声音其实是一种能量波，因此也有频率和振幅的特征，频率对应于时间轴线，振幅对应于电平轴线。波是无限光滑的，弦线可以看成由无数点组成，由于存储空间是相对有限的，数字编码过程中，必须对弦线的点进行采样。采样的过程就是抽取某点的频率值，很显然，在一秒中内抽取的点越多，获取得频率信息更丰富，为了复原波形，一次振动中，必须有2个点的采样，人耳能够感觉到的最高频率为20kHz，因此要满足人耳的听觉要求，则需要至少每秒进行40k次采样，用40kHz表达，这个40kHz就是采样率。我们常见的CD，采样率为44.1kHz。光有频率信息是不够的，我们还必须获得该频率的能量值并量化，用于表示信号强度。量化电平数为2的整数次幂，我们常见的CD位16bit的采样大小，即2的16次方。采样大小相对采样率更难理解，因为要显得抽象点，举个简单例子：假设对一个波进行8次采样，采样点分别对应的能量值分别为A1-A8，但我们只使用2bit的采样大小，结果我们只能保留A1-A8中4个点的值而舍弃另外4个。如果我们进行3bit的采样大小，则刚好记录下8个点的所有信息。采样率和采样大小的值越大，记录的波形更接近原始信号。</p>
<h3 id="有损和无损">有损和无损</h3><p>根据采样率和采样大小可以得知，相对自然界的信号，音频编码最多只能做到无限接近，至少目前的技术只能这样了，相对自然界的信号，任何数字音频编码方案都是有损的，因为无法完全还原。在计算机应用中，能够达到最高保真水平的就是PCM编码，被广泛用于素材保存及音乐欣赏，CD、DVD以及我们常见的WAV文件中均有应用。因此，PCM约定俗成了无损编码，因为PCM代表了数字音频中最佳的保真水准，并不意味着PCM就能够确保信号绝对保真，PCM也只能做到最大程度的无限接近。我们而习惯性的把MP3列入有损音频编码范畴，是相对PCM编码的。强调编码的相对性的有损和无损，是为了告诉大家，要做到真正的无损是困难的，就像用数字去表达圆周率，不管精度多高，也只是无限接近，而不是真正等于圆周率的值。</p>
<h3 id="为什么要使用音频压缩技术">为什么要使用音频压缩技术</h3><p>要算一个PCM音频流的码率是一件很轻松的事情，采样率值×采样大小值×声道数 bps。一个采样率为<code>44.1KHz</code>，采样大小为<code>16bit</code>，双声道的PCM编码的WAV文件，它的数据速率则为 <code>44.1K×16×2 =1411.2 Kbps</code>。我们常说<code>128K</code>的MP3，对应的WAV的参数，就是这个<code>1411.2 Kbps</code>，这个参数也被称为数据带宽，它和ADSL中的带宽是一个概念。将码率除以8,就可以得到这个WAV的数据速率，即<code>176.4KB/s</code>。这表示存储一秒钟采样率为<code>44.1KHz</code>，采样大小为<code>16bit</code>，双声道的PCM编码的音频信号，需要<code>176.4KB</code>的空间，1分钟则约为<code>10.34M</code>，这对大部分用户是不可接受的，尤其是喜欢在电脑上听音乐的朋友，要降低磁盘占用，只有2种方法，降低采样指标或者压缩。降低指标是不可取的，因此专家们研发了各种压缩方案。由于用途和针对的目标市场不一样，各种音频压缩编码所达到的音质和压缩比都不一样，在后面的文章中我们都会一一提到。有一点是可以肯定的，他们都压缩过。</p>
<h3 id="频率与采样率的关系">频率与采样率的关系</h3><p>采样率表示了每秒对原始信号采样的次数，我们常见到的音频文件采样率多为44.1KHz，这意味着什么呢？假设我们有2段正弦波信号，分别为20Hz和20KHz，长度均为一秒钟，以对应我们能听到的最低频和最高频，分别对这两段信号进行40KHz的采样，我们可以得到一个什么样的结果呢？结果是：20Hz的信号每次振动被采样了40K/20=2000次，而20K的信号每次振动只有2次采样。显然，在相同的采样率下，记录低频的信息远比高频的详细。这也是为什么有些音响发烧友指责CD有数码声不够真实的原因，CD的44.1KHz采样也无法保证高频信号被较好记录。要较好的记录高频信号，看来需要更高的采样率，于是有些朋友在捕捉CD音轨的时候使用48KHz的采样率，这是不可取的！这其实对音质没有任何好处，对抓轨软件来说，保持和CD提供的44.1KHz一样的采样率才是最佳音质的保证之一，而不是去提高它。较高的采样率只有相对模拟信号的时候才有用，如果被采样的信号是数字的，请不要去尝试提高采样率。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="音频编码基础知识">音频编码基础知识</h2><p>自然界中的声音非常复杂，波形极其复杂，通常我们采用的是脉冲代码调制编码，即PCM编码。PCM通过抽样、量化、编码三个步骤将连续变化的模拟信号转换为数字编码。</p>
<h3 id="什么是采样率和采样大小（位/b]]>
    </summary>
    
      <category term="Audio" scheme="http://ytlvy.com/tags/Audio/"/>
    
      <category term="Audio" scheme="http://ytlvy.com/categories/Audio/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Convert PCM To AAC]]></title>
    <link href="http://ytlvy.com/2015/08/11/Convert-PCM-To-AAC/"/>
    <id>http://ytlvy.com/2015/08/11/Convert-PCM-To-AAC/</id>
    <published>2015-08-11T13:58:23.000Z</published>
    <updated>2015-08-11T13:58:54.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/poechant/article/details/7435054" target="_blank" rel="external">reference</a></p>
<h2 id="音频编解码·实战篇（1）PCM转至AAC（AAC编码）">音频编解码·实战篇（1）PCM转至AAC（AAC编码）</h2><ul>
<li>作者：柳大·Poechant</li>
<li>博客：blog.csdn.net/poechant</li>
<li>邮箱：zhongchao.ustc@gmail.com</li>
<li>日期：April 7th, 2012</li>
</ul>
<p>这里利用FAAC来实现AAC编码。</p>
<h3 id="下载安装_FAAC">下载安装 FAAC</h3><p>这里的安装过程是在 Mac 和 Linux 上实现的，Windows可以类似参考。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="comment">//downloads.sourceforge.net/faac/faac-1.28.tar.gz</span></span><br><span class="line">tar zxvf faac-<span class="number">1.28</span><span class="class">.tar</span><span class="class">.gz</span></span><br><span class="line">cd faac-<span class="number">1.28</span></span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>如果才用默认的 configure 中的 prefix path，那么安装后的 lib 和 .h 文件分别在/usr/local/lib和/usr/local/include，后面编译的时候会用到。</p>
<p>如果编译过程中发现错误：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpeg4ip.h:126: <span class="keyword">error</span>: <span class="keyword">new</span> declaration ‘<span class="keyword">char</span>* strcasestr(<span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">const</span> <span class="keyword">char</span>*)’</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>解决方法：<br>从123行开始修改此文件mpeg4ip.h，到129行结束。 修改前：<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#ifdef __cplusplus</span></span><br><span class="line">extern <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line"><span class="keyword">char</span> *strcasestr(<span class="keyword">const</span> <span class="keyword">char</span> *haystack, <span class="keyword">const</span> <span class="keyword">char</span> *needle);</span><br><span class="line"><span class="preprocessor">#ifdef __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br></pre></td></tr></table></figure></p>
<p>修改后：<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#ifdef __cplusplus</span></span><br><span class="line">extern <span class="string">"C++"</span> &#123;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *strcasestr(<span class="keyword">const</span> <span class="keyword">char</span> *haystack, <span class="keyword">const</span> <span class="keyword">char</span> *needle);</span><br><span class="line"><span class="preprocessor">#ifdef __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br></pre></td></tr></table></figure></p>
<h3 id="FAAC_API">FAAC API</h3><h4 id="Open_FAAC_engine">Open FAAC engine</h4><p>Prototype:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">faacEncHandle faacEncOpen               <span class="comment">// 返回一个FAAC的handle</span></span><br><span class="line">(                   </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   nSampleRate,        <span class="comment">// 采样率，单位是bps</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   nChannels,          <span class="comment">// 声道，1为单声道，2为双声道</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   &amp;nInputSamples,     <span class="comment">// 传引用，得到每次调用编码时所应接收的原始数据长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   &amp;nMaxOutputBytes    <span class="comment">// 传引用，得到每次调用编码时生成的AAC数据的最大长度</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h4 id="Get/Set_encoding_configuration">Get/Set encoding configuration</h4><p>获取编码器的配置：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">faacEncConfigurationPtr faacEncGetCurrentConfiguration <span class="comment">// 得到指向当前编码器配置的指针</span></span><br><span class="line">(</span><br><span class="line">    faacEncHandle hEncoder  <span class="comment">// FAAC的handle</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>设定编码器的配置：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> FAA<span class="built_in">CAPI</span> faacEncSetConfiguration</span><br><span class="line">(</span><br><span class="line">    faacDecHandle hDecoder,         <span class="comment">// 此前得到的FAAC的handle</span></span><br><span class="line">    faacEncConfigurationPtr config  <span class="comment">// FAAC编码器的配置</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h4 id="Encode">Encode</h4><p>Prototype:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> faacEncEncode</span><br><span class="line">(</span><br><span class="line">    faacEncHandle hEncoder,     <span class="comment">// FAAC的handle</span></span><br><span class="line">    <span class="keyword">short</span> *inputBuffer,         <span class="comment">// PCM原始数据</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> samplesInput,  <span class="comment">// 调用faacEncOpen时得到的nInputSamples值</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *outputBuffer,<span class="comment">// 至少具有调用faacEncOpen时得到的nMaxOutputBytes字节长度的缓冲区</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bufferSize     <span class="comment">// outputBuffer缓冲区的实际大小</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h4 id="Close_FAAC_engine">Close FAAC engine</h4><p>Prototype<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> faacEncClose</span><br><span class="line">(</span><br><span class="line">    faacEncHandle hEncoder  <span class="comment">// 此前得到的FAAC handle</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h3 id="流程">流程</h3><h4 id="做什么准备？">做什么准备？</h4><p>采样率，声道数（双声道还是单声道？），还有你的PCM的单个样本是8位的还是16位的？</p>
<h4 id="开启FAAC编码器，做编码前的准备">开启FAAC编码器，做编码前的准备</h4><ol>
<li>调用faacEncOpen开启FAAC编码器后，得到了单次输入样本数nInputSamples和输出数据最大字节数nMaxOutputBytes；</li>
<li>根据nInputSamples和nMaxOutputBytes，分别为PCM数据和将要得到的AAC数据创建缓冲区；</li>
<li>调用faacEncGetCurrentConfiguration获取当前配置，修改完配置后，调用faacEncSetConfiguration设置新配置。</li>
</ol>
<h4 id="开始编码">开始编码</h4><p>调用<code>faacEncEncode</code>，该准备的刚才都准备好了，很简单。</p>
<h4 id="善后">善后</h4><p>关闭编码器，另外别忘了释放缓冲区，如果使用了文件流，也别忘记了关闭。</p>
<h3 id="测试程序">测试程序</h3><h4 id="完整代码">完整代码</h4><p>将PCM格式音频文件<code>/home/michael/Development/testspace/in.pcm</code>转至AAC格式文件<code>/home/michael/Development/testspace/out.aac</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;faac.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>   ULONG;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>    UINT;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>   BYTE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>            _TCHAR;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, _TCHAR* argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ULONG nSampleRate = <span class="number">11025</span>;  <span class="comment">// 采样率</span></span><br><span class="line">    UINT nChannels = <span class="number">1</span>;         <span class="comment">// 声道数</span></span><br><span class="line">    UINT nPCMBitSize = <span class="number">16</span>;      <span class="comment">// 单样本位数</span></span><br><span class="line">    ULONG nInputSamples = <span class="number">0</span>;</span><br><span class="line">    ULONG nMaxOutputBytes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nRet;</span><br><span class="line">    faacEncHandle hEncoder;</span><br><span class="line">    faacEncConfigurationPtr pConfiguration; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nBytesRead;</span><br><span class="line">    <span class="keyword">int</span> nPCMBufferSize;</span><br><span class="line">    BYTE* pbPCMBuffer;</span><br><span class="line">    BYTE* pbAACBuffer;</span><br><span class="line"></span><br><span class="line">    FILE* fpIn; <span class="comment">// PCM file for input</span></span><br><span class="line">    FILE* fpOut; <span class="comment">// AAC file for output</span></span><br><span class="line"></span><br><span class="line">    fpIn = fopen(<span class="string">"/home/michael/Development/testspace/in.pcm"</span>, <span class="string">"rb"</span>);</span><br><span class="line">    fpOut = fopen(<span class="string">"/home/michael/Development/testspace/out.aac"</span>, <span class="string">"wb"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (1) Open FAAC engine</span></span><br><span class="line">    hEncoder = faacEncOpen(nSampleRate, nChannels, &amp;nInputSamples, &amp;nMaxOutputBytes);</span><br><span class="line">    <span class="keyword">if</span>(hEncoder == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[ERROR] Failed to call faacEncOpen()\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nPCMBufferSize = nInputSamples * nPCMBitSize / <span class="number">8</span>;</span><br><span class="line">    pbPCMBuffer = <span class="keyword">new</span> BYTE [nPCMBufferSize];</span><br><span class="line">    pbAACBuffer = <span class="keyword">new</span> BYTE [nMaxOutputBytes];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (2.1) Get current encoding configuration</span></span><br><span class="line">    pConfiguration = faacEncGetCurrentConfiguration(hEncoder);</span><br><span class="line">    pConfiguration-&gt;inputFormat = FAAC_INPUT_16BIT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (2.2) Set encoding configuration</span></span><br><span class="line">    nRet = faacEncSetConfiguration(hEncoder, pConfiguration);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读入的实际字节数，最大不会超过nPCMBufferSize，一般只有读到文件尾时才不是这个值</span></span><br><span class="line">        nBytesRead = fread(pbPCMBuffer, <span class="number">1</span>, nPCMBufferSize, fpIn);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输入样本数，用实际读入字节数计算，一般只有读到文件尾时才不是nPCMBufferSize/(nPCMBitSize/8);</span></span><br><span class="line">        nInputSamples = nBytesRead / (nPCMBitSize / <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (3) Encode</span></span><br><span class="line">        nRet = faacEncEncode(</span><br><span class="line">        hEncoder, (<span class="keyword">int</span>*) pbPCMBuffer, nInputSamples, pbAACBuffer, nMaxOutputBytes);</span><br><span class="line"></span><br><span class="line">        fwrite(pbAACBuffer, <span class="number">1</span>, nRet, fpOut);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d: faacEncEncode returns %d\n"</span>, i, nRet);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nBytesRead &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        // (3) Flushing</span><br><span class="line">        nRet = faacEncEncode(</span><br><span class="line">        hEncoder, (int*) pbPCMBuffer, 0, pbAACBuffer, nMaxOutputBytes);</span><br><span class="line"></span><br><span class="line">        if(nRet &lt;= 0)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// (4) Close FAAC engine</span></span><br><span class="line">    nRet = faacEncClose(hEncoder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] pbPCMBuffer;</span><br><span class="line">    <span class="keyword">delete</span>[] pbAACBuffer;</span><br><span class="line">    fclose(fpIn);</span><br><span class="line">    fclose(fpOut);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getchar();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="编译运行">编译运行</h4><p>将上述代码保存为“pcm2aac.cpp”文件，然后编译：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">g</span>++ pcm2aac.cpp -o pcm2aac -<span class="keyword">L</span>/usr/<span class="keyword">local</span>/lib -lfaac -I/usr/<span class="keyword">local</span>/<span class="keyword">include</span></span><br></pre></td></tr></table></figure></p>
<p>运行：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./pc<span class="title">m2</span>aac</span><br></pre></td></tr></table></figure></p>
<p>然后就生成了out.aac文件了，听听看吧！~</p>
<h3 id="Reference">Reference</h3><ul>
<li><a href="http://www.audiocoding.com/faac.html" target="_blank" rel="external">AudioCoding.com - FAAC</a></li>
<li><a href="http://blog.tcltk.co.kr/?p=2130" target="_blank" rel="external">Dogfoot – 재밌는 개발</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://blog.csdn.net/poechant/article/details/7435054">reference</a></p>
<h2 id="音频编解码·实战篇（1）PCM转至AAC（AAC编码）">音频编解码·实战篇（1）PCM转至AAC（AAC编码）</h2><ul>
<li>作者：柳大·Poechant</li>
<li>博客：blog.csdn.net/poechant</li>
<li>邮箱：zhongchao.ustc@gmail.com</li>
<li>日期：April 7th, 2012</li>
</ul>
<p>这里利用FAAC来实现AAC编码。</p>
<h3 id="下载安装_FAAC">下载安装 FAAC</h3><p>这里的安装过程是在 Mac 和 Linux 上实现的，Windows可以类似参考。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="comment">//downloads.sourceforge.net/faac/faac-1.28.tar.gz</span></span><br><span class="line">tar zxvf faac-<span class="number">1.28</span><span class="class">.tar</span><span class="class">.gz</span></span><br><span class="line">cd faac-<span class="number">1.28</span></span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>如果才用默认的 configure 中的 prefix path，那么安装后的 lib 和 .h 文件分别在/usr/local/lib和/usr/local/include，后面编译的时候会用到。</p>
<p>如果编译过程中发现错误：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpeg4ip.h:126: <span class="keyword">error</span>: <span class="keyword">new</span> declaration ‘<span class="keyword">char</span>* strcasestr(<span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">const</span> <span class="keyword">char</span>*)’</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Audio" scheme="http://ytlvy.com/tags/Audio/"/>
    
      <category term="Audio" scheme="http://ytlvy.com/categories/Audio/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Wave And PCM Audio Format]]></title>
    <link href="http://ytlvy.com/2015/08/11/Wave-And-PCM-Audio-Format/"/>
    <id>http://ytlvy.com/2015/08/11/Wave-And-PCM-Audio-Format/</id>
    <published>2015-08-11T13:57:06.000Z</published>
    <updated>2015-08-11T13:57:42.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/poechant/article/details/7436710" target="_blank" rel="external">reference</a></p>
<h2 id="音频编解码·格式篇（1）Wave_PCM_audio_format（WAV）">音频编解码·格式篇（1）Wave PCM audio format（WAV）</h2><ul>
<li>作者：柳大·Poechant</li>
<li>博客：Blog.CSDN.net/Poechant</li>
<li>邮箱：zhongchao.ustc@gmail.com</li>
<li>日期：April 6th, 2012</li>
</ul>
<h3 id="音频编解码基础">音频编解码基础</h3><ul>
<li>采样率：声音信号在“模数转换”过程中单位时间内采样的次数。</li>
<li>采样值：每一次采样周期内声音模拟信号的积分值。</li>
<li>单声道：11.025 KHz 采样值，8 Bits 采样值（0x00 - 0xFF）。</li>
<li>双声道：44.1 KHz 采样值，16 Bits 采样值。高八位表示左声道，低八位表示右声道。</li>
</ul>
<h3 id="WAV音频文件格式">WAV音频文件格式</h3><p>见下图：<br><img src="http://img.my.csdn.net/uploads/201204/08/1333820202_8901.png" alt=""></p>
<p>1) 文件头</p>
<ul>
<li>RIFF/WAV 文件标识段</li>
<li>声音数据格式说明段</li>
</ul>
<p>2) 数据体：由 PCM（脉冲编码调制）格式表示的样本组成。</p>
<p>单声道 WAV 文件中，声道0代表左声道，声道1代表右声道；多声道 WAV 文件中，左右声道的样本是交替出现的。</p>
<a id="more"></a>
<h4 id="文件头格式：">文件头格式：</h4><table>
<thead>
<tr>
<th>偏移地址</th>
<th>字节数</th>
<th>数据类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00</td>
<td>4</td>
<td>char</td>
<td>“RIFF”标志</td>
</tr>
<tr>
<td>0x04</td>
<td>4</td>
<td>long int</td>
<td>文件长度</td>
</tr>
<tr>
<td>0x08</td>
<td>4</td>
<td>char</td>
<td>“WAVE”标志</td>
</tr>
<tr>
<td>0x0C</td>
<td>4</td>
<td>char</td>
<td>“fmt ”标志</td>
</tr>
<tr>
<td>0x10</td>
<td>4</td>
<td></td>
<td>过度字节（不定）</td>
</tr>
<tr>
<td>0x14</td>
<td>2</td>
<td>int</td>
<td>格式类别（0x10是PCM形式的声音格式）</td>
</tr>
<tr>
<td>0x16</td>
<td>2</td>
<td>int</td>
<td>通道数（1为单声道，2为双声道）</td>
</tr>
<tr>
<td>0x18</td>
<td>2</td>
<td>int</td>
<td>采样率（每秒的样本数，表示每个通道的播放速度）</td>
</tr>
<tr>
<td>0x1C</td>
<td>4</td>
<td>long int</td>
<td>波形音频数据传输速率，为（通道数x每秒数据位数x样本的数据位数/8，播放器根据此值估算缓冲区大小）</td>
</tr>
<tr>
<td>0x20</td>
<td>2</td>
<td>int</td>
<td>数据块的调整数，为（通道数x没样本的数据位值/8），播放软件一次需要处理多个该值大小的字节数据，以便就爱将其值用于缓冲区的调整</td>
</tr>
<tr>
<td>0x22</td>
<td>2</td>
<td></td>
<td>每样本的数据位数，表示每个声道中各样本的数据位数，如果有多个声道，对每个声道而言，样本大小都一样</td>
</tr>
</tbody>
</table>
<h4 id="数据体格式：">数据体格式：</h4><table>
<thead>
<tr>
<th>偏移地址</th>
<th>字节数</th>
<th>数据类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x24</td>
<td>4</td>
<td>char</td>
<td>数据标记符“data”</td>
</tr>
<tr>
<td>0x28</td>
<td>4</td>
<td>long int</td>
<td>语音数据的长度</td>
</tr>
</tbody>
</table>
<p>然后就是语音数据帧了。下表中的0声道代表左声道，1声道代表右声道：</p>
<table>
<thead>
<tr>
<th>偏移地址</th>
<th>sample1</th>
<th>sample2</th>
</tr>
</thead>
<tbody>
<tr>
<td>8位单声道</td>
<td>0声道</td>
<td>0声道</td>
</tr>
<tr>
<td>8位双声道</td>
<td>0声道，1声道</td>
<td>0声道，1声道</td>
</tr>
<tr>
<td>16位单声道</td>
<td>0声道低字节，0声道高字节</td>
<td>0声道低字节，0声道高字节</td>
</tr>
<tr>
<td>16位双声道</td>
<td>0声道低字节，0声道搞字节</td>
<td>1声道低字节，1声道高字节</td>
</tr>
</tbody>
</table>
<h4 id="WAV文件格式实例分析（转载）">WAV文件格式实例分析（转载）</h4><table>
<thead>
<tr>
<th>地址段</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00000000</td>
<td>52</td>
<td>49</td>
<td>46</td>
<td>46</td>
<td>0A</td>
<td>06</td>
<td>01</td>
<td>00</td>
<td>57</td>
<td>41</td>
<td>56</td>
<td>45</td>
<td>66</td>
<td>6D</td>
<td>74</td>
<td>20</td>
</tr>
<tr>
<td>0x00000010</td>
<td>12</td>
<td>00</td>
<td>00</td>
<td>00</td>
<td>01</td>
<td>00</td>
<td>02</td>
<td>00</td>
<td>44</td>
<td>AC</td>
<td>00</td>
<td>00</td>
<td>10</td>
<td>B1</td>
<td>02</td>
<td>00</td>
</tr>
<tr>
<td>0x00000020</td>
<td>04</td>
<td>00</td>
<td>10</td>
<td>00</td>
<td>00</td>
<td>00</td>
<td>66</td>
<td>61</td>
<td>63</td>
<td>74</td>
<td>04</td>
<td>00</td>
<td>00</td>
<td>00</td>
<td>76</td>
<td>41</td>
</tr>
<tr>
<td>0x00000030</td>
<td>00</td>
<td>00</td>
<td>64</td>
<td>61</td>
<td>74</td>
<td>61</td>
<td>D8</td>
<td>05</td>
<td>01</td>
<td>00</td>
<td>00</td>
<td>00</td>
<td>00</td>
<td>00</td>
<td>FF</td>
<td>FF</td>
</tr>
<tr>
<td>0x00000040</td>
<td>00</td>
<td>00</td>
<td>FE</td>
<td>FF</td>
<td>FE</td>
<td>FF</td>
<td>00</td>
<td>00</td>
<td>00</td>
<td>00</td>
<td>FE</td>
<td>FF</td>
<td>FE</td>
<td>FF</td>
<td>00</td>
<td>00</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>0x00000050</td>
<td>64</td>
<td>61</td>
<td>6B</td>
<td>61</td>
<td>D8</td>
<td>05</td>
<td>01</td>
<td>00</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>地址段</th>
<th>字节数</th>
<th>数据类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00 - 0x03</td>
<td>4</td>
<td>4个char</td>
<td>标志位，”RIFF”</td>
</tr>
<tr>
<td>0x04 - 0x07</td>
<td>4</td>
<td>1个int</td>
<td>文件长度，小尾端，实际是0x0001060A</td>
</tr>
<tr>
<td>0x08 - 0x0B</td>
<td>4</td>
<td>4个char</td>
<td>标志位，“WAVE”</td>
</tr>
<tr>
<td>0x0C - 0x0F</td>
<td>4</td>
<td>4个char</td>
<td>标志位，“fmt ”，fmt表示为，最后一个是空格</td>
</tr>
<tr>
<td>0x10 - 0x13</td>
<td>4</td>
<td>1个int</td>
<td>0x00000012，sizeof(PCMWAVEFORMAT)</td>
</tr>
<tr>
<td>0x14 - 0x15</td>
<td>2</td>
<td>1个short</td>
<td>格式类别，1（WAVE_FORMAT_PCM）表示PCM形式的声音数据</td>
</tr>
<tr>
<td>0x16 - 0x17</td>
<td>2</td>
<td>1个short</td>
<td>通道数，1为单声道，2为双声道</td>
</tr>
<tr>
<td>0x18 - 0x1B</td>
<td>4</td>
<td>1个int</td>
<td>采样率</td>
</tr>
<tr>
<td>0x1C - 0x1F</td>
<td>4</td>
<td>1个int</td>
<td>0x10B10000，每秒数据量</td>
</tr>
<tr>
<td>0x20 - 0x21</td>
<td>2</td>
<td>1个short</td>
<td>数据块的调整值（按字节算）</td>
</tr>
<tr>
<td>0x22 - 0x4F</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>0x50 - 0x53</td>
<td>4</td>
<td>4个char</td>
<td>标志位，“data”</td>
</tr>
<tr>
<td>0x54 - 0x57</td>
<td>4</td>
<td>1个int</td>
<td>语音数据大小，0x000105D8</td>
</tr>
</tbody>
</table>
<h3 id="Reference">Reference</h3><ul>
<li><a href="http://wenku.baidu.com/view/c8357e6baf1ffc4ffe47ac08.html" target="_blank" rel="external">WAV(PCM)文件格式分析</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://blog.csdn.net/poechant/article/details/7436710">reference</a></p>
<h2 id="音频编解码·格式篇（1）Wave_PCM_audio_format（WAV）">音频编解码·格式篇（1）Wave PCM audio format（WAV）</h2><ul>
<li>作者：柳大·Poechant</li>
<li>博客：Blog.CSDN.net/Poechant</li>
<li>邮箱：zhongchao.ustc@gmail.com</li>
<li>日期：April 6th, 2012</li>
</ul>
<h3 id="音频编解码基础">音频编解码基础</h3><ul>
<li>采样率：声音信号在“模数转换”过程中单位时间内采样的次数。</li>
<li>采样值：每一次采样周期内声音模拟信号的积分值。</li>
<li>单声道：11.025 KHz 采样值，8 Bits 采样值（0x00 - 0xFF）。</li>
<li>双声道：44.1 KHz 采样值，16 Bits 采样值。高八位表示左声道，低八位表示右声道。</li>
</ul>
<h3 id="WAV音频文件格式">WAV音频文件格式</h3><p>见下图：<br><img src="http://img.my.csdn.net/uploads/201204/08/1333820202_8901.png" alt=""></p>
<p>1) 文件头</p>
<ul>
<li>RIFF/WAV 文件标识段</li>
<li>声音数据格式说明段</li>
</ul>
<p>2) 数据体：由 PCM（脉冲编码调制）格式表示的样本组成。</p>
<p>单声道 WAV 文件中，声道0代表左声道，声道1代表右声道；多声道 WAV 文件中，左右声道的样本是交替出现的。</p>]]>
    
    </summary>
    
      <category term="Audio" scheme="http://ytlvy.com/tags/Audio/"/>
    
      <category term="Audio" scheme="http://ytlvy.com/categories/Audio/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[git flow]]></title>
    <link href="http://ytlvy.com/2015/08/09/git-flow/"/>
    <id>http://ytlvy.com/2015/08/09/git-flow/</id>
    <published>2015-08-09T13:33:20.000Z</published>
    <updated>2015-08-09T13:33:53.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="external">reference</a></p>
<h2 id="A_successful_Git_branching_model">A successful Git branching model</h2><p><code>git flow</code> 工作流, 流转示意图:</p>
<p><img src="http://nvie.com/img/git-model@2x.png" alt="git flow"></p>
<h3 id="去中心化_和_中心化">去中心化 和 中心化</h3><p>此工作流中, 存在唯一的<code>中心仓库</code> — <code>origin</code>. 每个程序员向中心仓库, 拉取更新和提交更新. 然而, 程序员也可以被划分为小组, 来进入更进一步的划分, 先从这些<code>分中心仓库</code> 来拉取更新和提交更新, 先完成小组的同步, 再和中心仓库同步.</p>
<p><img src="http://nvie.com/img/centr-decentr@2x.png" alt=""></p>
<h3 id="主要分支">主要分支</h3><p>这个工作流的核心为两个主分支:</p>
<ol>
<li>Master</li>
<li>Develop</li>
</ol>
<p><img src="http://nvie.com/img/main-branches@2x.png" alt=""></p>
<a id="more"></a>
<p>在<code>origin</code> 上的主分支, 对 Git 用户来说是很熟悉了, 另外一个则是 <code>develop</code> 分支. 我们认为 <code>origin/master</code> 分支的 <code>HEAD</code> 总是<strong>发布版</strong>的源代码. 而 <code>origin/develop</code> 分支的 <code>HEAD</code> 则是为下一个开发版准备的最新开发状态. 此分支也被称为<strong>整合分支</strong>. 这也是所有 <code>nightly</code> 版本编译的来源.</p>
<p>当在开发分支上达到一定的稳定状态时, 会被合并到 <code>master</code> 分支, 从而生成一个全新的发布版本. 我们倾向于严格的处理主分支的合并, 此外, 我们可以采用一个 <code>Git hook</code> 脚本来监控主分支的 <code>commit</code> 事件, 然后自动打包, 并将程序分发到产品服务器.</p>
<h3 id="支持分支">支持分支</h3><p>除了主要分支外, 工作流还使用了很多支持分支, 来方便并发开发. 比如: 新功能开发, 版本发布准备和版本 bug 修复工作同步处理. 不像主要分支, 这些分支都有一定的生命周期, 他们将最终被删除.</p>
<p>支持分支类型:</p>
<ol>
<li>Feature branches</li>
<li>Release branches</li>
<li>Hotfix branches</li>
</ol>
<p>这些分支都有自己独特的使命, 并存在严格的处理规则, 例如从哪里派生, 合并到哪里.这些分支在技术角度是没有区别的, 只是我们人为的划分为不同的功能.</p>
<h3 id="Feature_branches">Feature branches</h3><p>可以派生自:<br><code>Develop</code> 分支</p>
<p>必须合并到:<br><code>Develop</code> 分支</p>
<p>命名规则:<br>除 <code>master, develop, release-*, or hotfix-*</code> 以外</p>
<p><img src="http://nvie.com/img/fb@2x.png" alt=""></p>
<p><code>Feature branches</code> 主要用来开发新功能. 当进入 <code>Feature</code> 开发时, 最终会发布到那个版本, 可能还没有确定. <code>Feature</code>分支最终会合并入 <code>Develop</code>分支, 或者废弃. <code>Feature</code>分支只存在于开发库中, 不应该同步到 <code>origin</code> 中心仓库.</p>
<h4 id="Creating_a_feature_branch">Creating a feature branch</h4><p>从<code>develop</code> 派生新的功能分支</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -<span class="tag">b</span> myfeature develop</span><br><span class="line">Switched to <span class="tag">a</span> new branch <span class="string">"myfeature"</span></span><br></pre></td></tr></table></figure>
<h4 id="Incorporating_a_finished_feature_on_develop">Incorporating a finished feature on develop</h4><p>当功能分支结束开发, 合并回开发分支.</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout develop</span><br><span class="line"><span class="keyword">Switched </span>to <span class="keyword">branch </span><span class="string">'develop'</span></span><br><span class="line"></span><br><span class="line">$ git merge --no-ff myfeature</span><br><span class="line"><span class="label">Updating</span> ea1b82a..<span class="number">05</span>e9557</span><br><span class="line">(Summary of changes)</span><br><span class="line"></span><br><span class="line">$ git <span class="keyword">branch </span>-d myfeature</span><br><span class="line"><span class="label">Deleted</span> <span class="keyword">branch </span>myfeature (was <span class="number">05</span>e9557).</span><br><span class="line"></span><br><span class="line">$ git <span class="keyword">push </span>origin develop</span><br></pre></td></tr></table></figure>
<p><code>--no-ff</code> 符号会使得合并总是生成一个新的提交点, 即使是 <code>fast-forward</code> 合并. 这可以避免丢失分支的历史存在信息.</p>
<p><img src="http://nvie.com/img/merge-without-ff@2x.png" alt=""></p>
<p>在上图中, 后面不添加 <code>--no-ff</code> 的做法, 就使得我们很难看出, 曾经合并了一个功能分支, 除非通过阅读所有的日志信息.</p>
<h3 id="Release_branches">Release branches</h3><p>可以派生自:<br><code>Develop</code> 分支</p>
<p>必须合并到:<br><code>develop</code> 分支 和 <code>master</code> 分支</p>
<p>命名规则:<br><code>release-*</code></p>
<p>发布分支为下一个版本的发布做准备. 它允许少量的 bug 修复, 以及发布准备(例如: 版本号, 编译日期, 等). 通过在发布分支做这些事情, 可以使得 开发分支 清晰的去合并新的功能分支, 从而为下一个版本做准备.</p>
<p>发布分支是在开发分支达到一定的发布状态时, 才在开发分支派生的, 例如至少要在所有当前版本功能, 都合并入开发分支后. 此时所有的未来版本功能不应合并入开发分支, 直到发布分支派生后为止.</p>
<h4 id="Creating_a_release_branch">Creating a release branch</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -<span class="tag">b</span> release-<span class="number">1.2</span> develop</span><br><span class="line">Switched to <span class="tag">a</span> new branch <span class="string">"release-1.2"</span></span><br><span class="line"></span><br><span class="line">$ ./bump-version<span class="class">.sh</span> <span class="number">1.2</span></span><br><span class="line">Files modified successfully, version bumped to <span class="number">1.2</span>.</span><br><span class="line"></span><br><span class="line">$ git commit -<span class="tag">a</span> -m <span class="string">"Bumped version number to 1.2"</span></span><br><span class="line">[release-<span class="number">1.2</span> <span class="number">74</span>d9424] Bumped version number to <span class="number">1.2</span></span><br><span class="line"><span class="number">1</span> files changed, <span class="number">1</span> <span class="function"><span class="title">insertions</span><span class="params">(+)</span></span>, <span class="number">1</span> <span class="function"><span class="title">deletions</span><span class="params">(-)</span></span></span><br></pre></td></tr></table></figure>
<p><code>bump-version.sh</code> 脚本为一个变更文件版本号的脚本, 此步骤可以通过手工更改代替.</p>
<p>这个新分支会存在一段时间, 直到可以确定发布为止. 在此阶段, 此分支的主要功能为 bug 修改. 此时严禁合并大的功能模块. 此分支会最终合并回开发分支, 在开发分支为下一个发布做准备.</p>
<h4 id="Finishing_a_release_branch">Finishing a release branch</h4><p>当发布分支准备完毕后, 会被首先合并到 <code>master</code> 分支, 因为所有的发布状态都会放到此分支. 然后在主分支打标签, 以便未来浏览. 最后在发布分支上的修改会合并回 <code>develop</code>.</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched <span class="built_in">to</span> branch <span class="string">'master'</span></span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">merge</span> <span class="comment">--no-ff release-1.2</span></span><br><span class="line">Merge made <span class="keyword">by</span> recursive.</span><br><span class="line">(Summary <span class="operator">of</span> changes)</span><br><span class="line"></span><br><span class="line">$ git tag -<span class="operator">a</span> <span class="number">1.2</span></span><br></pre></td></tr></table></figure>
<p>发布完成, 也打完了标签</p>
<blockquote>
<p>你可能希望使用 <code>-s or -u &lt;key&gt;</code> 来打标签</p>
</blockquote>
<p>合并回 <code>develop</code> </p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout develop</span><br><span class="line">Switched <span class="built_in">to</span> branch <span class="string">'develop'</span></span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">merge</span> <span class="comment">--no-ff release-1.2</span></span><br><span class="line">Merge made <span class="keyword">by</span> recursive.</span><br><span class="line">(Summary <span class="operator">of</span> changes)</span><br></pre></td></tr></table></figure>
<p>这一步可能引起冲突, 如果发生, 先解决冲突再提交.</p>
<p>删除此分支<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>-d release-<span class="number">1</span>.<span class="number">2</span></span><br><span class="line"><span class="label">Deleted</span> <span class="keyword">branch </span>release-<span class="number">1</span>.<span class="number">2</span> (was ff452fe).</span><br></pre></td></tr></table></figure></p>
<h3 id="Hotfix_branches">Hotfix branches</h3><p>可以派生自:<br><code>master</code> 分支</p>
<p>必须合并到:<br><code>develop</code> 分支 和 <code>master</code> 分支</p>
<p>命名规则:<br><code>hotfix-*</code></p>
<p><code>Hotfix</code> 分支和 <code>release</code> 分支很像, 都是为新的版本发布做准备. 他们为解决某个线上产品版本的严重 bug 而生. 它的存在是为了不打断现阶段的开发进程.</p>
<p><img src="http://nvie.com/img/hotfix-branches@2x.png" alt=""></p>
<h4 id="Creating_the_hotfix_branch">Creating the hotfix branch</h4><p><code>Hotfix</code> 分支派生自 <code>master</code>分支. 例如: 当前版本为1.2, 出现了严重问题. 然而在 <code>develop</code> 分支修改是很不稳定的, 因为此分支目前可能有新的不完善的功能, 所以我们需要派生一个 <code>Hotfix</code> 分支.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -<span class="tag">b</span> hotfix-<span class="number">1.2</span>.<span class="number">1</span> master</span><br><span class="line">Switched to <span class="tag">a</span> new branch <span class="string">"hotfix-1.2.1"</span></span><br><span class="line"></span><br><span class="line">$ ./bump-version<span class="class">.sh</span> <span class="number">1.2</span>.<span class="number">1</span></span><br><span class="line">Files modified successfully, version bumped to <span class="number">1.2</span>.<span class="number">1</span>.</span><br><span class="line"></span><br><span class="line">$ git commit -<span class="tag">a</span> -m <span class="string">"Bumped version number to 1.2.1"</span></span><br><span class="line">[hotfix-<span class="number">1.2</span>.<span class="number">1</span> <span class="number">41</span>e61bb] Bumped version number to <span class="number">1.2</span>.<span class="number">1</span></span><br><span class="line"><span class="number">1</span> files changed, <span class="number">1</span> <span class="function"><span class="title">insertions</span><span class="params">(+)</span></span>, <span class="number">1</span> <span class="function"><span class="title">deletions</span><span class="params">(-)</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>不要忘记修改版本信息</p>
</blockquote>
<p>然后 bug 修复完了, 我们需要提交修改</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"Fixed severe production problem"</span></span><br><span class="line">[hotfix-<span class="number">1.2</span>.<span class="number">1</span> abbe5d6] Fixed severe production problem</span><br><span class="line"><span class="number">5</span> files changed, <span class="number">32</span> <span class="function"><span class="title">insertions</span><span class="params">(+)</span></span>, <span class="number">17</span> <span class="function"><span class="title">deletions</span><span class="params">(-)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="Finishing_a_hotfix_branch">Finishing a hotfix branch</h4><p>结束后, <code>bugfix</code> 需要合并回 <code>master</code>, 同时也需要合并到 <code>develop</code>. </p>
<p>合并到主分支<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched <span class="built_in">to</span> branch <span class="string">'master'</span></span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">merge</span> <span class="comment">--no-ff hotfix-1.2.1</span></span><br><span class="line">Merge made <span class="keyword">by</span> recursive.</span><br><span class="line">(Summary <span class="operator">of</span> changes)</span><br><span class="line"></span><br><span class="line">$ git tag -<span class="operator">a</span> <span class="number">1.2</span>.1</span><br></pre></td></tr></table></figure></p>
<p>合并到开发分支<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout develop</span><br><span class="line">Switched <span class="built_in">to</span> branch <span class="string">'develop'</span></span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">merge</span> <span class="comment">--no-ff hotfix-1.2.1</span></span><br><span class="line">Merge made <span class="keyword">by</span> recursive.</span><br><span class="line">(Summary <span class="operator">of</span> changes)</span><br></pre></td></tr></table></figure></p>
<p>例外情况为, 如果此时 <code>release</code>分支存在, 则直接合并入此 <code>release</code>分支, 不再直接合并入 <code>develop</code>. 因为<code>release</code>分支最终回合并回 <code>develop</code>.</p>
<p>删除此分支<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>-d hotfix-<span class="number">1</span>.<span class="number">2</span>.<span class="number">1</span></span><br><span class="line"><span class="label">Deleted</span> <span class="keyword">branch </span>hotfix-<span class="number">1</span>.<span class="number">2</span>.<span class="number">1</span> (was abbe5d6).</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://nvie.com/posts/a-successful-git-branching-model/">reference</a></p>
<h2 id="A_successful_Git_branching_model">A successful Git branching model</h2><p><code>git flow</code> 工作流, 流转示意图:</p>
<p><img src="http://nvie.com/img/git-model@2x.png" alt="git flow"></p>
<h3 id="去中心化_和_中心化">去中心化 和 中心化</h3><p>此工作流中, 存在唯一的<code>中心仓库</code> — <code>origin</code>. 每个程序员向中心仓库, 拉取更新和提交更新. 然而, 程序员也可以被划分为小组, 来进入更进一步的划分, 先从这些<code>分中心仓库</code> 来拉取更新和提交更新, 先完成小组的同步, 再和中心仓库同步.</p>
<p><img src="http://nvie.com/img/centr-decentr@2x.png" alt=""></p>
<h3 id="主要分支">主要分支</h3><p>这个工作流的核心为两个主分支:</p>
<ol>
<li>Master</li>
<li>Develop</li>
</ol>
<p><img src="http://nvie.com/img/main-branches@2x.png" alt=""></p>]]>
    
    </summary>
    
      <category term="Git" scheme="http://ytlvy.com/tags/Git/"/>
    
      <category term="Git" scheme="http://ytlvy.com/categories/Git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Notes: The interesting things from WWDC, iOS 9, Swift 2]]></title>
    <link href="http://ytlvy.com/2015/08/08/Notes-The-interesting-things-from-WWDC-iOS-9-Swift-2/"/>
    <id>http://ytlvy.com/2015/08/08/Notes-The-interesting-things-from-WWDC-iOS-9-Swift-2/</id>
    <published>2015-08-08T13:25:39.000Z</published>
    <updated>2015-08-08T13:26:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="WWDC中那些令人感兴趣的事物:iOS_9,_Swift_2">WWDC中那些令人感兴趣的事物:iOS 9, Swift 2</h2><blockquote>
<ul>
<li>原文链接 : <a href="http://iosdevtips.co/post/121053658888/wwdc-ios-9-swift-2-notes" target="_blank" rel="external">Notes: The interesting things from WWDC, iOS 9, Swift 2</a></li>
<li>原文作者: <a href="http://iosdevtips.co" target="_blank" rel="external">Rounak Jain</a></li>
<li>译文出自: <a href="http://www.devtf.cn/" target="_blank" rel="external">开发技术前线http://www.devtf.cn/</a></li>
<li>译者 : <a href="https://github.com/Lollypo" target="_blank" rel="external">Lollypo</a> </li>
<li>校对者:<a href="https://github.com/bboyfeiyu" target="_blank" rel="external">Mr.Simple</a></li>
<li>状态 :  完成</li>
</ul>
</blockquote>
<p>今天WWDC上的Keynote非常棒,即便到目前为止还未结束.在开发者方面,已经有大量的新事物出现,其中包括有Swift 2, iOS 9, CloudKit等等.</p>
<p>这里是我在浏览发布日志,API差异,新特性等内容时记录的笔记</p>
<ul>
<li><p>你不需要加入$99的开发者计划就可以在真机上调试应用程序.此外,Mac与iOS开发者计划合并,可以节省一半支出:<br><img src="http://40.media.tumblr.com/ab8cf0d95f459e63bb10ded612e2fa34/tumblr_inline_npnb64YpK31qh9cw7_500.png" alt=""></p>
</li>
<li><p>Interface Builder支持实时预览模糊与透明效果<br><img src="http://40.media.tumblr.com/ed19a7cbd80fe5ccb49f5a9102744eec/tumblr_inline_npnb8aLtBC1qh9cw7_500.png" alt=""></p>
</li>
<li><p>Objective-C支持泛型,这意味着集合对象,如数组,字典可以像Swift一样指定类型<br><img src="http://40.media.tumblr.com/4ed77823bca27d89db84f654080d7d28/tumblr_inline_npnbbdudd01qh9cw7_500.png" alt=""></p>
</li>
<li><p>新的名为 <a href="https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIStackView_Class_Reference/index.html#//apple_ref/doc/uid/TP40015256" target="_blank" rel="external">UIStackView</a>UI类,是Mac中NSStackView的一种实现.</p>
</li>
<li><p><a href="https://developer.apple.com/library/prerelease/ios/documentation/DataManagement/Conceptual/CloutKitWebServicesReference/Introduction/Introduction.html#//apple_ref/doc/uid/TP40015240" target="_blank" rel="external">CloudKit现在也可以在Web中使用</a></p>
</li>
<li><p>开放 CASpringAnimation!<br><img src="http://40.media.tumblr.com/65c41c82d295034c23ef986214404c6d/tumblr_inline_npnbg2mCrc1qh9cw7_500.png" alt=""></p>
</li>
<li><p>应用程序现在可以作为拓展插入到Safari中,听起来有点像广告拦截器.此外,应用程序可以在Safari的共享链接填充内容</p>
</li>
<li><p>开发者现在可以使用 <code>SFSafariViewController</code>, 这可以共享Safari中中cookies, 自动填充以及其他Safari中的特性.</p>
</li>
<li><p><code>UIPickerView</code> 可转换为任意尺寸,而不必再使用那些丑陋的转换技巧.</p>
</li>
<li><p>iOS应用程序可在发出提醒展示一段文本域,此前仅限于Messages使用.</p>
</li>
<li><p>通讯录可通过面向对象的API来访问,而不是之前的C</p>
</li>
<li><p>电话API在低版本设备上不支持,这也许会导致编译时错误.现在有新的判断条件来决定是否执行代码,这可以有效避免使用新的API导致的应用程序崩溃:<br><img src="http://41.media.tumblr.com/c1875f851f168467e8e3bd435fa31f8d/tumblr_inline_npnbnvrUp31qh9cw7_500.png" alt=""></p>
</li>
<li><p><code>UICollectionView</code> 新添加了许多方法来支持交互式移动</p>
</li>
<li><p>新的名为 <code>UIFieldBehavior</code> 的 UIKit Dynamics类</p>
</li>
<li><p>Xcode Assets Catalog: 设备不会一次性下载所有尺寸的图片,而根据其自身的需要下载 1x, 2x 或 3x 的图片,大大减少了应用程序的大小.</p>
</li>
</ul>
<h2 id="其他一些你可能感兴趣的链接:">其他一些你可能感兴趣的链接:</h2><ul>
<li><a href="https://t.co/cOdmXdQ0EQ" target="_blank" rel="external">API差异</a></li>
<li><a href="https://itunes.apple.com/us/book/swift-programming-language/id1002622538?mt=11" target="_blank" rel="external">Swift 2提前发布版电子书</a></li>
<li><a href="http://t.co/5pU8P4iNEH" target="_blank" rel="external">Xcode 7 发布日志</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="WWDC中那些令人感兴趣的事物:iOS_9,_Swift_2">WWDC中那些令人感兴趣的事物:iOS 9, Swift 2</h2><blockquote>
<ul>
<li>原文链接 : <a href="http://iosdevtips.co/post/1]]>
    </summary>
    
      <category term="WWDC" scheme="http://ytlvy.com/tags/WWDC/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift UIKit Dynamics Tutorial: Getting Started]]></title>
    <link href="http://ytlvy.com/2015/08/08/Swift-UIKit-Dynamics-Tutorial-Getting-Started/"/>
    <id>http://ytlvy.com/2015/08/08/Swift-UIKit-Dynamics-Tutorial-Getting-Started/</id>
    <published>2015-08-08T13:24:37.000Z</published>
    <updated>2015-08-08T13:25:06.000Z</updated>
    <content type="html"><![CDATA[<h2 id="UIKit_Dynamics_教程:_起步">UIKit Dynamics 教程: 起步</h2><blockquote>
<ul>
<li>原文链接 : <a href="http://www.raywenderlich.com/76147/uikit-dynamics-tutorial-swift" target="_blank" rel="external">UIKit Dynamics Tutorial: Getting Started</a></li>
<li>原文作者: <a href="http://www.raywenderlich.com/u/frosty" target="_blank" rel="external">James Frost</a></li>
<li>译文出自: <a href="http://www.devtf.cn/" target="_blank" rel="external">开发技术前线http://www.devtf.cn/</a></li>
<li>译者 : <a href="https://github.com/Lollypo" target="_blank" rel="external">Lollypo</a> </li>
<li>校对者: <a href="https://github.com/mrchenhao" target="_blank" rel="external">Harries Chen</a></li>
<li>状态 :  完成</li>
</ul>
</blockquote>
<p><strong>更新备注</strong>:本教程是由<a href="http://www.raywenderlich.com/u/ColinEberhardt" target="_blank" rel="external">Colin Eberhardt</a>编写的<a href="http://www.raywenderlich.com/?page_id=48020" target="_blank" rel="external"> iOS 7 by Tutorials</a>其中某章节的精简版本.由James Frost更新到iOS8并用Swift重写,在Xcode 6 beta 7版本上测试通过。</p>
<p>iOS的设计目标鼓励你去创建数字界面模拟触摸，手势，改变方向等，就好像它们真实的物理对象而远非像素的集合。最终给予用户更深层级的交互而不是肤浅的拟真设计。</p>
<p>这听起来感觉挺难的，因为让数字界面看起来是真实的远比让它感觉是真实的简单。不过好在你有一些漂亮的新工具:</p>
<ul>
<li><strong>UIKit Dynamics</strong> 是集成到UIKit中的物理引擎。这允许你创建一个感觉像是真实的界面，通过添加一些行为，例如重力，锚连接 (弹簧)以及力. 你可以定义你希望你的界面需要的物理特征, Dynamics会帮你关心其他的细枝末节。</li>
<li><strong>Motion Effects</strong> 允许你创建类似于iOS 7 主屏幕中酷酷的视差效果. 基本上你可以利用手机加速器提供的数据来创建界面来模拟手机方向发生改变的反应。</li>
</ul>
<p>当一起使用的时候，由 Dynamics 与 Motion形成用户体验的工具，让你的界面给用户生活带来非同一般的体验。当观察到他们的操作是通过一种自然、动态的方式，你的用户将会与你的app进行更深层次的连接。</p>
<blockquote>
<p><strong>注意</strong>: 由于本教程编写的时候iOS 8 还处于测试中，因此<a href="http://www.raywenderlich.com/?p=74138" target="_blank" rel="external">没有提供iOS8的截图</a>. 所有的截图都是iOS7环境下的,不过看起来与iOS 8相差不大.</p>
</blockquote>
<a id="more"></a>
<h3 id="Getting_started_起步">Getting started  起步</h3><p>UIKit Dynamics是非常有趣的；最好的学习方法就是脚踏实地先学一些小例子。</p>
<p>打开Xcode，依次选择<strong>File / New / Project …</strong> 然后选择 <strong>iOS Application / Single View Application</strong> 最后命名你的项目为<strong>DynamicsDemo</strong>。项目创建完成之后，打开 <strong>ViewController.swift</strong> ，然后在<code>viewDidLoad</code>方法中添加如下代码:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> square = <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">100</span>, y: <span class="number">100</span>, width: <span class="number">100</span>, height: <span class="number">100</span>))</span><br><span class="line">square.backgroundColor = <span class="type">UIColor</span>.grayColor()</span><br><span class="line">view.addSubview(square)</span><br></pre></td></tr></table></figure>
<p>以上代码仅仅是在界面上添加一个方形的<code>UIView</code>。</p>
<p>运行你的App,你就可以在模拟器中看到如下的正方形:</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/09/LonelySquare.png" alt=""></p>
<p>如果你在真机中运行此app,可以尝试倾斜、颠倒甚至是摇晃它.你会发现这样做没什么效果.这是因为一切是按照设计来工作的.当你添加一个View到界面上时,你希望它一直固定在设定好的坐标上,除非是你给界面添加一些动态的效果.</p>
<h3 id="Adding_gravity_添加重力">Adding gravity   添加重力</h3><p>还是在 <strong>ViewController.swift</strong>中，在<code>viewDidLoad</code>之上加上下面这些属性:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> animator: <span class="type">UIDynamicAnimator</span>!</span><br><span class="line"><span class="keyword">var</span> gravity: <span class="type">UIGravityBehavior</span>!</span><br></pre></td></tr></table></figure>
<p>这些属性是表示自动拆包可选类型(在类型后由!表示).这些属性必须是可选类型的,因为我们在<code>init</code>方法中不会初始化它们.同时也是因为在你初始化之后它们不可能为空.这样通过!就可以避免每一次都手动拆包.</p>
<p>在<code>viewDidLoad</code>方法的最后加上这段代码:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">animator = <span class="type">UIDynamicAnimator</span>(referenceView: view)</span><br><span class="line">gravity = <span class="type">UIGravityBehavior</span>(items: [square])</span><br><span class="line">animator.addBehavior(gravity)</span><br></pre></td></tr></table></figure>
<p>我会在一会儿之后解释这个.现在,运行你的程序.你会看到你的方块慢慢的开始加速向下运行,直到掉落在屏幕的底部.</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/09/FallingSquare.png" alt=""></p>
<p>刚刚添加的代码中,有两个Dynamics的类在起作用:</p>
<ul>
<li><strong>UIDynamicAnimator</strong> 是UIKit物理引擎.这个类跟踪你添加到Dynamics中的各种行为,例如重力,并且提供了整体的上下文.当你创建一个动画实例时, 你需要传递一个该动画用来定义坐标系统的View.</li>
<li><strong>UIGravityBehavior</strong> 模拟重力行为以及对一个或者多个物体施力,允许你模拟物理行为.当你创建一个行为的实例时, 你需要将此行为关联到一系列的物体上  — 通常来说是View. 这样你就可以选择哪些物体受到该行为的影响,在这个案例中物体受重力影响.</li>
</ul>
<p>大多数的行为有一些配置属性;例如,重力行为允许你改变它的角度和大小.尝试修改这些属性让你的对象降落,侧移,或者是不同加速度的对角线.</p>
<p>注意:稍微说一下,在物理世界中,重力(g)表示米每秒平方,约等于9.8m/s2.使用牛顿第二定律,运用下列公式可以计算出在重力的影响下物体将会下滑多远.</p>
<p><strong>distance = 0.5 × g × time2</strong></p>
<p>在UIKit Dynamics中,该公式是一样的不过单位却是有所不同.你使用的是每千像素平方秒而不是米.使用牛顿第二定律,基于你所提供的重力组件,仍然可以计算出在任意时间点你的View的地点.</p>
<p>但是你真的需要全部了解么?并不是这样;你真正需要知道的是<strong>g</strong>越大就表示物体下降的越快,这在数学的角度来看并不难理解.</p>
<h3 id="Setting_boundaries_设定边界">Setting boundaries  设定边界</h3><p>虽然你看不到它，这个方块甚至会继续下落后即便它已经消失在屏幕的底部.为了让它在屏幕的范围内，你需要定义一个边界.</p>
<p>在<strong>ViewController.swift</strong>中添加另外一个属性:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> collision: <span class="type">UICollisionBehavior</span>!</span><br></pre></td></tr></table></figure>
<p>在<code>viewDidLoad</code>方法的最后加上这几行:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">collision = <span class="type">UICollisionBehavior</span>(items: [square])</span><br><span class="line">collision.translatesReferenceBoundsIntoBoundary = <span class="literal">true</span></span><br><span class="line">animator.addBehavior(collision)</span><br></pre></td></tr></table></figure>
<p>以上代码创建了一个碰撞行为,其中定义了若干边界与该物体交互.</p>
<p>以上代码将<code>translatesReferenceBoundsIntoBoundary</code> 属性设为<code>true</code>,而不是显示的定义边界坐标. 这表示被关联的View的坐标被用于<code>UIDynamicAnimator</code>.</p>
<p>运行程序,你会看到方块碰撞屏幕的底部,然后反弹一下,停了下来,就像这样:</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/09/SquareAtRest.png" alt=""></p>
<p>这是一些令人印象深刻的行为,特别是考虑到你此时只添加了这一点代码.</p>
<h3 id="Handling_collisions_处理碰撞">Handling collisions  处理碰撞</h3><p>接下来,你将添加一个不可移动的障碍物来与下落的方块进行碰撞交互.</p>
<p>将下面的代码添加到<code>viewDidLoad</code>方法中添加方块View的后面:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> barrier = <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">300</span>, width: <span class="number">130</span>, height: <span class="number">20</span>))</span><br><span class="line">barrier.backgroundColor = <span class="type">UIColor</span>.redColor()</span><br><span class="line">view.addSubview(barrier)</span><br></pre></td></tr></table></figure>
<p>运行你的程序;你会看到一个红色的”障碍物”在屏幕的中间穿过.然而事实是障碍物并未对下落的方块产生影响:</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2013/09/BadBarrier.png" alt=""></p>
<p>这并不是你想要的效果,但这却是一个重要的提醒:Dynamics为只对已关联的行为的View产生影响.</p>
<p>可以看一下这张图:</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/09/DynamicClasses.png" alt=""></p>
<p><strong>UIDynamicAnimator</strong>与一个提供了坐标系统的View相关联.然后你在与此关联的物体上添加了若干个行为对它们施力.大多数行为可以与多个物体关联,同样的一个物体也可以与若干个行为关联.上面的图显示当前程序中有关联的行为.</p>
<p>无论是你现在代码中的行为还是障碍物都是不被知道的,所以从引擎系统角度看,障碍物是不存在的.</p>
<h3 id="Making_objects_respond_to_collisions_让物体对碰撞做出反应">Making objects respond to collisions  让物体对碰撞做出反应</h3><p>为了使方块与障碍物相碰撞,找到初始化碰撞行为的那行,然后替换成下面的:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collision = <span class="type">UICollisionBehavior</span>(items: [square, barrier])</span><br></pre></td></tr></table></figure>
<p>碰撞对象需要知道应该与之几乎的每一个View;因此添加障碍物到物体列表中,这样就允许碰撞对象与之发生作用.</p>
<p>运行你的程序;这两个对象产生碰撞行为,如下面的截图所示:</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2013/09/GoodBarrier.png" alt=""></p>
<p>这个碰撞的行为围绕与之关联的每个物体,形成了一个”边界”.将他们从对象改变成更坚固的物体.</p>
<p>更新之前的图示,现在可以看到现在碰撞行为与View相关联了:</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2013/09/DynamicClasses2.png" alt=""></p>
<p>然后,两个物体的相互作用还是有些不太对劲.障碍物应该是不可移动的,但是当两个物体碰撞时,你当前的配置的障碍物向着屏幕的底部移动了.</p>
<p>更奇怪的是,障碍物居然在屏幕底部弹跳,而且不像方块那样停止下来 -这样是因为重力行为没有与障碍物交互.这同样也解释了为什么障碍物直到与方块碰撞才移动.</p>
<p>看起来你需要一个不一样的解决问题的办法.由于障碍物是不可移动的,没有任何必须要让运动引擎直到它的存在,但这样如何检测碰撞呢?</p>
<h3 id="Invisible_boundaries_and_collisions_可见的边界与碰撞">Invisible boundaries and collisions  可见的边界与碰撞</h3><p>恢复碰撞行为的初始化到原来的状态，让它只知道方块：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collision = <span class="type">UICollisionBehavior</span>(items: [square])</span><br></pre></td></tr></table></figure>
<p>此行之后,添加以下内容:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add a boundary that has the same frame as the barrier</span></span><br><span class="line">collision.addBoundaryWithIdentifier(<span class="string">"barrier"</span>, forPath: <span class="type">UIBezierPath</span>(rect: barrier.frame))</span><br></pre></td></tr></table></figure>
<p>上面的代码添加了一个具有同样结构的障碍物View作为可见的边界.这个红色的障碍物保持着对用户可见,但对Dynamics引擎不可见,同时,边界对于Dynamics引擎可见,对于用户却不可见.当方块落下时,看起来似乎是与障碍物交互的,然而实际上却是撞到了不可移动的边界.</p>
<p>运行你的程序看看这个动作,如下图:</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/09/BestBarrier.png" alt=""></p>
<p>现在方块在边界处反弹,旋转了一下,然后继续继续朝屏幕底部落下.</p>
<p>现在的UIKit Dynamics的能力变得相当清楚：你可以用少量代码完成效果.在这之中有很多细节;接下来的部分我将向你展示一些Dynamics在你的应用程序中与对象的交互细节。</p>
<h3 id="Behind_the_scenes_of_collisions_碰撞背后的知识">Behind the scenes of collisions  碰撞背后的知识</h3><p>任何Dynamic行为都有一个action属性,用来提供一个block,在动画的每一步都执行:添加以下代码到<code>viewDidLoad</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">collision.action = &#123;</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">"<span class="subst">\(NSStringFromCGAffineTransform(square.transform)</span>) <span class="subst">\(NSStringFromCGPoint(square.center)</span>)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码的日志记录了下落方块的center与transform属性.运行程序,然后你就会在Xcode的输出窗口看到这些输出.</p>
<p>从开始到400毫秒这段时间,你应该是看到类似下面的日志信息:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], &#123;<span class="number">150</span>, <span class="number">236</span>&#125;</span><br><span class="line">[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], &#123;<span class="number">150</span>, <span class="number">243</span>&#125;</span><br><span class="line">[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], &#123;<span class="number">150</span>, <span class="number">250</span>&#125;</span><br></pre></td></tr></table></figure>
<p>这里你可以看到运动引擎一直在改变方块的center — 也就是动画执行中的每一步的frame值.</p>
<p>只要方块撞到障碍物,就开始旋转,这就会生成类似以下的日志信息:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0.99797821</span>, <span class="number">0.063557133</span>, -<span class="number">0.063557133</span>, <span class="number">0.99797821</span>, <span class="number">0</span>, <span class="number">0</span>] &#123;<span class="number">152</span>, <span class="number">247</span>&#125;</span><br><span class="line">[<span class="number">0.99192101</span>, <span class="number">0.12685727</span>, -<span class="number">0.12685727</span>, <span class="number">0.99192101</span>, <span class="number">0</span>, <span class="number">0</span>] &#123;<span class="number">154</span>, <span class="number">244</span>&#125;</span><br><span class="line">[<span class="number">0.97873402</span>, <span class="number">0.20513339</span>, -<span class="number">0.20513339</span>, <span class="number">0.97873402</span>, <span class="number">0</span>, <span class="number">0</span>] &#123;<span class="number">157</span>, <span class="number">241</span>&#125;</span><br></pre></td></tr></table></figure>
<p>这里你可以看到Dynamics使用的是transform与基于底层物理模型定位视图偏移的组合.</p>
<p>虽然对于Dynamics的这些属性的兴趣可能不大,不过重要的是要知道,他们正在发挥作用.因此,如果你以编程方式更改frame或transform的属性,你可以假设这些值将被覆盖.这意味着当对象被Dynamics控制时,你就不能使用transform缩放对象了.</p>
<p>该方法为Dynamics行为签名,选择物体而不是View.应用动力学行为的唯一需要就是让对象实现 <code>UIDynamicItem</code> 协议,这样:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">UIDynamicItem</span> : <span class="title">NSObjectProtocol</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> center: <span class="type">CGPoint</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">  <span class="keyword">var</span> bounds: <span class="type">CGRect</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  <span class="keyword">var</span> transform: <span class="type">CGAffineTransform</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>UIDynamicItem</code>协议允许Dynamics读写center和transform属性,允许其基于其内部计算来移动物体.它对bounds也有读取的权限,用来确定物体的大小。这允许它来创建碰撞边界的四周的物体以及计算当前物体的质量.</p>
<p>这个协议意味着引擎不与UIView耦合,此外还有一个UIKit类不是视图但仍然遵循这个协议:<code>UICollectionViewLayoutAttributes</code>.这允许引擎在集合视图内执行动画.</p>
<h3 id="Collision_notifications_碰撞提醒">Collision notifications 碰撞提醒</h3><p>到目前为止,你已经添加了一些视图和行为然后让Dynamics控制.在这一节你会看看如何在物体碰撞时接收通知.</p>
<p>还是在<strong>ViewController.swift</strong>文件中,修改类的声明来遵循 <code>UICollisionBehaviorDelegate</code>协议:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="typename">UIViewController</span>, <span class="typename">UICollisionBehaviorDelegate &#123;</span></span></span><br></pre></td></tr></table></figure>
<p>在 <code>viewDidLoad</code>方法中,将视图控制器设置为刚刚初始化的碰撞代理对象,如下:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collision<span class="class">.collisionDelegate</span> = self</span><br></pre></td></tr></table></figure>
<p>接下来,在类中实现碰撞行为代理中的一个方法:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">collisionBehavior</span><span class="params">(behavior: UICollisionBehavior!, beganContactForItem item: UIDynamicItem!, withBoundaryIdentifier identifier: NSCopying!, atPoint p: CGPoint)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">println</span>(<span class="string">"Boundary contact occurred - <span class="subst">\(identifier)</span>"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该代理方法会在发生碰撞时调用.这会在控制台输出日志信息.为了避免太多的日志信息搞乱了控制台的消息,请随意删除上一节添加的<code>collision.action</code>日志.</p>
<p>运行程序,物体发生交互,然后控制台会输出这些:</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Boundary </span>contact occurred - <span class="keyword">barrier</span><br><span class="line"></span><span class="keyword">Boundary </span>contact occurred - <span class="keyword">barrier</span><br><span class="line"></span><span class="keyword">Boundary </span>contact occurred - nil</span><br><span class="line"><span class="keyword">Boundary </span>contact occurred - nil</span><br><span class="line"><span class="keyword">Boundary </span>contact occurred - nil</span><br><span class="line"><span class="keyword">Boundary </span>contact occurred - nil</span><br></pre></td></tr></table></figure>
<p>从上面的日志消息中可以看到,方块与标识的边界发生两次碰撞;这是您前面添加的不可见的边界。(null)标识符是指外部引用视图边界.</p>
<p>这些日志消息可以引人入胜(很严肃的说!),不过需要提供一个视觉指示项来表示反弹.</p>
<p>在第二次输出日志的行后,添加以下代码:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> collidingView = item <span class="keyword">as</span> <span class="type">UIView</span></span><br><span class="line">collidingView.backgroundColor = <span class="type">UIColor</span>.yellowColor()</span><br><span class="line"><span class="type">UIView</span>.animateWithDuration(<span class="number">0.3</span>) &#123;</span><br><span class="line">collidingView.backgroundColor = <span class="type">UIColor</span>.grayColor()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码将碰撞物体的的背景颜色更改为黄色,然后再消褪到灰色.</p>
<p>运行程序然后查看这个效果:</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2013/09/YellowCollision.png" alt=""></p>
<p>方块每次碰撞到边界都会变化成黄色.</p>
<p>到目前为止UIKit Dynamics 通过计算它们的bounds自动为你的物体设置物理属性(如质量和弹性).接下来你将看到如何自己使用<code>UIDynamicItemBehavior</code>类来控制这些物理属性.</p>
<h3 id="Configuring_item_properties_设置属性">Configuring item properties  设置属性</h3><p>在<code>viewDidLoad</code>方法中,在方法的末尾加上以下代码:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let itemBehaviour = <span class="function"><span class="title">UIDynamicItemBehavior</span><span class="params">(items: [square])</span></span></span><br><span class="line">itemBehaviour<span class="class">.elasticity</span> = <span class="number">0.6</span></span><br><span class="line">animator.<span class="function"><span class="title">addBehavior</span><span class="params">(itemBehaviour)</span></span></span><br></pre></td></tr></table></figure>
<p>以上代码创建了一个物体行为,并与方块关联上,接着将其添加到animator中. elasticity属性控制物体的弹力;其值为1.0时表示碰撞完全反弹;也就是说,碰撞不消耗能量或者减缓速度.你为方块设置的elasticity为0.6,这意味着你的方块每次碰撞时都会减缓速度.</p>
<p>运行你的程序,然后你会发现方块现在的行为很有弹性,如下所示:</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2013/09/PrettyBounce.png" alt=""></p>
<blockquote>
<p>注意:如果你想知道我是如何产生上图的方块轨迹图的,这实际上很简单!我只是添加了一个block到每个行为中的action属性中,该block每三秒执行一次,然后使用当前方块的center和transform属性在视图中添加一个新的方块.下面就是我的解决方案.<br>解决方案:<br><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var updateCount = 0</span><br><span class="line"><span class="component">collision.action = &#123;</span><br><span class="line">  if (updateCount % 3 == 0) &#123;</span><br><span class="line">    let outline = UIView(frame: square<span class="string">.bounds)</span></span><br><span class="line">    outline<span class="string">.transform</span> = square<span class="string">.transform</span></span><br><span class="line">    outline<span class="string">.center</span> = square<span class="string">.center</span></span><br><span class="line">    outline<span class="string">.alpha</span> = 0.5</span><br><span class="line">    outline<span class="string">.backgroundColor</span> = UIColor<span class="string">.clearColor()</span></span><br><span class="line">    outline<span class="string">.layer.borderColor</span> = square<span class="string">.layer.presentationLayer().backgroundColor</span></span><br><span class="line">    outline<span class="string">.layer.borderWidth</span> = 1.0</span><br><span class="line">    self<span class="string">.view.addSubview(outline)</span></span><br><span class="line">  &#125;</span></span><br><span class="line">    ++updateCount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>在上面的代码你只改变了物体的弹力;然而,物体的行为类有许多可以控制的属性,如下:</p>
<ul>
<li><code>elasticity</code> – 弹力,决定碰撞时的弹力,例如,当物体发生碰撞行为时的弹力或者韧性.</li>
<li><code>friction</code>   –  摩擦力,决定物体滑动时的抵抗力.</li>
<li><code>density</code>   –  密度,如果加上大小,就能表示物体的质量.质量越大,物体越难加速或减速.</li>
<li><code>resistance</code> – 阻力,任何线性运动的抵抗力.与摩擦力不同的是,摩擦力只对滑动有效.</li>
<li><code>angularResistance</code> – 旋转的阻力.</li>
<li><code>allowsRotation</code> – 这个有点意思,因为这不表示真实物理世界中的属性. 将这个属性设置为NO可以让物体不管任何发生力量的旋转都无效.</li>
</ul>
<h3 id="Adding_behaviors_dynamically_动态添加行为">Adding behaviors dynamically  动态添加行为</h3><p>在当前情况下,你的程序为系统设置全部的行为,然后让Dynamics处理系统中的物理事件直到是全部的物体都静止下来.接下来,你将看到如何动态的添加与删除行为.</p>
<p>打开<strong>ViewController.swift</strong>,然后在<code>viewDidLoad</code>方法中添加以下属性:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> firstContact</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>添加以下代码到碰撞的代理方法<code>collisionBehavior(behavior:beganContactForItem:withBoundaryIdentifier:atPoint:)</code>的最后</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="params">(!firstContact)</span> &#123;</span><br><span class="line">  firstContact = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">let</span> <span class="built_in">square</span> = UIView<span class="params">(frame: CGRect<span class="params">(x: <span class="number">30</span>, y: <span class="number">0</span>, width: <span class="number">100</span>, height: <span class="number">100</span>)</span>)</span></span><br><span class="line">  <span class="built_in">square</span>.backgroundColor = UIColor.grayColor<span class="params">()</span></span><br><span class="line">  view.addSubview<span class="params">(square)</span></span><br><span class="line"></span><br><span class="line">  collision.addItem<span class="params">(square)</span></span><br><span class="line">  gravity.addItem<span class="params">(square)</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">let</span> attach = UIAttachmentBehavior<span class="params">(item: collidingView, attachedToItem:square)</span></span><br><span class="line">  animator.addBehavior<span class="params">(attach)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码检测初次接触时的障碍物和方块,然后创建第二个方块,并为其添加碰撞与重力行为.此外,你创建一个锚链接行为来为一对对象创建虚拟的弹簧效果.</p>
<p>运行你的程序;当最初的方块碰撞到障碍物时,你将会看到一个新的方块出现,就像下面这样:</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2013/09/Attachment.png" alt=""></p>
<p>尽管这样看起来两个方块之间似乎是连接着的,不过你在屏幕上是无法看到线条或者弹簧之类的.</p>
<h3 id="User_Interaction_用户交互">User Interaction  用户交互</h3><p>正如刚刚所看到的那样,你可以动态的添加或是删除你定义的物理系统中正在运动的行为.在最后一节,你将添加另一种类型的Dynamics行为-<code>UISnapBehavior</code>,当用户点击屏幕时,<code>UISnapBehavior</code>会生成一个弹簧动画跳转到指定位置.</p>
<p>删除你在上一节添加的代码:<code>firstContact</code>属性与<code>collisionBehavior()</code>中的if语句.这样当界面中只有一个方块时,就很容易看出来<code>UISnapBehavior</code>的作用.</p>
<p>在<code>viewDidLoad</code>中加上这两个属性:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> square</span>: UIView!</span><br><span class="line"><span class="variable"><span class="keyword">var</span> snap</span>: UISnapBehavior!</span><br></pre></td></tr></table></figure>
<p>这记录了方块视图,这样你就可以在控制器的任何地方访问到它.接下来你就会用到<code>snap</code>对象.</p>
<p>在<code>viewDidLoad</code>方法中,从声明方块的地方移除<code>let</code>关键字,这样就可以使用新的属性来替代局部变量:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">square = UIView(<span class="string">frame:</span> CGRect(<span class="string">x:</span> <span class="number">100</span>, <span class="string">y:</span> <span class="number">100</span>, <span class="string">width:</span> <span class="number">100</span>, <span class="string">height:</span> <span class="number">100</span>))</span><br></pre></td></tr></table></figure>
<p>最后,实现<code>touchesEnded</code>方法,每当用户点击屏幕的时候就创建新的触摸行为:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">touchesEnded</span><span class="params">(touches: NSSet, withEvent event: UIEvent)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (snap != <span class="literal">nil</span>) &#123;</span><br><span class="line">    animator.removeBehavior(snap)</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">let</span> touch = touches.anyObject() <span class="keyword">as</span> <span class="type">UITouch</span> </span><br><span class="line">  snap = <span class="type">UISnapBehavior</span>(item: square, snapToPoint: touch.locationInView(view))</span><br><span class="line">  animator.addBehavior(snap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码相当简单.首先,它会检查当前是否已经存在触摸行为并且移除.然后创建一个新的触摸行为来检测用户是否触摸方块,最后添加到animator中.</p>
<p>运行你的程序.尝试点击一下;无论你点击哪个地方,方块都应该会放大.</p>
<h3 id="Where_To_Go_From_Here?_何去何从">Where To Go From Here? 何去何从</h3><p>此时,你应该对于Dynamics的核心概念有了一定的理解.你可以下载本教程最后<a href="http://cdn5.raywenderlich.com/wp-content/uploads/2014/07/DynamicsDemo-Final-7.zip" target="_blank" rel="external">DynamicsDemo项目</a> 进行进一步的研究。</p>
<p>UIKit Dynamics 给你的应用带来物理引擎的能力.通过精妙的的反弹和弹簧和重力效果,给你的应用程序注入新的血液,让用户如同身临其境.</p>
<p>如果你想要更深入的学习UIKit Dynamics,请查阅我们编写的<a href="http://www.raywenderlich.com/?page_id=48020" target="_blank" rel="external">iOS 7 By Tutorials</a>. 这本书让你的知识更进一步,向你展示如何在真实场景中使用UIKit Dynamics:</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2013/09/SandwichFlowDynamics.png" alt=""></p>
<p>用户可以把菜谱上一瞥,当他们将菜谱放回时,它会掉回菜谱堆中,或者靠近屏幕顶部.最终给予应用程序一个真实的物理效果。</p>
<p>我希望你能喜欢这个UIKit Dynamics的教程,我们觉得这是非常炫酷的,期待你在程序中创造性的使用他们.如果你有任何的问题或意见,请在一下进行讨论!</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="UIKit_Dynamics_教程:_起步">UIKit Dynamics 教程: 起步</h2><blockquote>
<ul>
<li>原文链接 : <a href="http://www.raywenderlich.com/76147/uikit-dynamics-tutorial-swift">UIKit Dynamics Tutorial: Getting Started</a></li>
<li>原文作者: <a href="http://www.raywenderlich.com/u/frosty">James Frost</a></li>
<li>译文出自: <a href="http://www.devtf.cn/">开发技术前线http://www.devtf.cn/</a></li>
<li>译者 : <a href="https://github.com/Lollypo">Lollypo</a> </li>
<li>校对者: <a href="https://github.com/mrchenhao">Harries Chen</a></li>
<li>状态 :  完成</li>
</ul>
</blockquote>
<p><strong>更新备注</strong>:本教程是由<a href="http://www.raywenderlich.com/u/ColinEberhardt">Colin Eberhardt</a>编写的<a href="http://www.raywenderlich.com/?page_id=48020"> iOS 7 by Tutorials</a>其中某章节的精简版本.由James Frost更新到iOS8并用Swift重写,在Xcode 6 beta 7版本上测试通过。</p>
<p>iOS的设计目标鼓励你去创建数字界面模拟触摸，手势，改变方向等，就好像它们真实的物理对象而远非像素的集合。最终给予用户更深层级的交互而不是肤浅的拟真设计。</p>
<p>这听起来感觉挺难的，因为让数字界面看起来是真实的远比让它感觉是真实的简单。不过好在你有一些漂亮的新工具:</p>
<ul>
<li><strong>UIKit Dynamics</strong> 是集成到UIKit中的物理引擎。这允许你创建一个感觉像是真实的界面，通过添加一些行为，例如重力，锚连接 (弹簧)以及力. 你可以定义你希望你的界面需要的物理特征, Dynamics会帮你关心其他的细枝末节。</li>
<li><strong>Motion Effects</strong> 允许你创建类似于iOS 7 主屏幕中酷酷的视差效果. 基本上你可以利用手机加速器提供的数据来创建界面来模拟手机方向发生改变的反应。</li>
</ul>
<p>当一起使用的时候，由 Dynamics 与 Motion形成用户体验的工具，让你的界面给用户生活带来非同一般的体验。当观察到他们的操作是通过一种自然、动态的方式，你的用户将会与你的app进行更深层次的连接。</p>
<blockquote>
<p><strong>注意</strong>: 由于本教程编写的时候iOS 8 还处于测试中，因此<a href="http://www.raywenderlich.com/?p=74138">没有提供iOS8的截图</a>. 所有的截图都是iOS7环境下的,不过看起来与iOS 8相差不大.</p>
</blockquote>]]>
    
    </summary>
    
      <category term="UIKit Dynamics" scheme="http://ytlvy.com/tags/UIKit-Dynamics/"/>
    
      <category term="Swift" scheme="http://ytlvy.com/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift UIKit Dynamics - Tossing Views]]></title>
    <link href="http://ytlvy.com/2015/08/08/Swift-UIKit-Dynamics-Tossing-Views/"/>
    <id>http://ytlvy.com/2015/08/08/Swift-UIKit-Dynamics-Tossing-Views/</id>
    <published>2015-08-08T13:23:36.000Z</published>
    <updated>2015-08-08T13:24:14.000Z</updated>
    <content type="html"><![CDATA[<h2 id="UIKit_Dynamics_和_Swift_教程：抛掷视图_(Tossing_Views)">UIKit Dynamics 和 Swift 教程：抛掷视图 (Tossing Views)</h2><blockquote>
<ul>
<li>原文链接 : <a href="http://www.raywenderlich.com/94719/uikit-dynamics-swift-tutorial-tossing-views" target="_blank" rel="external">UIKit Dynamics and Swift Tutorial:Tossing Views</a></li>
<li>原文作者 : <a href="http://www.raywenderlich.com" target="_blank" rel="external">Ray Wenderlich</a></li>
<li>译文出自 : <a href="http://www.devtf.cn" target="_blank" rel="external">开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/samw00" target="_blank" rel="external">samw00</a> </li>
<li>校对者: <a href="https://github.com/mrchenchao" target="_blank" rel="external">mrchenchao</a></li>
<li>状态 : 完成</li>
</ul>
</blockquote>
<p>在这篇UIKit Dynamics教程中，你将学会如何通过添加手势，用一种很自然的方式将视图抛掷出屏幕的显示区域。如下图所示：</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/07/UIKitDynamics3.gif" alt="效果预览图"></p>
<p>你可能已经在<a href="https://itunes.apple.com/us/app/tweetbot-3-for-twitter-iphone/id722294701" target="_blank" rel="external">Tweetbot</a>这个流行的app里看到这一个技巧被大量的运用。</p>
<p>这篇教程特别适合中级水平的开发人员，因为内容包括如何实现一些特别棒的特效，比如用原生的UIKit框架实现旋转(rotation)和飞离(fly-away)等动画效果。</p>
<p>如果你刚刚接触UIKit dynamics, 也别紧张 － 因为这篇教程会一步一步引导你如何去做。</p>
<p>废话不多说，让我们直切主题吧！</p>
<a id="more"></a>
<h1 id="让我们开始吧">让我们开始吧</h1><blockquote>
<p>注意: 这一节是为那些想从头开始写这个项目的开发员所准备的。有经验的开发者可以直接跳过这一节去下一节”UIDynamicAnimator and UIAttachmentBehavior”, 在那我们已为你准备好了这个教程的启动项目。</p>
</blockquote>
<p>运行你的Xcode，选择<code>File\New\Project...</code>, 选择<code>iOS\Application\Single View Application template</code>然后点击<code>Next</code>。将项目命名为DynamicToss，确保语言用的是Swfit然后将设备设为iPhone.</p>
<p>接下来在左边点选项目名称并在Xcode顶部位置点击<strong>General</strong>。在<strong>Deployment Info/Device Orientation</strong>中不要勾选<strong>Landscape Left</strong>和<strong>Landscape Right</strong>，因为你的app只有竖屏这一种显示模式。</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/02/dynamictoss-orientation.png" alt=""></p>
<p>然后，下载你这个项目需要的<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2014/05/flying_goldfish.zip" target="_blank" rel="external">图片</a>，照片提供者：<a href="http://www.vickiwenderlich.com/" target="_blank" rel="external">gameartguppy.com</a>。</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/05/goldfish_feature.jpg" alt=""></p>
<p>将图片解压后添加到你项目中Images asset目录里。</p>
<p>接着，点击<strong>Main.storyboard</strong>然后再右边的工具栏中选择<strong>File Inspector</strong>。在本片教程中你不需要用到auto layout和size classes，所以勾掉<strong>Use Auto Layout</strong>选项。这会自动勾掉size classes。 在弹出的对话框中，在Keep size class data for：这一选项选iPhone，然后点击<strong>Disable Size Classes</strong>。</p>
<p>在storyboard中，在默认视图控制器中添加一个image view，然后将图片设为<strong>goldfish_feature</strong>。在image view的尺寸观察器中设置下列数值：X=33, y=137, Width=254, Height=172。紧接着在autoresizing mask中消掉弹性高度，宽度，右边距和底边距。这意味着只有顶边距和左边距是“被点选“的。</p>
<p>你的屏幕看起来应该像这样：</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/02/dynamictoss-imageview.png" alt=""></p>
<p>然后，在视图控制器中拖入两个view用以跟踪你的手势，并设置为下列数值</p>
<ul>
<li>View 1: (X=156, Y=219, Width=8, Height=8, Background=red)</li>
<li>View 2: (X=80, Y=420, Width=8, Height=8. Background=blue)</li>
</ul>
<p>当你完成之后，你的视图看起来应该是这样的：</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/02/dynamictoss-views.png" alt=""></p>
<p>基本上那就是你在storyboard中要做的所有准备，接下来就是代码了！</p>
<h2 id="Touch_Handling_触摸操作">Touch Handling 触摸操作</h2><p>打开<strong>ViewController.swift</strong>并在类中加入下列属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> imageView: <span class="type">UIImageView</span>!</span><br><span class="line"><span class="preprocessor">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> redSquare: <span class="type">UIView</span>!</span><br><span class="line"><span class="preprocessor">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> blueSquare: <span class="type">UIView</span>!</span><br><span class="line"> </span><br><span class="line">private <span class="keyword">var</span> originalBounds = <span class="type">CGRect</span>.zeroRect</span><br><span class="line">private <span class="keyword">var</span> originalCenter = <span class="type">CGPoint</span>.zeroPoint</span><br><span class="line"> </span><br><span class="line">private <span class="keyword">var</span> animator: <span class="type">UIDynamicAnimator</span>!</span><br><span class="line">private <span class="keyword">var</span> attachmentBehavior: <span class="type">UIAttachmentBehavior</span>!</span><br><span class="line">private <span class="keyword">var</span> pushBehavior: <span class="type">UIPushBehavior</span>!</span><br><span class="line">private <span class="keyword">var</span> itemBehavior: <span class="type">UIDynamicItemBehavior</span>!</span><br></pre></td></tr></table></figure>
<p>你将在等一会连接这些外部引用。其他的属性用来控制image view的运行轨迹和在触摸事件中跟踪image view的状态。</p>
<p>打开<strong>Main.storyboard</strong>然后右键（或者按住control）点击<strong>View Controller</strong>。在外部引用列表中的<strong>blueSquare</strong>右边有一个空心的小圈圈，点选后不要松开鼠标左键，然后拖拽到blue square的视图上来再松手。这会讲属性和视图对象绑定起来。</p>
<p>用同样的方式绑定red square和属性<strong>imageView</strong>。现在三个view属性应该绑定好了，如下图所示：</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/05/finallinking.png" alt=""></p>
<p>红色和蓝色的正方形代表着UIKit dynamics物理引擎用来时图像运动起来的点。</p>
<p>蓝色的正方形就代表着你触摸开始的那个点，也就是当你手指第一次触碰到屏幕的那个点。红色的正方形会跟踪你手指滑动的轨迹。</p>
<p>待会你将对dynamics做一些配置，使得当你在移动那个点的时候，image view也会相应的进行物理运动。</p>
<p>最后你还有一件事要做 － 给view添加一个手势识别。打开<strong>ViewController.swift</strong>然后在文件中加入下列方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">handleAttachmentGesture</span><span class="params">(sender:UIPanGestureRecognizer)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> location = sender.locationInView(<span class="keyword">self</span>.view)</span><br><span class="line">    <span class="keyword">let</span> boxLocation = sender.locationInView(<span class="keyword">self</span>.imageView)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> sender.state &#123;</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Began</span>:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"Your touch start position is <span class="subst">\(location)</span>"</span>)</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"Start location in image is <span class="subst">\(boxLocation)</span>"</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Ended</span>:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"Your touch end position is <span class="subst">\(location)</span>"</span>)</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"End location in image is <span class="subst">\(boxLocation)</span>"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你还要添加一个拖拽手势识别，也就是panning，然后当panning触发时，调用这个方法。现阶段，这个方法就是简单的现实你的手指在两个坐标系(view, image view)中的位置而已。</p>
<p>打开<strong>Main.storyboard</strong>，往视图上拖拽一个<strong>Pan Gesture Recognizer</strong>。然后按住control点住<strong>Pan Gesture Recognizer</strong>拖到你的<strong>View Controller</strong>，然后连接<strong>handleAttachmentGesture:</strong>。</p>
<p>现在编译运行。在屏幕上滑动或者拖拽，你应该能在控制台上看到：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Your touch <span class="operator"><span class="keyword">start</span> <span class="keyword">position</span> <span class="keyword">is</span> (<span class="number">125.0</span>,<span class="number">227.0</span>)</span><br><span class="line"><span class="keyword">Start</span> location <span class="keyword">in</span> image <span class="keyword">is</span> (<span class="number">92.0</span>,<span class="number">90.0</span>)</span><br><span class="line">Your touch <span class="keyword">end</span> <span class="keyword">position</span> <span class="keyword">is</span> (<span class="number">195.5</span>,<span class="number">374.0</span>)</span><br><span class="line"><span class="keyword">End</span> location <span class="keyword">in</span> image <span class="keyword">is</span> (<span class="number">162.5</span>,<span class="number">237.0</span>)</span></span><br></pre></td></tr></table></figure>
<p>棒极了！你已经将一切都准备好了－接下来就是添加动态特效了。</p>
<h1 id="UIDynamicAnimator_和_UIAttachmentBehavior">UIDynamicAnimator 和 UIAttachmentBehavior</h1><blockquote>
<p>注意：如果你略过了之前的内容，先下载<a href="http://cdn4.raywenderlich.com/wp-content/uploads/2015/02/DynamicToss-Starter.zip" target="_blank" rel="external">项目</a>然后继续下面的内容。</p>
</blockquote>
<p>你要做的第一件事就是当你拖拽时，让你的image view也跟着动起来。你会用到UIKit Dynamics类中一个叫UIAttachmentBehavior的类。</p>
<p>打开<strong>ViewController.swift</strong>，然后在<strong>viewDidLoad()</strong>里面，将下边的代码添加到<strong>super.viewDidLoad()</strong>下面。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">animator = <span class="type">UIDynamicAnimator</span>(referenceView: view)</span><br><span class="line">originalBounds = imageView.bounds</span><br><span class="line">originalCenter = imageView.center</span><br></pre></td></tr></table></figure>
<p>上面的代码设立了一个UIDynamicAnimator，这是UIKit的一个引擎，就是为实现物理动画而准备的。这个引擎所参照的坐标系就是你提供的这个视图控制器的view。</p>
<p>通过给animator添加各种行为(behaviors)，你可以实现attaching views, pushing views, 让视图受重力影响等等。</p>
<p>让我们先从UIAttachmentBehavior开始，当你做了一个拖拽手势时让image view跟随你的指尖移动。</p>
<p>为了实现这效果，在<strong>handleAttachmentGesture(sender:)</strong>中添加如下代码，在<strong>case .Began</strong>中的两个<strong>println</strong>语句之后：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">animator.removeAllBehaviors()</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> centerOffset = <span class="type">UIOffset</span>(horizontal: boxLocation.x - imageView.bounds.midX,</span><br><span class="line">                            vertical: boxLocation.y - imageView.bounds.midY)</span><br><span class="line">attachmentBehavior = <span class="type">UIAttachmentBehavior</span>(item: imageView,</span><br><span class="line">    offsetFromCenter: centerOffset, attachedToAnchor: location)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">redSquare.center = attachmentBehavior.anchorPoint</span><br><span class="line">blueSquare.center = location</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line">animator.addBehavior(attachmentBehavior)</span><br></pre></td></tr></table></figure>
<p>让我们来看看每一步都做了些什么：</p>
<ol>
<li>第一步，先移除animtor中任何可能残留的动画行为。</li>
<li>然后，你创建了一个<strong>UIAttachmentBehavior</strong>，用来连接用户在image view内点击的点和一个锚点（刚好这两个点是重合的）。晚点你将改变这个锚点，从而使image view跟着移动。给视图添加一个锚点，就好比在view上一个固定的点和锚点之间添加了一个隐形的拉杆。</li>
<li>更新red square来表示锚点，而blue square就是表示在image view中和锚点相连的点。当手势刚开始时，这两个点是重合的。</li>
<li>在引擎animator添加这个行为使其生效。</li>
</ol>
<p>下一步你要告诉锚点跟随你的指尖。在<strong>handleAttachmentGesture(_:)</strong>，替换掉<strong>default:</strong>中的<strong>break</strong>语句为下列代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">attachmentBehavior.anchorPoint = sender.locationInView(view)</span><br><span class="line">redSquare.center = attachmentBehavior.anchorPoint</span><br></pre></td></tr></table></figure>
<p>当用户拖拽时候，default里面的代码内容来响应手势一直更新这个事件。上面的代码就是简单的将锚点，red square和手指当前位置合为一体。当用户手指移动时，手势识别则调用这个方法更新锚点至指尖移动到的位置。同时，animator也会随着锚点的移动自动更新view。</p>
<p>编译并运行，现在你可以把view拖来拖去了：</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2014/07/004_DraggedView-281x500.png" alt=""></p>
<p>注意观察view并不是在屏幕中简单的变动；如果手势起于图像的某一个角，你会发现当你移动时view会旋转，这就要归功于锚点了。</p>
<p>不过，当你拖拽完后，视图最好能回到自己的初始位置。我们类中添加一个新的方法来完善这个功能：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">resetDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    animator.removeAllBehaviors()</span><br><span class="line">    </span><br><span class="line">    <span class="type">UIView</span>.animateWithDuration(<span class="number">0.45</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.imageView.bounds = <span class="keyword">self</span>.originalBounds</span><br><span class="line">        <span class="keyword">self</span>.imageView.center = <span class="keyword">self</span>.originalCenter</span><br><span class="line">        <span class="keyword">self</span>.imageView.transform = <span class="type">CGAffineTransformIdentiy</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在<strong>handelAttachmentGesture(_:)</strong>中，在<strong>.Ended</strong>中的<strong>println</strong>语句下添加:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resetDemo()</span><br></pre></td></tr></table></figure>
<p>编译运行，现在当你拖拽完之后，视图就应该回到它自己初始的位置了。</p>
<h1 id="UIPushBehavior">UIPushBehavior</h1><p>接下来，我们要实现的是：当你停止拖拽时，使你的view飞离(detach)，我们会给这个view赋予动能，所以当你的手松开时，它能会延续它的既定轨道去运动。我们将通过<strong>UIPushBehavior</strong>来实现这一点。</p>
<p>首先，你需要两个常量。在文件头部添加它们：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ThrowingThreshold: <span class="variable">CGFloat =</span> <span class="number">1000</span></span><br><span class="line"><span class="keyword">let</span> ThrowingVelocityPadding: <span class="variable">CGFloat =</span> <span class="number">35</span></span><br></pre></td></tr></table></figure>
<p><strong>ThrowingThreshold</strong>表明view必须移动多块才能在手指松开后继续移动(而不是马上回到它的初始位置)。<strong>ThrowingVelocityPadding</strong>是一个神奇的常量，它对抛掷view速度快慢产生影响(这个数值是经过反复试错而得出的）。</p>
<p>最后，在<strong>handleAttachmentGesture(_:)</strong>中，在<strong>.Ended</strong>分支下，用下面的代码替换原来的<strong>resetDemo()</strong>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">animator.removeAllBehaviors()</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> velocity = sender.velocityInView(view)</span><br><span class="line"><span class="keyword">let</span> magnitude = sqrt((velocity.x * velocity.x) + (velocity.y * velocity.y))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> magnitude &gt; <span class="type">ThrowingThreshold</span> &#123;</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">let</span> pushBehavior = <span class="type">UIPushBehavior</span>(items: [imageView], mode: .<span class="type">Instantaneous</span>)</span><br><span class="line">    pushBehavior.pushDirection = <span class="type">CGVector</span>(dx: velocity.x / <span class="number">10</span>, dy: velocity.y / <span class="number">10</span>)</span><br><span class="line">    pushBehavior.magnitude = magnitude / <span class="type">ThrowingVelocityPadding</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">self</span>.pushBehavior = pushBehavior</span><br><span class="line">    animator.addBehavior(pushBehavior)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">let</span> angle = <span class="type">Int</span>(arc4random_uniform(<span class="number">20</span>)) - <span class="number">10</span></span><br><span class="line"> </span><br><span class="line">    itemBehavior = <span class="type">UIDynamicItemBehavior</span>(items: [imageView])</span><br><span class="line">    itemBehavior.friction = <span class="number">0.2</span></span><br><span class="line">    itemBehavior.allowsRotation = <span class="literal">true</span></span><br><span class="line">    itemBehavior.addAngularVelocity(<span class="type">CGFloat</span>(angle), forItem: imageView)</span><br><span class="line">    animator.addBehavior(itemBehavior)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">let</span> timeOffset = <span class="type">Int64</span>(<span class="number">0.4</span> * <span class="type">Double</span>(<span class="type">NSEC_PER_SEC</span>))</span><br><span class="line">    dispatch_after(dispatch_time(<span class="type">DISPATCH_TIME_NOW</span>, timeOffset), dispatch_get_main_queue()) &#123;</span><br><span class="line">        <span class="keyword">self</span>.resetDemo()</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    resetDemo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们再来看看每一步干了些什么：</p>
<ol>
<li><p>向手势获取拖拽的速度。通过速度和你的老朋友勾股定理，你可以计算出速度的量级 － 也就是x轴方向的速度和y轴方向的速度所构成的三角形的斜边(弦）。如果想了解这个定理背后的知识，可以瞅瞅<a href="http://www.raywenderlich.com/?p=90520" target="_blank" rel="external">Trigonometry for Game Programming Tutorial</a>.</p>
</li>
<li><p>当速度的量级超过了你设定的临界值，则创建一个push behavior。Push behavior会给特定的对象施加一种力，在这里，我们通过push behavior给图像施加一种瞬间，猝发的力。而运行的方向则是由x轴速度和y轴速度合起来转换出的一个方向向量来决定的。当你创建好push behavior之后，将其添加到animator的行为序列中。</p>
</li>
<li><p>这一步则将添加一下旋转特效，让图像看起来像是“飞离”一样。你可以在这里了解背后复杂的<a href="https://github.com/u10int/URBMediaFocusViewController/blob/master/URBMediaFocusViewController.m#L636-L686" target="_blank" rel="external">数学知识</a>。其中有部分效果取决于当你开始手势时，你的手指离边界的距离。你可以尝试设置其他的值然后观察它们的移动效果。这里用的值，会给出一个非常流畅平滑和酷毙了的旋转效果。</p>
</li>
<li><p>在指定的一段时间过后，图像将会被重置回原来初始的位置，所以“颼”的一下，图像又回到屏幕中 － 就想一个撞到墙弹回来的球一样。</p>
</li>
</ol>
<p>编译并运行，这回你应该可以愉快地把你的view随意的拖拽了。</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/07/UIKitDynamics3.gif" alt=""></p>
<h1 id="接下来可以做什么？">接下来可以做什么？</h1><p>这篇UIKit Dynamics教程中的项目可以在这里<a href="http://cdn5.raywenderlich.com/wp-content/uploads/2015/04/DynamicToss-Final-1.2.zip" target="_blank" rel="external">下载</a>。</p>
<p>恭喜你，你现在已经学了如何添加一些UIKit Dynamics动画特效让你的app的UI看起来更加的酷炫。</p>
<p>如果你想学更多UIKit Dynamics的技巧, 记得去看看<a href="http://www.raywenderlich.com/?page_id=48020" target="_blank" rel="external">iOS 7 by Tutorials</a>中有两章节是专门讲UIKit Dynamics的。</p>
<p>没事就到论坛去留个言分享一下你的成功经验或者问些关于如何在iOS中实现一些酷的动画特效的问题等等。然后善用你新get的技能！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="UIKit_Dynamics_和_Swift_教程：抛掷视图_(Tossing_Views)">UIKit Dynamics 和 Swift 教程：抛掷视图 (Tossing Views)</h2><blockquote>
<ul>
<li>原文链接 : <a href="http://www.raywenderlich.com/94719/uikit-dynamics-swift-tutorial-tossing-views">UIKit Dynamics and Swift Tutorial:Tossing Views</a></li>
<li>原文作者 : <a href="http://www.raywenderlich.com">Ray Wenderlich</a></li>
<li>译文出自 : <a href="http://www.devtf.cn">开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/samw00">samw00</a> </li>
<li>校对者: <a href="https://github.com/mrchenchao">mrchenchao</a></li>
<li>状态 : 完成</li>
</ul>
</blockquote>
<p>在这篇UIKit Dynamics教程中，你将学会如何通过添加手势，用一种很自然的方式将视图抛掷出屏幕的显示区域。如下图所示：</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/07/UIKitDynamics3.gif" alt="效果预览图"></p>
<p>你可能已经在<a href="https://itunes.apple.com/us/app/tweetbot-3-for-twitter-iphone/id722294701">Tweetbot</a>这个流行的app里看到这一个技巧被大量的运用。</p>
<p>这篇教程特别适合中级水平的开发人员，因为内容包括如何实现一些特别棒的特效，比如用原生的UIKit框架实现旋转(rotation)和飞离(fly-away)等动画效果。</p>
<p>如果你刚刚接触UIKit dynamics, 也别紧张 － 因为这篇教程会一步一步引导你如何去做。</p>
<p>废话不多说，让我们直切主题吧！</p>]]>
    
    </summary>
    
      <category term="UIKit Dynamics" scheme="http://ytlvy.com/tags/UIKit-Dynamics/"/>
    
      <category term="Swift" scheme="http://ytlvy.com/categories/Swift/"/>
    
  </entry>
  
</feed>