<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Yt's Blog]]></title>
  <subtitle><![CDATA[Valar Morghulis]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://ytlvy.com//"/>
  <updated>2015-06-30T07:45:06.000Z</updated>
  <id>http://ytlvy.com//</id>
  
  <author>
    <name><![CDATA[Yt]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[DispatchOnce]]></title>
    <link href="http://ytlvy.com/2015/06/30/DispatchOnce/"/>
    <id>http://ytlvy.com/2015/06/30/DispatchOnce/</id>
    <published>2015-06-30T07:31:31.000Z</published>
    <updated>2015-06-30T07:45:06.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/images/DispatchOnce.jpg" alt=""></p>
<h2 id="Dispatch_Once">Dispatch_Once</h2><p>四种场景如上图</p>
<ol>
<li>第一次执行，<code>block调用</code>，调用结束后需要置标记变量</li>
<li>非第一次执行，而此时#1<code>block调用</code>尚未完成(预执行拿到的 obj 为 nil, 此时需要废弃此次预执行)，线程需进入等待#1状态</li>
<li>非第一次执行，而此时#1<code>block调用</code>已经完成(预执行拿到的 obj 已经初始化完毕)此时线程的预执行是正确的, 之后可能继续执行,也可能由于时间问题,废弃此次预执行进入等待</li>
<li>非第一次执行，而此时#1已经完成，线程预执行后, 直接跳过block而进行后续任务</li>
</ol>
<p>Dispatch_Once 保证了当第一个线程在进行alloc 对象时，有其他线程发起, 会废弃此线程的预执行，进入等待。在第一个线程结束时，将正在等待的线程唤醒。而实现这一机制的方法是在生成对象和变更identifier之间加入一个大于预执行时间的等待来实现的。</p>
<h3 id="Dispatch_Once实现用到的技术">Dispatch_Once实现用到的技术</h3><ul>
<li>原子操作 “原子比较交换函数” __sync_bool_compare_and_swap</li>
<li>cpuid指令 实现大于预执行时间的延迟等待</li>
<li>dispatch_thread_semaphore 来实现线程之间的等待和唤醒</li>
</ul>
<h3 id="cpu的分支预测和预执行">cpu的分支预测和预执行</h3><blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;流水线特性使得CPU能更快地执行线性指令序列，但是当遇到条件判断分支时，麻烦来了，在判定语句返回结果之前，cpu不知道该执行哪个分支，那就得等着（术语叫做pipeline stall），这怎么能行呢，所以，CPU会进行预执行，cpu先猜测一个可能的分支，然后开始执行分支中的指令。现代CPU一般都能做到超过90%的猜测命中率，这可比NBA选手发球命中率高多了。然后当判定语句返回，加入cpu猜错分支，那么之前进行的执行都会被抛弃，然后从正确的分支重新开始执行。<br>&nbsp;&nbsp;&nbsp;&nbsp;在dispatch_once中，唯一一个判断分支就是predicate，dispatch_once会让CPU预执行条件不成立的分支，这样可以大大提升函数执行速度。但是这样的预执行导致的结果是使用了未初始化的obj并将函数返回，这显然不是预期结果。</p>
</blockquote>
<h3 id="不对称barrier">不对称barrier</h3><blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在intel的CPU上，dispatch_once动用了cpuid指令来达成这个目的。cpuid本来是用作取得cpu的信息，但是这个指令也同时强制将指令流串行化，并且这个指令是需要比较长的执行时间的(在某些cpu上，甚至需要几百圈cpu时钟).这个指令保证了, 当其他线程预执行读取到 nil时,可以废弃当前的预执行操作,从而进入 dispatch_once 的 else 方法进入等待.</p>
</blockquote>
<h3 id="dispatch_once读取端的实现">dispatch_once读取端的实现</h3><blockquote>
<p>DISPATCH_EXPECT 是用来告诉cpu *predicate等于~0l是更有可能的判定结果，这就使得cpu能猜测到更正确的分支，并提高效率</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_INLINE DISPATCH_ALWAYS_INLINE DISPATCH_NONNULL_ALL DISPATCH_NOTHROW</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_dispatch_once(<span class="keyword">dispatch_once_t</span> *predicate, <span class="keyword">dispatch_block_t</span> block)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (DISPATCH_EXPECT(*predicate, ~<span class="number">0l</span>) != ~<span class="number">0l</span>) &#123;</span><br><span class="line">        dispatch_once(predicate, block);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> dispatch_once _dispatch_once</span></span><br></pre></td></tr></table></figure>
<h3 id="dispatch_once的实现">dispatch_once的实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> _dispatch_once_waiter_s &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">struct</span> _dispatch_once_waiter_s *<span class="keyword">volatile</span> dow_next;</span><br><span class="line">    <span class="keyword">_dispatch_thread_semaphore_t</span> dow_sema;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DISPATCH_ONCE_DONE ((struct _dispatch_once_waiter_s *)~0l)</span></span><br><span class="line"> </span><br><span class="line"><span class="preprocessor">#ifdef __BLOCKS__</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">dispatch_once</span><span class="params">(dispatch_once_t *val, dispatch_block_t block)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> Block_basic *bb = (<span class="keyword">void</span> *)block;</span><br><span class="line"> </span><br><span class="line">    dispatch_once_f(val, block, (<span class="keyword">void</span> *)bb-&gt;Block_invoke);</span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line"><span class="title">dispatch_once_f</span><span class="params">(dispatch_once_t *val, <span class="keyword">void</span> *ctxt, dispatch_function_t func)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> _dispatch_once_waiter_s * <span class="keyword">volatile</span> *vval = (<span class="keyword">struct</span> _dispatch_once_waiter_s**)val;</span><br><span class="line">    <span class="keyword">struct</span> _dispatch_once_waiter_s dow = &#123; NULL, <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">struct</span> _dispatch_once_waiter_s *tail, *tmp;</span><br><span class="line">    <span class="keyword">_dispatch_thread_semaphore_t</span> sema;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (dispatch_atomic_cmpxchg(vval, NULL, &amp;dow)) &#123;</span><br><span class="line">        dispatch_atomic_acquire_barrier();<span class="comment">//这是一个空的宏函数，什么也不做</span></span><br><span class="line">        _dispatch_client_callout(ctxt, func);</span><br><span class="line">        dispatch_atomic_maximally_synchronizing_barrier();</span><br><span class="line">        <span class="comment">//dispatch_atomic_release_barrier(); // assumed contained in above</span></span><br><span class="line">        tmp = dispatch_atomic_xchg(vval, DISPATCH_ONCE_DONE);</span><br><span class="line">        tail = &amp;dow;</span><br><span class="line">        <span class="keyword">while</span> (tail != tmp) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!tmp-&gt;dow_next) &#123;</span><br><span class="line">                _dispatch_hardware_pause();</span><br><span class="line">            &#125;</span><br><span class="line">            sema = tmp-&gt;dow_sema;</span><br><span class="line">            tmp = (<span class="keyword">struct</span> _dispatch_once_waiter_s*)tmp-&gt;dow_next;</span><br><span class="line">            <span class="keyword">_dispatch_t</span>hread_semaphore_signal(sema);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dow.dow_sema = <span class="keyword">_dispatch_get_t</span>hread_semaphore();</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            tmp = *vval;</span><br><span class="line">            <span class="keyword">if</span> (tmp == DISPATCH_ONCE_DONE) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dispatch_atomic_store_barrier();</span><br><span class="line">            <span class="keyword">if</span> (dispatch_atomic_cmpxchg(vval, tmp, &amp;dow)) &#123;</span><br><span class="line">                dow.dow_next = tmp;</span><br><span class="line">                <span class="keyword">_dispatch_t</span>hread_semaphore_wait(dow.dow_sema);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">_dispatch_put_t</span>hread_semaphore(dow.dow_sema);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>dispatch_atomic_cmpxchg 是 “原子比较交换函数”__sync_bool_compare_and_swap的宏替换</p>
</blockquote>
<h4 id="执行block的分支">执行block的分支</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;当dispatch_once第一次执行时，predicate也即val为0，那么此“原子比较交换函数”将返回true并将vval指向值赋值为&amp;dow，即为“等待中”，_dispatch_client_callout其内部做了一些判定，但实际上是调用了func而已。到此，block中的用户代码执行完毕。<br>&nbsp;&nbsp;&nbsp;&nbsp; 接下来就是上篇提及的cpuid指令等待，使得其他线程的【读取到未初始化值的】预执行能被判定为猜测未命中，从而使得这些线程能够进入dispatch_once_f里的另一个分支从而进行等待。<br>&nbsp;&nbsp;&nbsp;&nbsp; cpuid指令完毕后，调用dispatch_atomic_xchg进行赋值，置其为DISPATCH_ONCE_DONE，即“完成”，这里dispatch_atomic_xchg是内建“原子交换函数”__sync_swap的优化版宏替换，其将第二个参数的值赋给第一个参数（解引用指针），然后返回第一个参数被赋值前的解引用值，其原型为：</p>
<blockquote>
<p>type __sync_swap(type *ptr, type value, …)</p>
</blockquote>
<p>接下来是对信号量链的处理：</p>
<ol>
<li>在block执行过程中，没有其他线程进入本函数来等待，则vval指向值保持为&amp;dow，即tmp被赋值为&amp;dow，即下方while循环不会被执行，此分支结束。</li>
<li>在block执行过程中，有其他线程进入本函数来等待，那么会构造一个信号量链表（vval指向值变为信号量链的头部，链表的尾部为&amp;dow），此时就会进入while循环，在此while循环中，遍历链表，逐个signal每个信号量，然后结束循环。</li>
</ol>
<blockquote>
<p>while (!tmp-&gt;dow_next)此循环是等待在&amp;dow上，因为线程等待分支#2会中途将val赋值为&amp;dow，然后为-&gt;dow_next赋值，这期间-&gt;dow_next值为NULL，需要等待，详见下面线程等待分支#2的描述<br>_dispatch_hardware_pause此句是为了提示cpu减少额外处理，提升性能，节省电力</p>
</blockquote>
<h4 id="线程等待分支">线程等待分支</h4><p>当执行block分支#1未完成，且有线程再进入本函数时，将进入线程等待分支：</p>
<ol>
<li>先调用_dispatch_get_thread_semaphore创建一个信号量，此信号量被赋值给dow.dow_sema</li>
<li>然后进入一个无限for循环，假如发现vval的指向值已经为DISPATCH_ONCE_DONE，即“完成”，则直接break，然后调用_dispatch_put_thread_semaphore函数销毁信号量并退出函数</li>
</ol>
<blockquote>
<p>_dispatch_get_thread_semaphore内部使用的是“有即取用，无即创建”策略来获取信号量。<br>_dispatch_put_thread_semaphore内部使用的是“销毁旧的，存储新的”策略来缓存信号量。</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp; 假如vval的解引用值并非DISPATCH_ONCE_DONE，则进行一个“原子比较并交换”操作（此操作可以避免两个等待线程同时操作链表带来的问题），假如此时vval指向值已不再是tmp（这种情况发生在多个线程同时进入线程等待分支#2，并交错修改链表）则for循环重新开始，再尝试重新获取一次vval来进行同样的操作；若指向值还是tmp，则将vval的指向值赋值为&amp;dow，此时val-&gt;dow_next值为NULL，可能会使得block执行分支#1进行while等待（如前述），紧接着执行dow.dow_next = tmp这句来增加链表节点（同时也使得block执行分支#1的while等待结束），然后等待在信号量上，当block执行分支#1完成并遍历链表来signal时，唤醒、释放信号量，然后一切就完成了。</p>
<h3 id="小结">小结</h3><ol>
<li>线程A执行Block时，任何其它线程都需要等待。</li>
<li>线程A执行完Block应该立即标记任务完成状态，然后遍历信号量链来唤醒所有等待线程。</li>
<li>线程A遍历信号量链来signal时，任何其他新进入函数的线程都应该直接返回而无需等待。</li>
<li>线程A遍历信号量链来signal时，若有其它等待线程B仍在更新或试图更新信号量链，应该保证此线程B能正确_完成其任务：a.直接返回 b.等待在信号量上并很快又被唤醒。</li>
<li>线程B构造信号量时，应该考虑线程A随时可能改变状态（“等待”、“完成”、“遍历信号量链”）。</li>
<li>线程B构造信号量时，应该考虑到另一个线程C也可能正在更新或试图更新信号量链，应该保证B、C都能正常_完成其任务：a.增加链节并等待在信号量上 b.发现线程A已经标记“完成”然后直接销毁信号量并退出函数。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[Dispatch Once 解析]]>
    
    </summary>
    
      <category term="Dispatch Once" scheme="http://ytlvy.com/tags/Dispatch-Once/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/tags/IOS/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[UITableView Cancel Request]]></title>
    <link href="http://ytlvy.com/2015/06/30/UITableView-Cancel-Request/"/>
    <id>http://ytlvy.com/2015/06/30/UITableView-Cancel-Request/</id>
    <published>2015-06-30T01:22:03.000Z</published>
    <updated>2015-06-30T01:22:44.000Z</updated>
    <content type="html"><![CDATA[<h3 id="仅加载可见Cell的图片">仅加载可见Cell的图片</h3><p>load images for just the visible rows in viewDidLoad and when the user stops scrolling<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span>(void)<span class="tag">viewDidLoad</span>&#123;</span><br><span class="line">    <span class="tag">for</span> (NSIndexPath *indexPath in [self.tableView indexPathsForVisibleRows]) &#123;</span><br><span class="line">        <span class="attr_selector">[self loadImageForCellAtPath:indexPath]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">-</span>(void)<span class="tag">scrollViewDidEndDecelerating</span>:(UIScrollView *)<span class="tag">scrollView</span> &#123;</span><br><span class="line">    <span class="tag">for</span> (NSIndexPath *indexPath in [self.tableView indexPathsForVisibleRows]) &#123;</span><br><span class="line">        <span class="attr_selector">[self loadImageForCellAtPath:indexPath]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="取消Request_—-_NSBlockOperation">取消Request —- NSBlockOperation</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span><span class="variable">.operationQueue</span> = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.operationQueue</span> setMaxConcurrentOperationCount:<span class="built_in">NSOperationQueueDefaultMaxConcurrentOperationCount</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)loadImageForCellAtPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    __block <span class="built_in">NSBlockOperation</span> *operation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="keyword">if</span> (![operation isCancelled]) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *galleryTinyImageUrl = [[<span class="keyword">self</span><span class="variable">.smapi</span> getImageUrls:imageId imageKey:imageKey] objectForKey:<span class="string">@"TinyURL"</span>];</span><br><span class="line">            <span class="built_in">NSData</span> *imageData = [[<span class="built_in">NSData</span> alloc] initWithContentsOfURL:[<span class="built_in">NSURL</span> URLWithString:galleryTinyImageUrl]];</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                <span class="keyword">if</span> (imageData != <span class="literal">nil</span>) &#123;</span><br><span class="line">                    <span class="built_in">UITableViewCell</span> *cell = [tableView cellForRowAtIndexPath:indexPath];</span><br><span class="line">                    cell<span class="variable">.imageView</span><span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageWithData:imageData];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSValue</span> *nonRetainedOperation = [<span class="built_in">NSValue</span> valueWithNonretainedObjectValue:operation];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.operations</span> addObject:nonRetainedOperation forKey:indexPath];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.operationQueue</span> addOperation:operation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Here operations is an NSMutableDictionary. When you want to cancel an operation, you retrieve it by the cell’s indexPath, cancel it, and remove it from the dictionary:</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSValue *operationHolder = [self.operations objectForKey:indexPath]<span class="comment">;</span></span><br><span class="line">NSOperation *operation = [operationHolder nonretainedObjectValue]<span class="comment">;</span></span><br><span class="line">[operation cancel]<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h3 id="prefetch_the_images_—-_SDWebImagePrefetcher">prefetch the images —-  SDWebImagePrefetcher</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr_selector">[self.tableView reloadData]</span>;</span><br><span class="line"><span class="tag">dispatch_async</span>(<span class="function">dispatch_get_main_queue</span>(), ^&#123;</span><br><span class="line">    <span class="attr_selector">[self prefetchImagesForTableView:self.tableView]</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>anytime I stop scrolling, I do the same:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)scrollViewDidEndDecelerating:(<span class="built_in">UIScrollView</span> *)scrollView &#123;</span><br><span class="line">    [<span class="keyword">self</span> prefetchImagesForTableView:<span class="keyword">self</span><span class="variable">.tableView</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView willDecelerate:(<span class="built_in">BOOL</span>)decelerate &#123;</span><br><span class="line">    <span class="keyword">if</span> (!decelerate)</span><br><span class="line">        [<span class="keyword">self</span> prefetchImagesForTableView:<span class="keyword">self</span><span class="variable">.tableView</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#pragma mark - Prefetch cells</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSInteger</span> <span class="keyword">const</span> kPrefetchRowCount = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Prefetch a certain number of images for rows prior to and subsequent to the currently visible cells</span><br><span class="line"> *</span><br><span class="line"> * @param  tableView   The tableview for which we're going to prefetch images.</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)prefetchImagesForTableView:(<span class="built_in">UITableView</span> *)tableView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *indexPaths = [<span class="keyword">self</span><span class="variable">.tableView</span> indexPathsForVisibleRows];</span><br><span class="line">    <span class="keyword">if</span> ([indexPaths count] == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSIndexPath</span> *minimumIndexPath = indexPaths[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">NSIndexPath</span> *maximumIndexPath = [indexPaths lastObject];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// they should be sorted already, but if not, update min and max accordingly</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSIndexPath</span> *indexPath <span class="keyword">in</span> indexPaths) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([minimumIndexPath compare:indexPath] == <span class="built_in">NSOrderedDescending</span>)</span><br><span class="line">            minimumIndexPath = indexPath;</span><br><span class="line">        <span class="keyword">if</span> ([maximumIndexPath compare:indexPath] == <span class="built_in">NSOrderedAscending</span>)</span><br><span class="line">            maximumIndexPath = indexPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build array of imageURLs for cells to prefetch</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *imageURLs = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSArray</span> *precedingRows = [<span class="keyword">self</span> tableView:tableView indexPathsForPrecedingRows:kPrefetchRowCount fromIndexPath:minimumIndexPath];</span><br><span class="line">    [imageURLs addObjectsFromArray:precedingRows];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSArray</span> *followingRows = [<span class="keyword">self</span> tableView:tableView indexPathsForFollowingRows:kPrefetchRowCount fromIndexPath:maximumIndexPath];</span><br><span class="line">    [imageURLs addObjectsFromArray:followingRows];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now prefetch</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([imageURLs count] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        [[SDWebImagePrefetcher sharedImagePrefetcher] prefetchURLs:imageURLs];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Retrieve NSIndexPath for a certain number of rows preceding particular NSIndexPath in the table view.</span><br><span class="line"> *</span><br><span class="line"> * @param  tableView  The tableview for which we're going to retrieve indexPaths.</span><br><span class="line"> * @param  count      The number of rows to retrieve</span><br><span class="line"> * @param  indexPath  The indexPath where we're going to start (presumably the first visible indexPath)</span><br><span class="line"> *</span><br><span class="line"> * @return            An array of indexPaths.</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView indexPathsForPrecedingRows:(<span class="built_in">NSInteger</span>)count fromIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *indexPaths = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="built_in">NSInteger</span> row = indexPath<span class="variable">.row</span>;</span><br><span class="line">    <span class="built_in">NSInteger</span> section = indexPath<span class="variable">.section</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (row == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (section == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> indexPaths;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                section--;</span><br><span class="line">                row = [tableView numberOfRowsInSection:section] - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            row--;</span><br><span class="line">        &#125;</span><br><span class="line">        [indexPaths addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:row inSection:section]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> indexPaths;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Retrieve NSIndexPath for a certain number of following particular NSIndexPath in the table view.</span><br><span class="line"> *</span><br><span class="line"> * @param  tableView  The tableview for which we're going to retrieve indexPaths.</span><br><span class="line"> * @param  count      The number of rows to retrieve</span><br><span class="line"> * @param  indexPath  The indexPath where we're going to start (presumably the last visible indexPath)</span><br><span class="line"> *</span><br><span class="line"> * @return            An array of indexPaths.</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView indexPathsForFollowingRows:(<span class="built_in">NSInteger</span>)count fromIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *indexPaths = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="built_in">NSInteger</span> row = indexPath<span class="variable">.row</span>;</span><br><span class="line">    <span class="built_in">NSInteger</span> section = indexPath<span class="variable">.section</span>;</span><br><span class="line">    <span class="built_in">NSInteger</span> rowCountForSection = [tableView numberOfRowsInSection:section];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        row++;</span><br><span class="line">        <span class="keyword">if</span> (row == rowCountForSection) &#123;</span><br><span class="line">            row = <span class="number">0</span>;</span><br><span class="line">            section++;</span><br><span class="line">            <span class="keyword">if</span> (section == [tableView numberOfSections]) &#123;</span><br><span class="line">                <span class="keyword">return</span> indexPaths;</span><br><span class="line">            &#125;</span><br><span class="line">            rowCountForSection = [tableView numberOfRowsInSection:section];</span><br><span class="line">        &#125;</span><br><span class="line">        [indexPaths addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:row inSection:section]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> indexPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[UITableview 取消请求]]>
    
    </summary>
    
      <category term="IOS" scheme="http://ytlvy.com/tags/IOS/"/>
    
      <category term="UITableView" scheme="http://ytlvy.com/tags/UITableView/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CFRunLoop examples]]></title>
    <link href="http://ytlvy.com/2015/06/30/CFRunLoop-examples/"/>
    <id>http://ytlvy.com/2015/06/30/CFRunLoop-examples/</id>
    <published>2015-06-30T01:16:56.000Z</published>
    <updated>2015-06-30T01:24:47.000Z</updated>
    <content type="html"><![CDATA[<h3 id="第一个">第一个</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#include <span class="title">&lt;CoreFoundation/CoreFoundation.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>  </span><br><span class="line">_perform(<span class="keyword">void</span> *info __unused)  </span><br><span class="line">&#123;  </span><br><span class="line">    printf(<span class="string">"hello\n"</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>  </span><br><span class="line">_timer(<span class="built_in">CFRunLoopTimerRef</span> timer __unused, <span class="keyword">void</span> *info)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">CFRunLoopSourceSignal</span>(info);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span>  </span><br><span class="line">main()  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">CFRunLoopSourceRef</span> source;  </span><br><span class="line">    <span class="built_in">CFRunLoopSourceContext</span> source_context;  </span><br><span class="line">    <span class="built_in">CFRunLoopTimerRef</span> timer;  </span><br><span class="line">    <span class="built_in">CFRunLoopTimerContext</span> timer_context;  </span><br><span class="line">  </span><br><span class="line">    bzero(&amp;source_context, <span class="keyword">sizeof</span>(source_context));  </span><br><span class="line">    source_context<span class="variable">.perform</span> = _perform;  </span><br><span class="line">    source = <span class="built_in">CFRunLoopSourceCreate</span>(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;source_context);  </span><br><span class="line">    <span class="built_in">CFRunLoopAddSource</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), source, k<span class="built_in">CFRunLoopCommonModes</span>);  </span><br><span class="line">  </span><br><span class="line">    bzero(&amp;timer_context, <span class="keyword">sizeof</span>(timer_context));  </span><br><span class="line">    timer_context<span class="variable">.info</span> = source;  </span><br><span class="line">    timer = <span class="built_in">CFRunLoopTimerCreate</span>(<span class="literal">NULL</span>, <span class="built_in">CFAbsoluteTimeGetCurrent</span>(), <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, </span><br><span class="line">    _timer, &amp;timer_context);  </span><br><span class="line">    <span class="built_in">CFRunLoopAddTimer</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), timer, k<span class="built_in">CFRunLoopCommonModes</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">CFRunLoopRun</span>();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二个：">第二个：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;dispatch/dispatch.h&gt;  </span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;  </span></span><br><span class="line">  </span><br><span class="line">int  </span><br><span class="line"><span class="function"><span class="title">main</span></span>()  </span><br><span class="line">&#123;  </span><br><span class="line">    dispatch_<span class="built_in">source</span>_t <span class="built_in">source</span>, timer;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">source</span> = dispatch_<span class="built_in">source</span>_create(DISPATCH_SOURCE_TYPE_DATA_ADD, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>));  </span><br><span class="line">    dispatch_<span class="built_in">source</span>_<span class="built_in">set</span>_event_handler(<span class="built_in">source</span>, ^&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"hello\n"</span>);  </span><br><span class="line">    &#125;);  </span><br><span class="line">    dispatch_resume(<span class="built_in">source</span>);  </span><br><span class="line">  </span><br><span class="line">    timer = dispatch_<span class="built_in">source</span>_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, </span><br><span class="line">    dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>));  </span><br><span class="line">    dispatch_<span class="built_in">source</span>_<span class="built_in">set</span>_timer(timer, DISPATCH_TIME_NOW, <span class="number">1</span>ull * NSEC_PER_SEC, <span class="number">0</span>);  </span><br><span class="line">    dispatch_<span class="built_in">source</span>_<span class="built_in">set</span>_event_handler(timer, ^&#123;  </span><br><span class="line">        dispatch_<span class="built_in">source</span>_merge_data(<span class="built_in">source</span>, <span class="number">1</span>);  </span><br><span class="line">    &#125;);  </span><br><span class="line">    dispatch_resume(timer);  </span><br><span class="line">  </span><br><span class="line">    dispatch_main();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>功能是向main线程中加入两个input source，一个是timer，一个是自定义input source，然后这个timer中触发自定义source，于是调用其回调方法。 在这儿timer触发source来调用回调方法，显得有点多此一举。但是在多线程开发当中，这就很有用了，我们可以把这个自定义的source加入到子线程的runloop中，然后在主线程中触发source，这样在子线程中就可以调用回调方法了。  这样做的好久是什么呀？ 节约用电，因为runloop一般情况下是休眠的，只有事件触发的时候才开始工作。 这与windows下的waitforsingleobject有点类似， 与多线程中的信号量，事件也有些雷同。</p>
<p>上面说到的input source（输入源例）到底是什么呢？输入源样例可能包括用户输入设备（如点击button）、网络链接(socket收到数据)、定期或时间延迟事件（NSTimer），还有异步回调(NSURLConnection的异步请求)。然后我们对其进行了分类，有三类可以被runloop监控，分别是sources、timers、observers。<br>在苹果文档中对runloop有详细介绍，下面参考中有中文版。那文档中的代码关于NSPort的部份在iOS上是不行的，不过可以用其CF方法实现，在我的demo中有展示。</p>
<p>每一个线程都有自己的runloop, 主线程是默认开启的，创建的子线程要手动开启，因为NSApplication 只启动main applicaiton thread。<br>没有source的runloop会自动结束。<br>事件由NSRunLoop 类处理。<br>RunLoop监视操作系统的输入源，如果没有事件数据， 不消耗任何CPU 资源。<br>如果有事件数据，run loop 就发送消息，通知各个对象。<br>用 currentRunLoop 获得 runloop的 reference<br>给 runloop 发送run 消息启动它。</p>
<p>文档中介绍下面四种情况是使用runloop的场合：<br> 1.使用端口或自定义输入源和其他线程通信<br> 2.子线程中使用了定时器<br> 3.cocoa中使用任何performSelector到了线程中运行方法<br> 4.使线程履行周期性任务，（我把这个理解与2相同）<br>如果我们在子线程中用了NSURLConnection异步请求，那也需要用到runloop，不然线程退出了，相应的delegate方法就不能触发。</p>
<h3 id="用户事件事例：累计更新">用户事件事例：累计更新</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dispatch_source_t source = dispatch_source_create<span class="list">(<span class="keyword">DISPATCH_SOURCE_TYPE_DATA_ADD</span>, <span class="number">0</span>, <span class="number">0</span>, dispatch_get_main_queue<span class="list">()</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_source_set_event_handler<span class="list">(<span class="keyword">source</span>, ^&#123;</span><br><span class="line">    [progressIndicator incrementBy<span class="keyword">:dispatch_source_get_data</span><span class="list">(<span class="keyword">source</span>)</span>]<span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_resume<span class="list">(<span class="keyword">source</span>)</span><span class="comment">;</span></span><br><span class="line"> </span><br><span class="line">dispatch_apply<span class="list">([array count], globalQueue, ^<span class="list">(<span class="keyword">size_t</span> index)</span> &#123;</span><br><span class="line">    // do some work on data at index</span><br><span class="line">    dispatch_source_merge_data<span class="list">(<span class="keyword">source</span>, <span class="number">1</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>假设你已经将进度条的min/max值设置好了，那么这段代码就完美了。数据会被并发处理。当每一段数据完成后，会通知dispatch source并将dispatch source data加1，这样我们就认为一个单元的工作完成了。事件句柄根据已完成的工作单元来更新进度条。若主线程比较空闲并且这些工作单元进行的比较慢，那么事件句柄会在每个工作单元完成的时候被调用，实时更新。如果主线程忙于其他工作，或者工作单元完成速度很快，那么完成事件会被联结起来，导致进度条只在主线程变得可用时才被更新，并且一次将积累的改变更新至GUI。使用的dispatch source而不使用dispatch_async的唯一原因就是利用联结的优势。</p>
<h3 id="内建事件">内建事件</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t globalQueue = dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_source_t stdinSource = dispatch_source_create<span class="list">(<span class="keyword">DISPATCH_SOURCE_TYPE_READ</span>,</span><br><span class="line">                                                       STDIN_FILENO,</span><br><span class="line">                                                       <span class="number">0</span>,</span><br><span class="line">                                                       globalQueue)</span><span class="comment">;</span></span><br><span class="line">dispatch_source_set_event_handler<span class="list">(<span class="keyword">stdinSource</span>, ^&#123;</span><br><span class="line">    char buf[<span class="number">1024</span>]<span class="comment">;</span></span><br><span class="line">    int len = read<span class="list">(<span class="keyword">STDIN_FILENO</span>, buf, sizeof<span class="list">(<span class="keyword">buf</span>)</span>)</span><span class="comment">;</span></span><br><span class="line">    if<span class="list">(<span class="keyword">len</span> &gt; <span class="number">0</span>)</span></span><br><span class="line">        NSLog<span class="list">(@<span class="string">"Got data from stdin: %.*s"</span>, len, buf)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_resume<span class="list">(<span class="keyword">stdinSource</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>这是标准的UNIX方式来处理事务的好处，不用去写loop。如果使用经典的 read调用，我们还得万分留神，因为返回的数据可能比请求的少，还得忍受无厘头的“errors”，比如 EINTR (系统调用中断)。使用GCD，我们啥都不用管，就从这些蛋疼的情况里解脱了。如果我们在文件描述符中留下了未读取的数据，GCD会再次调用我们的句柄。<br>对于标准输入，这没什么问题，但是对于其他文件描述符，我们必须考虑在完成读写之后怎样清除描述符。对于dispatch source还处于活跃状态时，我们决不能关闭描述符。如果另一个文件描述符被创建了（可能是另一个线程创建的）并且新的描述符刚好被分配了相同的数字，那么你的dispatch source可能会在不应该的时候突然进入读写状态。de这个bug可不是什么好玩的事儿。<br>适当的清除方式是使用 dispatch_source_set_cancel_handler，并传入一个block来关闭文件描述符。然后我们使用 dispatch_source_cancel来取消dispatch source，使得句柄被调用，然后文件描述符被关闭。<br>使用其他dispatch source类型也差不多。总的来说，你提供一个source（mach port、文件描述符、进程ID等等）的区分符来作为diapatch source的句柄。mask参数通常不会被使用，但是对于 DISPATCH_SOURCE_TYPE_PROC 来说mask指的是我们想要接受哪一种进程事件。然后我们提供一个句柄，然后恢复这个source（前面我加粗字体所说的，得先恢复），搞定。dispatch source也提供一个特定于source的data，我们使用 dispatch_source_get_data函数来访问它。例如，文件描述符会给出大致可用的字节数。进程source会给出上次调用之后发生的事件的mask。具体每种source给出的data的含义，</p>
]]></content>
    <summary type="html">
    <![CDATA[CFRunLoop 示例]]>
    
    </summary>
    
      <category term="CFRunLoop" scheme="http://ytlvy.com/tags/CFRunLoop/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/tags/IOS/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Dispatch Sources]]></title>
    <link href="http://ytlvy.com/2015/06/30/Dispatch-Sources/"/>
    <id>http://ytlvy.com/2015/06/30/Dispatch-Sources/</id>
    <published>2015-06-30T01:14:45.000Z</published>
    <updated>2015-06-30T01:15:39.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Dispatch_Sources">Dispatch Sources</h2><p>简单来说，是一种能够监控某种事件的对象。当事件发生的时候，此对象自动唤醒设置好的block，并在指定的queue中运行。</p>
<h3 id="events_Type">events Type</h3><ul>
<li>Mach port send right state changes.</li>
<li>Mach port receive right state changes.</li>
<li>External process state change.</li>
<li>File descriptor ready for read.</li>
<li>File descriptor ready for write.</li>
<li>Filesystem node event.</li>
<li>POSIX signal.</li>
<li>Custom timer.</li>
<li>Custom event.</li>
</ul>
<h3 id="Custom_Events">Custom Events</h3><p>通过<code>dispatch_source_merge_data</code>来发送消息，此方法取名<code>merge</code>的原因是，在事件回调执行前，GCD会自动合并累计的消息，直到对应的运行Queue有空闲，可以运行回调Block。所以，这是一种提高效率的方式，将多次消息合并成一个。<br>自定义事件分为：<code>DISPATCH_SOURCE_TYPE_DATA_ADD</code> 和 <code>DISPATCH_SOURCE_TYPE_DATA_OR</code>, 每个event Source有一个<code>unsigned long data</code>属性，用来合并<code>dispatch_source_merge_data</code>的参数。<code>dispatch_source_get_data</code>可以获取到当前的<code>data</code>数据。</p>
<h3 id="举例">举例</h3><p>异步更新progressBar的状态<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dispatch_source_t source = dispatch_source_create<span class="list">(<span class="keyword">DISPATCH_SOURCE_TYPE_DATA_ADD</span>, </span><br><span class="line">                                                <span class="number">0</span>, </span><br><span class="line">                                                <span class="number">0</span>,</span><br><span class="line">                                                dispatch_get_main_queue<span class="list">()</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_source_set_event_handler<span class="list">(<span class="keyword">source</span>, ^&#123;</span><br><span class="line">    [progressIndicator incrementBy<span class="keyword">:dispatch_source_get_data</span><span class="list">(<span class="keyword">source</span>)</span>]<span class="comment">;</span></span><br><span class="line">    &#125;)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_apply<span class="list">([array count], globalQueue, ^&#123;</span><br><span class="line">    dispatch_source_merge_data<span class="list">(<span class="keyword">source</span>, <span class="number">1</span>)</span><span class="comment">;</span></span><br><span class="line">    &#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[dispatch_source 介绍]]>
    
    </summary>
    
      <category term="DISPATCH_SOURCE" scheme="http://ytlvy.com/tags/DISPATCH-SOURCE/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/tags/IOS/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OSSpinLock]]></title>
    <link href="http://ytlvy.com/2015/06/30/OSSpinLock/"/>
    <id>http://ytlvy.com/2015/06/30/OSSpinLock/</id>
    <published>2015-06-30T01:10:44.000Z</published>
    <updated>2015-06-30T01:13:55.000Z</updated>
    <content type="html"><![CDATA[<h2 id="OSSpinLock">OSSpinLock</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/message.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;libkern/OSAtomic.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#define ITERATIONS (1024*1024*32)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> disp=<span class="number">0</span>, land=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main()&#123;</span><br><span class="line">    <span class="keyword">double</span> then, now;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i, count;</span><br><span class="line">    pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">    OSSpinLock spinlock = OS_SPINLOCK_INIT;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSAutoreleasePool</span> *pool = [<span class="built_in">NSAutoreleasePool</span> new];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLock</span> *lock = [<span class="built_in">NSLock</span> new];</span><br><span class="line">    then = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;ITERATIONS; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        [lock lock];</span><br><span class="line">        [lock unlock];</span><br><span class="line">    &#125;</span><br><span class="line">    now = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line">    printf(<span class="string">"NSLock: %f sec\n"</span>, now-then);    </span><br><span class="line"></span><br><span class="line">    then = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line">    IMP lockLock = [lock methodForSelector:<span class="keyword">@selector</span>(lock)];</span><br><span class="line">    IMP unlockLock = [lock methodForSelector:<span class="keyword">@selector</span>(unlock)];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;ITERATIONS; ++i) &#123;</span><br><span class="line">        lockLock(lock,<span class="keyword">@selector</span>(lock));</span><br><span class="line">        unlockLock(lock,<span class="keyword">@selector</span>(unlock));</span><br><span class="line">    &#125;</span><br><span class="line">    now = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line">    printf(<span class="string">"NSLock+IMP Cache: %f sec\n"</span>, now-then);    </span><br><span class="line"></span><br><span class="line">    then = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;ITERATIONS;++i) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    now = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line">    printf(<span class="string">"pthread_mutex: %f sec\n"</span>, now-then);</span><br><span class="line"></span><br><span class="line">    then = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;ITERATIONS; ++i) &#123;</span><br><span class="line">        OSSpinLockLock(&amp;spinlock);</span><br><span class="line">        OSSpinLockUnlock(&amp;spinlock);</span><br><span class="line">    &#125;</span><br><span class="line">    now = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line">    printf(<span class="string">"OSSpinlock: %f sec\n"</span>, now-then);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">id</span> obj = [<span class="built_in">NSObject</span> new];</span><br><span class="line"></span><br><span class="line">    then = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;ITERATIONS; ++i)&#123;</span><br><span class="line">        <span class="keyword">@synchronized</span>(obj) &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    now = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line">    printf(<span class="string">"@synchronized: %f sec\n"</span>, now-then);</span><br><span class="line"></span><br><span class="line">    [pool release];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">NSLock</span>: <span class="number">3.5175</span> sec</span><br><span class="line">NSLock+IMP <span class="attribute">Cache</span>: <span class="number">3.1165</span> sec</span><br><span class="line"><span class="attribute">Mutex</span>: <span class="number">1.5870</span> sec</span><br><span class="line"><span class="attribute">SpinLock</span>: <span class="number">1.0893</span></span><br><span class="line"><span class="variable">@synchronized</span>: <span class="number">9.9488</span> sec</span><br></pre></td></tr></table></figure>
<h3 id="分析">分析</h3><ol>
<li>@synchronized 非常沉重的api, 因为他需要额外设置一个exception handler, 并且结束的时候，需要少量内部锁。</li>
<li>OSSpinLock 不需要进入内核，只是简单的重复检测锁是否释放。如果此任务需要执行很久的话，效率会非常低。但是由于它节省了系统调用和上下文切换的时间，所以当任务确实很快的时候，效率很好。</li>
<li>Pthread mutexes 首先采用OSSpinLock来检测，如果没有结束，则进入内核锁方案</li>
<li>NSLock 是针对pthread mutexes的封装，因为多了Objc环境的调用所以效率较低。（have to pay for the extra ObjC overhead）</li>
</ol>
<h3 id="原子操作">原子操作</h3><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void DWDispatchOnce<span class="params">(dispatch_once_t *predicate, dispatch_block_t block)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span><span class="params">(*predicate == <span class="number">2</span>)</span> &#123;</span><br><span class="line">        __sync_synchronize<span class="params">()</span>;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    volatile dispatch_once_t <span class="built_in">*</span>volatilePredicate = predicate;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span><span class="params">(__sync_bool_compare_and_swap<span class="params">(volatilePredicate, <span class="number">0</span>, <span class="number">1</span>)</span>)</span> &#123;</span><br><span class="line">        block<span class="params">()</span>;</span><br><span class="line">        __sync_synchronize<span class="params">()</span>;</span><br><span class="line">        <span class="built_in">*</span>volatilePredicate = <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        while<span class="params">(*volatilePredicate != <span class="number">2</span>)</span></span><br><span class="line">            ;<span class="comment">//注意这里没有循环体</span></span><br><span class="line">        __sync_synchronize<span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先检查predicate是否为2，假如为2，则调用<strong>sync_synchronize这个builtin函数并返回，调用此函数会产生一个memory barrier，用以保证cpu读写顺序严格按照程序的编写顺序来进行，关于memory barrier的更多信息，还是查wiki吧。<br>紧接着是一个volatile修饰符修饰的指针临时变量，如此编译器就会假定此指针指向的值可能会随时被其它线程改变，从而防止编译器对此指针指向的值的读写进行优化，比如cache，reorder等。<br>然后进行“原子比较交换”，如果predicate为0，则将predicate置为1，表示正在执行block，并返回true，如此便进入了block执行分支，在block执行完毕之后，我们依旧需要一个memory barrier，最后我们将predicate置为2，表示执行已经完成，后续调用应该直接返回。<br>当某个线程A正在执行block时，任何线程B再进入此函数，便会进入else分支，然后在此分支中进行等待，直至线程A将predicate置为2，然后调用</strong>sync_synchronize并返回<br>这个实现是线程安全的，并且是无锁的，但是，依旧需要消耗11.5ns来执行，比自旋锁都慢，实际上memory barrier是很慢的。至于为什么比自旋锁还慢，memory barrier有好几种，__sync_synchronize产生的是mfenceCPU指令，是最蛋疼的一种，跟那蛋疼到忧伤的SSE4指令集是一路货。但不管怎么样，我想说的是，memory barrier是有不小的开销的</p>
<h3 id="dispatch_semaphore">dispatch_semaphore</h3><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t ioQueue = dispatch_queue_create<span class="params">(<span class="string">"com.dreamingwish.imagegcd.io"</span>, NULL)</span>;</span><br><span class="line"> </span><br><span class="line">int cpuCount = [[NSProcessInfo processInfo] processorCount];</span><br><span class="line">dispatch_semaphore_t jobSemaphore = dispatch_semaphore_create<span class="params">(cpuCount * <span class="number">2</span>)</span>;</span><br><span class="line"> </span><br><span class="line">dispatch_group_t group = dispatch_group_create<span class="params">()</span>;</span><br><span class="line">__block uint32_t count = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span><span class="params">(NSString *path in enumerator)</span></span><br><span class="line">&#123;</span><br><span class="line">    WithAutoreleasePool<span class="params">(^&#123;</span><br><span class="line">        if<span class="params">([[[path pathExtension] lowercaseString] isEqual: @<span class="string">"jpg"</span>])</span></span><br><span class="line">        &#123;</span><br><span class="line">            NSString *fullPath = [dir stringByAppendingPathComponent: path];</span><br><span class="line">             </span><br><span class="line">            dispatch_semaphore_wait<span class="params">(jobSemaphore, DISPATCH_TIME_FOREVER)</span>;</span><br><span class="line">         </span><br><span class="line">            dispatch_group_async<span class="params">(group, ioQueue, BlockWithAutoreleasePool<span class="params">(^&#123;</span><br><span class="line">                NSData *data = [NSData dataWithContentsOfFile: fullPath];</span><br><span class="line">                dispatch_group_async<span class="params">(group, globalQueue, BlockWithAutoreleasePool<span class="params">(^&#123;</span><br><span class="line">                    NSData *thumbnailData = ThumbnailDataForData<span class="params">(data)</span>;</span><br><span class="line">                    if<span class="params">(thumbnailData)</span> &#123;</span><br><span class="line">                        NSString *thumbnailName = [NSString stringWithFormat: @<span class="string">"%d.jpg"</span>,</span><br><span class="line">                                                   OSAtomicIncrement32<span class="params">(&amp;count;)</span>];</span><br><span class="line">                        NSString *thumbnailPath = [destination stringByAppendingPathComponent: thumbnailName];</span><br><span class="line">                        dispatch_group_async<span class="params">(group, ioQueue, BlockWithAutoreleasePool<span class="params">(^&#123;</span><br><span class="line">                            [thumbnailData writeToFile: thumbnailPath atomically: NO];</span><br><span class="line">                            dispatch_semaphore_signal<span class="params">(jobSemaphore)</span>;</span><br><span class="line">                        &#125;)</span>)</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else&#123;</span><br><span class="line">                        dispatch_semaphore_signal<span class="params">(jobSemaphore)</span>;</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;)</span>)</span>;</span><br><span class="line">            &#125;)</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span>;</span><br><span class="line">&#125;</span><br><span class="line">dispatch_group_wait<span class="params">(group, DISPATCH_TIME_FOREVER)</span>;</span><br></pre></td></tr></table></figure>
<p>dispatch_semaphore_wait() has only decremented the semaphore value if it returns 0</p>
<h3 id="dispatch_source">dispatch_source</h3><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">NSArray* indexPathsAry = @[ ... ]<span class="comment">;</span></span><br><span class="line">const NSTimeInterval intervalInSeconds = 1.0 / 30.0<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">__block NSUInteger i = 0<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue())<span class="comment">;</span></span><br><span class="line">dispatch_source_set_timer(timer, DISPATCH_TIME_NOW,  (uint64_t)(intervalInSeconds * NSEC_PER_SEC), 0)<span class="comment">;</span></span><br><span class="line">dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">    NSIndexPath *indexPath = indexPathsAry[i++]<span class="comment">;</span></span><br><span class="line">    id item = items[indexPath.row]<span class="comment">;</span></span><br><span class="line">    [items removeObject:item]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    [tableView beginUpdates]<span class="comment">;</span></span><br><span class="line">    [tableView deleteRowsAtIndexPaths:indexPath withAnimation:...]<span class="comment">;</span></span><br><span class="line">    [tableView endUpdates]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    if (i &gt;= indexPathsAry.count) &#123;</span><br><span class="line">        dispatch_source_cancel(timer)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_source_set_cancel_handler(timer, ^&#123;</span><br><span class="line">    // whatever you want to happen when all the removes are done.</span><br><span class="line">&#125;)</span><br><span class="line">dispatch_resume(timer)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">NSOperation* finishOp = <span class="comment">[NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">    // ... whatever you want to have happen when all deletes have been processed.</span><br><span class="line">&#125;]</span>;</span><br><span class="line"></span><br><span class="line">for (NSIndexPath* toDelete in indexPathsAry)</span><br><span class="line">&#123;</span><br><span class="line">    NSOperation* op = <span class="comment">[NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        id item = items<span class="comment">[toDelete.row]</span>;</span><br><span class="line">        <span class="comment">[items removeObject: item]</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">[tableView beginUpdates]</span>;</span><br><span class="line">        <span class="comment">[tableView deleteRowsAtIndexPaths: @<span class="comment">[toDelete]</span> withAnimation:...]</span>;</span><br><span class="line">        <span class="comment">[tableView endUpdates]</span>;</span><br><span class="line">    &#125;]</span>;</span><br><span class="line">    <span class="comment">[finishOp addDependency: op]</span>;</span><br><span class="line">    <span class="comment">[<span class="comment">[NSOperationQueue mainQueue]</span> addOperation: op]</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">[<span class="comment">[NSOperationQueue mainQueue]</span> addOperation: finishOp]</span>;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[IOS LOCk]]>
    
    </summary>
    
      <category term="IOS" scheme="http://ytlvy.com/tags/IOS/"/>
    
      <category term="LOCK" scheme="http://ytlvy.com/tags/LOCK/"/>
    
      <category term="OSSpinLock" scheme="http://ytlvy.com/tags/OSSpinLock/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Cancel a NSBlockOperation]]></title>
    <link href="http://ytlvy.com/2015/06/30/Cancel-a-NSBlockOperation/"/>
    <id>http://ytlvy.com/2015/06/30/Cancel-a-NSBlockOperation/</id>
    <published>2015-06-30T01:08:23.000Z</published>
    <updated>2015-06-30T01:25:10.000Z</updated>
    <content type="html"><![CDATA[<h3 id="make_NSBlockOperation_cancelable">make NSBlockOperation cancelable</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSBlockOperation</span> *operation = [[<span class="built_in">NSBlockOperation</span> alloc] init];</span><br><span class="line">__<span class="keyword">weak</span> <span class="built_in">NSBlockOperation</span> *weakOperation = operation;</span><br><span class="line">[operation addExecutionBlock:^&#123;</span><br><span class="line">   <span class="keyword">while</span>( ! [weakOperation isCancelled])&#123;</span><br><span class="line">      <span class="comment">//do something...</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[你对本页的描述]]>
    
    </summary>
    
      <category term="IOS" scheme="http://ytlvy.com/tags/IOS/"/>
    
      <category term="NSBlockOperation" scheme="http://ytlvy.com/tags/NSBlockOperation/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Xcode Notes]]></title>
    <link href="http://ytlvy.com/2015/06/22/Xcode-Notes/"/>
    <id>http://ytlvy.com/2015/06/22/Xcode-Notes/</id>
    <published>2015-06-22T08:57:42.000Z</published>
    <updated>2015-06-22T08:58:20.000Z</updated>
    <content type="html"><![CDATA[<h3 id="快捷键">快捷键</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">⌘（command）、⌥（option）、⇧（shift）、⇪（caps <span class="operator"><span class="keyword">lock</span>）、</span><br><span class="line">⌃（control）、↩（<span class="keyword">return</span>）、⌅（enter）</span><br><span class="line"></span><br><span class="line">^ + <span class="number">1</span>                 <span class="keyword">corresponding</span> Nib/Storyboard file</span><br><span class="line">^ + <span class="number">2</span>                 <span class="keyword">show</span> the previous history</span><br><span class="line">^ + <span class="number">6</span>                 methods list</span><br><span class="line"></span><br><span class="line">^ + ⌘ + <span class="keyword">left</span>         <span class="keyword">go</span> back</span><br><span class="line">⌘ + Shift + O        jump <span class="keyword">to</span> a particular filename method</span><br><span class="line">⌘ + L                <span class="keyword">go</span> <span class="keyword">to</span> line</span><br><span class="line">⌘ + Y                toggle <span class="keyword">all</span> breakpoints</span><br><span class="line">⌘ + <span class="number">0</span>                toggle <span class="keyword">left</span> panel</span><br><span class="line">⌘ + <span class="number">1</span>                <span class="keyword">show</span> Project Nacigator</span><br><span class="line"></span><br><span class="line">^ + P                 移动光标到上一行</span><br><span class="line">^ + N                 移动光标到下一行</span><br><span class="line">^ + A                 移动光标到本行行首</span><br><span class="line">^ + E                 移动光标到本行行尾</span><br><span class="line">^ + D                 删除光标右边的字符</span><br><span class="line">^ + K                 删除空行/光标到行尾</span><br><span class="line">^ + L                 将插入点置于窗口正中</span><br><span class="line"></span><br><span class="line">⌘ + ⌥ + d           显示／隐藏 dock</span><br><span class="line"></span><br><span class="line">Fn + <span class="keyword">Delete</span>           删除光标后的一个字符</span><br><span class="line">⌘ + <span class="keyword">Delete</span>           删除光标至行首的内容</span><br><span class="line"></span><br><span class="line">⌘ + ⇧ + ;</span>           调出拼写检查对话框。</span><br><span class="line">⌘ + ⌥ + =           xib <span class="operator"><span class="keyword">update</span> frame</span></span><br></pre></td></tr></table></figure>
<h4 id="全局删除光标右边字符">全局删除光标右边字符</h4><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">^ + <span class="keyword">D</span>                 删除光标右边的字符</span><br><span class="line">⌘ + ^ + <span class="keyword">D</span>            直接调用字典</span><br></pre></td></tr></table></figure>
<h3 id="xcode_target_build_setting">xcode target build setting</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XCBuildConfiguration</span><br></pre></td></tr></table></figure>
<h4 id="xcode_plugin">xcode plugin</h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~<span class="regexp">/Library/</span>Application\ Support<span class="regexp">/Developer/</span>Shared<span class="regexp">/Xcode/</span>Plug-ins</span><br><span class="line">~<span class="regexp">/Library/</span>Developer<span class="regexp">/CoreSimulator</span></span><br></pre></td></tr></table></figure>
<h4 id="Xcode_plugins">Xcode plugins</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">FuzzyAutocomplete</span></span><br><span class="line">KSImageNamed</span><br><span class="line">HOStringSense</span><br><span class="line">VVDocumenter-xcode</span><br></pre></td></tr></table></figure>
<h3 id="xcode_环境变量_Environment_variable">xcode 环境变量 Environment variable</h3><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">OBJC_PRINT_LOAD_METHODS</span></span><br><span class="line"><span class="variable">OBJC_PRINT_REPLACED_METHODS</span></span><br><span class="line"><span class="variable">OBJC_PRINT_DEPRECATION_WARNINGS</span></span><br><span class="line"><span class="variable">OBJC_DEBUG_NIL_SYNC</span></span><br><span class="line"><span class="variable">NSZombieEnabled</span>     <span class="exclamation_mark">!</span><span class="exclamation_mark">!</span></span><br><span class="line"><span class="variable">XcodeColors</span></span><br></pre></td></tr></table></figure>
<h3 id="xcode_7_Enable_Address_Sanitizer">xcode 7 Enable Address Sanitizer</h3><p><img src="http://cc.cocimg.com/api/uploads/20150616/1434421492186513.png" alt=""><br>打开的方法: Schema-&gt;Run-&gt;Diagnostics  Enable Address Sanitizer</p>
<h3 id="delevoper_tools">delevoper tools</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">colorsnapper</span></span><br><span class="line">prepo</span><br><span class="line">simpholders</span><br><span class="line">xscope</span><br><span class="line">kaleidoscope</span><br></pre></td></tr></table></figure>
<h3 id="xcode_模拟器地址">xcode 模拟器地址</h3><pre><code><span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/</span>iPhoneSimulator.platform<span class="regexp">/Developer/</span>SDKs/
<span class="string">https:</span><span class="comment">//developer.apple.com/downloads/index.action</span>
</code></pre><h3 id="开发工具">开发工具</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-<span class="built_in">select</span> <span class="comment">--install</span></span><br></pre></td></tr></table></figure>
<h3 id="xocde_uuid">xocde uuid</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults <span class="keyword">read</span> <span class="regexp">/Applications/</span>Xcode-beta.app<span class="regexp">/Contents/I</span>nfo DVTPlugInCompatibilityUUID</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[Xocde 快捷键 调试设置等]]>
    
    </summary>
    
      <category term="IOS" scheme="http://ytlvy.com/tags/IOS/"/>
    
      <category term="Xcode" scheme="http://ytlvy.com/categories/Xcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Valar Morghulis Valar Dohaeris]]></title>
    <link href="http://ytlvy.com/2015/06/16/Valar-Morghulis-Valar-Dohaeris/"/>
    <id>http://ytlvy.com/2015/06/16/Valar-Morghulis-Valar-Dohaeris/</id>
    <published>2015-06-16T12:38:22.000Z</published>
    <updated>2015-06-16T12:49:59.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/mw1024/8edf7b7agw1et5ppc4i12g20dw0697uc.gif" alt=""></p>
<p>Valar Morghulis = 凡人皆有一死<br>Valar Dohaeris = 凡人皆须侍奉<br>这两句是需要放在一起理解的</p>
<p>看字面意思，凡人皆有一死，似乎表明的是死亡的不可避免。满含悲观的情绪。这和史塔克的家族箴言一样，凛冬将至。对于命运我们无能为力。</p>
<p>但是，这句话还伴随着另外那句：凡人皆须侍奉。这两句是高等瓦雷利亚语，缘起于千面之神和信仰它的神秘组织 无面者。</p>
<p>关于无面者的起源，一直流传着一个传奇故事。<br>曾经，驾着巨龙的瓦雷利亚人统治着世界，他们从各地掳来大量的奴隶，将这些奴隶安排在深深的矿井中劳作。千面之神的信仰最初就诞生于矿井内这些悲惨的奴隶群中。<br>矿内的奴隶经常起义，而第一个无面者就是反抗者之一。有人认为他本身就是个奴隶，有人坚持说他是自由堡垒的公民，出身于贵族世家，有人甚至会告诉你，他是个同情手下奴隶的监工。但是没人真正清楚他的来历，人们只知道他在奴隶中活动，聆听他们的祈祷。<br>奴隶们来自世界各地，他们每个人都用自己的语言向自己的神祷告。然而祈求的却都是同一件事———解脱，终结痛苦。这对于任何神来说，是一件极为普通极其简单的小事，但却没有神回应他们。<br>煎熬无止境地继续着。直到有天晚上，在火山矿井泛红的黑暗中，第一位无面者顿悟了：所有神祗都有自己的工具，为其效力的善男信女在世间执行他们的意志。表面上，奴隶是在向上百个不同的神灵哭喊，其实那是同一个神，有着上百张不同的脸孔而已。而他即是这个神的工具。此后，第一个无面者将“礼物”赐予那些绝望的奴隶，这个礼物就死亡。对于被困在地下矿井中日夜生活在绝望中的人们来说，死亡即是终结了他们的痛苦。<br>所以，对于信仰千面之神的人来说，死亡就是仁慈的解脱。</p>
<p>再回来看这两句。<br>当一个人说出，凡人皆有一死，就已经接受了死亡在生命的尽头等待他。<br>死亡是神赐予他这个凡人的礼物。<br>但接下来的，凡人皆须侍奉。似乎跟上面的一切都毫无关联。<br>其实，死亡这个礼物是有代价的。每个凡人终其一生，都用自己的方式来侍奉千面之神。不论你从事什么职业，不论你如何生活，你的一生都是在做好自己的侍奉。<br>而当你完成自己的侍奉时，千面之神就会用死亡来解脱你。</p>
<p>因此，你告诉别人，valar morghulis，终有一天死亡会给你带来解脱。<br>而别人会回应你，valar dohaeris，只要你还活着，那么你就要做好神交给你的一切，完成侍奉才会得到死亡。</p>
]]></content>
    <summary type="html">
    <![CDATA[Valar Morghulis Valar Dohaeris]]>
    
    </summary>
    
      <category term="other" scheme="http://ytlvy.com/tags/other/"/>
    
      <category term="other" scheme="http://ytlvy.com/categories/other/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ios MRC && ARC]]></title>
    <link href="http://ytlvy.com/2015/06/16/ios-MRC-ARC/"/>
    <id>http://ytlvy.com/2015/06/16/ios-MRC-ARC/</id>
    <published>2015-06-16T01:48:11.000Z</published>
    <updated>2015-06-16T01:48:59.000Z</updated>
    <content type="html"><![CDATA[<h2 id="ARC">ARC</h2><h3 id="MRC">MRC</h3><h4 id="MRC内存管理原则">MRC内存管理原则</h4><p>􏰀1. You have ownership of any objects you create.<br>2.􏰀 You can take ownership of an object using retain.<br>􏰀3. When no longer needed, you must relinquish ownership of an object you own.<br>􏰀4. You must not relinquish ownership of an object you don’t own.</p>
<table>
<thead>
<tr>
<th>Action for Objective-C Object</th>
<th>Objective-C Method</th>
</tr>
</thead>
<tbody>
<tr>
<td>Create and have ownership of it</td>
<td>alloc/new/copy/mutableCopy group</td>
</tr>
<tr>
<td>Take ownership of it</td>
<td>retian</td>
</tr>
<tr>
<td>Relinquish it</td>
<td>release</td>
</tr>
<tr>
<td>Dispose of it</td>
<td>dealloc</td>
</tr>
</tbody>
</table>
<h4 id="调用者持有">调用者持有</h4><p>Relinquishing Ownership of a Retained Object. 下面的例子将函数将自己持有的obj, 通过return传递给了调用者,由调用者来来持有此变量<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (id)allocObject</span><br><span class="line">&#123;</span><br><span class="line">  /*</span><br><span class="line">  - <span class="type">You</span> create an <span class="keyword">object</span> <span class="keyword">and</span> have ownership. */</span><br><span class="line">  id obj = [[<span class="type">NSObject</span> alloc] init];</span><br><span class="line">  /*</span><br><span class="line">  - <span class="type">At</span> this moment, this <span class="keyword">method</span> has ownership <span class="keyword">of</span> the <span class="keyword">object</span>. */</span><br><span class="line">  <span class="keyword">return</span> obj; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="调用者不持有">调用者不持有</h4><p>通过autorelease, 可以让调用者不持有该对象. Autorelease offers a mechanism to relinquish objects properly when the lifetime of the objects has ended.自动释放提供了一种, 当对象生命周期结束时,自动释放的机制.<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (id)<span class="keyword">object</span></span><br><span class="line">&#123;</span><br><span class="line">  id obj = [[<span class="type">NSObject</span> alloc] init];</span><br><span class="line">  /*</span><br><span class="line">  - <span class="type">At</span> this moment, this <span class="keyword">method</span> has ownership <span class="keyword">of</span> the <span class="keyword">object</span>. */</span><br><span class="line">  [obj autorelease];</span><br><span class="line">  /*</span><br><span class="line">  - <span class="type">The</span> <span class="keyword">object</span> exists, <span class="keyword">and</span> you don’t have ownership <span class="keyword">of</span> it. */</span><br><span class="line">  <span class="keyword">return</span> obj; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="autorelease">autorelease</h4><p>通过autorelease将对象注册到 最近的autoReleasePool中,当pool调用<code>drain</code>时, 该对象的release被调用.</p>
<h4 id="不要释放,_非你持有的对象">不要释放, 非你持有的对象</h4><p>app crash<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id obj = <span class="comment">[<span class="comment">[NSObject alloc]</span> init]</span>;</span><br><span class="line"><span class="comment">[obj release]</span>;</span><br><span class="line"><span class="comment">[obj release]</span>;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id obj1 = [obj0 object]<span class="comment">;</span></span><br><span class="line">[obj1 release]<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h4 id="GNUstep_—_The_alloc_Method">GNUstep — The alloc Method</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> obj_layout &#123;</span><br><span class="line">  <span class="built_in">NSUInteger</span> retained; </span><br><span class="line">&#125;;</span><br><span class="line">+ (<span class="keyword">id</span>) alloc &#123;</span><br><span class="line">  <span class="keyword">int</span> size = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> obj_layout) + size_of_the_object; </span><br><span class="line">  <span class="keyword">struct</span> obj_layout *p = (<span class="keyword">struct</span> obj_layout *)calloc(<span class="number">1</span>, size); </span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">id</span>)(p + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>动态分配地址, 并将第一个字节, 转换为引用计数.</p>
<h5 id="GNUstep_—_malloc_&amp;&amp;_calloc">GNUstep —  malloc &amp;&amp; calloc</h5><p>malloc 分配的空间没有初始化为0, calloc分配的空间初始化为0; calloc可以分配多个</p>
<h4 id="GNUstep_—_The_retain_Method">GNUstep —  The retain Method</h4><p>The alloc method returns a memory block filled with zero containing a struct obj_layout header, which has a variable “retained” to store the number of references. This number is called the reference count</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init]; </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"retainCount=%d"</span>, [obj retainCount]); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSUInteger</span>) retainCount &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NSExtraRefCount</span>(<span class="keyword">self</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">NSUInteger</span> <span class="built_in">NSExtraRefCount</span>(<span class="keyword">id</span> anObject)&#123;</span><br><span class="line">  <span class="keyword">return</span> ((<span class="keyword">struct</span> obj_layout *)anObject)[-<span class="number">1</span>]<span class="variable">.retained</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>) retain &#123;</span><br><span class="line">  <span class="built_in">NSIncrementExtraRefCount</span>(<span class="keyword">self</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="built_in">NSIncrementExtraRefCount</span>(<span class="keyword">id</span> anObject) &#123;</span><br><span class="line">  <span class="keyword">if</span> (((<span class="keyword">struct</span> obj_layout *)anObject)[-<span class="number">1</span>]<span class="variable">.retained</span> == <span class="built_in">UINT_MAX</span> - <span class="number">1</span>)</span><br><span class="line">      [<span class="built_in">NSException</span> raise: <span class="built_in">NSInternalInconsistencyException</span></span><br><span class="line">                  format: <span class="string">@"NSIncrementExtraRefCount() asked to increment too far"</span>];</span><br><span class="line"> </span><br><span class="line">  ((<span class="keyword">struct</span> obj_layout *)anObject)[-<span class="number">1</span>]<span class="variable">.retained</span>++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="GNUstep_—_The_release_Method">GNUstep — The release Method</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) release &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">NSDecrementExtraRefCountWasZero</span>(<span class="keyword">self</span>))</span><br><span class="line">    [<span class="keyword">self</span> dealloc];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">BOOL</span> <span class="built_in">NSDecrementExtraRefCountWasZero</span>(<span class="keyword">id</span> anObject) &#123;</span><br><span class="line">  <span class="keyword">if</span> (((<span class="keyword">struct</span> obj_layout *)anObject)[-<span class="number">1</span>]<span class="variable">.retained</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    ((<span class="keyword">struct</span> obj_layout *)anObject)[-<span class="number">1</span>]<span class="variable">.retained</span>--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="GNUstep_—_The_dealloc_Method">GNUstep — The dealloc Method</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) dealloc </span><br><span class="line">  <span class="built_in">NSDeallocateObject</span> (<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="built_in">NSDeallocateObject</span>(<span class="keyword">id</span> anObject) &#123;</span><br><span class="line">  <span class="keyword">struct</span> obj_layout *o = &amp;((<span class="keyword">struct</span> obj_layout *)anObject)[-<span class="number">1</span>];</span><br><span class="line">  free(o); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="GNUstep_—_总结">GNUstep — 总结</h4><p>􏰀1. All Objective-C objects have an integer value called the reference count.<br>􏰀2. The reference count is incremented by one when one of alloc/new/copy/mutableCopy or retain is called.<br>􏰀3. It is decremented by one when release is called.<br>􏰀4. Dealloc is called when the integer counter becomes zero.</p>
<h4 id="Apple’s_Implementation">Apple’s Implementation</h4><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">retainCount </span><br><span class="line"></span>  __CFDoExternRefOperation</span><br><span class="line">  CFBasicHashGetCountOfKey</span><br><span class="line"></span><br><span class="line">-<span class="ruby">retain </span><br><span class="line"></span>  __CFDoExternRefOperation </span><br><span class="line">  CFBasicHashAddValue</span><br><span class="line"></span><br><span class="line">-<span class="ruby">release </span><br><span class="line"></span>  __CFDoExternRefOperation </span><br><span class="line">  CFBasicHashRemoveValue</span><br></pre></td></tr></table></figure>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __CFDoExternRefOperation(uintptr_t op, id obj) &#123; </span><br><span class="line">  CFBasicHashRef table = get hashtable <span class="keyword">from</span> obj; <span class="keyword">int</span> <span class="keyword">count</span>;</span><br><span class="line">  <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> OPERATION_retainCount:</span><br><span class="line">      <span class="keyword">count</span> = CFBasicHashGetCountOfKey(table, obj); </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">count</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> OPERATION_retain: </span><br><span class="line">      CFBasicHashAddValue(table, obj); </span><br><span class="line">      <span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> OPERATION_release:</span><br><span class="line">      <span class="keyword">count</span> = CFBasicHashRemoveValue(table, obj);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span> == <span class="keyword">count</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在GUNstep的实现中, 引用计数存放在每个obj的header部分, 而Apple的实现, 将所有的对象的引用计数存放在一个HashTable中,</p>
<p>GUNstep实现的好处:</p>
<ul>
<li>更少的代码</li>
<li>很容易控制生命周期, 因为计数, 本身包含在每个对象中</li>
</ul>
<p>Apple实现的好处:</p>
<ul>
<li>每个对象不必有header部分, 从而不需要考虑对齐的问题</li>
<li>计数统一管理, 每个对象的计数都可以访问到, 便于系统批量处理.</li>
<li>当每个对象的内存出问题的时候, 可以通过hashTable来定位到该对象</li>
</ul>
<h4 id="Autorelease">Autorelease</h4><h5 id="Automatic_Variables">Automatic Variables</h5><p>当一个自动变量, 超出其作用域时, 会自动释放.<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="keyword">int</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>With autorelease, you can use objects in the same manner as automatic variables, meaning that when execution leaves a code block, the “release” method is called on the object automatically. You can control the block itself as well.</p>
<p>The following steps</p>
<ol>
<li>Create an NSAutoreleasePool object.</li>
<li>Call “autorelease” to allocated objects.</li>
<li>Discard the NSAutoreleasePool object</li>
</ol>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSAutoreleasePool *pool = <span class="comment">[<span class="comment">[NSAutoreleasePool alloc]</span> init]</span>; id obj = <span class="comment">[<span class="comment">[NSObject alloc]</span> init]</span>;</span><br><span class="line"><span class="comment">[obj autorelease]</span>;</span><br><span class="line"><span class="comment">[pool drain]</span>;</span><br></pre></td></tr></table></figure>
<p>In the Cocoa Framework, NSAutoreleasePool objects are created, owned, or disposed of all over the place, such as NSRunLoop, which is the main loop of the application </p>
<p>But when there are too many autoreleased objects, application memory becomes short (Figure 1–14). It happens because the objects still exist until the NSAutoreleasePool object is discarded. A typical example of this is loading and resizing many images. Many autoreleased objects, such as NSData objects for reading files, UImage objects for the data, and resized images exist at the same time.</p>
<p>当有太多autorelease对象时, 程序的可用内存会急剧减少. 因为这些对象会一直存在, 直到pool被结束时.<br>典型应用场景: 加载或调整大量图片的时候.<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numberOfImages; ++i) &#123;</span><br><span class="line">  <span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span><br><span class="line">  * Loading images, etc.</span><br><span class="line">  * Too many autoreleased objects exist. </span><br><span class="line">  */</span></span><br><span class="line"></span><br><span class="line">  [pool drain];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Implementing_autorelease">Implementing autorelease</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">[obj autorelease]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (id) <span class="tag">autorelease</span> &#123;</span><br><span class="line">  <span class="attr_selector">[NSAutoreleasePool addObject:self]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>) addObject: (<span class="keyword">id</span>)anObj &#123;</span><br><span class="line">  <span class="built_in">NSAutoreleasePool</span> *pool = getting active <span class="built_in">NSAutoreleasePool</span>; </span><br><span class="line">  <span class="keyword">if</span> (pool != <span class="literal">nil</span>) &#123;</span><br><span class="line">    [pool addObject:anObj]; </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"autorelease is called without active NSAutoreleasePool."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Apple’s_Implementation_of_autorelease">Apple’s Implementation of autorelease</h4><p>runtime/NSObject.mm  #493<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="name">NSAutoreleasePool</span> *<span class="atom">pool</span> = [[<span class="name">NSAutoreleasePool</span> <span class="atom">alloc</span>] <span class="atom">init</span>];</span><br><span class="line"><span class="comment">/* equivalent to objc_autoreleasePoolPush() */</span></span><br><span class="line"></span><br><span class="line"><span class="atom">id</span> <span class="atom">obj</span> = [[<span class="name">NSObject</span> <span class="atom">alloc</span>] <span class="atom">init</span>];</span><br><span class="line">[<span class="atom">obj</span> <span class="atom">autorelease</span>];</span><br><span class="line"><span class="comment">/* equivalent to objc_autorelease(obj) */</span></span><br><span class="line"></span><br><span class="line">[<span class="atom">pool</span> <span class="atom">drain</span>];</span><br><span class="line"><span class="comment">/* equivalent to objc_autoreleasePoolPop(pool) */</span></span><br></pre></td></tr></table></figure></p>
<h3 id="ARC_Rules">ARC Rules</h3><h4 id="Ownership_qualifiers">Ownership qualifiers</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">􏰀__<span class="keyword">strong</span></span><br><span class="line">􏰀__<span class="keyword">weak</span></span><br><span class="line">􏰀__unsafe_unretained</span><br><span class="line">__autoreleasing</span><br></pre></td></tr></table></figure>
<h4 id="__strong_ownership_qualifier_—_作用域情况">__strong ownership qualifier — 作用域情况</h4><p><code>__strong</code>是默认的修饰符. </p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id obj = <span class="comment">[<span class="comment">[NSObject alloc]</span> init]</span>;</span><br></pre></td></tr></table></figure>
<p>等同于<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br></pre></td></tr></table></figure></p>
<p>在ARC环境中<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="comment">/*ARC*/</span></span><br><span class="line">  <span class="keyword">id</span> __<span class="keyword">strong</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当超出变量作用域时, ARC在编译期会自动添加release操作, 以达到和非ARC一致的目的<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">&#123;/*non-ARC*/</span><br><span class="line">  id obj = <span class="collection">[<span class="collection">[NSObject alloc]</span> init]</span><span class="comment">;</span></span><br><span class="line">  <span class="collection">[obj release]</span><span class="comment">; </span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Assigning_to___strong_ownership_qualified_variables_—_赋值情况">Assigning to __strong ownership qualified variables — 赋值情况</h4><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  /<span class="keyword">*</span> 持有一个非自己创建的obj <span class="keyword">*</span>/</span><br><span class="line">  id __strong obj = [NSMutableArray array];</span><br><span class="line">&#125; /<span class="keyword">*</span> 超出作用域, 变量不再使用,  自动添加release<span class="keyword">*</span>/</span><br><span class="line">/<span class="keyword">*</span>obj被自动释放<span class="keyword">*</span>/</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj0 = [[<span class="built_in">NSObject</span> alloc] init]; <span class="comment">//objA</span></span><br><span class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj1 = [[<span class="built_in">NSObject</span> alloc] init]; <span class="comment">//objB</span></span><br><span class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj2 = <span class="literal">nil</span>;</span><br><span class="line">obj0 = obj1;  <span class="comment">//objA 不再有人持有,自动添加release, objB引用计数+1</span></span><br><span class="line">obj2 = obj0;  <span class="comment">//objB 引用计数+1</span></span><br><span class="line"></span><br><span class="line">obj1 = <span class="literal">nil</span>;   <span class="comment">//objB引用计数-1</span></span><br><span class="line">obj0 = <span class="literal">nil</span>;   <span class="comment">//objB引用计数-1</span></span><br><span class="line">obj2 = <span class="literal">nil</span>;   <span class="comment">//objB引用计数-1 当前计数为0 调用dealloc</span></span><br></pre></td></tr></table></figure>
<p>ownership is properly managed not only by variable scope, but also by assignments between variables, which are qualified with <strong>strong. Of course, a </strong>strong qualifier can be used as a member variable of Objective-C class or any argument of methods.<br>持有关系,不仅可以通过作用域来自动判定, 也可以通过给strong类型的变量赋值来自动判定</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Test</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">id</span> __<span class="keyword">strong</span> obj_;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span> __<span class="keyword">strong</span>)obj; </span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Test</span> - (<span class="title">id</span>)<span class="title">init</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span> __<span class="keyword">strong</span>)obj&#123;</span><br><span class="line">  obj_ = obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="atom">id</span> <span class="name">__strong</span> <span class="atom">test</span> = [[<span class="name">Test</span> <span class="atom">alloc</span>] <span class="atom">init</span>];</span><br><span class="line">  <span class="comment">/*test 持有Test obj*/</span></span><br><span class="line"></span><br><span class="line">  [<span class="atom">test</span> <span class="atom">setObject</span>:[[<span class="name">NSObject</span> <span class="atom">alloc</span>] <span class="atom">init</span>]]; </span><br><span class="line">  <span class="comment">/*test的属性obj_持有Object*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*超出作用域, 因为test不再被使用, 自动添加release, test调用release释放Test obj, 因为obj_也讲被销毁 其所持有的Object也会调用release方法 */</span></span><br><span class="line"><span class="comment">/* 变量自动释放完毕*/</span></span><br></pre></td></tr></table></figure>
<h4 id="__weak_ownership_qualifier">__weak ownership qualifier</h4><p>避免循环引用.<br>循环引用的案例: 两个对象同时持有对方, 或者一个对象持有自身.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br></pre></td></tr></table></figure>
<p>变量在赋值后, 马上自动释放,因为没有任何变量, 持有新生成的obj.</p>
<h4 id="Weak_Reference_Disappears">Weak Reference Disappears</h4><p>当weak变量所指向的变量被释放时, 此weak变量自动指向nil.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> obj1 = <span class="literal">nil</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">id</span> __<span class="keyword">strong</span> obj0 = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">  obj1 = obj0;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"A: %@"</span>, obj1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"B: %@"</span>, obj1); <span class="comment">// (null)</span></span><br></pre></td></tr></table></figure>
<h4 id="__unsafe_unretained_ownership_qualifier">__unsafe_unretained ownership qualifier</h4><p><code>__unsafe_unretained</code> 和<code>__weak</code>相似不持有对象.但是当此标示符的变量指向的对象被释放后, 系统不会自动设置该变量为nil.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> __unsafe_unretained obj1 = <span class="literal">nil</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">id</span> __<span class="keyword">strong</span> obj0 = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">  obj1 = obj0;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"A: %@"</span>, obj1);    <span class="comment">//&lt;NSObject: 0x753e180&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"B: %@"</span>, obj1);      <span class="comment">//&lt;NSObject: 0x753e180&gt;</span></span><br><span class="line"><span class="comment">/* 此处输出的其实乱指针,因为 生成的对象已经被释放, 但是猜测,由于目前还没有回收该内存, 只是做了标记, 所以暂时指向的地址还是正确的.*/</span></span><br></pre></td></tr></table></figure>
<p>此标示符不建议使用, 除非是为了在ios4等低版本系统中, 为了替换<code>__weak</code>.</p>
<h4 id="__autoreleasing_ownership_qualifier">__autoreleasing ownership qualifier</h4><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* non-ARC */</span></span><br><span class="line"><span class="name">NSAutoreleasePool</span> *<span class="atom">pool</span> = [[<span class="name">NSAutoreleasePool</span> <span class="atom">alloc</span>] <span class="atom">init</span>];</span><br><span class="line"><span class="atom">id</span> <span class="atom">obj</span> = [[<span class="name">NSObject</span> <span class="atom">alloc</span>] <span class="atom">init</span>];</span><br><span class="line">[<span class="atom">obj</span> <span class="atom">autorelease</span>];</span><br><span class="line">[<span class="atom">pool</span> <span class="atom">drain</span>];</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ARC */</span></span><br><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">  <span class="keyword">id</span> __autoreleasing obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>__autoreleasing</code>标示符,相当于非ARC环境下调用<code>autorelease</code><br>但是实际中, 只有非常罕见的情况下才需要设置此标示符.下面解释为什么不需要设置</p>
<h5 id="Compiler_Cares___autoreleasing_Automatically">Compiler Cares __autoreleasing Automatically</h5><p>To obtain an object without creation, you use some methods not in the alloc/new/copy/mutableCopy method group. In this case, the object is automatically registered to the autoreleasepool. It is same as obtaining an autoreleased object. When an object is returned from a method, the compiler checks if the method begins with alloc/new/copy/mutableCopy, and if not, the returned object is automatically registered to the autorelease pool. Exceptionally, any method whose name begins with init, doesn’t register the return value to autoreleasepool. Please see below for more about this new rule: the naming rule for methods related to object creation must be followed<br>当不是使用alloc/new/copy/mutableCopy之外方法, 来获得的对象时, 系统自动将该对象注册到autoreleasepool中,<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line"></span><br><span class="line">  id __strong obj = [<span class="type">NSMutableArray</span> <span class="type">array</span>];</span><br><span class="line">  /*</span><br><span class="line">  * <span class="type">The</span> variable obj <span class="keyword">is</span> qualified <span class="keyword">with</span> __strong.</span><br><span class="line">  * <span class="type">Which</span> means, it has ownership <span class="keyword">of</span> the <span class="keyword">object</span>.</span><br><span class="line">  * <span class="type">And</span> the <span class="keyword">object</span> <span class="keyword">is</span> registered <span class="keyword">in</span> autoreleasepool,</span><br><span class="line">  * because the compiler decides it by checking the <span class="keyword">method</span> name. </span><br><span class="line">  */</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">* <span class="type">Leaving</span> the scope <span class="keyword">of</span> variable obj, its strong reference disappears.</span><br><span class="line">* <span class="type">The</span> <span class="keyword">object</span> <span class="keyword">is</span> released automatically. *</span><br><span class="line">* <span class="type">Leaving</span> @autoreleasepool <span class="keyword">block</span>,</span><br><span class="line">* all the objects registered <span class="keyword">in</span> the autoreleasepool are released automatically. *</span><br><span class="line">* <span class="type">The</span> <span class="keyword">object</span> <span class="keyword">is</span> discarded because no one has ownership.</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+<span class="function"> (</span>id<span class="function">)</span><span class="instruction"> array </span>&#123;</span><br><span class="line">  id obj = <span class="keyword">[</span><span class="keyword">[</span>NSMutableArray alloc] init];</span><br><span class="line"> <span class="instruction"> return </span>obj; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“id obj” does not have a qualifier. So it is qualified with __strong. When the “return” sentence is executed, the variable scope is left and the strong reference disappears. Therefore the object will be released automatically. Before that, if the compiler detects that the object will be passed to the caller, the object is registered in autoreleasepool</p>
<p>When a variable with a <code>__weak</code> qualifier is used, <strong><em>the object is always registered in autoreleasepool</em></strong><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> obj1 = obj0; </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"class=%@"</span>, [obj1 class]);</span><br></pre></td></tr></table></figure></p>
<p>等同下面<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> obj1 = obj0;</span><br><span class="line"><span class="keyword">id</span> __autoreleasing tmp = obj1; </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"class=%@"</span>, [tmp class]);</span><br></pre></td></tr></table></figure></p>
<p>weak修饰的变量, 因为不持有对象, 为了安全的释放, weak对象自动注册到autoreleasepool中.</p>
<h4 id="weak对象的调用">weak对象的调用</h4><p>通过编译代码可以看出, 获取一个weak变量指向的对象, 需要调用<code>objc_loadWeak</code>方法,<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id objc_loadWeak(id *<span class="class"><span class="keyword">object</span>) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> objc_autorelease(objc_loadWeakRetained(<span class="class"><span class="keyword">object</span>));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">[weakObject doSomething]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>ARC转换为:<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">Object</span> *<span class="keyword">strongObject </span>= objc_autorelease(objc_loadWeakRetained(weakObject))<span class="comment">;</span></span><br><span class="line">[<span class="keyword">strongObject </span>doSomething]<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="__autoreleasing_默认修饰符">__autoreleasing 默认修饰符</h4><p><code>id *obj</code>             &lt;==&gt;  <code>id __autoreleasing *obj</code><br><code>NSObject **obj</code>      &lt;==&gt;  <code>NSObject * __autoreleasing *obj</code><br>Any pointers to ‘id’ or object types are qualified with __autoreleasing as default.</p>
<h4 id="Returning_a_Result_as_the_Argument">Returning a Result as the Argument</h4><p>NSError作为参数, 返回结果时. 满足非通过alloc/new/copy/mutableCopy生成的对象, 不持有该对象原则.所以此对象需要自动注册到autoreleasepoool中, 来进行自动释放.<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>) performOperationWithError:(<span class="built_in">NSError</span> * __autoreleasing *)error &#123;</span><br><span class="line">  <span class="comment">/* Error occurred. Set errorCode */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NO</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>By assigning to <em>error, which is NSError </em> __autoreleasing * type, an object can be passed to its caller after being registered in autoreleasepool.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *error = <span class="literal">nil</span>;       <span class="comment">//strong</span></span><br><span class="line"><span class="built_in">NSError</span> **pError = &amp;error;  <span class="comment">//weak   编译报错,不能将strong对象 赋值给weak</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">NSError</span> * __<span class="keyword">strong</span> *pError = &amp;error;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSError</span> __<span class="keyword">weak</span> *error = <span class="literal">nil</span>; </span><br><span class="line"><span class="built_in">NSError</span> * __<span class="keyword">weak</span> *pError = &amp;error;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSError</span> __unsafe_unretained *unsafeError = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">NSError</span> * __unsafe_unretained *pUnsafeError = &amp;unsafeError;</span><br></pre></td></tr></table></figure>
<p>NSRunLoop has autoreleasepool to release all the objects once in each loop.<br><code>_objc_autoreleasePoolPrint();</code>打印注册的所有对象</p>
<h4 id="Rules">Rules</h4><ul>
<li>Forget about using retain, release, retainCount, and autorelease.</li>
<li>Forget about using NSAllocateObject and NSDeallocateObject.</li>
<li>Follow the naming rule for methods related to object creation. (alloc/new/copy/mutablecopy/init)</li>
<li>Forget about calling dealloc explicitly.</li>
<li>Use @autoreleasepool instead of NSAutoreleasePool.</li>
<li>Forget about using Zone (NSZone).</li>
<li>Object type variables can’t be members of struct or union in C language.</li>
<li>‘id’ and ‘void*’ have to be cast explicitly.</li>
</ul>
<p>in many cases, dealloc is a suitable place to remove the object from delegate or observers.<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (void) <span class="tag">dealloc</span> &#123;</span><br><span class="line">  <span class="comment">/*</span><br><span class="line">  - Write here to be disposed of properly.</span><br><span class="line">  */</span></span><br><span class="line">  <span class="attr_selector">[[NSNotificationCenter defaultCenter]</span> <span class="tag">removeObserver</span><span class="pseudo">:self</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ARC环境下不需显示调用<code>[super dealloc]</code>了.</p>
<h4 id="Object_Type_Variables_Cannot_Be_Members_of_struct_or_union_in_C_Language">Object Type Variables Cannot Be Members of struct or union in C Language</h4><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">  NSMutableArray *array;   <span class="comment">//error</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为ARC环境下, 编译器需要掌握对象的生命周期, 来进行内存管理,但是C结构体, 没有这些信息,没有被ARC所覆盖.可以通过<code>__unsafe_unretained</code>修饰符暂时停止该对象的ARC管理来解决<br><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">  NSMutableArray __unsafe_unretained *array; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="‘id’_and_‘void*’_Have_to_Be_Cast_Explicitly">‘id’ and ‘void*’ Have to Be Cast Explicitly</h4><h5 id="__bridge_cast">__bridge cast</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init]; </span><br><span class="line"><span class="keyword">void</span> *p = (__bridge <span class="keyword">void</span> *)obj;    <span class="comment">//more dangerous than an __unsafe_unretained, 需要手动管理内存</span></span><br><span class="line"><span class="keyword">id</span> o = (__bridge <span class="keyword">id</span>)p;</span><br></pre></td></tr></table></figure>
<h5 id="__bridge_retained_cast">__bridge_retained cast</h5><p>__bridge_retained cast works as if the assigned variable has ownership of the object.<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="keyword">void</span> *p = (__bridge_retained <span class="keyword">void</span> *)obj;</span><br></pre></td></tr></table></figure></p>
<p>__bridge_retained的名称是因为, (void *)为C语言实现,不再ARC的管理范围, 所以该次赋值, 需要将对象的计数器+1, 以实现转换后的变量, 对此对象的持有操作.</p>
<p>Non ARC<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="keyword">void</span> *p = obj; </span><br><span class="line">[(<span class="keyword">id</span>)p retain];</span><br></pre></td></tr></table></figure></p>
<p>在非ARC环境下, 变量在转换后, 需要执行retain操作.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p = <span class="number">0</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">  p = (__bridge_retained <span class="keyword">void</span> *)obj; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"class=%@"</span>, [(__bridge <span class="keyword">id</span>)p class]);</span><br></pre></td></tr></table></figure>
<p>obj在离开作用域后, 由于不再使用,自动调用release释放, 而此时由于p仍然持有对象, 所以对象没有被销毁.</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span> non-ARC <span class="keyword">*</span>/ void <span class="keyword">*</span>p = 0;</span><br><span class="line">&#123;</span><br><span class="line">  id obj = [[NSObject alloc] init];    /<span class="keyword">*</span> [obj retainCount] -&gt; 1 <span class="keyword">*</span>/</span><br><span class="line">  p = [obj retain];                    /<span class="keyword">*</span> [obj retainCount] -&gt; 2 <span class="keyword">*</span>/</span><br><span class="line">  [obj release];                       /<span class="keyword">*</span> [obj retainCount] -&gt; 1 <span class="keyword">*</span>/</span><br><span class="line">&#125;</span><br><span class="line">NSLog(<span class="comment">@"class=%@", [(__bridge id)p class]);</span></span><br></pre></td></tr></table></figure>
<h4 id="__bridge_transfer_cast">__bridge_transfer cast</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="property">id</span> obj = (__bridge_transfer <span class="property">id</span>)p;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* non-ARC */</span></span><br><span class="line"><span class="keyword">id</span> obj = (<span class="keyword">id</span>)p; </span><br><span class="line">[obj retain]; </span><br><span class="line">[(<span class="keyword">id</span>)p release];</span><br></pre></td></tr></table></figure>
<p>As <code>__bridge_retained</code> cast is replaced with <code>retain</code>, <code>__bridge_transfer</code> cast is replaced with <code>release</code>. </p>
<p>The variable obj is retained because it is qualified with __strong. With these two casts, you can create, own, and release any objects without using ‘id’ or object type variables. But it is not recommended</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p = (__bridge_retained <span class="keyword">void</span> *)[[<span class="built_in">NSObject</span> alloc] init]; </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"class=%@"</span>, [(__bridge <span class="keyword">id</span>)p class]); </span><br><span class="line">(<span class="keyword">void</span>)(__bridge_transfer <span class="keyword">id</span>)p;</span><br></pre></td></tr></table></figure>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* non-ARC */</span></span><br><span class="line"><span class="atom">id</span> <span class="atom">p</span> = [[<span class="name">NSObject</span> <span class="atom">alloc</span>] <span class="atom">init</span>];</span><br><span class="line"><span class="name">NSLog</span>(@<span class="string">"class=%@"</span>, [<span class="atom">p</span> <span class="atom">class</span>]);</span><br><span class="line">[<span class="atom">p</span> <span class="atom">release</span>];</span><br></pre></td></tr></table></figure>
<h4 id="CoreFoundation_Object_&amp;&amp;_Objective-C_Object">CoreFoundation Object &amp;&amp; Objective-C Object</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFTypeRef</span> <span class="built_in">CFBridgingRetain</span>(<span class="keyword">id</span> X) &#123;</span><br><span class="line">  <span class="keyword">return</span> (__bridge_retained <span class="built_in">CFTypeRef</span>)X; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">CFBridgingRelease</span>(<span class="built_in">CFTypeRef</span> X) &#123;</span><br><span class="line">  <span class="keyword">return</span> (__bridge_transfer <span class="keyword">id</span>)X; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CFBridgingRetain_function">CFBridgingRetain function</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFMutableArrayRef</span> cfObject = <span class="literal">NULL</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">id</span> obj = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">  cfObject = <span class="built_in">CFBridgingRetain</span>(obj);</span><br><span class="line">  <span class="built_in">CFShow</span>(cfObject);</span><br><span class="line">  printf(<span class="string">"retain count = %d\n"</span>, <span class="built_in">CFGetRetainCount</span>(cfObject));</span><br><span class="line">&#125;</span><br><span class="line">printf(<span class="string">"retain count after the scope = %d\n"</span>, <span class="built_in">CFGetRetainCount</span>(cfObject)); </span><br><span class="line"><span class="built_in">CFRelease</span>(cfObject);</span><br></pre></td></tr></table></figure>
<p>换成<code>__bridge</code>会造成空指针</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFMutableArrayRef</span> cfObject = <span class="literal">NULL</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">id</span> obj = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">  <span class="comment">/*variable obj has a strong reference to the object */</span></span><br><span class="line"></span><br><span class="line">  cfObject = (__bridge <span class="built_in">CFMutableArrayRef</span>)obj; </span><br><span class="line">  <span class="built_in">CFShow</span>(cfObject);</span><br><span class="line">  printf(<span class="string">"retain count = %d\n"</span>, <span class="built_in">CFGetRetainCount</span>(cfObject));</span><br><span class="line">  <span class="comment">/*</span><br><span class="line">   * __bridge cast does not touch ownership status.</span><br><span class="line">   * Reference count is one because of variable obj's strong reference.</span><br><span class="line">   */</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * Leaving the scope of variable obj, its strong reference disappears.</span><br><span class="line"> * The object is released automatically.</span><br><span class="line"> * Because no one has ownership, the object is discarded. </span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* From here, any access to the object is invalid! (dangling pointer) */</span></span><br><span class="line">printf(<span class="string">"retain count after the scope = %d\n"</span>, <span class="built_in">CFGetRetainCount</span>(cfObject)); </span><br><span class="line"><span class="built_in">CFRelease</span>(cfObject);</span><br></pre></td></tr></table></figure>
<h4 id="CFBridgingRelease_function">CFBridgingRelease function</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  CFMutableArrayRef cfObject =</span><br><span class="line">      CFArrayCreateMutable(kCFAllocatorDefault, <span class="number">0</span>, NULL);</span><br><span class="line">  printf(<span class="string">"retain count = %d\n"</span>, CFGetRetainCount(cfObject));</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">   * The object <span class="keyword">is</span> created <span class="keyword">with</span> ownership <span class="keyword">by</span> Core Foundation Framework API. </span><br><span class="line">   * The retain <span class="command">count</span> <span class="keyword">is</span> one.</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">  <span class="property">id</span> obj = CFBridgingRelease(cfObject);</span><br><span class="line">  /*</span><br><span class="line">  * By assignment <span class="keyword">after</span> CFBridgingRelease,</span><br><span class="line">  * variable obj has a strong <span class="keyword">reference</span> <span class="keyword">and</span> <span class="keyword">then</span> * <span class="keyword">the</span> object <span class="keyword">is</span> released <span class="keyword">by</span> CFRelease.</span><br><span class="line">  */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  printf(<span class="string">"retain count after the cast = %d\n"</span>, CFGetRetainCount(cfObject));</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">  * Only <span class="keyword">the</span> variable obj has a strong <span class="keyword">reference</span> <span class="keyword">to</span></span><br><span class="line">  * <span class="keyword">the</span> object, so <span class="keyword">the</span> retain <span class="command">count</span> <span class="keyword">is</span> one. *</span><br><span class="line">  * And, <span class="keyword">after</span> being cast <span class="keyword">by</span> CFBridgingRelease,</span><br><span class="line">  * pointer stored <span class="keyword">in</span> variable cfObject <span class="keyword">is</span> still valid. </span><br><span class="line">  */</span><br><span class="line"></span><br><span class="line">  NSLog(@<span class="string">"class=%@"</span>, obj);</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">* Leaving <span class="keyword">the</span> scope <span class="keyword">of</span> variable obj, <span class="keyword">its</span> strong <span class="keyword">reference</span> disappears.</span><br><span class="line">* The object <span class="keyword">is</span> released automatically.</span><br><span class="line">* Because no one has ownership, <span class="keyword">the</span> object <span class="keyword">is</span> discarded. </span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>如果换成<code>__bridge</code>会造成内存泄露</p>
<h4 id="Property">Property</h4><table>
<thead>
<tr>
<th>Property modifier</th>
<th>Ownership qualifier</th>
</tr>
</thead>
<tbody>
<tr>
<td>assign</td>
<td>__unsafe_unretained</td>
</tr>
<tr>
<td>copy</td>
<td>__strong (note: new copied object is assigned.)</td>
</tr>
<tr>
<td>retain</td>
<td>__strong</td>
</tr>
<tr>
<td>strong</td>
<td>__strong</td>
</tr>
<tr>
<td>unsafe_unretained</td>
<td>__unsafe_unretained</td>
</tr>
<tr>
<td>weak</td>
<td>__weak</td>
</tr>
</tbody>
</table>
<h4 id="Array">Array</h4><p>By the way, any variables qualified with <strong>strong, </strong>weak, or <strong>autoreleasing other than </strong>unsafe_unretained, are initialized with nil.<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">&#123;</span><br><span class="line">  id objs<span class="collection">[<span class="number">2</span>]</span><span class="comment">;</span></span><br><span class="line">  objs<span class="collection">[<span class="number">0</span>]</span> = <span class="collection">[<span class="collection">[NSObject alloc]</span> init]</span><span class="comment">;</span></span><br><span class="line">  objs<span class="collection">[<span class="number">1</span>]</span> = <span class="collection">[NSMutableArray array]</span><span class="comment">; </span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>When the control flow leaves the scope of the array, all the variables that have strong references in the array disappear. The assigned objects are released automatically. It is identical to variables not in arrays</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSObject * __strong *array = nil;<span class="instruction"></span><br><span class="line">array </span>=<span class="function"> (</span>id __strong<span class="function"> *)calloc(</span>entries,<span class="function"> sizeof(</span>id<span class="function">)</span><span class="function">)</span>;</span><br><span class="line"></span><br><span class="line">//or<span class="instruction"></span><br><span class="line">array </span>=<span class="function"> (</span>id __strong<span class="function"> *)malloc(</span>entries *<span class="function"> sizeof(</span>id<span class="function">)</span><span class="function">)</span>; </span><br><span class="line">memset(array, 0, entries *<span class="function"> sizeof(</span>id<span class="function">)</span><span class="function">)</span>;</span><br></pre></td></tr></table></figure>
<p>C语音创建的数组需要手动释放<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (NSUInteger i = <span class="number">0</span>; i &lt; entries; ++i)&#123;</span><br><span class="line">  <span class="built_in">array</span>[i] = nil; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(<span class="built_in">array</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="ARC_Implementation">ARC Implementation</h3><blockquote>
<p>Automatic Reference Counting (ARC) in Objective-C makes memory management the job of the compiler</p>
</blockquote>
<p>but the truth is, ARC isn’t the only job of the compiler. The objective-C runtime needs to help as well</p>
<h4 id="__strong_ownership_qualifier">__strong ownership qualifier</h4><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">&#123;</span><br><span class="line">  id __strong obj = <span class="collection">[<span class="collection">[NSObject alloc]</span> init]</span><span class="comment">;</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>pseudo code by the compiler<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id obj = objc_msgSend<span class="list">(<span class="keyword">NSObject</span>, @selector<span class="list">(<span class="keyword">alloc</span>)</span>)</span><span class="comment">; </span></span><br><span class="line">objc_msgSend<span class="list">(<span class="keyword">obj</span>, @selector<span class="list">(<span class="keyword">init</span>)</span>)</span><span class="comment">; </span></span><br><span class="line">objc_release<span class="list">(<span class="keyword">obj</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Calling_the_array_method">Calling the array method</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">id</span> __<span class="keyword">strong</span> obj = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pseudo code by the compiler<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id obj = objc_msgSend<span class="list">(<span class="keyword">NSMutableArray</span>, @selector<span class="list">(<span class="keyword">array</span>)</span>)</span><span class="comment">; objc_retainAutoreleasedReturnValue(obj); </span></span><br><span class="line">objc_release<span class="list">(<span class="keyword">obj</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p><code>objc_retainAutoreleasedReturnValue</code> function is for performance optimization. It is inserted because the NSMutableArray class method array is not in the alloc/new/copy/mutableCopy method group. The compiler inserts this function every time just after the invocation of a method if the method is not in the group. As the name suggests, it retains an object returned from a method or function <strong><em>after the object is added in autorelease pool</em></strong>.</p>
<h4 id="Inside_the_array_Method">Inside the array Method</h4><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+<span class="function"> (</span>id<span class="function">)</span><span class="instruction"> array </span>&#123;</span><br><span class="line"> <span class="instruction"> return </span><span class="keyword">[</span><span class="keyword">[</span>NSMutableArray alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pseudo code<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+<span class="function"> (</span>id<span class="function">)</span><span class="instruction"> array </span>&#123;</span><br><span class="line">  id obj =<span class="function"> objc_msgSend(</span>NSMutableArray,<span class="function"> @selector(</span>alloc<span class="function">)</span><span class="function">)</span>; </span><br><span class="line"> <span class="function"> objc_msgSend(</span>obj,<span class="function"> @selector(</span>init<span class="function">)</span><span class="function">)</span>;</span><br><span class="line"> <span class="instruction"> return </span>objc_autoreleaseReturnValue(obj<span class="function">)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>in reality, <code>objc_autoreleaseReturnValue</code> doesn’t register it to autorelease pool all the time. 如果之前的代码已经调用了<code>objc_retainAutoreleasedReturnValue</code>,该函数将不再调用,因为此对象已经注册到pool中.</p>
<h4 id="__weak_ownership_qualifier-1">__weak ownership qualifier</h4><p>weak特性:</p>
<ul>
<li><strong>Nil</strong> is assigned to any variables qualified with __weak when referencing object is discarded.</li>
<li>When an object is accessed through a <strong>__weak</strong> qualified variable, the object is <strong><em>added to the autorelease pool</em></strong>.</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> obj1 = obj; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pseudo code<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id obj1<span class="comment">;</span></span><br><span class="line">objc_initWeak<span class="list">(<span class="keyword">&amp;obj1</span>, obj)</span><span class="comment">; </span></span><br><span class="line">objc_destroyWeak<span class="list">(<span class="keyword">&amp;obj1</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p><code>objc_initWeak</code> 实现</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj1 = 0<span class="comment">; </span></span><br><span class="line">objc_storeWeak(&amp;obj1, obj)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><code>objc_destroyWeak</code></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id obj1<span class="comment">;</span></span><br><span class="line">obj1 = 0<span class="comment">;</span></span><br><span class="line">objc_storeWeak(&amp;obj1, obj)<span class="comment">; </span></span><br><span class="line">objc_storeWeak(&amp;obj1, 0)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>objc_storeWeak function registers a <code>key-value</code> to a <code>table</code>, called a <code>weak table</code>. The key is the second argument, the address of the object to be assigned. The value is the first argument, the address of a variable that qualified with __weak. <strong>If the second argument is zero, the entry is removed from the table.</strong></p>
<p>The weak table is implemented as a hash table as a reference count table (see Chapter 1, Section “The Implementation by Apple”). With that, variables qualified with <strong>weak can be searched from a disposing object with reasonable performance. When the function is called with the same object for key, multiple </strong>weak qualified variables will be registered for the same object.</p>
<h4 id="Looking_Under_the_Hood_When_an_Object_Is_Discarded_对象销毁">Looking Under the Hood When an Object Is Discarded 对象销毁</h4><p>对象销毁流程</p>
<ol>
<li>objc_release.</li>
<li>dealloc is called because retain count becomes zero</li>
<li>_objc_rootDealloc</li>
<li>object_dispose</li>
<li>objc_destructInstance</li>
<li>objc_clear_deallocating</li>
</ol>
<p>objc_clear_deallocating 作用</p>
<ol>
<li>From the weak table, get an entry of which the key is the object to be discarded.</li>
<li>Set nil to all the __weak ownership qualified variables in the entry</li>
<li>Remove the entry from the table</li>
<li>For the object to be disposed of, remove its key from the reference table</li>
</ol>
<h4 id="Assigning_a_Newly_Created_Object">Assigning a Newly Created Object</h4><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">&#123;</span><br><span class="line">  id __weak obj = <span class="collection">[<span class="collection">[NSObject alloc]</span> init]</span><span class="comment">;</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>pseudo code<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">id obj<span class="comment">;</span></span><br><span class="line">id tmp = objc_msgSend<span class="list">(<span class="keyword">NSObject</span>, @selector<span class="list">(<span class="keyword">alloc</span>)</span>)</span><span class="comment">; </span></span><br><span class="line">objc_msgSend<span class="list">(<span class="keyword">tmp</span>, @selector<span class="list">(<span class="keyword">init</span>)</span>)</span><span class="comment">; </span></span><br><span class="line">objc_initWeak<span class="list">(<span class="keyword">&amp;obj</span>, tmp)</span><span class="comment">;</span></span><br><span class="line">objc_release<span class="list">(<span class="keyword">tmp</span>)</span><span class="comment">;</span></span><br><span class="line">objc_destroyWeak<span class="list">(<span class="keyword">&amp;object</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Immediate_Disposal_of_Objects">Immediate Disposal of Objects</h4><p>声明后马上释放的对象, 不影响方法的调用<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">void</span>)</span><span class="collection">[<span class="collection">[<span class="collection">[NSObject alloc]</span> init]</span> hash]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id tmp = objc_msgSend<span class="list">(<span class="keyword">NSObject</span>, @selector<span class="list">(<span class="keyword">alloc</span>)</span>)</span><span class="comment">; </span></span><br><span class="line">objc_msgSend<span class="list">(<span class="keyword">tmp</span>, @selector<span class="list">(<span class="keyword">init</span>)</span>)</span><span class="comment">; </span></span><br><span class="line">objc_msgSend<span class="list">(<span class="keyword">tmp</span>, @selector<span class="list">(<span class="keyword">hash</span>)</span>)</span><span class="comment">; </span></span><br><span class="line">objc_release<span class="list">(<span class="keyword">tmp</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h4 id="Adding_to_autorelease_pool_Automatically">Adding to autorelease pool Automatically</h4><p>when an object is accessed through a __weak qualified variable, the object has been added to the autorelease pool.<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">id</span> __<span class="keyword">weak</span> obj1 = obj;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, obj1); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>pseudo code by the compiler<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">id obj1<span class="comment">;</span></span><br><span class="line">objc_initWeak<span class="list">(<span class="keyword">&amp;obj1</span>, obj)</span><span class="comment">;</span></span><br><span class="line">id tmp = objc_loadWeakRetained<span class="list">(<span class="keyword">&amp;obj1</span>)</span><span class="comment">; </span></span><br><span class="line">objc_autorelease<span class="list">(<span class="keyword">tmp</span>)</span><span class="comment">;</span></span><br><span class="line">NSLog<span class="list">(@<span class="string">"%@"</span>, tmp)</span><span class="comment">; </span></span><br><span class="line">objc_destroyWeak<span class="list">(<span class="keyword">&amp;obj1</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p><code>objc_loadWeakRetained</code> and <code>objc_autorelease</code> function calls are newly inserted.</p>
<ul>
<li>objc_loadWeakRetained function retains the object referenced by the variable qualified with __weak</li>
<li>objc_autorelease function adds the object to the autorelease pool.<br>(自我猜测) </li>
</ul>
<ol>
<li>weak只是一个标示, 不能针对weak的变量直接进行方法调用</li>
<li>基于线程安全的考虑, 在weak变量在调用方法时, 先将对象retain, 以保证对象不被其他线程释放.</li>
</ol>
<h4 id="weak变量使用优化">weak变量使用优化</h4><p><strong><em>由于weak对象每次调用都需要注册到autoreleasepool中, 如果此类变量太多会加重pool的负担, 所以在使用时,应将weak变量, 重新赋值到一个strong变量中来操作</em></strong><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> o = obj; </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"1 %@"</span>, o); </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"2 %@"</span>, o);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"3 %@"</span>, o); </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"4 %@"</span>, o); </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"5 %@"</span>, o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="不支持weak的情况">不支持weak的情况</h4><p>第一种旧系统不支持, 第二种情况某些类由于重写了retain/release, 并拥有独立的引用计数机制.这些类有<code>objc_arc_weak_reference_unavailable</code>标示.</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- <span class="list">(<span class="keyword">BOOL</span>)</span>allowsWeakReference<span class="comment">; </span></span><br><span class="line">- <span class="list">(<span class="keyword">BOOL</span>)</span>retainWeakReference<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyObject</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">  <span class="built_in">NSUInteger</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyObject</span> - (<span class="title">id</span>)<span class="title">init</span> </span>&#123;</span><br><span class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">BOOL</span>)retainWeakReference &#123;</span><br><span class="line">    <span class="keyword">if</span> (++count &gt; <span class="number">3</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> retainWeakReference];</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj = [[MyObject alloc] init];</span><br><span class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> o = obj;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"1 %@"</span>, o);   <span class="comment">// &lt;MyObject: 0x753e180&gt;</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"2 %@"</span>, o);   <span class="comment">// &lt;MyObject: 0x753e180&gt;</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"3 %@"</span>, o);   <span class="comment">// &lt;MyObject: 0x753e180&gt;</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"4 %@"</span>, o);   <span class="comment">// (null)</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"5 %@"</span>, o);   <span class="comment">// (null)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="__autoreleasing_ownership_qualifier-1">__autoreleasing ownership qualifier</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"><span class="keyword">id</span> __autoreleasing obj = [[<span class="built_in">NSObject</span> alloc] init]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* pseudo code by the compiler */</span><br><span class="line">id pool = objc_autoreleasePoolPush<span class="list">()</span><span class="comment">;</span></span><br><span class="line">id obj = objc_msgSend<span class="list">(<span class="keyword">NSObject</span>, @selector<span class="list">(<span class="keyword">alloc</span>)</span>)</span><span class="comment">; </span></span><br><span class="line">objc_msgSend<span class="list">(<span class="keyword">obj</span>, @selector<span class="list">(<span class="keyword">init</span>)</span>)</span><span class="comment">; </span></span><br><span class="line">objc_autorelease<span class="list">(<span class="keyword">obj</span>)</span><span class="comment">; </span></span><br><span class="line">objc_autoreleasePoolPop<span class="list">(<span class="keyword">pool</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>非持有变量<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">  <span class="keyword">id</span> __autoreleasing obj = [<span class="built_in">NSMutableArray</span> array]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* pseudo code by the compiler */</span><br><span class="line">id pool = objc_autoreleasePoolPush<span class="list">()</span><span class="comment">;</span></span><br><span class="line">id obj = objc_msgSend<span class="list">(<span class="keyword">NSMutableArray</span>, @selector<span class="list">(<span class="keyword">array</span>)</span>)</span><span class="comment">; objc_retainAutoreleasedReturnValue(obj); </span></span><br><span class="line">objc_autorelease<span class="list">(<span class="keyword">obj</span>)</span><span class="comment">;</span></span><br><span class="line">objc_autoreleasePoolPop<span class="list">(<span class="keyword">pool</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h4 id="__unsafe_unretained_ownership_qualifier-1">__unsafe_unretained ownership qualifier</h4><p> Unlike the other ownership qualifiers, the compiler does nothing special for the qualifier. It just works as an assignment in C language. ARC不对其进行操作优化.</p>
<h4 id="Reference_Count">Reference Count</h4><p>可以通过<code>_objc_rootRetainCount</code> 来获取当前计数<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">&#123;</span><br><span class="line">id __strong obj = <span class="collection">[<span class="collection">[NSObject alloc]</span> init]</span><span class="comment">;</span></span><br><span class="line">NSLog<span class="list">(@<span class="string">"retain count = %d"</span>, _objc_rootRetainCount<span class="list">(<span class="keyword">obj</span>)</span>)</span><span class="comment">; </span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> o = obj;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"retain count = %d"</span>, _objc_rootRetainCount(obj));  <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">  <span class="keyword">id</span> __<span class="keyword">strong</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">  <span class="keyword">id</span> __autoreleasing o = obj;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"retain count = %d"</span>, _objc_rootRetainCount(obj));  <span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">&#123;</span><br><span class="line">id __strong obj = <span class="collection">[<span class="collection">[NSObject alloc]</span> init]</span><span class="comment">; </span></span><br><span class="line">@autoreleasepool <span class="collection">&#123;</span><br><span class="line">  id __autoreleasing o = obj;</span><br><span class="line">  NSLog<span class="list">(@<span class="string">"retain count = %d in @autoreleasepool"</span>, _objc_rootRetainCount<span class="list">(<span class="keyword">obj</span>)</span>)</span><span class="comment">; //2</span></span><br><span class="line">&#125;</span></span><br><span class="line">  NSLog<span class="list">(@<span class="string">"retain count = %d"</span>, _objc_rootRetainCount<span class="list">(<span class="keyword">obj</span>)</span>)</span><span class="comment">; //1</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">_objc_autoreleasePoolPrint();</span><br><span class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> o = obj;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"before using __weak: retain count = %d"</span>, _objc_rootRetainCount(obj)); <span class="built_in">NSLog</span>(<span class="string">@"class = %@"</span>, [o class]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"after using __weak: retain count = %d"</span>, _objc_rootRetainCount(obj)); _objc_autoreleasePoolPrint();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[ios 内存管理, 以及实现详解]]>
    
    </summary>
    
      <category term="mrc arc" scheme="http://ytlvy.com/tags/mrc-arc/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ios gcd]]></title>
    <link href="http://ytlvy.com/2015/06/15/ios-gcd/"/>
    <id>http://ytlvy.com/2015/06/15/ios-gcd/</id>
    <published>2015-06-15T12:05:01.000Z</published>
    <updated>2015-06-15T12:05:17.000Z</updated>
    <content type="html"><![CDATA[<h2 id="GCD">GCD</h2><h3 id="befor_GCD">befor GCD</h3><h4 id="object_method">object method</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="typename">void</span>) <span class="string">performSelectorInBackground:</span> <span class="string">withObject:</span></span><br><span class="line">- (<span class="typename">void</span>) <span class="string">performSelectorOnMainThread:</span> <span class="string">withObject:</span> <span class="string">waitUntilDone:</span></span><br></pre></td></tr></table></figure>
<h3 id="多线程面临的问题">多线程面临的问题</h3><ol>
<li>race condition</li>
<li>dead lock</li>
<li>too much threads consumes two much memory</li>
</ol>
<h4 id="多线程的意义">多线程的意义</h4><p>高交互性， 界面编程中，将耗时的操作放入到其他线程执行，避免影响到主线程界面响应</p>
<h3 id="GCD_基础">GCD 基础</h3><h4 id="Dispatch_Queue_派发队列">Dispatch Queue 派发队列</h4><ol>
<li>serial dispath queue  顺序派发队列</li>
<li>concurrent dispath queue  并发派发队列</li>
</ol>
<p>和浏览器对同一域名可发起的同时连接数限制一样，可最多同时执行的线程数，也是由系统来决定的</p>
<h4 id="创建队列">创建队列</h4><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dispath_queue_t mySerialDispatchQueue = dispatch_queue_create<span class="list">(<span class="string">"com.example.gcd.MySerialDispatchQueue"</span>, NULL)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_queue_t myConcurrentDispathQueue = dispatch_queue_create<span class="list">(<span class="string">"com.ytlvy.gcd.MyConcurrentDispatchQueue"</span>, DISPATCH_QUEUE_CONCURRENT)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_async<span class="list">(<span class="keyword">myConcurrentQueue</span>, ^&#123;</span><br><span class="line">  //do staff</span><br><span class="line">  &#125;)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_release<span class="list">(<span class="keyword">mySerialDispatchQueue</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_retain<span class="list">(<span class="keyword">myConcurrentDispatchQueue</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>当并发队列添加任务后，队列被release，是没有问题的。因为block在添加到队列时，会触发dispatch_retain操作来持有队列，在block结束时，会自动触发dispatch_release来释放队列</p>
<h4 id="Main_Dispatch_Queue_/_Global_Dispatch_Queue">Main Dispatch Queue / Global Dispatch Queue</h4><p>可以采用系统方法来获取派发队列。<br> NAME                              | Type        | Description<br> ————————————          | ——————| ————————<br> Main dispatch queue               | Serial      | Executed on the main thread<br> Global dispatch queue(Hight)      | Concurrent  | Priority High<br> Global dispatch queue(default)    | Concurrent  | Priority Normal<br> Global dispatch queue(low)        | Concurrent  | Priority Low<br> Global dispatch queue(background) | Concurrent  | Priority Background</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t mainDispatchQueue = dispatch_get_main_queue<span class="list">()</span><span class="comment">;</span></span><br><span class="line">dispatch_queue_t globalDispatchQueueHight = </span><br><span class="line">    dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_HIGH</span>, <span class="number">0</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_queue_t globalDispatchQueueDefault =</span><br><span class="line">    dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_queue_t globalDispatchQueueLow = </span><br><span class="line">    dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_LOW</span>, <span class="number">0</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_queue_t globalDispatchQueueBackground = </span><br><span class="line">    dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_BACKGROUND</span>, <span class="number">0</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>dispatch_retain dispatch_release对系统分配的队列不生效。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">dispatch_async</span>(<span class="function">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>) ^&#123;</span><br><span class="line">   <span class="comment">//do staff</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">dispatch_async</span>(dispatch_get_main_queue, ^&#123;</span><br><span class="line">    <span class="comment">// update gui</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Controlling_Dispatch_Queue">Controlling Dispatch Queue</h4><p><code>dispatch_set_target_queue</code>设置队列优先级</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t mySerialDispatchQueue = </span><br><span class="line">    dispatch_create<span class="list">(<span class="string">"com.ytlvy.gcd.MySerialDispatchQueue"</span>, NULL)</span><span class="comment">;</span></span><br><span class="line">dispatch_queue_t globalDispatchQueueBackGround = </span><br><span class="line">    dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_BACKGROUND</span>, <span class="number">0</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_set_target_queue<span class="list">(<span class="keyword">mySerialDispatchQueue</span>, globalDispatchQueueBackground)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h4 id="dispatch_after">dispatch_after</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_time_t</span> time = <span class="keyword">dispatch_t</span>ime(DISPATCH_TIME_NOW, <span class="number">3u</span>ll * NSEC_PER_SEC);</span><br><span class="line"></span><br><span class="line">dispatch_after(time, dispatch_get_main_queue(), ^&#123;</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>“ull” is for “unsigned long long type”</p>
<p>毫秒<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_time_t</span> time = <span class="keyword">dispatch_t</span>ime(DISPATCH_TIME_NOW, <span class="number">1u</span>ll * NSEC_PER_MSEC);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dispatch_time_t getDispatchTimeByDate(NSDate *<span class="type">date</span>)&#123;</span><br><span class="line">  NSTimeInterval interval;</span><br><span class="line">  double <span class="keyword">second</span>, subsecond;</span><br><span class="line">  struct timespec, <span class="property">time</span>;</span><br><span class="line">  dispatch_time_t milestone;</span><br><span class="line"></span><br><span class="line">  interval = [<span class="type">date</span> timeIntervalSince1970];</span><br><span class="line">  subsecond = modf(interval, &amp;<span class="keyword">second</span>);</span><br><span class="line">  <span class="property">time</span>.tv_sec = <span class="keyword">second</span>;</span><br><span class="line">  <span class="property">time</span>.tv_nsec = subsecond * NSEC_PER_SEC;</span><br><span class="line">  milestone = dispatch_wailltime(&amp;<span class="property">time</span>, <span class="number">0</span>);</span><br><span class="line"><span class="command"></span><br><span class="line">  return</span> milstone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，dispatch第二个参数，应该使用<code>ull</code> 或者 <code>double</code>类型<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SDate <span class="built_in">*</span>start = [NSDate date];</span><br><span class="line">dispatch_time_t popTime = dispatch_time<span class="params">(DISPATCH_TIME_NOW, <span class="number">4</span> * NSEC_PER_SEC)</span>;</span><br><span class="line"></span><br><span class="line">dispatch_after<span class="params">(popTime, dispatch_get_main_queue<span class="params">()</span>, ^&#123;</span><br><span class="line">  NSLog<span class="params">(@<span class="string">"seconds: %f"</span>, [start timeIntervalSinceNow])</span>;</span><br><span class="line">&#125;)</span>;</span><br><span class="line"><span class="comment">// output: seconds: -0.0001</span></span><br><span class="line"></span><br><span class="line">NSDate <span class="built_in">*</span>start = [NSDate date];</span><br><span class="line">dispatch_time_t popTime = dispatch_time<span class="params">(DISPATCH_TIME_NOW, <span class="number">4.0</span> * NSEC_PER_SEC)</span>;</span><br><span class="line"></span><br><span class="line">dispatch_after<span class="params">(popTime, dispatch_get_main_queue<span class="params">()</span>, ^&#123;</span><br><span class="line">  NSLog<span class="params">(@<span class="string">"seconds: %f"</span>, [start timeIntervalSinceNow])</span>;</span><br><span class="line">&#125;)</span>;</span><br><span class="line"><span class="comment">// output: seconds: -4.0001</span></span><br></pre></td></tr></table></figure></p>
<h4 id="dispatch_group">dispatch group</h4><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = </span><br><span class="line">    dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_t group = dispatch_group_create<span class="list">()</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123; NSLog<span class="list">(@<span class="string">"blk0"</span>)</span><span class="comment">; &#125;);</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123; NSLog<span class="list">(@<span class="string">"blk1"</span>)</span><span class="comment">; &#125;);</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123; NSLog<span class="list">(@<span class="string">"blk2"</span>)</span><span class="comment">; &#125;);</span></span><br><span class="line"></span><br><span class="line">dispatch_group_notify<span class="list">(<span class="keyword">group</span>, dispatch_get_main_queue<span class="list">()</span>, ^&#123; NSLog<span class="list">(@<span class="string">"done"</span>)</span><span class="comment">; &#125;);</span></span><br><span class="line">dispatch_release<span class="list">(<span class="keyword">group</span>)</span><span class="comment">;</span></span></span></span></span></span><br></pre></td></tr></table></figure>
<p>等所有任务结束，使用派发队列组。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = </span><br><span class="line">    dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_t group = dispatch_group_create<span class="list">()</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;NSLog<span class="list">(@<span class="string">"blk0"</span>)</span><span class="comment">; &#125;);</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;NSLog<span class="list">(@<span class="string">"blk1"</span>)</span><span class="comment">; &#125;);</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;NSLog<span class="list">(@<span class="string">"blk2"</span>)</span><span class="comment">; &#125;);</span></span><br><span class="line"></span><br><span class="line">dispatch_group_wait<span class="list">(<span class="keyword">group</span>, DISPATCH_TIME_FOREVER)</span><span class="comment">;</span></span><br><span class="line">dispatch_release<span class="list">(<span class="keyword">group</span>)</span><span class="comment">;</span></span></span></span></span><br></pre></td></tr></table></figure></p>
<p>等待1秒<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dispatch_time_t time = dispatch_time(<span class="type">DISPATCH_TIME_NOW</span>, <span class="number">1</span>ull * <span class="type">NSEC_PER_SEC</span>);</span><br><span class="line">long <span class="literal">result</span> = dispatch_group_wait(group, time);</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">result</span> == <span class="number">0</span>)&#123;</span><br><span class="line">  //finished</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  //some task still running</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>检测任务是否完成<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long <span class="literal">result</span> = dispatch_group_wait(group, <span class="type">DISPATCH_TIME_NOW</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="dispatch_barrier_async">dispatch_barrier_async</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create<span class="list">(</span><br><span class="line">      <span class="string">"com.example.gcd.ForBarrier"</span>, DISPATCH_QUEUE_CONCURRENT)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_async<span class="list">(<span class="keyword">queue</span>, blk0_for_reading)</span><span class="comment">;</span></span><br><span class="line">dispatch_async<span class="list">(<span class="keyword">queue</span>, blk1_for_reading)</span><span class="comment">;</span></span><br><span class="line">dispatch_async<span class="list">(<span class="keyword">queue</span>, blk2_for_reading)</span><span class="comment">;</span></span><br><span class="line">dispatch_async<span class="list">(<span class="keyword">queue</span>, blk3_for_reading)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_barrier_async<span class="list">(<span class="keyword">queue</span>, blk_for_writing)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_async<span class="list">(<span class="keyword">queue</span>, blk4_for_reading)</span><span class="comment">;</span></span><br><span class="line">dispatch_async<span class="list">(<span class="keyword">queue</span>, blk5_for_reading)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_release<span class="list">(<span class="keyword">queue</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h3 id="dispatch_sync">dispatch_sync</h3><p>dead lock<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_main_queue<span class="list">()</span><span class="comment">;</span></span><br><span class="line">dispatch_sync<span class="list">(<span class="keyword">queue</span>, ^&#123;&#125;)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">//dead lock</span><br><span class="line">dispatch_async<span class="list">(<span class="keyword">queue</span>, ^&#123;</span><br><span class="line">  dispatch_sync<span class="list">(<span class="keyword">queue</span>, ^&#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><span class="comment">;</span></span><br><span class="line">  &#125;)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">//serial queue  dead lock</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create<span class="list">(<span class="string">"com.example"</span>, NULL)</span><span class="comment">;</span></span><br><span class="line">dispatch_async<span class="list">(<span class="keyword">queue</span>, ^&#123;</span><br><span class="line">  dispatch_sync<span class="list">(<span class="keyword">queue</span>, ^&#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><span class="comment">;</span></span><br><span class="line">  &#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="dispatch_apply">dispatch_apply</h4><p>与 <code>dispatch_sync</code> 和<code>dispatch_group</code>相关，可以多次添加同一任务, 并等待任务结束</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue =</span><br><span class="line">    dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_apply<span class="list">(<span class="number">10</span>, queue, ^<span class="list">(<span class="keyword">size_t</span> index)</span>&#123;</span><br><span class="line">  NSLog<span class="list">(<span class="string">"%zu"</span>, index)</span><span class="comment">;</span></span><br><span class="line">  &#125;)</span><span class="comment">;</span></span><br><span class="line">NSLog<span class="list">(@<span class="string">"done"</span>)</span><span class="comment">; //last output</span></span><br></pre></td></tr></table></figure>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = </span><br><span class="line">    dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_async<span class="list">(<span class="keyword">queue</span>, ^&#123;</span><br><span class="line"></span><br><span class="line">  dispatch_apply<span class="list">([array count], queue, ^<span class="list">(<span class="keyword">size_t</span> idx)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  //all tasks by dispatch_apply are finished</span><br><span class="line"></span><br><span class="line">  dispatch_async<span class="list">(<span class="keyword">dispatch_get_main_queue</span><span class="list">()</span>, ^&#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  &#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h4 id="dispatch_suspend_&amp;&amp;_dispatch_resume">dispatch_suspend &amp;&amp; dispatch_resume</h4><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dispatch_suspend<span class="list">(<span class="keyword">queue</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_resume<span class="list">(<span class="keyword">queue</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h4 id="dispatch_semaphore">dispatch semaphore</h4><p>NSMutableArray 是非线程安全的，当多个线程同时更改操作会导致程序崩溃.semaphore是一个更小粒度的多线程控制方法, 通过内部计数来控制线程的准入方式.<br>semaphore拥有一个内部计数器来模拟标志, 当计数器为0, 线程等待; 非0时,继续执行.<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create<span class="list">(<span class="number">1</span>)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_remaphore_wait<span class="list">(<span class="keyword">semaphore</span>, DISPATCH_TIME_FOREVER)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dispatch_time_t time = dispatch_time(<span class="type">DISPATCH_TIME_NOW</span>, <span class="number">1</span>ull * <span class="type">NSEC_PER_SEC</span>);</span><br><span class="line">long <span class="literal">result</span> = dispatch_semaphore_wait(semaphore, time);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">result</span> == <span class="number">0</span>)&#123;</span><br><span class="line">  //<span class="keyword">do</span> staff, execute a task</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  //wait </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当dispatch_semaphore_wait 返回0时, 可以安全执行一个有并发控制的任务. 当任务执行完毕, 需要调用dispatch_semaphore_signal 增加计数</p>
<p>Adding data to NSMutableArray<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = </span><br><span class="line">    dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">dispatch_semaphore_t</span> semaphore = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">NSMutableArray *arr = [NSMutableArray <span class="keyword">new</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; <span class="number">100000</span>; i++)&#123;</span><br><span class="line">  dispatch_async(<span class="built_in">queue</span>, ^&#123;</span><br><span class="line">      dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span><br><span class="line">       *  因为semaphore的计数大于1. 在disaptch_semaphore_wait返回后,</span><br><span class="line">       *  计数器被设置为0. 因为只有一个线程可以获准进入,所以此时更新</span><br><span class="line">       *  NSMutableArray是安全的.</span><br><span class="line">       */</span></span><br><span class="line">      [arr addObject:@(i)];</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span><br><span class="line">       * 需要并发控制的任务结束后, 需要调用signal来增加semaphore的计数器,</span><br><span class="line">       * 以便其他等待的线程可以通过dispatch_semaphore_wait, 获得执行权限</span><br><span class="line">       */</span></span><br><span class="line">      dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_release(semaphore);</span><br></pre></td></tr></table></figure></p>
<h4 id="dispatch_once">dispatch_once</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> pred;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;pred, ^&#123;</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Dispatch_I/O">Dispatch I/O</h3><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t pipe_q =</span><br><span class="line">    dispatch_queue_create<span class="params">(<span class="string">"PipeQ"</span>, NULL)</span>;</span><br><span class="line">pipe_channel = dispatch_io_create<span class="params">(DISPATCH_IO_STREAM, fd, pipe_q, ^<span class="params">(int err)</span>&#123;</span><br><span class="line">  close<span class="params">(fd)</span>;</span><br><span class="line">  &#125;)</span>;</span><br><span class="line"></span><br><span class="line">  out_fd = fdpair[<span class="number">1</span>];</span><br><span class="line">  dispatch_io_set_low_water<span class="params">(pipe_channel, SIZE_MAX)</span>;</span><br><span class="line">  dispatch_io_read<span class="params">(pipe_channel, <span class="number">0</span>, SIZE_MAX, pipe_q, </span><br><span class="line">    ^<span class="params">(bool done, dispatch_data_t pipedata, int error)</span>&#123;</span><br><span class="line">      if<span class="params">(error == <span class="number">0</span>)</span>&#123;</span><br><span class="line">          size_t len = dispatch_data_get_size<span class="params">(pipedata)</span>;</span><br><span class="line">          if<span class="params">(len &gt; <span class="number">0</span>)</span>&#123;</span><br><span class="line">            const char *bytes = NULL;</span><br><span class="line">            char *encode;</span><br><span class="line"></span><br><span class="line">            dispatch_data_t md = dispatch_data_create_map<span class="params">(</span><br><span class="line">              pipedata, <span class="params">(const void **)</span>&amp;bytes, &amp;len)</span>;</span><br><span class="line">            encoded = asl_core_encode_buffer<span class="params">(bytes, len)</span>;</span><br><span class="line">            asl_set<span class="params">(<span class="params">(aslmsg)</span>merged_msg, ASL_KEY_AUX_DATA, encode)</span>;</span><br><span class="line">            free<span class="params">(encoded)</span>;</span><br><span class="line"></span><br><span class="line">            _asl_send_message<span class="params">(NULL, merged_msg, -<span class="number">1</span>, NULL)</span>;</span><br><span class="line">            asl_msg_release<span class="params">(merged_msg)</span>;</span><br><span class="line">            dispatch_release<span class="params">(md)</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if<span class="params">(done)</span>&#123;</span><br><span class="line">        dispatch_semaphore_signal<span class="params">(semaphore)</span>;</span><br><span class="line">        dispatch_relase<span class="params">(pipe_channel)</span>;</span><br><span class="line">        dispatch_release<span class="params">(pipe_q)</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;)</span>;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[你对本页的描述]]>
    
    </summary>
    
      <category term="GCD" scheme="http://ytlvy.com/tags/GCD/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ios block]]></title>
    <link href="http://ytlvy.com/2015/06/15/ios-block/"/>
    <id>http://ytlvy.com/2015/06/15/ios-block/</id>
    <published>2015-06-15T12:02:03.000Z</published>
    <updated>2015-06-15T12:04:42.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Block">Block</h2><p>Converting Source Code<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc file_name_of_the_<span class="built_in">source</span>_code</span><br></pre></td></tr></table></figure></p>
<h3 id="无变量">无变量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">struct</span> __block_impl &#123;</span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Block\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = (<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA);</span><br><span class="line"></span><br><span class="line">  ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="static变量">static变量</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">    <span class="keyword">struct</span> __block_impl <span class="keyword">impl</span>;</span><br><span class="line">    <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *static_val;</span><br><span class="line"></span><br><span class="line">    __main_block_impl_0(void *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc,</span><br><span class="line">    <span class="keyword">int</span> *_static_val, <span class="keyword">int</span> flags=<span class="number">0</span>) : static_val(_static_val) &#123;</span><br><span class="line">        <span class="keyword">impl</span>.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">        <span class="keyword">impl</span>.Flags = flags;</span><br><span class="line">        <span class="keyword">impl</span>.FuncPtr = fp;</span><br><span class="line">        Desc = desc; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> void __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    <span class="keyword">int</span> *static_val = __cself-&gt;static_val;</span><br><span class="line">    (*static_val) *= <span class="number">3</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="__block_variable">__block variable</h3><p>将原来的变量更改为：Block_byref_val变量，此变量包含一个forwarding影像，用来存放block对其的修改。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//__block variable</span></span><br><span class="line"><span class="keyword">struct</span> __block_impl &#123;</span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __Block_byref_val_0 &#123;</span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_val_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line"></span><br><span class="line">  __Block_byref_val_0 *val; <span class="comment">// by ref</span></span><br><span class="line"></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, __Block_byref_val_0 *_val, <span class="keyword">int</span> flags=<span class="number">0</span>) : val(_val-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_val_0 *val = __cself-&gt;val; <span class="comment">// bound by ref</span></span><br><span class="line">(val-&gt;__forwarding-&gt;val) = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0*dst, <span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;val, (<span class="keyword">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*copy)(<span class="keyword">struct</span> __main_block_impl_0*, <span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_1 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_1* Desc;</span><br><span class="line"></span><br><span class="line">  __Block_byref_val_0 *val; <span class="comment">// by ref</span></span><br><span class="line"></span><br><span class="line">  __main_block_impl_1(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_1 *desc, __Block_byref_val_0 *_val, <span class="keyword">int</span> flags=<span class="number">0</span>) : val(_val-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_1(<span class="keyword">struct</span> __main_block_impl_1 *__cself) &#123;</span><br><span class="line">  __Block_byref_val_0 *val = __cself-&gt;val; <span class="comment">// bound by ref</span></span><br><span class="line">(val-&gt;__forwarding-&gt;val) = <span class="number">2</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_1(<span class="keyword">struct</span> __main_block_impl_1*dst, <span class="keyword">struct</span> __main_block_impl_1*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;val, (<span class="keyword">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_1(<span class="keyword">struct</span> __main_block_impl_1*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_1 &#123;</span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*copy)(<span class="keyword">struct</span> __main_block_impl_1*, <span class="keyword">struct</span> __main_block_impl_1*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __main_block_impl_1*);</span><br><span class="line">&#125; __main_block_desc_1_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_1), __main_block_copy_1, __main_block_dispose_1&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  __attribute__((__blocks__(byref))) __Block_byref_val_0 val = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_val_0 *)&amp;val, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_val_0), <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = (<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_val_0 *)&amp;val, <span class="number">570425344</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">void</span> (*blk1)(<span class="keyword">void</span>) = (<span class="keyword">void</span> (*)())&amp;__main_block_impl_1((<span class="keyword">void</span> *)__main_block_func_1, &amp;__main_block_desc_1_DATA, (__Block_byref_val_0 *)&amp;val, <span class="number">570425344</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> IMAGE_INFO &#123; <span class="keyword">unsigned</span> version; <span class="keyword">unsigned</span> flag; &#125; _OBJC_IMAGE_INFO = &#123; <span class="number">0</span>, <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure></p>
<p>two block share same instance of the __Block_byref_val_0</p>
<h3 id="Memory_Segments_for_Blocks">Memory Segments for Blocks</h3><ol>
<li>_NSConcreteStackBlock</li>
<li>_NSConcreteGlobalBlock</li>
<li>_NSConcreteMallocBlock</li>
</ol>
<p>|  program area   |<br>| (.text section) |<br>|————————-|<br>|   data area     |<br>|   .data section |  &lt;——-  _NSConcreteGlobalBlock<br>|————————-|<br>|                 |<br>|       heap      |  &lt;——-  _NSConcreteMallocBlock<br>|                 |<br>|                 |<br>|————————-|<br>|      stack      |  &lt;——-  _NSConcreteStackBlock</p>
<h4 id="NSConcreteGlobalBlock_Class_Object">NSConcreteGlobalBlock Class Object</h4><ol>
<li>when a Block literal is written where a global variable is<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;<span class="built_in">printf</span>(<span class="string">"Global Block\n"</span>);&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Because automatic variables can’t exist where the global variables are declared, capturing never happens</p>
<ol>
<li>when a Block literal is inside a function and doesn’t capture any automatic variables</li>
</ol>
<blockquote>
<p>Any Block created by another kind of Block literal will be an object of the _NSConcreteStackBlock class, and be stored on the stack.<br>此外所有其他生成的block都是_NSConcreteStackBlock</p>
<p>A Block, which is stored in the data section like global variables, can be accessed safely via pointers outside any variable scopes. But the other Blocks, which are stored on the stack, will be disposed of after the scope of the Block is left. And <strong>block variables are stored on the stack as well, so the </strong>block variables will be disposed of when the scope is left<br>全局block， 可以在任何函数域内，安全的进行存取。但是stackBlock会在函数域结束后，被自动释放。为了解决这个问题，Block提供了一种机制，可以将StackBlock复制到heap</p>
</blockquote>
<h4 id="Block_on_the_Heap">Block on the Heap</h4><p>复制到堆上的闭包类型, 变更为NSConcreteMallocBlock. __forwarding变量用来指向闭包,具体的存放位置, stack or heap.</p>
<h4 id="Copying_Blocks_Automatically">Copying Blocks Automatically</h4><p>在ARC环境下, 系统会自动检测, 并将block复制到heap.<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="keyword">int</span> (^blk_t)(<span class="keyword">int</span>);</span><br><span class="line">blk_t func(<span class="keyword">int</span> rate)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ^(<span class="keyword">int</span> <span class="keyword">count</span>)&#123;<span class="keyword">return</span> rate * <span class="keyword">count</span>;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Coping_Blocks_Manually">Coping Blocks Manually</h4><p>系统不能自动检测的情况</p>
<ol>
<li>When a Block is passed as an argument for methods or functions<br>(But if the method or the function copies the argument inside, the caller doesn’t need to copy it manually as)</li>
<li>Cocoa Framework methods, the name of which includes “usingBlock”</li>
<li>GCD API</li>
</ol>
<p>you need to copy a Block when you pass it to an NSArray class instance method “initWithObjects”<br>当你将Block作为参数, 传入数组 ‘initWithObjects’时,需要手动复制<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>) getBlockArray</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">NSArray</span> alloc] initWithObjects: </span><br><span class="line">     [^&#123;<span class="built_in">NSLog</span>(<span class="string">@"blk0:%d"</span>, val);&#125; <span class="keyword">copy</span>],</span><br><span class="line">     [^&#123;<span class="built_in">NSLog</span>(<span class="string">@"blk1:%d"</span>, val);&#125; <span class="keyword">copy</span>],</span><br><span class="line">      <span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>尽量多得使用copy对Block无不良影响</p>
<h4 id="Memory_Segments_for___block_Variables">Memory Segments for __block Variables</h4><ol>
<li>当闭包被复制到Heap时, 如果闭包使用了__block变量, 且此变量未被其他block使用, 此变量也会被复制到heap.</li>
<li>如果__block变量被多个闭包使用, 此变量也会被复制到heap. 当二个闭包被复制时, heap中得变量引用指数+1.</li>
</ol>
<h4 id="__forwarding">__forwarding</h4><p>始终指向最新的Block, 可以对齐进行存取</p>
<h4 id="automatic_variables_of_C_array_type_can’t_be_used_in_a_Block_directly">automatic variables of C array type can’t be used in a Block directly</h4><p>原因是C语言不允许将一个数组变量，赋值另外一个数组变量, 不能编译<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> a[10])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> b[<span class="number">10</span>] = a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, b[<span class="number">0</span>]); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">10</span>] = &#123;<span class="number">2</span>&#125;;</span><br><span class="line">    func(a); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Capturing_Objects">Capturing Objects</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  <span class="keyword">id</span> __<span class="keyword">strong</span> array;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="When_is_the_Block_on_the_stack_copied_to_the_heap">When is the Block on the stack copied to the heap</h4><p>􏰀1. When the instance method “copy” is called on the Block<br>􏰀2. When the Block is returned from a function<br>􏰀3. When the Block is assigned to a member variable of id or the Block type class, with __strong qualifier<br>􏰀4. When the Block is passed to a method, including “usingBlock” in the Cocoa Framework, or a Grand Central Dispatch API</p>
<h4 id="When_You_Should_Call_the_“copy”_Method">When You Should Call the “copy” Method</h4><p>􏰀1. When the Block is returned from a function<br>􏰀2. When the Block is assigned to a member variable of id or the Block<br>type class, with a __strong qualifier<br>􏰀3. When the Block is passed to a method, including “usingBlock” in the Cocoa Framework, or a Grand Central Dispatch API</p>
<h4 id="Circular_Reference_with_Blocks">Circular Reference with Blocks</h4><p>__weak</p>
<p>在不支持weak的情况下<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">id</span> tmp = <span class="keyword">self</span>;</span><br><span class="line">blk_ = ^&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"self = %@"</span>, tmp);</span><br><span class="line">  tmp = <span class="literal">nil</span>; </span><br><span class="line">&#125;;</span><br><span class="line">- (<span class="keyword">void</span>)execBlock &#123;</span><br><span class="line">  blk_();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果不执行execBlock, 还是存在循环引用, 要确保执行了execBlock</p>
]]></content>
    <summary type="html">
    <![CDATA[block用法, 以及底层实现]]>
    
    </summary>
    
      <category term="block" scheme="http://ytlvy.com/tags/block/"/>
    
      <category term="ios" scheme="http://ytlvy.com/tags/ios/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[wget]]></title>
    <link href="http://ytlvy.com/2015/06/11/wget/"/>
    <id>http://ytlvy.com/2015/06/11/wget/</id>
    <published>2015-06-11T05:06:15.000Z</published>
    <updated>2015-06-11T05:07:01.000Z</updated>
    <content type="html"><![CDATA[<h2 id="wget">wget</h2><h3 id="用wget做站点镜像">用wget做站点镜像</h3><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">wget</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">mirror</span> <span class="literal">-</span><span class="comment">p</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">convert</span><span class="literal">-</span><span class="comment">links</span> <span class="literal">-</span><span class="comment">P</span> <span class="title">[</span><span class="comment">本地目录</span><span class="title">]</span> <span class="title">[</span><span class="comment">网站地址</span><span class="title">]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -r -np -nd <span class="string">http:</span><span class="comment">//appinn.com</span></span><br></pre></td></tr></table></figure>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -r -<span class="tag">p</span> -np -k http:<span class="comment">//dsec.pku.edu.cn/~usr_name/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -m <span class="string">http:</span><span class="comment">//www.tldp.org/LDP/abs/html/</span></span><br></pre></td></tr></table></figure>
<h3 id="在不稳定的网络上下载一个部分下载的文件，以及在空闲时段下载">在不稳定的网络上下载一个部分下载的文件，以及在空闲时段下载</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -t <span class="number">0</span> -w <span class="number">31</span> -c <span class="string">http:</span><span class="comment">//dsec.pku.edu.cn/BBC.avi -o down.log &amp;</span></span><br></pre></td></tr></table></figure>
<h3 id="从filelist读入要下载的文件列表">从filelist读入要下载的文件列表</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -t <span class="number">0</span> -w <span class="number">31</span> -c -B <span class="string">ftp:</span><span class="comment">//dsec.pku.edu.cn/linuxsoft -i filelist.txt -o down.log &amp;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码还可以用来在网络比较空闲的时段进行下载。我的用法是:在mozilla中将不方便当时下载的URL链接拷贝到内存中然后粘贴到文件filelist.txt中，在晚上要出去前执行上面代码</p>
<h3 id="详细参数">详细参数</h3><h4 id="启动">启动</h4><blockquote>
<p> -V,  —version           显示wget的版本后退出<br>  -h,  —help              打印语法帮助<br>  -b,  —background        启动后转入后台执行<br>  -e,  —execute=COMMAND   执行`.wgetrc’格式的命令，wgetrc格式参见/etc/wgetrc或~/.wgetrc</p>
</blockquote>
<h4 id="记录和输入文件">记录和输入文件</h4><blockquote>
<p> -o,  —output-file=FILE     把记录写到FILE文件中<br>  -a,  —append-output=FILE   把记录追加到FILE文件中<br>  -d,  —debug                打印调试输出<br>  -q,  —quiet                安静模式(没有输出)<br>  -v,  —verbose              冗长模式(这是缺省设置)<br>  -nv, —non-verbose          关掉冗长模式，但不是安静模式<br>  -i,  —input-file=FILE      下载在FILE文件中出现的URLs<br>  -F,  —force-html           把输入文件当作HTML格式文件对待<br>  -B,  —base=URL             将URL作为在-F -i参数指定的文件中出现的相对链接的前缀<br>   —sslcertfile=FILE     可选客户端证书<br>   —sslcertkey=KEYFILE   可选客户端证书的KEYFILE<br>   —egd-file=FILE        指定EGD socket的文件名</p>
</blockquote>
<h4 id="下载">下载</h4><blockquote>
<p> —bind-address=ADDRESS   指定本地使用地址(主机名或IP，当本地有多个IP或名字时使用)<br>  -t,  —tries=NUMBER           设定最大尝试链接次数(0 表示无限制).<br>  -O   —output-document=FILE   把文档写到FILE文件中<br>  -nc, —no-clobber             不要覆盖存在的文件或使用.#前缀<br>  -c,  —continue               接着下载没下载完的文件<br>  —progress=TYPE          设定进程条标记<br>  -N,  —timestamping           不要重新下载文件除非比本地文件新<br>  -S,  —server-response        打印服务器的回应<br>  —spider                 不下载任何东西<br>  -T,  —timeout=SECONDS        设定响应超时的秒数<br>  -w,  —wait=SECONDS           两次尝试之间间隔SECONDS秒<br>  —waitretry=SECONDS      在重新链接之间等待1…SECONDS秒<br>  —random-wait            在下载之间等待0…2*WAIT秒<br>  -Y,  —proxy=on/off           打开或关闭代理<br>  -Q,  —quota=NUMBER           设置下载的容量限制<br>  —limit-rate=RATE        限定下载输率</p>
</blockquote>
<h4 id="目录">目录</h4><p>  -nd  —no-directories            不创建目录<br>  -x,  —force-directories         强制创建目录<br>  -nH, —no-host-directories       不创建主机目录<br>  -P,  —directory-prefix=PREFIX   将文件保存到目录 PREFIX/…<br>       —cut-dirs=NUMBER           忽略 NUMBER层远程目录</p>
<h4 id="HTTP_选项">HTTP 选项</h4><pre><code>--http-<span class="built_ins">user</span>=<span class="built_ins">USER</span>      设定HTTP用户名为 <span class="built_ins">USER</span>.
--http-passwd=PASS    设定http密码为 PASS.
</code></pre><p>  -C,  —cache=on/off        允许/不允许服务器端的数据缓存 (一般情况下允许).<br>  -E,  —html-extension      将所有text/html文档以.html扩展名保存<br>       —ignore-length       忽略 <code>Content-Length&#39;头域
       --header=STRING       在headers中插入字符串 STRING
       --proxy-user=USER     设定代理的用户名为 USER
       --proxy-passwd=PASS   设定代理的密码为 PASS
       --referer=URL         在HTTP请求中包含</code>Referer: URL’头<br>  -s,  —save-headers        保存HTTP头到文件<br>  -U,  —user-agent=AGENT    设定代理的名称为 AGENT而不是 Wget/VERSION.<br>       —no-http-keep-alive  关闭 HTTP活动链接 (永远链接).<br>       —cookies=off         不使用 cookies.<br>       —load-cookies=FILE   在开始会话前从文件 FILE中加载cookie<br>       —save-cookies=FILE   在会话结束后将 cookies保存到 FILE文件中</p>
<h4 id="FTP_选项">FTP 选项</h4><p>  -nr, —dont-remove-listing   不移走 `.listing’文件<br>  -g,  —glob=on/off           打开或关闭文件名的 globbing机制<br>       —passive-ftp           使用被动传输模式 (缺省值).<br>       —active-ftp            使用主动传输模式<br>       —retr-symlinks         在递归的时候，将链接指向文件(而不是目录)</p>
<h4 id="递归下载">递归下载</h4><p>  -r,  —recursive          递归下载－－慎用!<br>  -l,  —level=NUMBER       最大递归深度 (inf 或 0 代表无穷).<br>       —delete-after       在现在完毕后局部删除文件<br>  -k,  —convert-links      转换非相对链接为相对链接<br>  -K,  —backup-converted   在转换文件X之前，将之备份为 X.orig<br>  -m,  —mirror             等价于 -r -N -l inf -nr.<br>  -p,  —page-requisites    下载显示HTML文件的所有图片</p>
<h4 id="递归下载中的包含和不包含(accept/reject)">递归下载中的包含和不包含(accept/reject)</h4><p>  -A,  —accept=LIST                分号分隔的被接受扩展名的列表<br>  -R,  —reject=LIST                分号分隔的不被接受的扩展名的列表<br>  -D,  —domains=LIST               分号分隔的被接受域的列表<br>       —exclude-domains=LIST       分号分隔的不被接受的域的列表<br>       —follow-ftp                 跟踪HTML文档中的FTP链接<br>       —follow-tags=LIST           分号分隔的被跟踪的HTML标签的列表<br>  -G,  —ignore-tags=LIST           分号分隔的被忽略的HTML标签的列表<br>  -H,  —span-hosts                 当递归时转到外部主机<br>  -L,  —relative                   仅仅跟踪相对链接<br>  -I,  —include-directories=LIST   允许目录的列表<br>  -X,  —exclude-directories=LIST   不被包含目录的列表<br>  -np, —no-parent                  不要追溯到父目录</p>
]]></content>
    <summary type="html">
    <![CDATA[wget 用法]]>
    
    </summary>
    
      <category term="IOS" scheme="http://ytlvy.com/tags/IOS/"/>
    
      <category term="linux" scheme="http://ytlvy.com/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[AutoLayout -- Content Compression Resistance & Content Hugging]]></title>
    <link href="http://ytlvy.com/2015/06/08/AutoLayout-Content-Compression-Resistance-Content-Hugging/"/>
    <id>http://ytlvy.com/2015/06/08/AutoLayout-Content-Compression-Resistance-Content-Hugging/</id>
    <published>2015-06-08T13:26:29.000Z</published>
    <updated>2015-06-08T13:49:39.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Content_Compression_Resistance_&amp;&amp;_Content_Hugging">Content Compression Resistance &amp;&amp; Content Hugging</h2><p>Auto Layout中, 存在Content Compression Resistance 和 Content Hugging 这两个概念.这两个概念是在<code>固有内容尺寸</code>（Intrinsic Content Size）之上起作用的.</p>
<h3 id="Intrinsic_Content_Size">Intrinsic Content Size</h3><p>包含内容的UI控件, 由内容多少而决定的大小规则.</p>
<h3 id="Content_Compression_Resistance_&amp;_Content_Hugging">Content Compression Resistance &amp; Content Hugging</h3><ol>
<li>内容大小改变是指, 内容显示内容所占空间的长度来说的.</li>
<li><code>内容抗压指数</code>，在父视图变小时, 会根据抗压指数来缩小各子控件;</li>
<li><code>内容拥抱指数</code>, 内容越集中于控件中心, 周围空白越小.</li>
</ol>
<h3 id="例子">例子</h3><p>假设，你有一个下面这样的按钮：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[       Click Me        ]</span><br></pre></td></tr></table></figure></p>
<p>按钮与其父视图之间的边距约束优先级是500。<br>然后，如果按钮的吸附性优先级（Hugging priority）大于500，按钮看起来会是这样：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Click Me]</span><br></pre></td></tr></table></figure>
<p>如果，吸附性优先级小于500，按钮会是这样：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[       Click Me        ]</span><br></pre></td></tr></table></figure></p>
<p>然后，如果现在父视图收缩了，按钮的压缩阻力优先级（Compression Resistance priority）大于500，它看起来会是这样：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Click Me]</span><br></pre></td></tr></table></figure></p>
<p>否则，如果压缩阻力优先级小于500，它会是这样：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Cli..]</span><br></pre></td></tr></table></figure></p>
<p>如果不是这样，则很可能是有一些其他的约束扰乱了你的整个布局！ 例如，可能你的边距约束优先级是1000。或者你可能有一个优先级较高的宽度约束。如果遇到这种情况，可以试试“Editor &gt; Size to Fit Content”菜单命令。</p>
]]></content>
    <summary type="html">
    <![CDATA[autoLayout 内容抗压指数 和 内容吸附指数]]>
    
    </summary>
    
      <category term="autolayout" scheme="http://ytlvy.com/tags/autolayout/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[objc runtime method Cache]]></title>
    <link href="http://ytlvy.com/2015/06/08/objc-runtime-method-Cache/"/>
    <id>http://ytlvy.com/2015/06/08/objc-runtime-method-Cache/</id>
    <published>2015-06-08T13:01:55.000Z</published>
    <updated>2015-06-08T13:51:38.000Z</updated>
    <content type="html"><![CDATA[<h3 id="method_cache_更新机制">method cache 更新机制</h3><p>为了方便函数的查找, objc在运行时,引入了method cache机制,来快速定位函数.method cache的大小是动态更新的,在更新时, 将直接生成新容量的缓存, 并将旧的缓存放入到垃圾队列中,等待时机释放. 而时机的选择, 采用检测每个线程的program counter,来查看是否处于objc_msgSend.如果都不在,则释放.<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">BOOL ThreadsInMsgSend<span class="params">(void)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span><span class="params">(thread in GetAllThreads<span class="params">()</span>)</span> &#123;</span><br><span class="line">        uintptr_t pc = thread.GetPC<span class="params">()</span>;</span><br><span class="line">        <span class="keyword">if</span><span class="params">(pc &gt;= objc_msgSend_startAddress &amp;&amp; pc &lt;= objc_msgSend_endAddress)</span> &#123;</span><br><span class="line">            return YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bucket_t <span class="built_in">*</span>oldCache = class-&gt;cache;</span><br><span class="line">class-&gt;cache = malloc<span class="params">(newSize)</span>;</span><br><span class="line"></span><br><span class="line">append<span class="params">(gOldCachesList, oldCache)</span>;</span><br><span class="line"><span class="keyword">if</span><span class="params">(!ThreadsInMsgSend<span class="params">()</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span><span class="params">(cache in gOldCachesList)</span> &#123;</span><br><span class="line">        free<span class="params">(cache)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    gOldCachesList.clear<span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[objc运行时, 函数缓存更新机制]]>
    
    </summary>
    
      <category term="cache" scheme="http://ytlvy.com/tags/cache/"/>
    
      <category term="runtime" scheme="http://ytlvy.com/tags/runtime/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IOS Multithreading && Memory Management]]></title>
    <link href="http://ytlvy.com/2015/06/07/IOS-Multithreading-Memory-Management/"/>
    <id>http://ytlvy.com/2015/06/07/IOS-Multithreading-Memory-Management/</id>
    <published>2015-06-07T13:04:21.000Z</published>
    <updated>2015-06-07T13:06:15.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Block">Block</h2><p>Converting Source Code<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc file_name_of_the_<span class="built_in">source</span>_code</span><br></pre></td></tr></table></figure></p>
<h3 id="无变量">无变量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">struct</span> __block_impl &#123;</span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Block\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = (<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA);</span><br><span class="line"></span><br><span class="line">  ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="static变量">static变量</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">    <span class="keyword">struct</span> __block_impl <span class="keyword">impl</span>;</span><br><span class="line">    <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *static_val;</span><br><span class="line"></span><br><span class="line">    __main_block_impl_0(void *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc,</span><br><span class="line">    <span class="keyword">int</span> *_static_val, <span class="keyword">int</span> flags=<span class="number">0</span>) : static_val(_static_val) &#123;</span><br><span class="line">        <span class="keyword">impl</span>.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">        <span class="keyword">impl</span>.Flags = flags;</span><br><span class="line">        <span class="keyword">impl</span>.FuncPtr = fp;</span><br><span class="line">        Desc = desc; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> void __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    <span class="keyword">int</span> *static_val = __cself-&gt;static_val;</span><br><span class="line">    (*static_val) *= <span class="number">3</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="__block_variable">__block variable</h3><p>将原来的变量更改为：Block_byref_val变量，此变量包含一个forwarding影像，用来存放block对其的修改。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//__block variable</span></span><br><span class="line"><span class="keyword">struct</span> __block_impl &#123;</span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __Block_byref_val_0 &#123;</span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_val_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line"></span><br><span class="line">  __Block_byref_val_0 *val; <span class="comment">// by ref</span></span><br><span class="line"></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, __Block_byref_val_0 *_val, <span class="keyword">int</span> flags=<span class="number">0</span>) : val(_val-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_val_0 *val = __cself-&gt;val; <span class="comment">// bound by ref</span></span><br><span class="line">(val-&gt;__forwarding-&gt;val) = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0*dst, <span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;val, (<span class="keyword">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*copy)(<span class="keyword">struct</span> __main_block_impl_0*, <span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_1 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_1* Desc;</span><br><span class="line"></span><br><span class="line">  __Block_byref_val_0 *val; <span class="comment">// by ref</span></span><br><span class="line"></span><br><span class="line">  __main_block_impl_1(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_1 *desc, __Block_byref_val_0 *_val, <span class="keyword">int</span> flags=<span class="number">0</span>) : val(_val-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_1(<span class="keyword">struct</span> __main_block_impl_1 *__cself) &#123;</span><br><span class="line">  __Block_byref_val_0 *val = __cself-&gt;val; <span class="comment">// bound by ref</span></span><br><span class="line">(val-&gt;__forwarding-&gt;val) = <span class="number">2</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_1(<span class="keyword">struct</span> __main_block_impl_1*dst, <span class="keyword">struct</span> __main_block_impl_1*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;val, (<span class="keyword">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_1(<span class="keyword">struct</span> __main_block_impl_1*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_1 &#123;</span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*copy)(<span class="keyword">struct</span> __main_block_impl_1*, <span class="keyword">struct</span> __main_block_impl_1*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __main_block_impl_1*);</span><br><span class="line">&#125; __main_block_desc_1_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_1), __main_block_copy_1, __main_block_dispose_1&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  __attribute__((__blocks__(byref))) __Block_byref_val_0 val = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_val_0 *)&amp;val, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_val_0), <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = (<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_val_0 *)&amp;val, <span class="number">570425344</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">void</span> (*blk1)(<span class="keyword">void</span>) = (<span class="keyword">void</span> (*)())&amp;__main_block_impl_1((<span class="keyword">void</span> *)__main_block_func_1, &amp;__main_block_desc_1_DATA, (__Block_byref_val_0 *)&amp;val, <span class="number">570425344</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> IMAGE_INFO &#123; <span class="keyword">unsigned</span> version; <span class="keyword">unsigned</span> flag; &#125; _OBJC_IMAGE_INFO = &#123; <span class="number">0</span>, <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure></p>
<p>two block share same instance of the __Block_byref_val_0</p>
<h3 id="Memory_Segments_for_Blocks">Memory Segments for Blocks</h3><ol>
<li>_NSConcreteStackBlock</li>
<li>_NSConcreteGlobalBlock</li>
<li>_NSConcreteMallocBlock</li>
</ol>
<p>|  program area   |<br>| (.text section) |<br>|————————-|<br>|   data area     |<br>|   .data section |  &lt;——-  _NSConcreteGlobalBlock<br>|————————-|<br>|                 |<br>|       heap      |  &lt;——-  _NSConcreteMallocBlock<br>|                 |<br>|                 |<br>|————————-|<br>|      stack      |  &lt;——-  _NSConcreteStackBlock</p>
<h4 id="NSConcreteGlobalBlock_Class_Object">NSConcreteGlobalBlock Class Object</h4><ol>
<li>when a Block literal is written where a global variable is<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;<span class="built_in">printf</span>(<span class="string">"Global Block\n"</span>);&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Because automatic variables can’t exist where the global variables are declared, capturing never happens</p>
<ol>
<li>when a Block literal is inside a function and doesn’t capture any automatic variables</li>
</ol>
<blockquote>
<p>Any Block created by another kind of Block literal will be an object of the _NSConcreteStackBlock class, and be stored on the stack.<br>此外所有其他生成的block都是_NSConcreteStackBlock</p>
<p>A Block, which is stored in the data section like global variables, can be accessed safely via pointers outside any variable scopes. But the other Blocks, which are stored on the stack, will be disposed of after the scope of the Block is left. And <strong>block variables are stored on the stack as well, so the </strong>block variables will be disposed of when the scope is left<br>全局block， 可以在任何函数域内，安全的进行存取。但是stackBlock会在函数域结束后，被自动释放。为了解决这个问题，Block提供了一种机制，可以将StackBlock复制到heap</p>
</blockquote>
<h4 id="Block_on_the_Heap">Block on the Heap</h4><p>复制到堆上的闭包类型, 变更为NSConcreteMallocBlock. __forwarding变量用来指向闭包,具体的存放位置, stack or heap.</p>
<h4 id="Copying_Blocks_Automatically">Copying Blocks Automatically</h4><p>在ARC环境下, 系统会自动检测, 并将block复制到heap.<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="keyword">int</span> (^blk_t)(<span class="keyword">int</span>);</span><br><span class="line">blk_t func(<span class="keyword">int</span> rate)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ^(<span class="keyword">int</span> <span class="keyword">count</span>)&#123;<span class="keyword">return</span> rate * <span class="keyword">count</span>;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Coping_Blocks_Manually">Coping Blocks Manually</h4><p>系统不能自动检测的情况</p>
<ol>
<li>When a Block is passed as an argument for methods or functions<br>(But if the method or the function copies the argument inside, the caller doesn’t need to copy it manually as)</li>
<li>Cocoa Framework methods, the name of which includes “usingBlock”</li>
<li>GCD API</li>
</ol>
<p>you need to copy a Block when you pass it to an NSArray class instance method “initWithObjects”<br>当你将Block作为参数, 传入数组 ‘initWithObjects’时,需要手动复制<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>) getBlockArray</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">NSArray</span> alloc] initWithObjects: </span><br><span class="line">     [^&#123;<span class="built_in">NSLog</span>(<span class="string">@"blk0:%d"</span>, val);&#125; <span class="keyword">copy</span>],</span><br><span class="line">     [^&#123;<span class="built_in">NSLog</span>(<span class="string">@"blk1:%d"</span>, val);&#125; <span class="keyword">copy</span>],</span><br><span class="line">      <span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>尽量多得使用copy对Block无不良影响</p>
<h4 id="Memory_Segments_for___block_Variables">Memory Segments for __block Variables</h4><ol>
<li>当闭包被复制到Heap时, 如果闭包使用了__block变量, 且此变量未被其他block使用, 此变量也会被复制到heap.</li>
<li>如果__block变量被多个闭包使用, 此变量也会被复制到heap. 当二个闭包被复制时, heap中得变量引用指数+1.</li>
</ol>
<h4 id="__forwarding">__forwarding</h4><p>始终指向最新的Block, 可以对齐进行存取</p>
<h4 id="automatic_variables_of_C_array_type_can’t_be_used_in_a_Block_directly">automatic variables of C array type can’t be used in a Block directly</h4><p>原因是C语言不允许将一个数组变量，赋值另外一个数组变量, 不能编译<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> a[10])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> b[<span class="number">10</span>] = a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, b[<span class="number">0</span>]); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">10</span>] = &#123;<span class="number">2</span>&#125;;</span><br><span class="line">    func(a); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Capturing_Objects">Capturing Objects</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  <span class="keyword">id</span> __<span class="keyword">strong</span> array;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="When_is_the_Block_on_the_stack_copied_to_the_heap">When is the Block on the stack copied to the heap</h4><p>􏰀1. When the instance method “copy” is called on the Block<br>􏰀2. When the Block is returned from a function<br>􏰀3. When the Block is assigned to a member variable of id or the Block type class, with __strong qualifier<br>􏰀4. When the Block is passed to a method, including “usingBlock” in the Cocoa Framework, or a Grand Central Dispatch API</p>
<h4 id="When_You_Should_Call_the_“copy”_Method">When You Should Call the “copy” Method</h4><p>􏰀1. When the Block is returned from a function<br>􏰀2. When the Block is assigned to a member variable of id or the Block<br>type class, with a __strong qualifier<br>􏰀3. When the Block is passed to a method, including “usingBlock” in the Cocoa Framework, or a Grand Central Dispatch API</p>
<h4 id="Circular_Reference_with_Blocks">Circular Reference with Blocks</h4><p>__weak</p>
<p>在不支持weak的情况下<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">id</span> tmp = <span class="keyword">self</span>;</span><br><span class="line">blk_ = ^&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"self = %@"</span>, tmp);</span><br><span class="line">  tmp = <span class="literal">nil</span>; </span><br><span class="line">&#125;;</span><br><span class="line">- (<span class="keyword">void</span>)execBlock &#123;</span><br><span class="line">  blk_();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果不执行execBlock, 还是存在循环引用, 要确保执行了execBlock</p>
<h2 id="GCD">GCD</h2><h3 id="befor_GCD">befor GCD</h3><h4 id="object_method">object method</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="typename">void</span>) <span class="string">performSelectorInBackground:</span> <span class="string">withObject:</span></span><br><span class="line">- (<span class="typename">void</span>) <span class="string">performSelectorOnMainThread:</span> <span class="string">withObject:</span> <span class="string">waitUntilDone:</span></span><br></pre></td></tr></table></figure>
<h3 id="多线程面临的问题">多线程面临的问题</h3><ol>
<li>race condition</li>
<li>dead lock</li>
<li>too much threads consumes two much memory</li>
</ol>
<h4 id="多线程的意义">多线程的意义</h4><p>高交互性， 界面编程中，将耗时的操作放入到其他线程执行，避免影响到主线程界面响应</p>
<h3 id="GCD_基础">GCD 基础</h3><h4 id="Dispatch_Queue_派发队列">Dispatch Queue 派发队列</h4><ol>
<li>serial dispath queue  顺序派发队列</li>
<li>concurrent dispath queue  并发派发队列</li>
</ol>
<p>和浏览器对同一域名可发起的同时连接数限制一样，可最多同时执行的线程数，也是由系统来决定的</p>
<h4 id="创建队列">创建队列</h4><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dispath_queue_t mySerialDispatchQueue = dispatch_queue_create<span class="list">(<span class="string">"com.example.gcd.MySerialDispatchQueue"</span>, NULL)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_queue_t myConcurrentDispathQueue = dispatch_queue_create<span class="list">(<span class="string">"com.ytlvy.gcd.MyConcurrentDispatchQueue"</span>, DISPATCH_QUEUE_CONCURRENT)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_async<span class="list">(<span class="keyword">myConcurrentQueue</span>, ^&#123;</span><br><span class="line">  //do staff</span><br><span class="line">  &#125;)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_release<span class="list">(<span class="keyword">mySerialDispatchQueue</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_retain<span class="list">(<span class="keyword">myConcurrentDispatchQueue</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>当并发队列添加任务后，队列被release，是没有问题的。因为block在添加到队列时，会触发dispatch_retain操作来持有队列，在block结束时，会自动触发dispatch_release来释放队列</p>
<h4 id="Main_Dispatch_Queue_/_Global_Dispatch_Queue">Main Dispatch Queue / Global Dispatch Queue</h4><p>可以采用系统方法来获取派发队列。<br> NAME                              | Type        | Description<br> ————————————          | ——————| ————————<br> Main dispatch queue               | Serial      | Executed on the main thread<br> Global dispatch queue(Hight)      | Concurrent  | Priority High<br> Global dispatch queue(default)    | Concurrent  | Priority Normal<br> Global dispatch queue(low)        | Concurrent  | Priority Low<br> Global dispatch queue(background) | Concurrent  | Priority Background</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t mainDispatchQueue = dispatch_get_main_queue<span class="list">()</span><span class="comment">;</span></span><br><span class="line">dispatch_queue_t globalDispatchQueueHight = </span><br><span class="line">    dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_HIGH</span>, <span class="number">0</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_queue_t globalDispatchQueueDefault =</span><br><span class="line">    dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_queue_t globalDispatchQueueLow = </span><br><span class="line">    dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_LOW</span>, <span class="number">0</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_queue_t globalDispatchQueueBackground = </span><br><span class="line">    dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_BACKGROUND</span>, <span class="number">0</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>dispatch_retain dispatch_release对系统分配的队列不生效。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">dispatch_async</span>(<span class="function">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>) ^&#123;</span><br><span class="line">   <span class="comment">//do staff</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">dispatch_async</span>(dispatch_get_main_queue, ^&#123;</span><br><span class="line">    <span class="comment">// update gui</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Controlling_Dispatch_Queue">Controlling Dispatch Queue</h4><p><code>dispatch_set_target_queue</code>设置队列优先级</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t mySerialDispatchQueue = </span><br><span class="line">    dispatch_create<span class="list">(<span class="string">"com.ytlvy.gcd.MySerialDispatchQueue"</span>, NULL)</span><span class="comment">;</span></span><br><span class="line">dispatch_queue_t globalDispatchQueueBackGround = </span><br><span class="line">    dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_BACKGROUND</span>, <span class="number">0</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_set_target_queue<span class="list">(<span class="keyword">mySerialDispatchQueue</span>, globalDispatchQueueBackground)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h4 id="dispatch_after">dispatch_after</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_time_t</span> time = <span class="keyword">dispatch_t</span>ime(DISPATCH_TIME_NOW, <span class="number">3u</span>ll * NSEC_PER_SEC);</span><br><span class="line"></span><br><span class="line">dispatch_after(time, dispatch_get_main_queue(), ^&#123;</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>“ull” is for “unsigned long long type”</p>
<p>毫秒<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_time_t</span> time = <span class="keyword">dispatch_t</span>ime(DISPATCH_TIME_NOW, <span class="number">1u</span>ll * NSEC_PER_MSEC);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dispatch_time_t getDispatchTimeByDate(NSDate *<span class="type">date</span>)&#123;</span><br><span class="line">  NSTimeInterval interval;</span><br><span class="line">  double <span class="keyword">second</span>, subsecond;</span><br><span class="line">  struct timespec, <span class="property">time</span>;</span><br><span class="line">  dispatch_time_t milestone;</span><br><span class="line"></span><br><span class="line">  interval = [<span class="type">date</span> timeIntervalSince1970];</span><br><span class="line">  subsecond = modf(interval, &amp;<span class="keyword">second</span>);</span><br><span class="line">  <span class="property">time</span>.tv_sec = <span class="keyword">second</span>;</span><br><span class="line">  <span class="property">time</span>.tv_nsec = subsecond * NSEC_PER_SEC;</span><br><span class="line">  milestone = dispatch_wailltime(&amp;<span class="property">time</span>, <span class="number">0</span>);</span><br><span class="line"><span class="command"></span><br><span class="line">  return</span> milstone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，dispatch第二个参数，应该使用<code>ull</code> 或者 <code>double</code>类型<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SDate <span class="built_in">*</span>start = [NSDate date];</span><br><span class="line">dispatch_time_t popTime = dispatch_time<span class="params">(DISPATCH_TIME_NOW, <span class="number">4</span> * NSEC_PER_SEC)</span>;</span><br><span class="line"></span><br><span class="line">dispatch_after<span class="params">(popTime, dispatch_get_main_queue<span class="params">()</span>, ^&#123;</span><br><span class="line">  NSLog<span class="params">(@<span class="string">"seconds: %f"</span>, [start timeIntervalSinceNow])</span>;</span><br><span class="line">&#125;)</span>;</span><br><span class="line"><span class="comment">// output: seconds: -0.0001</span></span><br><span class="line"></span><br><span class="line">NSDate <span class="built_in">*</span>start = [NSDate date];</span><br><span class="line">dispatch_time_t popTime = dispatch_time<span class="params">(DISPATCH_TIME_NOW, <span class="number">4.0</span> * NSEC_PER_SEC)</span>;</span><br><span class="line"></span><br><span class="line">dispatch_after<span class="params">(popTime, dispatch_get_main_queue<span class="params">()</span>, ^&#123;</span><br><span class="line">  NSLog<span class="params">(@<span class="string">"seconds: %f"</span>, [start timeIntervalSinceNow])</span>;</span><br><span class="line">&#125;)</span>;</span><br><span class="line"><span class="comment">// output: seconds: -4.0001</span></span><br></pre></td></tr></table></figure></p>
<h4 id="dispatch_group">dispatch group</h4><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = </span><br><span class="line">    dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_t group = dispatch_group_create<span class="list">()</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123; NSLog<span class="list">(@<span class="string">"blk0"</span>)</span><span class="comment">; &#125;);</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123; NSLog<span class="list">(@<span class="string">"blk1"</span>)</span><span class="comment">; &#125;);</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123; NSLog<span class="list">(@<span class="string">"blk2"</span>)</span><span class="comment">; &#125;);</span></span><br><span class="line"></span><br><span class="line">dispatch_group_notify<span class="list">(<span class="keyword">group</span>, dispatch_get_main_queue<span class="list">()</span>, ^&#123; NSLog<span class="list">(@<span class="string">"done"</span>)</span><span class="comment">; &#125;);</span></span><br><span class="line">dispatch_release<span class="list">(<span class="keyword">group</span>)</span><span class="comment">;</span></span></span></span></span></span><br></pre></td></tr></table></figure>
<p>等所有任务结束，使用派发队列组。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = </span><br><span class="line">    dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_t group = dispatch_group_create<span class="list">()</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;NSLog<span class="list">(@<span class="string">"blk0"</span>)</span><span class="comment">; &#125;);</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;NSLog<span class="list">(@<span class="string">"blk1"</span>)</span><span class="comment">; &#125;);</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^&#123;NSLog<span class="list">(@<span class="string">"blk2"</span>)</span><span class="comment">; &#125;);</span></span><br><span class="line"></span><br><span class="line">dispatch_group_wait<span class="list">(<span class="keyword">group</span>, DISPATCH_TIME_FOREVER)</span><span class="comment">;</span></span><br><span class="line">dispatch_release<span class="list">(<span class="keyword">group</span>)</span><span class="comment">;</span></span></span></span></span><br></pre></td></tr></table></figure></p>
<p>等待1秒<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dispatch_time_t time = dispatch_time(<span class="type">DISPATCH_TIME_NOW</span>, <span class="number">1</span>ull * <span class="type">NSEC_PER_SEC</span>);</span><br><span class="line">long <span class="literal">result</span> = dispatch_group_wait(group, time);</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">result</span> == <span class="number">0</span>)&#123;</span><br><span class="line">  //finished</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  //some task still running</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>检测任务是否完成<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long <span class="literal">result</span> = dispatch_group_wait(group, <span class="type">DISPATCH_TIME_NOW</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="dispatch_barrier_async">dispatch_barrier_async</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create<span class="list">(</span><br><span class="line">      <span class="string">"com.example.gcd.ForBarrier"</span>, DISPATCH_QUEUE_CONCURRENT)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_async<span class="list">(<span class="keyword">queue</span>, blk0_for_reading)</span><span class="comment">;</span></span><br><span class="line">dispatch_async<span class="list">(<span class="keyword">queue</span>, blk1_for_reading)</span><span class="comment">;</span></span><br><span class="line">dispatch_async<span class="list">(<span class="keyword">queue</span>, blk2_for_reading)</span><span class="comment">;</span></span><br><span class="line">dispatch_async<span class="list">(<span class="keyword">queue</span>, blk3_for_reading)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_barrier_async<span class="list">(<span class="keyword">queue</span>, blk_for_writing)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_async<span class="list">(<span class="keyword">queue</span>, blk4_for_reading)</span><span class="comment">;</span></span><br><span class="line">dispatch_async<span class="list">(<span class="keyword">queue</span>, blk5_for_reading)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_release<span class="list">(<span class="keyword">queue</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h3 id="dispatch_sync">dispatch_sync</h3><p>dead lock<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_main_queue<span class="list">()</span><span class="comment">;</span></span><br><span class="line">dispatch_sync<span class="list">(<span class="keyword">queue</span>, ^&#123;&#125;)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">//dead lock</span><br><span class="line">dispatch_async<span class="list">(<span class="keyword">queue</span>, ^&#123;</span><br><span class="line">  dispatch_sync<span class="list">(<span class="keyword">queue</span>, ^&#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><span class="comment">;</span></span><br><span class="line">  &#125;)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">//serial queue  dead lock</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create<span class="list">(<span class="string">"com.example"</span>, NULL)</span><span class="comment">;</span></span><br><span class="line">dispatch_async<span class="list">(<span class="keyword">queue</span>, ^&#123;</span><br><span class="line">  dispatch_sync<span class="list">(<span class="keyword">queue</span>, ^&#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><span class="comment">;</span></span><br><span class="line">  &#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="dispatch_apply">dispatch_apply</h4><p>与 <code>dispatch_sync</code> 和<code>dispatch_group</code>相关，可以多次添加同一任务, 并等待任务结束</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue =</span><br><span class="line">    dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_apply<span class="list">(<span class="number">10</span>, queue, ^<span class="list">(<span class="keyword">size_t</span> index)</span>&#123;</span><br><span class="line">  NSLog<span class="list">(<span class="string">"%zu"</span>, index)</span><span class="comment">;</span></span><br><span class="line">  &#125;)</span><span class="comment">;</span></span><br><span class="line">NSLog<span class="list">(@<span class="string">"done"</span>)</span><span class="comment">; //last output</span></span><br></pre></td></tr></table></figure>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = </span><br><span class="line">    dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_async<span class="list">(<span class="keyword">queue</span>, ^&#123;</span><br><span class="line"></span><br><span class="line">  dispatch_apply<span class="list">([array count], queue, ^<span class="list">(<span class="keyword">size_t</span> idx)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  //all tasks by dispatch_apply are finished</span><br><span class="line"></span><br><span class="line">  dispatch_async<span class="list">(<span class="keyword">dispatch_get_main_queue</span><span class="list">()</span>, ^&#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  &#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h4 id="dispatch_suspend_&amp;&amp;_dispatch_resume">dispatch_suspend &amp;&amp; dispatch_resume</h4><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dispatch_suspend<span class="list">(<span class="keyword">queue</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_resume<span class="list">(<span class="keyword">queue</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h4 id="dispatch_semaphore">dispatch semaphore</h4><p>NSMutableArray 是非线程安全的，当多个线程同时更改操作会导致程序崩溃.semaphore是一个更小粒度的多线程控制方法, 通过内部计数来控制线程的准入方式.<br>semaphore拥有一个内部计数器来模拟标志, 当计数器为0, 线程等待; 非0时,继续执行.<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create<span class="list">(<span class="number">1</span>)</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_remaphore_wait<span class="list">(<span class="keyword">semaphore</span>, DISPATCH_TIME_FOREVER)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dispatch_time_t time = dispatch_time(<span class="type">DISPATCH_TIME_NOW</span>, <span class="number">1</span>ull * <span class="type">NSEC_PER_SEC</span>);</span><br><span class="line">long <span class="literal">result</span> = dispatch_semaphore_wait(semaphore, time);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">result</span> == <span class="number">0</span>)&#123;</span><br><span class="line">  //<span class="keyword">do</span> staff, execute a task</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  //wait </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当dispatch_semaphore_wait 返回0时, 可以安全执行一个有并发控制的任务. 当任务执行完毕, 需要调用dispatch_semaphore_signal 增加计数</p>
<p>Adding data to NSMutableArray<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = </span><br><span class="line">    dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">dispatch_semaphore_t</span> semaphore = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">NSMutableArray *arr = [NSMutableArray <span class="keyword">new</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; <span class="number">100000</span>; i++)&#123;</span><br><span class="line">  dispatch_async(<span class="built_in">queue</span>, ^&#123;</span><br><span class="line">      dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span><br><span class="line">       *  因为semaphore的计数大于1. 在disaptch_semaphore_wait返回后,</span><br><span class="line">       *  计数器被设置为0. 因为只有一个线程可以获准进入,所以此时更新</span><br><span class="line">       *  NSMutableArray是安全的.</span><br><span class="line">       */</span></span><br><span class="line">      [arr addObject:@(i)];</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span><br><span class="line">       * 需要并发控制的任务结束后, 需要调用signal来增加semaphore的计数器,</span><br><span class="line">       * 以便其他等待的线程可以通过dispatch_semaphore_wait, 获得执行权限</span><br><span class="line">       */</span></span><br><span class="line">      dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_release(semaphore);</span><br></pre></td></tr></table></figure></p>
<h4 id="dispatch_once">dispatch_once</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> pred;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;pred, ^&#123;</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Dispatch_I/O">Dispatch I/O</h3><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t pipe_q =</span><br><span class="line">    dispatch_queue_create<span class="params">(<span class="string">"PipeQ"</span>, NULL)</span>;</span><br><span class="line">pipe_channel = dispatch_io_create<span class="params">(DISPATCH_IO_STREAM, fd, pipe_q, ^<span class="params">(int err)</span>&#123;</span><br><span class="line">  close<span class="params">(fd)</span>;</span><br><span class="line">  &#125;)</span>;</span><br><span class="line"></span><br><span class="line">  out_fd = fdpair[<span class="number">1</span>];</span><br><span class="line">  dispatch_io_set_low_water<span class="params">(pipe_channel, SIZE_MAX)</span>;</span><br><span class="line">  dispatch_io_read<span class="params">(pipe_channel, <span class="number">0</span>, SIZE_MAX, pipe_q, </span><br><span class="line">    ^<span class="params">(bool done, dispatch_data_t pipedata, int error)</span>&#123;</span><br><span class="line">      if<span class="params">(error == <span class="number">0</span>)</span>&#123;</span><br><span class="line">          size_t len = dispatch_data_get_size<span class="params">(pipedata)</span>;</span><br><span class="line">          if<span class="params">(len &gt; <span class="number">0</span>)</span>&#123;</span><br><span class="line">            const char *bytes = NULL;</span><br><span class="line">            char *encode;</span><br><span class="line"></span><br><span class="line">            dispatch_data_t md = dispatch_data_create_map<span class="params">(</span><br><span class="line">              pipedata, <span class="params">(const void **)</span>&amp;bytes, &amp;len)</span>;</span><br><span class="line">            encoded = asl_core_encode_buffer<span class="params">(bytes, len)</span>;</span><br><span class="line">            asl_set<span class="params">(<span class="params">(aslmsg)</span>merged_msg, ASL_KEY_AUX_DATA, encode)</span>;</span><br><span class="line">            free<span class="params">(encoded)</span>;</span><br><span class="line"></span><br><span class="line">            _asl_send_message<span class="params">(NULL, merged_msg, -<span class="number">1</span>, NULL)</span>;</span><br><span class="line">            asl_msg_release<span class="params">(merged_msg)</span>;</span><br><span class="line">            dispatch_release<span class="params">(md)</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if<span class="params">(done)</span>&#123;</span><br><span class="line">        dispatch_semaphore_signal<span class="params">(semaphore)</span>;</span><br><span class="line">        dispatch_relase<span class="params">(pipe_channel)</span>;</span><br><span class="line">        dispatch_release<span class="params">(pipe_q)</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;)</span>;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[ios 多线程以及内存管理笔记]]>
    
    </summary>
    
      <category term="BLock" scheme="http://ytlvy.com/tags/BLock/"/>
    
      <category term="GCD" scheme="http://ytlvy.com/tags/GCD/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[冰之魔女]]></title>
    <link href="http://ytlvy.com/2015/06/07/ice-girl/"/>
    <id>http://ytlvy.com/2015/06/07/ice-girl/</id>
    <published>2015-06-06T17:41:14.000Z</published>
    <updated>2015-06-06T17:47:33.000Z</updated>
    <content type="html"><![CDATA[<h2 id="冰之魔女">冰之魔女</h2>]]></content>
    <summary type="html">
    <![CDATA[冰之魔女]]>
    
    </summary>
    
      <category term="IOS" scheme="http://ytlvy.com/tags/IOS/"/>
    
      <category term="default" scheme="http://ytlvy.com/categories/default/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IOS NSPredicate]]></title>
    <link href="http://ytlvy.com/2015/06/06/ios-nspredicate/"/>
    <id>http://ytlvy.com/2015/06/06/ios-nspredicate/</id>
    <published>2015-06-06T12:56:36.000Z</published>
    <updated>2015-06-06T16:04:12.000Z</updated>
    <content type="html"><![CDATA[<h3 id="NSPredicate">NSPredicate</h3><p>NSPredicate is a Foundation class that specifies how data should be fetched or filtered.<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSPredicate</span> *bobPredicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"firstName = 'Bob'"</span>];</span><br><span class="line"><span class="built_in">NSPredicate</span> *thirtiesPredicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"age &gt;= 30"</span>];</span><br><span class="line"></span><br><span class="line">[people filterdArrayUsingPredicate:bobPredicate];</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h4 id="Predicate_Syntax">Predicate Syntax</h4><ol>
<li>%@ is a var arg substitution for an object value—often a string, number, or date</li>
<li>%K is a var arg substitution for a key path</li>
</ol>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSPredicate <span class="variable">*ageIs33Predicate</span> = [NSPredicate predicateWithFormat: <span class="variable">@"</span><span class="variable">%K</span> = <span class="variable">%@</span><span class="string">", @"</span>age<span class="string">", 33]</span></span><br></pre></td></tr></table></figure>
<ol>
<li>$VARIABLE_NAME is a value that can be substituted<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSPredicate *namesBeginningWithLetterPredicate = </span><br><span class="line">    [NSPredicate <span class="string">predicateWithFormat:</span> @<span class="string">"(firstName BEGINSWITH[cd] $letter) OR (lastName BEGINWITH[cd] $letter)"</span>];</span><br><span class="line"></span><br><span class="line">NSLog(@<span class="string">"'A' Names: %@"</span>, </span><br><span class="line">            [people <span class="string">filterWithPredicate:</span></span><br><span class="line">                [namesBeginningWithLetterPredicate <span class="string">predicateWithSubstitutionVariables:</span>@&#123;@<span class="string">"letter"</span> : @<span class="string">"A"</span>&#125;]]);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="Basic_Comparisons">Basic Comparisons</h4><ol>
<li>=, ==:   equal </li>
<li><blockquote>
<p>=, =&gt;:  greater than or equal</p>
</blockquote>
</li>
<li>&lt;=, =&lt;:  less than or equal</li>
<li><blockquote>
<p>: T     greater t.</p>
</blockquote>
</li>
<li>&lt;:       less than.</li>
<li>!=, &lt;&gt;:  not equal to</li>
<li>BETWEEN  eg: 1 BETWEEN { 0 , 33 }  $INPUT BETWEEN { $LOWER, $UPPER }</li>
</ol>
<h4 id="Basic_Compound_Predicates">Basic Compound Predicates</h4><ol>
<li>AND, &amp;&amp;</li>
<li>OR, ||</li>
<li>NOT, !</li>
</ol>
<h4 id="String_Comparisons">String Comparisons</h4><p>String comparisons are case and diacritic sensitive. by default. One can modify an operator using the key characters c and d within square braces to specify case and diacritic insensitivity respectively. eg: firstName BEGINSWITH[cd] $FIRST_NAME.</p>
<ol>
<li>BEGINSWITH</li>
<li>CONTAINS</li>
<li>ENDSWITH</li>
<li>LIKE         ? and * are allowed as wildcard characters</li>
<li>MATCHES      regex-style </li>
</ol>
<h3 id="Aggregate_Operations">Aggregate Operations</h3><h4 id="Relational_Operations">Relational Operations</h4><ol>
<li>ANY, SOME            eg: ANY children.age &lt; 18</li>
<li>ALL                  eg: ALL children.age &lt; 18</li>
<li>NONE                 eg: NONE children.age &lt; 18</li>
<li>IN                   eg: name IN {‘Ben’, ‘Melissa’, ‘Nick’ }</li>
</ol>
<h4 id="Array_Operations">Array Operations</h4><ol>
<li>array[index]         Specifies the element at the specified index in array</li>
<li>array[FIRST]</li>
<li>array[LAST]</li>
<li>array[SIZE]</li>
<li>Boolean</li>
<li>TRUEPREDICATE        A predicate that always evaluates to TRUE</li>
<li>FALSEPREDICATE       A predicate that always evaluates to FALSE</li>
</ol>
<h4 id="NSCompoundPredicate">NSCompoundPredicate</h4><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[NSCompoundPredicate andPredicateWithSubpredicate:@<span class="collection">[</span><br><span class="line">    <span class="collection">[NSPredicate predicateWithFormat: @<span class="string">"age &gt; 25"</span>]</span>,</span><br><span class="line">    <span class="collection">[NSPredicate predicateWithFormat: @<span class="string">"firstName = %@"</span>, @<span class="string">"Quentin"</span>]</span></span><br><span class="line">    ]</span>]</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="collection">[NSPredicate predicateWithFormat: @<span class="string">"(age &gt; 25) AND (firstName = %@)"</span>, @<span class="string">"Quentin"</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h4 id="NSComparisonPredicate">NSComparisonPredicate</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSPredicate</span> *)predicateWithLeftExpression:</span><br><span class="line">(<span class="built_in">NSExpression</span> *)lhs</span><br><span class="line">rightExpression:(<span class="built_in">NSExpression</span> *)rhs</span><br><span class="line">       modifier:(<span class="built_in">NSComparisonPredicateModifier</span>)modifier</span><br><span class="line">           type:(<span class="built_in">NSPredicateOperatorType</span>)type</span><br><span class="line">        options:(<span class="built_in">NSUInteger</span>)options</span><br></pre></td></tr></table></figure>
<ul>
<li>lhs: The left hand expression.</li>
<li>rhs: The right hand expression.</li>
<li>modifier: The modifier to apply. (ANY or ALL)</li>
<li>type: The predicate operator type.</li>
<li>options: The options to apply. For no options, pass 0.</li>
</ul>
<h4 id="Block_Predicates">Block Predicates</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSPredicate</span> *shortNamePredicate = </span><br><span class="line">    [<span class="built_in">NSPredicate</span> predicateWithBlock: ^<span class="built_in">BOOL</span>(<span class="keyword">id</span> evaluatedObject, <span class="built_in">NSDictionary</span> *bindings)&#123;</span><br><span class="line">        <span class="keyword">return</span> [[evaluatedObject firstName] length] &lt;= <span class="number">5</span>;</span><br><span class="line">    &#125; ]</span><br></pre></td></tr></table></figure>
<p><strong><em>NSPredicates created with predicateWithBlock: cannot be used for Core Data fetch requests backed by a SQLite store</em></strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="NSPredicate">NSPredicate</h3><p>NSPredicate is a Foundation class that specifies how data should be fetched or filtered.<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSPredicate</span> *bobPredicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"firstName = 'Bob'"</span>];</span><br><span class="line"><span class="built_in">NSPredicate</span> *thirtiesPredicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"age &gt;= 30"</span>];</span><br><span class="line"></span><br><span class="line">[people filterdArrayUsingPredicate:bobPredicate];</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IOS NSSortDescriptor]]></title>
    <link href="http://ytlvy.com/2015/06/06/ios-nssortdescriptor/"/>
    <id>http://ytlvy.com/2015/06/06/ios-nssortdescriptor/</id>
    <published>2015-06-06T12:54:35.000Z</published>
    <updated>2015-06-06T16:19:58.000Z</updated>
    <content type="html"><![CDATA[<h2 id="NSSortDescriptor">NSSortDescriptor</h2><p>NSSortDescriptor objects are constructed with the following parameters:</p>
<ol>
<li>key: for a given collection, the key for the corresponding value to be sorted on for each object in the collection</li>
<li>ascending: a boolean specifying whether the collection should be sorted in ascending (YES) or descending (NO) order</li>
<li>a selector (SEL) or comparator (NSComparator)</li>
</ol>
<a id="more"></a>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *firstNames = @[<span class="string">@"Alice"</span>, <span class="string">@"Bob"</span>, <span class="string">@"Charlie"</span>, <span class="string">@"Quentin"</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *lastNames = @[<span class="string">@"Smith"</span>, <span class="string">@"Jones"</span>, <span class="string">@"Smith"</span>, <span class="string">@"Alberts"</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *ages = @[@<span class="number">24</span>, @<span class="number">27</span>, @<span class="number">33</span>, @<span class="number">31</span>];</span><br><span class="line"><span class="built_in">NSMutableArray</span> *people = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"></span><br><span class="line">[firstNames enumerateObjectsUsingBlock: ^(<span class="keyword">id</span> obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">    Person *person = [[Person alloc] init];</span><br><span class="line">    person<span class="variable">.firstName</span> = [firstNames objectAtIndex:idx];</span><br><span class="line">    person<span class="variable">.lastName</span> = [lastNames objectAtIndex:idx];</span><br><span class="line">    person<span class="variable">.age</span> = [ages objectAtIndex:idx];</span><br><span class="line">    [people addObject:person];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSSortDescriptor</span> *firstNameSortDescriptor = </span><br><span class="line">    [<span class="built_in">NSSortDescriptor</span> sortDescriptorWithKey:<span class="string">@"firstName"</span></span><br><span class="line">                                        ascending: <span class="literal">YES</span></span><br><span class="line">                                        selector:<span class="keyword">@selector</span>(localizedStandardCompare:)];</span><br><span class="line"><span class="built_in">NSSortDescriptor</span> *lastNameSortDescriptor =</span><br><span class="line">    [<span class="built_in">NSSortDescriptor</span> sortDescriptorWithKey:<span class="string">@"lastName"</span></span><br><span class="line">                                    ascending: <span class="literal">YES</span></span><br><span class="line">                                    selector: <span class="keyword">@selector</span>(localizedStandardCompare:)];</span><br><span class="line">[people sortedArrayUsingDescriptor:@[firstNameSortDescriptor, lastNameSortDescriptor]];</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="NSSortDescriptor">NSSortDescriptor</h2><p>NSSortDescriptor objects are constructed with the following parameters:</p>
<ol>
<li>key: for a given collection, the key for the corresponding value to be sorted on for each object in the collection</li>
<li>ascending: a boolean specifying whether the collection should be sorted in ascending (YES) or descending (NO) order</li>
<li>a selector (SEL) or comparator (NSComparator)</li>
</ol>]]>
    
    </summary>
    
      <category term="ios" scheme="http://ytlvy.com/tags/ios/"/>
    
      <category term="sort" scheme="http://ytlvy.com/tags/sort/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IOS Key-Value Coding &amp;&amp; Collection Operators]]></title>
    <link href="http://ytlvy.com/2015/06/06/ios-key-value-coding-and-and-collection-operators/"/>
    <id>http://ytlvy.com/2015/06/06/ios-key-value-coding-and-and-collection-operators/</id>
    <published>2015-06-06T12:52:04.000Z</published>
    <updated>2015-06-06T16:05:03.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Key-Value_Coding_&amp;&amp;_Collection_Operators">Key-Value Coding &amp;&amp; Collection Operators</h2><blockquote>
<p>KVC Collection Operators allows actions to be performed on a collection using key path notation in valueForKeyPath:. @’s in a key path denote an aggregate function whose result can be returned or chained, just like any other key path.</p>
</blockquote>
<h3 id="Simple_Collection_Operators">Simple Collection Operators</h3><ol>
<li>@count: Returns the number of objects in the collection.</li>
<li>@sum: Converts each object in the collection to a double, computes the sum, and returns the sum.</li>
<li>@avg: Takes the double value of each object in the collection, and returns the average value.</li>
<li>@max: Determines the maximum value using compare:. Objects must support mutual comparison for this to work.</li>
<li>@min: Same as @max, but returns the minimum value.</li>
</ol>
<a id="more"></a>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[products <span class="string">valueForKeyPath:</span>@<span class="string">"@count"</span>]; <span class="comment">// 4</span></span><br><span class="line">[products <span class="string">valueForKeyPath:</span>@<span class="string">"@sum.price"</span>]; <span class="comment">// 3526.00</span></span><br><span class="line">[products <span class="string">valueForKeyPath:</span>@<span class="string">"@avg.price"</span>]; <span class="comment">// 881.50</span></span><br><span class="line">[products <span class="string">valueForKeyPath:</span>@<span class="string">"@max.price"</span>]; <span class="comment">// 1699.00</span></span><br><span class="line">[products <span class="string">valueForKeyPath:</span>@<span class="string">"@min.launchedOn"</span>];</span><br></pre></td></tr></table></figure>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">To <span class="built_in">get</span> <span class="operator">the</span> aggregate <span class="built_in">value</span> <span class="operator">of</span> <span class="operator">an</span> array <span class="operator">or</span> <span class="built_in">set</span> <span class="operator">of</span> NSNumbers, simply pass self <span class="keyword">as</span> <span class="operator">the</span> key path <span class="keyword">after</span> <span class="operator">the</span> operator,</span><br><span class="line">e.g. [@[@(<span class="number">1</span>), @(<span class="number">2</span>), @(<span class="number">3</span>)] valueForKeyPath:@<span class="string">"@max.self "</span>]</span><br></pre></td></tr></table></figure>
<h3 id="Object_Operators">Object Operators</h3><p>@unionOfObjects / @distinctUnionOfObjects</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="name">NSArray</span> *<span class="atom">inventory</span> = @[<span class="atom">iPhone5</span>, <span class="atom">iPhone5</span>, <span class="atom">iPhone5</span>, <span class="atom">iPadMini</span>, <span class="atom">macBookPro</span>, <span class="atom">macBookPro</span>];</span><br><span class="line">[<span class="atom">inventory</span> <span class="atom">valueForKeyPath</span>:@<span class="string">"@unionOfObjects.name"</span>];</span><br><span class="line"></span><br><span class="line">[<span class="atom">inventory</span> <span class="atom">valueForKeyPath</span>:@<span class="string">"@distinctUnionOfObjects.name"</span>];</span><br><span class="line">// <span class="string">"iPhone 5"</span>, <span class="string">"iPad mini"</span>, <span class="string">"MacBook Pro"</span></span><br></pre></td></tr></table></figure>
<h3 id="Array_and_Set_Operators">Array and Set Operators</h3><ol>
<li>@distinctUnionOfArrays / @unionOfArrays</li>
<li>@distinctUnionOfSets / </li>
</ol>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">telecomStoreInventory = <span class="variable">@[</span>iPhone5, iPhone5, iPadMini];</span><br><span class="line"></span><br><span class="line">[<span class="variable">@[</span>appleStoreInventory, telecomStoreInventory] valueForKeyPath:<span class="variable">@"</span><span class="variable">@distinctUnionOfArrays</span>.name<span class="string">"];</span></span><br></pre></td></tr></table></figure>
<p>KVC Collection Operators are a must-know for anyone wanting to save a few extra lines of code and look cool in the process.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Key-Value_Coding_&amp;&amp;_Collection_Operators">Key-Value Coding &amp;&amp; Collection Operators</h2><blockquote>
<p>KVC Collection Operators allows actions to be performed on a collection using key path notation in valueForKeyPath:. @’s in a key path denote an aggregate function whose result can be returned or chained, just like any other key path.</p>
</blockquote>
<h3 id="Simple_Collection_Operators">Simple Collection Operators</h3><ol>
<li>@count: Returns the number of objects in the collection.</li>
<li>@sum: Converts each object in the collection to a double, computes the sum, and returns the sum.</li>
<li>@avg: Takes the double value of each object in the collection, and returns the average value.</li>
<li>@max: Determines the maximum value using compare:. Objects must support mutual comparison for this to work.</li>
<li>@min: Same as @max, but returns the minimum value.</li>
</ol>]]>
    
    </summary>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C Storage Classes]]></title>
    <link href="http://ytlvy.com/2015/06/06/c-storage-classes/"/>
    <id>http://ytlvy.com/2015/06/06/c-storage-classes/</id>
    <published>2015-06-06T12:49:35.000Z</published>
    <updated>2015-06-06T16:05:20.000Z</updated>
    <content type="html"><![CDATA[<h2 id="C_Storage_Classes">C Storage Classes</h2><p>There are 4 storage classes in C: auto, register, static &amp; extern.</p>
<h3 id="static">static</h3><p>When it comes to storage classes, static means one of two things.</p>
<ol>
<li>A static variable inside a method or function retains its value between invocations.</li>
<li>A static variable declared globally can called by any function or method, so long as those functions appear in the same file as the static variable. The same goes for static functions.</li>
</ol>
<h3 id="Static_Singletons">Static Singletons</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)sharedInstance&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">id</span> _sharedInstance = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    dispath_once(&amp;onceToken, ^&#123;</span><br><span class="line">        _sharedInstance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">        <span class="comment">//any config</span></span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="keyword">return</span> _sharedInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="extern">extern</h3><p>Whereas static makes functions and variables globally visible within a particular file, extern makes them visible globally to all files.</p>
<h4 id="Global_String_Constants">Global String Constants</h4><p>Any time your application uses a string constant in a public interface, it should be declared as an external string constant. This is especially true of NSNotification names, NSError domains, and keys in userInfo dictionaries.<br>Declare an extern NSString <em> const in a public header, and define that NSString </em> const in the implementation:</p>
<p>AppConstants.h<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kAppErrorDomain;</span><br></pre></td></tr></table></figure></p>
<p>AppConstants.m<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> kAppErrorDomain = <span class="string">@"com.example.yourapp.error"</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="Public_Functions">Public Functions</h4><p>TransactionStateMachine.h<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, TransactionState) &#123;</span><br><span class="line">    TransactionOpened,</span><br><span class="line">    TransactionPending,</span><br><span class="line">    TransactionClosed,</span><br><span class="line">&#125;!;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="built_in">NSStringFromTransactionState</span>(TransactionState state);</span><br></pre></td></tr></table></figure></p>
<p>TransactionStateMachine.m<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *</span><br><span class="line">  <span class="built_in">NSStringFromTransactionState</span>(TransactionState state) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">    <span class="keyword">case</span> TransactionOpened: <span class="keyword">return</span> <span class="string">@"Opened"</span></span><br><span class="line">    <span class="keyword">case</span> TransactionPending: <span class="keyword">return</span> <span class="string">@"Pending"</span>;</span><br><span class="line">    <span class="keyword">case</span> TransactionClosed: <span class="keyword">return</span> <span class="string">@"Closed"</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="C_Storage_Classes">C Storage Classes</h2><p>There are 4 storage classes in C: auto, register, static &amp; extern.</p>
<h3 id="static">static</h3><p>When it comes to storage classes, static means one of two things.</p>
<ol>
<li>A static variable inside a method or function retains its value between invocations.</li>
<li>A static variable declared globally can called by any function or method, so long as those functions appear in the same file as the static variable. The same goes for static functions.</li>
</ol>
<h3 id="Static_Singletons">Static Singletons</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)sharedInstance&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">id</span> _sharedInstance = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    dispath_once(&amp;onceToken, ^&#123;</span><br><span class="line">        _sharedInstance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">        <span class="comment">//any config</span></span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="keyword">return</span> _sharedInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="C" scheme="http://ytlvy.com/categories/C/"/>
    
  </entry>
  
</feed>