<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Yt's Blog]]></title>
  <subtitle><![CDATA[Valar Morghulis]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://ytlvy.com//"/>
  <updated>2015-08-04T13:35:45.000Z</updated>
  <id>http://ytlvy.com//</id>
  
  <author>
    <name><![CDATA[Yt]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[parse crashLog manually]]></title>
    <link href="http://ytlvy.com/2015/08/04/parse-crashLog-manually/"/>
    <id>http://ytlvy.com/2015/08/04/parse-crashLog-manually/</id>
    <published>2015-08-04T13:35:14.000Z</published>
    <updated>2015-08-04T13:35:45.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://foggry.com/blog/2015/07/27/ru-he-shou-dong-jie-xi-crashlog/" target="_blank" rel="external">转自</a></p>
<h2 id="如何手动解析CrashLog">如何手动解析CrashLog</h2><p>解决崩溃问题是移动应用开发者最日常的工作之一。如果是开发过程中遇到的崩溃，可以根据重现步骤调试，但线上版本就无能为力了。好在目前已经有很多不错的第三方CrashLog搜集平台（如友盟、Crashlytics等）为我们做好了解析工作，甚至在Xcode7里苹果也跟进了解析线上版本崩溃日志的功能，为开发者减轻了不少负担。尽管通常已经不需要我们手工处理CrashLog，了解CrashLog的还原原理和方法还是有必要的。</p>
<h3 id="-dSYM">.dSYM</h3><p><code>.dSYM(debugging SYMbols)</code>又称为调试符号表，是苹果为了方便调试和定位问题而使用的一种调试方案，本质上使用的是起源于贝尔实验室的DWARF（Debugging With Attributed Record Formats），其在<code>.xcarchive</code>目录中的层次结构为：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.xcarchive</span><br><span class="line"><span class="comment">--dSYMs</span></span><br><span class="line">  |<span class="comment">--Your.app.dSYM</span></span><br><span class="line">    |<span class="comment">--Contents</span></span><br><span class="line">      |<span class="comment">--Resources</span></span><br><span class="line">        |<span class="comment">--DWARF</span></span><br></pre></td></tr></table></figure></p>
<p>关于DWARF的具体内容以后有机会再说。我们能解析CrashLog全靠.dSYM文件，解析方式见后文。</p>
<a id="more"></a>
<h3 id="确定符号表和崩溃日志的一致性">确定符号表和崩溃日志的一致性</h3><p>有了符号表文件，有了崩溃日志文件，在解析之前一定要确保二者的对应关系，否则就算按照下述步骤解析出内容也肯定是不准确的。二者的对应关系可以通过UUID来确定。</p>
<h3 id="从崩溃日志中获取UUID">从崩溃日志中获取UUID</h3><p>崩溃日志比较靠下的位置有个<code>Binary Images</code>模块，其第一行内容如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Binary <span class="string">Images:</span></span><br><span class="line"><span class="number">0xa2000</span> - <span class="number">0x541fff</span> Your armv7  &lt;a5c8d3cfda65396689e4370bf3a0ac64&gt; <span class="regexp">/var/</span>mobile<span class="regexp">/Containers/</span>Bundle<span class="regexp">/Application/</span><span class="number">645</span>D3184-<span class="number">4</span>C20-<span class="number">4161</span>-<span class="number">924</span>B-BDE170FA64CC<span class="regexp">/Your.app/</span>Your</span><br></pre></td></tr></table></figure>
<p>从中可以看到关于你应用的若干信息：</p>
<ul>
<li>代码段的起终地址为：0xa2000 – 0x541fff</li>
<li>运行你应用的CPU指令集为：armv7</li>
<li>应用的UUID为：a5c8d3cfda65396689e4370bf3a0ac64（不区分大小写）</li>
</ul>
<h4 id="从符号表中获取UUID">从符号表中获取UUID</h4><p>执行以下命令从符号表中提取UUID：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dwarfdump --uuid Your<span class="class">.app</span><span class="class">.dSYM</span></span><br></pre></td></tr></table></figure></p>
<p>或者：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dwarfdump --uuid Your<span class="class">.app</span><span class="class">.dSYM</span>/Contents/Resources/DWARF/Your</span><br></pre></td></tr></table></figure></p>
<p>执行结果为：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">UUID:</span> A5C8D3CF-DA65-<span class="number">3966</span>-<span class="number">89E4</span>-<span class="number">370</span>BF3A0AC64 (armv7) Your.app.dSYM<span class="regexp">/Contents/</span>Resources<span class="regexp">/DWARF/</span>Your</span><br></pre></td></tr></table></figure></p>
<p>由此得到armv7指令集的UUID为：A5C8D3CF-DA65-3966-89E4-370BF3A0AC64（如果你的二进制文件支持多个指令集，这里会列出每个指令集对应符号表的UUID），通过和崩溃日志中的对比发现二者一致，才可进行进一步的解析操作。</p>
<h3 id="计算崩溃符号表地址">计算崩溃符号表地址</h3><p>以下面的崩溃堆栈为例：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Thread <span class="number">0</span>:</span><br><span class="line"><span class="number">0</span>   libobjc.A.dylib                   <span class="number">0x33f10f60</span> <span class="number">0x33efe000</span> + <span class="number">77664</span></span><br><span class="line"><span class="number">1</span>   Foundation                        <span class="number">0x273526ac</span> <span class="number">0x2734a000</span> + <span class="number">34476</span></span><br><span class="line"><span class="number">2</span>   Foundation                        <span class="number">0x27355c3e</span> <span class="number">0x2734a000</span> + <span class="number">48190</span></span><br><span class="line"><span class="number">3</span>   UIKit                             <span class="number">0x29ef9d1c</span> <span class="number">0x29bbc000</span> + <span class="number">3398940</span></span><br><span class="line"><span class="number">4</span>   UIKit                             <span class="number">0x29ef9c9a</span> <span class="number">0x29bbc000</span> + <span class="number">3398810</span></span><br><span class="line"><span class="number">5</span>   UIKit                             <span class="number">0x29ef954c</span> <span class="number">0x29bbc000</span> + <span class="number">3396940</span></span><br><span class="line"><span class="number">6</span>   UIKit                             <span class="number">0x29c3a16a</span> <span class="number">0x29bbc000</span> + <span class="number">516458</span></span><br><span class="line"><span class="number">7</span>   UIKit                             <span class="number">0x29e4b8e6</span> <span class="number">0x29bbc000</span> + <span class="number">2685158</span></span><br><span class="line"><span class="number">8</span>   UIKit                             <span class="number">0x29c3a128</span> <span class="number">0x29bbc000</span> + <span class="number">516392</span></span><br><span class="line"><span class="number">9</span>   Your                              <span class="number">0x000f0846</span> <span class="number">0xa2000</span> + <span class="number">321606</span></span><br><span class="line"><span class="number">10</span>  UIKit                             <span class="number">0x29e90fb2</span> <span class="number">0x29bbc000</span> + <span class="number">2969522</span></span><br><span class="line"><span class="number">11</span>  UIKit                             <span class="number">0x29e91076</span> <span class="number">0x29bbc000</span> + <span class="number">2969718</span></span><br><span class="line"><span class="number">12</span>  UIKit                             <span class="number">0x29e867cc</span> <span class="number">0x29bbc000</span> + <span class="number">2926540</span></span><br><span class="line"><span class="number">13</span>  UIKit                             <span class="number">0x29c9e8ea</span> <span class="number">0x29bbc000</span> + <span class="number">927978</span></span><br><span class="line"><span class="number">14</span>  UIKit                             <span class="number">0x29bc8a6a</span> <span class="number">0x29bbc000</span> + <span class="number">51818</span></span><br><span class="line"><span class="number">15</span>  QuartzCore                        <span class="number">0x295f0a08</span> <span class="number">0x295e4000</span> + <span class="number">51720</span></span><br><span class="line"><span class="number">16</span>  QuartzCore                        <span class="number">0x295ec3e0</span> <span class="number">0x295e4000</span> + <span class="number">33760</span></span><br><span class="line"><span class="number">17</span>  QuartzCore                        <span class="number">0x295ec268</span> <span class="number">0x295e4000</span> + <span class="number">33384</span></span><br><span class="line"><span class="number">18</span>  QuartzCore                        <span class="number">0x295ebc4c</span> <span class="number">0x295e4000</span> + <span class="number">31820</span></span><br><span class="line"><span class="number">19</span>  QuartzCore                        <span class="number">0x295eba50</span> <span class="number">0x295e4000</span> + <span class="number">31312</span></span><br><span class="line"><span class="number">20</span>  QuartzCore                        <span class="number">0x295e5928</span> <span class="number">0x295e4000</span> + <span class="number">6440</span></span><br><span class="line"><span class="number">21</span>  CoreFoundation                    <span class="number">0x266d0d92</span> <span class="number">0x26604000</span> + <span class="number">839058</span></span><br><span class="line"><span class="number">22</span>  CoreFoundation                    <span class="number">0x266ce44e</span> <span class="number">0x26604000</span> + <span class="number">828494</span></span><br><span class="line"><span class="number">23</span>  CoreFoundation                    <span class="number">0x266ce856</span> <span class="number">0x26604000</span> + <span class="number">829526</span></span><br><span class="line"><span class="number">24</span>  CoreFoundation                    <span class="number">0x2661c3bc</span> <span class="number">0x26604000</span> + <span class="number">99260</span></span><br><span class="line"><span class="number">25</span>  CoreFoundation                    <span class="number">0x2661c1ce</span> <span class="number">0x26604000</span> + <span class="number">98766</span></span><br><span class="line"><span class="number">26</span>  GraphicsServices                  <span class="number">0x2da1a0a4</span> <span class="number">0x2da11000</span> + <span class="number">37028</span></span><br><span class="line"><span class="number">27</span>  UIKit                             <span class="number">0x29c2a7ac</span> <span class="number">0x29bbc000</span> + <span class="number">452524</span></span><br><span class="line"><span class="number">28</span>  Your                              <span class="number">0x0024643a</span> <span class="number">0xa2000</span> + <span class="number">1721402</span></span><br><span class="line"><span class="number">29</span>  libdyld.dylib                     <span class="number">0x34484aac</span> <span class="number">0x34483000</span> + <span class="number">6828</span></span><br></pre></td></tr></table></figure></p>
<h4 id="1、_符号表堆栈地址计算方式">1、 符号表堆栈地址计算方式</h4><p>要想利用符号表解析出崩溃对应位置，需要计算出符号表中对应的崩溃堆栈地址。而从上述堆栈中第9行可以看到，应用崩溃发生在运行时地址<code>0x000f0846</code>，该进程的运行时起始地址是<code>0xa2000</code>，崩溃处距离进程起始地址的偏移量为十进制的<code>321606</code>(对应十六进制为<code>0x4E846</code>)。三者对应关系：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x000f0846</span> = <span class="number">0xa2000</span> + <span class="number">0x4E846</span></span><br></pre></td></tr></table></figure></p>
<p>对应的公式为：<br><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">运行时堆栈地址 </span>=<span class="string"> 运行时起始地址 + 偏移量</span></span><br></pre></td></tr></table></figure></p>
<p>崩溃堆栈中的起始地址和崩溃地址均为运行时地址，根据虚拟内存偏移量不变原理，只要提供了符号表TEXT段的起始地址，再加上偏移量（这里为0x4E846）就能得到符号表中的堆栈地址，即：<br><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">符号表堆栈地址 </span>=<span class="string"> 符号表起始地址 + 偏移量</span></span><br></pre></td></tr></table></figure></p>
<h4 id="2、获取符号表中的TEXT段起始地址">2、获取符号表中的TEXT段起始地址</h4><p>符号表中TEXT段的起始地址可以通过以下命令获得：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$otool</span> -l Your<span class="class">.app</span><span class="class">.dSYM</span>/Contents/Resources/DWARF/Your</span><br></pre></td></tr></table></figure></p>
<p>运行结果中的片段如下：<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Load command 3</span><br><span class="line">      cmd LC_SEGMENT</span><br><span class="line">  cmdsize 736</span><br><span class="line">  segname __TEXT</span><br><span class="line">   vmaddr <span class="number">0x00004000</span></span><br><span class="line">   vmsize <span class="number">0x00700000</span></span><br><span class="line">  fileoff 0</span><br><span class="line"> filesize 0</span><br><span class="line">  maxprot <span class="number">0x00000005</span></span><br><span class="line"> initprot <span class="number">0x00000005</span></span><br><span class="line">   nsects 10</span><br><span class="line">    flags 0x0</span><br></pre></td></tr></table></figure></p>
<p>其中的<code>vmaddr 0x00004000</code>字段即为TEXT段的起始地址。</p>
<h4 id="3、计算符号表地址">3、计算符号表地址</h4><p>由公式：</p>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">符号表堆栈地址 </span>=<span class="string"> 符号表起始地址 + 偏移量</span></span><br></pre></td></tr></table></figure>
<p>可得：<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x52846</span> = <span class="number">0x4E846</span> + 0x4000</span><br></pre></td></tr></table></figure></p>
<p>即符号表中的崩溃地址为<code>0x52846</code>，接下来就可以根据这个地址解析出崩溃位置了。</p>
<h3 id="崩溃信息还原">崩溃信息还原</h3><p>有了符号表的崩溃地址，有以下几种方式解析崩溃信息：</p>
<h4 id="dwarfdump">dwarfdump</h4><p>命令如下：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">$dwarfdump</span> --<span class="keyword">arch</span> armv7 Your.<span class="keyword">app</span>.dSYM --<span class="keyword">lookup</span> 0x52846 | grep '<span class="keyword">Line</span> <span class="keyword">table</span>'</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是：</p>
<ul>
<li><p>这里的armv7是运行设备的CPU指令集，而不是二进制文件的指令集, 比如armv7指令集的二进制文件运行在arm64指令集的设备上，这个地方应该写arm64。</p>
</li>
<li><p><code>—lookup</code>后面跟的一定是经过准确计算的符号表中的崩溃地址</p>
</li>
<li>使用dwarfdump解析的结果较杂乱，因此使用grep命令抓取其中关键点展示出来</li>
</ul>
<p>运行结果如下：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Line</span> <span class="keyword">table</span> <span class="keyword">dir</span> : '/data/.../Src/OBDConnectSetting/Controller'</span><br><span class="line"><span class="keyword">Line</span> <span class="keyword">table</span> <span class="keyword">file</span>: 'OBDFirstConnectViewController.<span class="keyword">m</span>' <span class="keyword">line</span> 882, column 5 with start address 0x000000000052768</span><br></pre></td></tr></table></figure></p>
<p>其中第一行是编译时文件目录，第二行包含了崩溃发生的文件名称以及文件中具体行号等信息，有了这些信息就能准确定位崩溃原因啦。</p>
<h4 id="atos">atos</h4><p>atos是另一种更加简洁的崩溃日志解析方法，使用方式如下：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">$atos</span> -o LuBao -<span class="keyword">arch</span> armv7 0x52846</span><br></pre></td></tr></table></figure></p>
<p>其执行结果如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-[OBDFirstConnectViewController showOilPricePickerView] (<span class="keyword">in</span> Your) (OBDFirstConnectViewController<span class="class">.m</span>:<span class="number">882</span>)</span><br></pre></td></tr></table></figure></p>
<p>相对<code>dwarfdump</code>命令的解析结果，更加简洁直观的指出了崩溃发生的位置。</p>
<h4 id="无需符号表崩溃地址的解析方式">无需符号表崩溃地址的解析方式</h4><p>实际上，<code>atos</code>还提供了另外一种无需计算崩溃地址对应的符号表地址的方式，命令格式如下：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">$atos</span> -o Your.<span class="keyword">app</span>.dSYM/Contents/Resources/DWARF/Your -<span class="keyword">arch</span> armv7 -<span class="keyword">l</span> 0xa2000 0x000f0846</span><br></pre></td></tr></table></figure>
<p>其中-l选项指定了二进制文件在运行时的起始地址0xa2000（获取方式见Binary Images相关内容）,后面跟的是崩溃发生的运行时地址0x000f0846，解析结果和使用计算得到的符号表中崩溃地址一致：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-[OBDFirstConnectViewController showOilPricePickerView] (<span class="keyword">in</span> Your) (OBDFirstConnectViewController<span class="class">.m</span>:<span class="number">882</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="参考文档">参考文档</h3><p><a href="https://developer.apple.com/library/mac/qa/qa1765/_index.html" target="_blank" rel="external">How to Match a Crash Report to a Build</a><br><a href="https://developer.apple.com/library/mac/technotes/tn2004/tn2123.html" target="_blank" rel="external">CrashReporter</a><br><a href="https://developer.apple.com/library/ios/technotes/tn2151/_index.html" target="_blank" rel="external">Understanding and Analyzing iOS Application Crash Reports</a><br><a href="http://stackoverflow.com/a/12464678/2293677" target="_blank" rel="external">atos and dwarfdump won’t symbolicate my address</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://foggry.com/blog/2015/07/27/ru-he-shou-dong-jie-xi-crashlog/">转自</a></p>
<h2 id="如何手动解析CrashLog">如何手动解析CrashLog</h2><p>解决崩溃问题是移动应用开发者最日常的工作之一。如果是开发过程中遇到的崩溃，可以根据重现步骤调试，但线上版本就无能为力了。好在目前已经有很多不错的第三方CrashLog搜集平台（如友盟、Crashlytics等）为我们做好了解析工作，甚至在Xcode7里苹果也跟进了解析线上版本崩溃日志的功能，为开发者减轻了不少负担。尽管通常已经不需要我们手工处理CrashLog，了解CrashLog的还原原理和方法还是有必要的。</p>
<h3 id="-dSYM">.dSYM</h3><p><code>.dSYM(debugging SYMbols)</code>又称为调试符号表，是苹果为了方便调试和定位问题而使用的一种调试方案，本质上使用的是起源于贝尔实验室的DWARF（Debugging With Attributed Record Formats），其在<code>.xcarchive</code>目录中的层次结构为：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.xcarchive</span><br><span class="line"><span class="comment">--dSYMs</span></span><br><span class="line">  |<span class="comment">--Your.app.dSYM</span></span><br><span class="line">    |<span class="comment">--Contents</span></span><br><span class="line">      |<span class="comment">--Resources</span></span><br><span class="line">        |<span class="comment">--DWARF</span></span><br></pre></td></tr></table></figure></p>
<p>关于DWARF的具体内容以后有机会再说。我们能解析CrashLog全靠.dSYM文件，解析方式见后文。</p>]]>
    
    </summary>
    
      <category term="Debug" scheme="http://ytlvy.com/tags/Debug/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS NSURLProtocal]]></title>
    <link href="http://ytlvy.com/2015/08/04/iOS-NSURLProtocal/"/>
    <id>http://ytlvy.com/2015/08/04/iOS-NSURLProtocal/</id>
    <published>2015-08-04T13:34:18.000Z</published>
    <updated>2015-08-04T13:34:49.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://xiangwangfeng.com/2014/11/29/NSURLProtocol%E5%92%8CNSRunLoop%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/" target="_blank" rel="external">转自</a><br>最近用AFNetworking替换掉了工程里的ASIHttpRequest，结果陆续碰到很多问题：</p>
<ul>
<li>如何统一地添加全局的HTTP头(不仅仅是UA而已)</li>
<li>如何优雅地进行流量统计</li>
<li>对特定的地址进行CDN加速(URL到IP的替换)</li>
<li>怎么实现HTTP的同步请求</li>
</ul>
<p>前三个需求对于ASIHttpReqeust来说都不是问题，只需要在几个统一的点进行修改即可。而使用AFNetworking后就没有那么容易了：一方面AFNetworking中生成NSURLRequest的点比较多，并没有一个统一的路径。其次工程中会有部分直接使用NSURLConnecion的场景，无法统一。经cyzju提醒发现了NSURLProtocol这个大杀器，可惜对应的文档过于简略，唯一比较详细的介绍就只有RW的这篇教程而已，掉了很多坑，值得记上一笔。</p>
<h2 id="NSURLProtocol">NSURLProtocol</h2><h3 id="概念">概念</h3><p>NSURLProtocol也是苹果众多黑魔法中的一种，使用它可以轻松地重定义整个URL Loading System。当你注册自定义NSURLProtocol后，就有机会对所有的请求进行统一的处理，基于这一点它可以让你</p>
<ul>
<li>自定义请求和响应</li>
<li>提供自定义的全局缓存支持</li>
<li>重定向网络请求</li>
<li>提供HTTP Mocking (方便前期测试)</li>
<li>其他一些全局的网络请求修改需求</li>
</ul>
<a id="more"></a>
<h3 id="使用方法">使用方法</h3><p>继承NSURLPorotocl，并注册你的NSURLProtocol<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[NSURLProtocol registerClass:<span class="collection">[YXURLProtocol class]</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>当NSURLConnection准备发起请求时，它会遍历所有已注册的NSURLProtocol，询问它们能否处理当前请求。所以你需要尽早注册这个Protocol。<br>实现NSURLProtocol的相关方法<br>当遍历到我们自定义的NSURLProtocol时，系统先会调用canInitWithRequest:这个方法。顾名思义，这是整个流程的入口，只有这个方法返回YES我们才能够继续后续的处理。我们可以在这个方法的实现里面进行请求的过滤，筛选出需要进行处理的请求。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)canInitWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSURLProtocol</span> propertyForKey:YXURLProtocolHandled inRequest:request])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSString</span> *scheme = [[request URL] scheme];</span><br><span class="line">    <span class="built_in">NSDictionary</span> *dict = [request allHTTPHeaderFields];</span><br><span class="line">    <span class="keyword">return</span> [dict objectForKey:<span class="string">@"custom_header"</span>] == <span class="literal">nil</span> &amp;&amp;</span><br><span class="line">    ([scheme caseInsensitiveCompare:<span class="string">@"http"</span>] == <span class="built_in">NSOrderedSame</span> ||</span><br><span class="line">     [scheme caseInsensitiveCompare:<span class="string">@"https"</span>] == <span class="built_in">NSOrderedSame</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当筛选出需要处理的请求后，就可以进行后续的处理，需要至少实现如下4个方法<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSURLRequest</span> *)canonicalRequestForRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="built_in">BOOL</span>)requestIsCacheEquivalent:(<span class="built_in">NSURLRequest</span> *)a</span><br><span class="line">                       toRequest:(<span class="built_in">NSURLRequest</span> *)b</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> requestIsCacheEquivalent:a toRequest:b];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)startLoading</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableReqeust = [[<span class="keyword">self</span> request] mutableCopy];</span><br><span class="line">    [YXURLProtocol applyCustomHeaders:mutableReqeust];</span><br><span class="line">    [<span class="built_in">NSURLProtocol</span> setProperty:@(<span class="literal">YES</span>)</span><br><span class="line">                        forKey:YXURLProtocolHandled</span><br><span class="line">                     inRequest:mutableReqeust];</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">self</span><span class="variable">.connection</span> = [<span class="built_in">NSURLConnection</span> connectionWithRequest:mutableReqeust</span><br><span class="line">                                                    delegate:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)stopLoading</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.connection</span> cancel];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.connection</span> = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>canonicalRequestForRequest:</code> 返回规范化后的request,一般就只是返回当前request即可。</li>
<li><code>requestIsCacheEquivalent:toRequest:</code>用于判断你的自定义reqeust是否相同，这里返回默认实现即可。它的主要应用场景是某些直接使用缓存而非再次请求网络的地方。</li>
<li><code>startLoading</code> 和 <code>stopLoading</code> 实现请求和取消流程。</li>
</ul>
<h3 id="实现NSURLConnectionDelegate和NSURLConnectionDataDelegate">实现NSURLConnectionDelegate和NSURLConnectionDataDelegate</h3><p>因为在第二步中我们接管了整个请求过程，所以需要实现相应的协议并使用NSURLProtocolClient将消息回传给URL Loading System。在我们的场景中推荐实现所有协议。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection</span><br><span class="line">  didFailWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.client</span> URLProtocol:<span class="keyword">self</span></span><br><span class="line">            didFailWithError:error];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSURLRequest</span> *)connection:(<span class="built_in">NSURLConnection</span> *)connection willSendRequest:(<span class="built_in">NSURLRequest</span> *)request redirectResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (response != <span class="literal">nil</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        [[<span class="keyword">self</span> client] URLProtocol:<span class="keyword">self</span> wasRedirectedToRequest:request redirectResponse:response];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">BOOL</span>)connectionShouldUseCredentialStorage:(<span class="built_in">NSURLConnection</span> *)connection</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection</span><br><span class="line">didReceiveAuthenticationChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.client</span> URLProtocol:<span class="keyword">self</span></span><br><span class="line">didReceiveAuthenticationChallenge:challenge];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection</span><br><span class="line">didCancelAuthenticationChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge </span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.client</span> URLProtocol:<span class="keyword">self</span></span><br><span class="line">didCancelAuthenticationChallenge:challenge];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection</span><br><span class="line">didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.client</span> URLProtocol:<span class="keyword">self</span></span><br><span class="line">          didReceiveResponse:response</span><br><span class="line">          cacheStoragePolicy:[[<span class="keyword">self</span> request] cachePolicy]];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection</span><br><span class="line">    didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.client</span> URLProtocol:<span class="keyword">self</span></span><br><span class="line">                 didLoadData:data];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSCachedURLResponse</span> *)connection:(<span class="built_in">NSURLConnection</span> *)connection</span><br><span class="line">                  willCacheResponse:(<span class="built_in">NSCachedURLResponse</span> *)cachedResponse</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> cachedResponse;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.client</span> URLProtocolDidFinishLoading:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在每个delgate的实现中我都刨去了工程中的特定实现(流量统计)，只保留了需要实现的最小Protocol集合。</p>
<h3 id="NSURLProtocol那些坑">NSURLProtocol那些坑</h3><p>从上面的介绍来看，NSURLProtocol还是比较简单，但是实际使用的过程中却容易掉进各种坑，一方面是文档不够详尽，另一方面也是对于苹果这套URL Loading Sytem并不熟悉，不能将整个调用过程有机地统一。</p>
<p>1) 坑1：企图在<code>canonicalRequestForRequest:</code>进行request的自定义操作，导致各种递归调用导致连接超时。这个API的表述其实很暧昧:</p>
<blockquote>
<p>It is up to each concrete protocol implementation to define what “canonical” means. A protocol should guarantee that the same input request always yields the same canonical form.</p>
</blockquote>
<p>所谓的canonical form到底是什么呢？而围观了包括<code>NSEtcHosts</code>和<code>RNCachingURLProtocol</code>在内的实现，它们都是直接返回当前request。在这个方法内进行request的修改非常容易导致递归调用(即使通过<code>setProperty:forKey:inRequest:</code>对请求打了标记)</p>
<p>2) 坑2：没有实现足够的回调方法导致各种奇葩问题。如<code>connection:willSendRequest:redirectResponse:</code>内如果没有通过<code>[self client]</code>回传消息，那么需要重定向的网页就会出现问题:host不对或者造成跨域调用导致资源无法加载。</p>
<h3 id="同步AFNetworking请求">同步AFNetworking请求</h3><p>虽然Mattt各种鄙视同步做网络请求，但是我们不可否认某些场景下使用同步调用会带来不少便利。一种比较简单的实现是使用信号量做同步：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AFHTTPRequestOperation</span> (<span class="title">YX</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)yxStartSynchronous</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line">    [<span class="keyword">self</span> setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject) &#123;</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125; failure:^(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;];</span><br><span class="line">    [<span class="keyword">self</span> start];</span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>但是这样带来的问题是在UI线程调用同步请求就会导致线程堵死崩溃(好吧，就不应该允许UI线程上这么做)。一种改进的方法是使用NSRunLoop<br>即：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">while</span> (_shouldBlock)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr_selector">[[NSRunLoop currentRunLoop]</span> <span class="tag">runMode</span><span class="pseudo">:NSDefaultRunLoopMode</span></span><br><span class="line">                             <span class="tag">beforeDate</span>:<span class="attr_selector">[NSDate distantFuture]</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是这种写法是有大坑的：如果当前<code>NSRunLoop</code>并没有任何NSTimer或<code>Input Source</code>，<code>runMode:beforeDate:</code>方法将立刻返回NO，于是造成死循环，占用大量CPU，进而导致<code>NSURLConnection</code>请求超时。 </p>
<p>规避的方法是往RunLoop中添加NSTimer或者空NSPort使得NSRunLoop挂起而不占用CPU。(ASIHttpRequest就是在当前RunLoop中添加了0.25秒触发一次的刷新Timer)</p>
<blockquote>
<p>If no input sources or timers are attached to the run loop, this method exits immediately and returns NO; otherwise, it returns after either the first input source is processed or limitDate is reached. Manually removing all known input sources and timers from the run loop does not guarantee that the run loop will exit immediately. OS X may install and remove additional input sources as needed to process requests targeted at the receiver’s thread. Those sources could therefore prevent the run loop from exiting.</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://xiangwangfeng.com/2014/11/29/NSURLProtocol%E5%92%8CNSRunLoop%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/">转自</a><br>最近用AFNetworking替换掉了工程里的ASIHttpRequest，结果陆续碰到很多问题：</p>
<ul>
<li>如何统一地添加全局的HTTP头(不仅仅是UA而已)</li>
<li>如何优雅地进行流量统计</li>
<li>对特定的地址进行CDN加速(URL到IP的替换)</li>
<li>怎么实现HTTP的同步请求</li>
</ul>
<p>前三个需求对于ASIHttpReqeust来说都不是问题，只需要在几个统一的点进行修改即可。而使用AFNetworking后就没有那么容易了：一方面AFNetworking中生成NSURLRequest的点比较多，并没有一个统一的路径。其次工程中会有部分直接使用NSURLConnecion的场景，无法统一。经cyzju提醒发现了NSURLProtocol这个大杀器，可惜对应的文档过于简略，唯一比较详细的介绍就只有RW的这篇教程而已，掉了很多坑，值得记上一笔。</p>
<h2 id="NSURLProtocol">NSURLProtocol</h2><h3 id="概念">概念</h3><p>NSURLProtocol也是苹果众多黑魔法中的一种，使用它可以轻松地重定义整个URL Loading System。当你注册自定义NSURLProtocol后，就有机会对所有的请求进行统一的处理，基于这一点它可以让你</p>
<ul>
<li>自定义请求和响应</li>
<li>提供自定义的全局缓存支持</li>
<li>重定向网络请求</li>
<li>提供HTTP Mocking (方便前期测试)</li>
<li>其他一些全局的网络请求修改需求</li>
</ul>]]>
    
    </summary>
    
      <category term="Network" scheme="http://ytlvy.com/tags/Network/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[dSYM parse tool]]></title>
    <link href="http://ytlvy.com/2015/08/04/dSYM-parse-tool/"/>
    <id>http://ytlvy.com/2015/08/04/dSYM-parse-tool/</id>
    <published>2015-08-04T13:33:22.000Z</published>
    <updated>2015-08-04T13:33:51.000Z</updated>
    <content type="html"><![CDATA[<h2 id="dSYM_文件">dSYM 文件</h2><h3 id="什么是_dSYM_文件">什么是 dSYM 文件</h3><p>Xcode编译项目后，我们会看到一个同名的 <code>dSYM</code> <code>文件，dSYM</code> 是保存 16 进制函数地址映射信息的中转文件，我们调试的 symbols 都会包含在这个文件中，并且每次编译项目的时候都会生成一个新的 dSYM 文件，位于 <code>/Users/&lt;用户名&gt;/Library/Developer/Xcode/Archives</code> 目录下，对于每一个发布版本我们都很有必要保存对应的 <code>Archives</code> 文件 ( AUTOMATICALLY SAVE THE DSYM FILES 这篇文章介绍了通过脚本每次编译后都自动保存 dSYM 文件)。</p>
<h3 id="dSYM_文件有什么作用">dSYM 文件有什么作用</h3><p>当我们软件 release 模式打包或上线后，不会像我们在 Xcode 中那样直观的看到用崩溃的错误，这个时候我们就需要分析 crash report 文件了，iOS 设备中会有日志文件保存我们每个应用出错的函数内存地址，通过 Xcode 的 Organizer 可以将 iOS 设备中的 DeviceLog 导出成 crash 文件，这个时候我们就可以通过出错的函数地址去查询 dSYM 文件中程序对应的函数名和文件名。大前提是我们需要有软件版本对应的 dSYM 文件，这也是为什么我们很有必要保存每个发布版本的 Archives 文件了。</p>
<a id="more"></a>
<h3 id="如何将文件一一对应">如何将文件一一对应</h3><p>每一个 xx.app 和 xx.app.dSYM 文件都有对应的 UUID，crash 文件也有自己的 UUID，只要这三个文件的 UUID 一致，我们就可以通过他们解析出正确的错误函数信息了。</p>
<p>1) 查看 xx.app 文件的 UUID，terminal 中输入命令 ：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dwarfdump <span class="comment">--uuid xx.app/xx (xx代表你的项目名)</span></span><br></pre></td></tr></table></figure></p>
<p>2) 查看 xx.app.dSYM 文件的 UUID ，在 terminal 中输入命令：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dwarfdump --uuid xx<span class="class">.app</span><span class="class">.dSYM</span></span><br></pre></td></tr></table></figure></p>
<p>3) crash 文件内第一行 Incident Identifier 就是该 crash 文件的 UUID。</p>
<h3 id="dSYM工具">dSYM工具</h3><p>于是我抽了几个小时的时间将这些命令封装到一个应用中，也为以后解决bug提供了便利。</p>
<p>使用步骤:</p>
<ol>
<li>将打包发布软件时的xcarchive文件拖入软件窗口内的任意位置(支持多个文件同时拖入，注意：文件名不要包含空格)</li>
<li>选中任意一个版本的xcarchive文件，右边会列出该xcarchive文件支持的CPU类型，选中错误对应的CPU类型。</li>
<li>对比错误给出的UUID和工具界面中给出的UUID是否一致。</li>
<li>将错误地址输入工具的文本框中，点击分析。</li>
</ol>
<p><img src="http://bcs.duapp.com/answerhuang/blog/dsymTool.png" alt=""></p>
<p><a href="http://pan.baidu.com/s/1bnkxPvT" target="_blank" rel="external">Mac App</a><br><a href="https://github.com/answer-huang/dSYMTools" target="_blank" rel="external">项目源码</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="dSYM_文件">dSYM 文件</h2><h3 id="什么是_dSYM_文件">什么是 dSYM 文件</h3><p>Xcode编译项目后，我们会看到一个同名的 <code>dSYM</code> <code>文件，dSYM</code> 是保存 16 进制函数地址映射信息的中转文件，我们调试的 symbols 都会包含在这个文件中，并且每次编译项目的时候都会生成一个新的 dSYM 文件，位于 <code>/Users/&lt;用户名&gt;/Library/Developer/Xcode/Archives</code> 目录下，对于每一个发布版本我们都很有必要保存对应的 <code>Archives</code> 文件 ( AUTOMATICALLY SAVE THE DSYM FILES 这篇文章介绍了通过脚本每次编译后都自动保存 dSYM 文件)。</p>
<h3 id="dSYM_文件有什么作用">dSYM 文件有什么作用</h3><p>当我们软件 release 模式打包或上线后，不会像我们在 Xcode 中那样直观的看到用崩溃的错误，这个时候我们就需要分析 crash report 文件了，iOS 设备中会有日志文件保存我们每个应用出错的函数内存地址，通过 Xcode 的 Organizer 可以将 iOS 设备中的 DeviceLog 导出成 crash 文件，这个时候我们就可以通过出错的函数地址去查询 dSYM 文件中程序对应的函数名和文件名。大前提是我们需要有软件版本对应的 dSYM 文件，这也是为什么我们很有必要保存每个发布版本的 Archives 文件了。</p>]]>
    
    </summary>
    
      <category term="IOS" scheme="http://ytlvy.com/tags/IOS/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Variable Argument Lists]]></title>
    <link href="http://ytlvy.com/2015/08/04/Variable-Argument-Lists/"/>
    <id>http://ytlvy.com/2015/08/04/Variable-Argument-Lists/</id>
    <published>2015-08-04T13:30:58.000Z</published>
    <updated>2015-08-04T13:31:18.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://gracelancy.com/blog/2014/05/05/variable-argument-lists/" target="_blank" rel="external">转自</a></p>
<h2 id="Variable_Argument_Lists">Variable Argument Lists</h2><h3 id="Variable_argument_lists_使用方法">Variable argument lists 使用方法</h3><p>可变参数函数（<code>Variadic Function</code>），即是指一个可以接受可变数量的参数的函数。在C语言中，对该特性的支持，即是通过可变参数列表（Variable Argument list）来实现的，其定义在stdarg.h头文件。(若使用C++则在cstdarg头文件)。</p>
<p>以如下C代码为例说明，该函数接受可变数量的整数作为参数，求和：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> addemUp (<span class="keyword">int</span> firstNum, ...) &#123;</span><br><span class="line">  <span class="comment">// 1. 参数后面添加省略号...</span></span><br><span class="line">    va_list args;  <span class="comment">// 2. 创建一个va_list类型的变量</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">sum</span> = firstNum;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    va_start(args, firstNum); <span class="comment">// 3. 初始化va_list，此时va_list指向firstNum之后的第一个参数</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        number = va_arg(args, <span class="keyword">int</span>); <span class="comment">// 4. 获取当前指向的参数的值，并移动到下一个参数</span></span><br><span class="line">        <span class="keyword">sum</span> += number;</span><br><span class="line">        <span class="keyword">if</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 用0表示结束</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(args); <span class="comment">// 5. 清理</span></span><br><span class="line">    <span class="keyword">return</span>  <span class="keyword">sum</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">sum</span> = addemUp(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">// sum = 15</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>要创建一个可变参数函数，需要把一个省略号（…)放在函数的参数列表后面。</li>
<li>接着需要声明一个一个<code>va_list</code>类型的变量，这个<code>va_list</code>类型的变量类似于一个指向参数的指针。</li>
<li>接着我们调用<code>va_start()</code>并传入函数的最后一个声明的参数的变量名，来使得<code>va_list</code>变量指向第一个附加的参数。</li>
<li>接着我们调用<code>va_arg()</code>并传入我们期待的参数类型，程序就会返回与该类型匹配数量的字节（即参数的值），并且移动va_list指向下一个参数。之后不断的调用<code>va_arg()</code>，获得更多的参数的值，直到完成整个参数处理的过程。</li>
<li>最后调用<code>va_end()</code>来进行清理。</li>
</ol>
<h3 id="variable_argument_lists_的内部机制">variable argument lists 的内部机制</h3><p>如我们之前所说，当我们调用 <code>va_start()</code> 并将 <code>va_list</code> 和函数最后定义的参数传入时，实际上是将 <code>va_list</code> 内在的一个指针指向函数调用栈 （<code>call stack</code>）中参数所在的区域的一端，每一次我们调用<code>va_arg()</code>，其都会根据提供的类型，返回当前指针所指向的地址开始对应的字节数的数据，即参数的值，并移动指针相应字节数的距离。我们传给<code>va_arg()</code>的类型，即是其用来判定需要取得得数据的大小，以及指针需要移动的距离。如图描述了这个过程：</p>
<p><img src="http://gracelancy.com/assets/post/val0.png" alt=""></p>
<p>事实上，这是一个很危险的事情，你总是需要提供正确的类型来让va_arg()正确执行，而且va_arg()并不知道何时停止，你需要提供一个标记或一个参数的总数来停止va_arg()继续执行。若你提供了不正确的类型，或者没有在该停止的时候停止，你将会获得不可预测的值，并且很有可能导致程序崩溃。</p>
<h2 id="解决方案">解决方案</h2><p>一般而言，为了确保参数的获取正确进行，有如下两种解决方案：</p>
<h3 id="Format_string">Format string</h3><p>如C语言中的<code>printf</code>，Cocoa中的<code>NSLog</code>，<code>[NSString stringWithFormat:]</code>就是使用了<code>Format String</code>的解决方案。通常，该函数的第一个参数既为一个<code>format string</code>，函数内部实现会扫描这个<code>format string</code>，来确定之后接着的可变参数的数量和类型。例如：</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString <span class="variable">*str</span> = [NSString stringWithFormat:<span class="variable">@"</span><span class="keyword">int</span> <span class="variable">%d</span>, str <span class="variable">%@</span>, <span class="keyword">float</span> <span class="variable">%g</span><span class="string">", 123, @"</span>ok<span class="string">", 123.4];</span></span><br></pre></td></tr></table></figure>
<p>这里使用了<code>%</code>作为转义符，其后跟着的<code>d</code>代表<code>int</code>，<code>@</code>代表<code>id</code>，<code>g</code>代表<code>float/double</code>，这表示后面必须有三个参数，其类型必须与<code>format string</code>所指定的一致。</p>
<p>如之前所说，提供的参数的数量或者类型若与提供的<code>format string</code>不一致，则会发生不可预知的问题。而在运行的时候，我们没有任何的办法去保证其正确性，幸运的是编译器提供了一些方法，能让我们在编译的时候做一些检查：</p>
<p>gcc中定义了<code>__attribute__((format))</code>来标示一个可变参函数使用了<code>format string</code>，从而在编译时对其进行检查。其定义为<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">format</span> (archetype, <span class="keyword">string</span>-index, <span class="keyword">first</span>-<span class="built_in">to</span>-check)</span><br></pre></td></tr></table></figure></p>
<ol>
<li><code>archetype</code>代表<code>format string</code>的类型，它可以是<code>printf</code>，<code>scanf</code>，<code>strftime</code>或者<code>strfmon</code>，Cocoa开发者还可以使用<code>__NSString__</code>来指定其使用和<code>[NSString stringWithFormat:]</code>与<code>NSLog(</code>)一致的<code>format string</code>规则。</li>
<li><code>string-index</code>代表<code>format string</code>是第几个参数，</li>
<li><code>first-to-check</code>则代表了可变参数列表从第几个参数开始。</li>
</ol>
<p>示例：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 第一个参数是<span class="keyword">format</span>，第二个参数起是可变参数列表，<span class="keyword">format</span>的格式规则与<span class="keyword">printf</span>一致</span><br><span class="line">void customPrintf(const char *<span class="keyword">format</span>, ...) __attribute_<span class="number">_</span>((<span class="keyword">format</span>(<span class="keyword">printf</span>, <span class="number">1</span>, <span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 使用的时候，若<span class="keyword">format</span>和参数不符，则会报warning</span><br><span class="line">customPrintf(<span class="string">"what? <span class="variable">%d</span>"</span>, <span class="number">1.2</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p>Cocoa开发者可以使用<code>NS_FORMAT_FUNCTION(F,A)</code>宏来替代<code>__atribute__format</code>，F和A即对应<code>string-index</code>和<code>first-to-check</code>，事实上，他的实现类似于：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hexcolor">#def</span>ine <span class="function"><span class="title">NS_FORMAT_FUNCTION</span><span class="params">(F,A)</span></span> __attribute__((<span class="function"><span class="title">format</span><span class="params">(__NSString__, F, A)</span></span>))</span><br></pre></td></tr></table></figure>
<p>示例如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FOUNDATION_EXPORT <span class="keyword">void</span> <span class="built_in">NSLog</span>(<span class="built_in">NSString</span> *format, ...) <span class="built_in">NS_FORMAT_FUNCTION</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="Sentinel_value">Sentinel value</h3><p>哨兵值是另一种可变参数列表所常用的方案，如前一节我们的示例代码，即是使用了数字0作为哨兵值。当程序发现当前读取到的参数值为0时，则停止继续读取程序。在Cocoa中，我们经常使用<code>nil</code>作为哨兵值，比如<code>[NSArray arrayWithObjects:]</code>方法，其接受数量不等的对象作为参数，而在最后则必须使用<code>nil</code>结尾。如：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="constant">NSArray </span><span class="symbol">arrayWithObjects:</span><span class="variable">@1</span>, <span class="variable">@2</span>, <span class="variable">@3</span>, <span class="keyword">nil</span>];</span><br><span class="line"><span class="regexp">//</span>备注：我们现在通常使用@[<span class="variable">@1</span>, <span class="variable">@2</span>, <span class="variable">@3</span>]来代替这一行代码，且不需要在最后添加<span class="keyword">nil</span>，这称为字面量（<span class="constant">Literals)</span></span><br></pre></td></tr></table></figure>
<p>同<code>format string</code>一样危险的是，若开发者调用方法（函数）的时候，忘记在最后添加上哨兵值，则会发生不可预知的问题。同样幸运的是，编译器也为我们提供了一些方法来在编译时进行检查。<br>gcc中定义了<code>___attribute__((sentinel))</code>来标示一个函数需要在编译的时候对哨兵值进行检查。用法如下：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int addemUp <span class="list">(<span class="keyword">int</span> firstNum, ...)</span> __attribute__<span class="list">(<span class="list">(<span class="keyword">sentinel</span>)</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>Cocoa开发者可以使用<code>NS_REQUIRES_NIL_TERMINATION</code>宏来替代，其实现基本等同于上述代码：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="tag">instancetype</span>)<span class="rule"><span class="attribute">arrayWithObjects</span>:<span class="value">(id)firstObj, ... NS_REQUIRES_NIL_TERMINATION</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="工程实例">工程实例</h3><p>我在开发猿题库iOS客户端时，由于产品的需要会有许多<code>alert</code>弹框。但传统的<code>UIAlertView</code>经常需要实现相应的<code>UIAlertViewDelegate</code>，使用起来非常不便。我写了一个能够接收block作为回调的自定义的AlertView组件，同时为了保证其接口与UIAlertView基本一致，使用了可变参数列表。其接口定义如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CYAlertView</span> : <span class="title">UIAlertView</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)initWithTitle:(<span class="built_in">NSString</span> *)title</span><br><span class="line">            message:(<span class="built_in">NSString</span> *)message</span><br><span class="line">         clickedBlock:(<span class="keyword">void</span> (^)(CYAlertView *alertView, <span class="built_in">BOOL</span> cancelled, <span class="built_in">NSInteger</span> buttonIndex))clickedBlock</span><br><span class="line">  cancelButtonTitle:(<span class="built_in">NSString</span> *)cancelButtonTitle</span><br><span class="line">  otherButtonTitles:(<span class="built_in">NSString</span> *)otherButtonTitles, ... <span class="built_in">NS_REQUIRES_NIL_TERMINATION</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>完整的代码开源托管在GitHub（传送门），有兴趣的同学可以参考。</p>
<h2 id="参考">参考</h2><p><a href="http://clang.llvm.org/docs/AttributeReference.html#format-gnu-format" target="_blank" rel="external">Clang 3.5 documentation: Attributes in Clang</a><br><a href="http://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html" target="_blank" rel="external">GCC documentation: Function Attributes</a><br><a href="http://nshipster.com/__attribute__/" target="_blank" rel="external">NSHisper: attribute</a><br>Advanced Mac OS X Programming</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://gracelancy.com/blog/2014/05/05/variable-argument-lists/" target="_blank" rel="external">转自</a></p>
<h2 id="Variable_Argum]]>
    </summary>
    
      <category term="Argument" scheme="http://ytlvy.com/tags/Argument/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS bit computing]]></title>
    <link href="http://ytlvy.com/2015/08/04/iOS-bit-computing/"/>
    <id>http://ytlvy.com/2015/08/04/iOS-bit-computing/</id>
    <published>2015-08-04T13:30:00.000Z</published>
    <updated>2015-08-04T13:30:22.000Z</updated>
    <content type="html"><![CDATA[<h2 id="iOS_位与位运算">iOS 位与位运算</h2><h3 id="介绍">介绍</h3><p>位操作是程序设计中对位模式或二进制数的一元和二元操作. 在许多古老的微处理器上, 位运算比加减运算略快, 通常位运算比乘除法运算要快很多. 在现代架构中, 情况并非如此:位运算的运算速度通常与加法运算相同(仍然快于乘法运算).（摘自wikipedia）<br>OC作为c的扩展和超集，位运算自然使用的是c的操作符。c提供了6个位操作符，$，|，^，~，&lt;&lt;，&gt;&gt;。本文不打算做位运算的基础教学，只介绍一些开发中能用到的场景。</p>
<h3 id="提高运算速度">提高运算速度</h3><p>如前一段所说，位运算的运算速度是通常与加法速度相当，但是快于乘法运算的。故而如果我们的程序对性能有要求，我们可以使用位运算来提高运算速度。比如：</p>
<ul>
<li>乘以2：n &lt;&lt; 1;</li>
<li>除以2：n &gt;&gt; 1;</li>
<li>乘以2的m次方：n &lt;&lt; m;</li>
<li>除以2的m次方：n &gt;&gt; m;</li>
<li>判断奇偶：(n &amp; 1) == 1;</li>
<li>求平均数：(a + b) &gt;&gt; 1;</li>
<li>……</li>
</ul>
<p>基于乘除法的位运算提速还有很多，这里不一一列举。需要注意的是，你应当只在遇到性能瓶颈的时候，并且瓶颈的确是计算的时候才这么做。因为使用位运算并不利于程序的可读性和可维护性。（科学计算除外）</p>
<h3 id="压缩空间">压缩空间</h3><p>以前接触过ACM的筒子们应该对状态压缩不陌生，状态压缩的目的在于把一个大数据用有限的内存空间来进行表示。比如 Programming Pearls 里面的一个经典示例：如何对最多有一千万条不重复的7位整数（电话号码）进行排序？且可使用的内存空间有大约1MB多。</p>
<p>显而易见的常规做法既是做一个基于磁盘操作的外排序。然而如果转换一下思路，充分的使用内存中的每一个位，加上不存在重复的电话号码，以及不存在0和1开头的电话号码。我们只需要使用1000万个位（大约1.2mb），就能以集合的方式在内存里标记下所有的数据，从而轻松的实现位排序。此种方法大幅度的减少了IO时间，从而获得巨大的性能提升。</p>
<p>ACM里面有大量的如果使用位来压缩空间的示例，状态压缩的动态规划等，此处不做展开，只告诉读者，充分的使用内存的每一个位，经常能带来意想不到的收获。但需要注意的是，状态的压缩和提取，都需要一定的计算量，有时一味的追求状态压缩，反而会降低效率。</p>
<h3 id="表示数据">表示数据</h3><p>比较经典的一个应用场景，使用一串24位的十六机制数字来表现一个RGB颜色（或者32位来表示ARGB）。由于PS，Web以及各类取色器，都能快速的取出RGB的Hex值，但是UIColor没有对应的方法。故而我们可以写出下面这样一个UIColor的Category，来快速的用一个RGBHex生成一个UIColor。（源码在<a href="http://github.com/lancy/cyhelper" target="_blank" rel="external">UIColor + CYHelper.h</a>）<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (UIColor *)colorWithRGBHex:(UInt32)<span class="built_in">hex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [UIColor colorWithRGBHex:<span class="built_in">hex</span> <span class="built_in">alpha</span>:<span class="number">1.0</span>f];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (UIColor *)colorWithRGBHex:(UInt32)<span class="built_in">hex</span> <span class="built_in">alpha</span>:(CGFloat)<span class="built_in">alpha</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> r = (<span class="built_in">hex</span> &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">    <span class="built_in">int</span> g = (<span class="built_in">hex</span> &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">    <span class="built_in">int</span> b = (<span class="built_in">hex</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [UIColor colorWithRed:r / <span class="number">255.0</span>f <span class="built_in">green</span>:g / <span class="number">255.0</span>f <span class="built_in">blue</span>:b / <span class="number">255.0</span>f <span class="built_in">alpha</span>:<span class="built_in">alpha</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>状态与选项<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">UIViewAnimationOptions</span>) &#123;</span><br><span class="line">    <span class="built_in">UIViewAnimationOptionLayoutSubviews</span>            = <span class="number">1</span> &lt;&lt;  <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">UIViewAnimationOptionAllowUserInteraction</span>      = <span class="number">1</span> &lt;&lt;  <span class="number">1</span>, <span class="comment">// turn on user interaction while animating</span></span><br><span class="line">    <span class="built_in">UIViewAnimationOptionBeginFromCurrentState</span>     = <span class="number">1</span> &lt;&lt;  <span class="number">2</span>, <span class="comment">// start all views from current value, not initial value</span></span><br><span class="line">    <span class="built_in">UIViewAnimationOptionRepeat</span>                    = <span class="number">1</span> &lt;&lt;  <span class="number">3</span>, <span class="comment">// repeat animation indefinitely</span></span><br><span class="line">    <span class="built_in">UIViewAnimationOptionAutoreverse</span>               = <span class="number">1</span> &lt;&lt;  <span class="number">4</span>, <span class="comment">// if repeat, run animation back and forth</span></span><br><span class="line">    <span class="built_in">UIViewAnimationOptionOverrideInheritedDuration</span> = <span class="number">1</span> &lt;&lt;  <span class="number">5</span>, <span class="comment">// ignore nested duration</span></span><br><span class="line">    <span class="built_in">UIViewAnimationOptionOverrideInheritedCurve</span>    = <span class="number">1</span> &lt;&lt;  <span class="number">6</span>, <span class="comment">// ignore nested curve</span></span><br><span class="line">    <span class="built_in">UIViewAnimationOptionAllowAnimatedContent</span>      = <span class="number">1</span> &lt;&lt;  <span class="number">7</span>, <span class="comment">// animate contents (applies to transitions only)</span></span><br><span class="line">    <span class="built_in">UIViewAnimationOptionShowHideTransitionViews</span>   = <span class="number">1</span> &lt;&lt;  <span class="number">8</span>, <span class="comment">// flip to/from hidden state instead of adding/removing</span></span><br><span class="line">    <span class="built_in">UIViewAnimationOptionOverrideInheritedOptions</span>  = <span class="number">1</span> &lt;&lt;  <span class="number">9</span>, <span class="comment">// do not inherit any options or animation type</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIViewAnimationOptionCurveEaseInOut</span>            = <span class="number">0</span> &lt;&lt; <span class="number">16</span>, <span class="comment">// default</span></span><br><span class="line">    <span class="built_in">UIViewAnimationOptionCurveEaseIn</span>               = <span class="number">1</span> &lt;&lt; <span class="number">16</span>,</span><br><span class="line">    <span class="built_in">UIViewAnimationOptionCurveEaseOut</span>              = <span class="number">2</span> &lt;&lt; <span class="number">16</span>,</span><br><span class="line">    <span class="built_in">UIViewAnimationOptionCurveLinear</span>               = <span class="number">3</span> &lt;&lt; <span class="number">16</span>,</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIViewAnimationOptionTransitionNone</span>            = <span class="number">0</span> &lt;&lt; <span class="number">20</span>, <span class="comment">// default</span></span><br><span class="line">    <span class="built_in">UIViewAnimationOptionTransitionFlipFromLeft</span>    = <span class="number">1</span> &lt;&lt; <span class="number">20</span>,</span><br><span class="line">    <span class="built_in">UIViewAnimationOptionTransitionFlipFromRight</span>   = <span class="number">2</span> &lt;&lt; <span class="number">20</span>,</span><br><span class="line">    <span class="built_in">UIViewAnimationOptionTransitionCurlUp</span>          = <span class="number">3</span> &lt;&lt; <span class="number">20</span>,</span><br><span class="line">    <span class="built_in">UIViewAnimationOptionTransitionCurlDown</span>        = <span class="number">4</span> &lt;&lt; <span class="number">20</span>,</span><br><span class="line">    <span class="built_in">UIViewAnimationOptionTransitionCrossDissolve</span>   = <span class="number">5</span> &lt;&lt; <span class="number">20</span>,</span><br><span class="line">    <span class="built_in">UIViewAnimationOptionTransitionFlipFromTop</span>     = <span class="number">6</span> &lt;&lt; <span class="number">20</span>,</span><br><span class="line">    <span class="built_in">UIViewAnimationOptionTransitionFlipFromBottom</span>  = <span class="number">7</span> &lt;&lt; <span class="number">20</span>,</span><br><span class="line">&#125; <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">4</span>_0);</span><br></pre></td></tr></table></figure></p>
<p>我们观察Apple在<code>UIViewAnimationOptions</code>的枚举变量，使用了一个NSUInteger就表示了<code>UIViewAnimation</code>所需的所有Option。其中0~9十个是互不影响的可同时存在option。16~19，20~24使用了4位来表示互斥的option。</p>
<p>如此定义了之后，对<code>UIViewAnimationOptions</code>的赋值变得尤为简单，使用 | 操作符既可以获得一个给对应的option位赋值后的结果。例如：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">UIView</span> animateWithDuration:<span class="number">1</span>.<span class="number">0</span></span><br><span class="line">                      delay:<span class="number">0</span></span><br><span class="line">                    options:<span class="type">UIViewAnimationOptionAllowUserInteraction</span></span><br><span class="line">                         | <span class="type">UIViewAnimationOptionBeginFromCurrentState</span></span><br><span class="line">                         | <span class="type">UIViewAnimationOptionCurveEaseIn</span></span><br><span class="line">                 animations:<span class="decorator">&#123;...&#125;</span></span><br><span class="line">                 completion:<span class="decorator">&#123;...&#125;</span>];</span><br></pre></td></tr></table></figure></p>
<p>提取也比较简单，使用 <code>&amp;</code> 操作符 和 <code>&gt;&gt;</code> 操作符，就可以轻松判定某个位有没有被设置，以及提取某些状态位，例如：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIViewAnimationOptions</span> option = <span class="built_in">UIViewAnimationOptionAllowUserInteraction</span></span><br><span class="line">                                | <span class="built_in">UIViewAnimationOptionBeginFromCurrentState</span></span><br><span class="line">                                | <span class="built_in">UIViewAnimationOptionCurveEaseIn</span></span><br><span class="line">                                | <span class="built_in">UIViewAnimationOptionTransitionCrossDissolve</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (option &amp; <span class="built_in">UIViewAnimationOptionAllowUserInteraction</span>) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"UIViewAnimationOptionAllowUserInteraction has been set"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (option &amp; <span class="built_in">UIViewAnimationOptionBeginFromCurrentState</span>) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"UIViewAnimationOptionBeginFromCurrentState has been set"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">UInt8</span> optionCurve = option &gt;&gt; <span class="number">16</span> &amp; <span class="number">0xf</span>;</span><br><span class="line"><span class="keyword">if</span> (optionCurve == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"UIViewAnimationOptionCurveEaseIn has been set"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">UInt8</span> optionTransition = option &gt;&gt; <span class="number">20</span> &amp; <span class="number">0xf</span>;</span><br><span class="line"><span class="keyword">if</span> (optionTransition == <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"UIViewAnimationOptionTransitionCrossDissolve has been set"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里最需要注意的地方就是，对互斥的状态的设置必须尤为小心，如果你这么写：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIViewAnimationOptions</span> badOption = <span class="built_in">UIViewAnimationOptionCurveEaseIn</span> | <span class="built_in">UIViewAnimationOptionCurveEaseOut</span>;</span><br><span class="line"><span class="built_in">UInt8</span> oops = badOption &gt;&gt; <span class="number">16</span> &amp; <span class="number">0xf</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Sorry, it's not UIViewAnimationOptionCurveEaseInOut"</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"oops = %d, you got UIViewAnimationOptionCurveLinear"</span>, oops);</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="iOS_位与位运算">iOS 位与位运算</h2><h3 id="介绍">介绍</h3><p>位操作是程序设计中对位模式或二进制数的一元和二元操作. 在许多古老的微处理器上, 位运算比加减运算略快, 通常位运算比乘除法运算要快很多. 在现代架构中, 情况并非如此:]]>
    </summary>
    
      <category term="Bit" scheme="http://ytlvy.com/tags/Bit/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS Toll-Free Bridging]]></title>
    <link href="http://ytlvy.com/2015/08/04/iOS-Toll-Free-Bridging/"/>
    <id>http://ytlvy.com/2015/08/04/iOS-Toll-Free-Bridging/</id>
    <published>2015-08-04T13:28:29.000Z</published>
    <updated>2015-08-04T13:28:58.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://gracelancy.com/blog/2014/04/21/toll-free-bridging/" target="_blank" rel="external">reference</a></p>
<h2 id="Toll-Free_Bridging">Toll-Free Bridging</h2><h3 id="什么是_Toll-Free_Bridging">什么是 Toll-Free Bridging</h3><p>有一些数据类型是能够在 <code>Core Foundation Framework</code> 和 <code>Foundation Framework</code> 之间交换使用的。这意味着，对于同一个数据类型，你既可以将其作为参数传入 <code>Core Foundation</code>函数，也可以将其作为接收者对其发送 <code>Objective-C</code> 消息（即调用ObjC类方法）。这种在 <code>Core Foundation 和 Foundation</code> 之间交换使用数据类型的技术就叫 <code>Toll-Free Bridging</code>.</p>
<p>举例说明，<code>NSString</code>和<code>CFStringRef</code>即是一对可以相互转换的数据类型：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ARC 环境下</span></span><br><span class="line"><span class="comment">// Bridging from ObjC to CF</span></span><br><span class="line"><span class="built_in">NSString</span> *hello = <span class="string">@"world"</span>;</span><br><span class="line"><span class="built_in">CFStringRef</span> world = (__bridge <span class="built_in">CFStringRef</span>)(hello);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>, <span class="built_in">CFStringGetLength</span>(world));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bridging from CF to ObjC</span></span><br><span class="line"><span class="built_in">CFStringRef</span> hello = <span class="built_in">CFStringCreateWithCString</span>(k<span class="built_in">CFAllocatorDefault</span>, <span class="string">"hello"</span>, k<span class="built_in">CFStringEncodingUTF8</span>);</span><br><span class="line"><span class="built_in">NSString</span> *world = (__bridge <span class="built_in">NSString</span> *)(hello);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>, world<span class="variable">.length</span>);</span><br><span class="line"><span class="built_in">CFRelease</span>(hello);</span><br></pre></td></tr></table></figure>
<p>大部分（但不是所有！）<code>Core Foundation</code> 和 <code>Foundation</code> 的数据类型可以使用这个技术相互转换，Apple 的文档里有一个列表（<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html" target="_blank" rel="external">传送门</a>），列出了支持这项技术的数据类型。<br>MRC 下的 <code>Toll-Free Bridging</code> 因为不涉及内存管理的转移，可以直接相互 <code>bridge</code> 而不必使用类似<code>__bridge</code>修饰字，我们之后再讨论这个问题。</p>
<h3 id="Toll-Free_Bridging_是如何实现的？">Toll-Free Bridging 是如何实现的？</h3><p>1) 每一个能够 bridge 的 ObjC 类，都是一个类簇（<code>class cluster</code>）。类簇是一个公开的抽象类，但其核心功能的是在不同的私有子类中实现的，公开类只暴露一致的接口和实现一些辅助的创建方法。而与该 ObjC 类相对应的 <code>Core Foundation</code> 类的内存结构，正好与类簇的其中一个私有子类相同。</p>
<p>举个例子，NSString是一个类簇，一个公开的抽象类，但每次创建一个NSString的实例时，实际上我们会获得其中一个私有子类的实例。而NSString的其中一个私有子类实现既为NSCFString，其内存的结构与CFString是相同的，CFString的isa指针就指向NSCFString类，即，CFString对象就是一个NSCFString类的实例。</p>
<p>所以，当<code>NSString</code>的实现刚好是<code>NSCFString</code>的时候，他们两者之间的转换是相当容易而直接的，他们就是同一个类的实例。</p>
<p>2) 当<code>NSString</code>的实现不是<code>NSCFString</code>的时候（比如我们自己 subclass 了<code>NSString</code>），我们调用 CF 函数，就需要先检查对象的具体实现。如果发现其不是<code>NSCFString</code>，我们不会调用 CF 函数的实现来获得结果，而是通过给对象发送与函数功能相对应的 ObjC 消息（调用相对应的<code>NSString</code>的接口）来获得其结果。<br>例如<code>CFStringGetLength</code>函数，当收到一个作为参数传递进来的对象时，会先确认该对象到底是不是<code>NSCFString</code>实现。如果是的话，就会直接调用<code>CFStringGetLength</code>函数的实现来获得字符串的长度；如果不是的话，会给对象发送length消息（调用<code>NSString</code>的<code>- (NSUInteger)length</code>接口），来得到字符串的长度。<br>通过这样的技术，即使是我们自己子类了一个<code>NSString</code>，也可以和<code>CFStringRef</code>相互 Bridge。</p>
<p>3) 其他支持 Toll-Free Bridging 的数据类型原理也同NSString一样，比如NSNumber的NSCFNumber和CFNumber。</p>
<h3 id="ARC_下的_Toll-Free_Bridging">ARC 下的 Toll-Free Bridging</h3><p>如之前提到的，MRC 下的 <code>Toll－Free Bridging</code> 因为不涉及内存管理的转移，相互之间可以直接交换使用：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bridge</span></span><br><span class="line"><span class="built_in">NSString</span> *nsStr = (<span class="built_in">NSString</span> *)cfStr;</span><br><span class="line"><span class="built_in">CFStringRef</span> cfStr = (<span class="built_in">CFStringRef</span>)nsStr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数或者方法</span></span><br><span class="line"><span class="built_in">NSUInteger</span> length = [(<span class="built_in">NSString</span> *)cfStr length];</span><br><span class="line"><span class="built_in">NSUInteger</span> length = <span class="built_in">CFStringGetLength</span>((<span class="built_in">CFStringRef</span>)nsStr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// release</span></span><br><span class="line"><span class="built_in">CFRelease</span>((<span class="built_in">CFStringRef</span>)nsStr);</span><br><span class="line">[(<span class="built_in">NSString</span> *)cfStr release];</span><br></pre></td></tr></table></figure></p>
<p>而在 ARC 下，事情就会变得复杂一些，因为 ARC 能够管理 Objective-C 对象的内存，却不能管理 CF 对象，CF 对象依然需要我们手动管理内存。在 CF 和 ObjC 之间 bridge 对象的时候，问题就出现了，编译器不知道该如何处理这个同时有 ObjC 指针和 CFTypeRef 指向的对象。</p>
<p>这时候，我们需要使用<code>__bridge</code>, <code>__bridge_retained</code>, <code>__bridge_transfer</code> 修饰符来告诉编译器该如何去做。</p>
<h3 id="__bridge">__bridge</h3><p>最常用的修饰符，这意味着告诉编译器不做任何内存管理的事情，编译器仍然负责管理好在 Objc 一端的引用计数的事情，开发者也继续负责管理好在 CF 一端的事情。举例说明：</p>
<p>例子1:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc to cf</span></span><br><span class="line"><span class="built_in">NSString</span> *nsStr = [<span class="keyword">self</span> createSome<span class="built_in">NSString</span>];</span><br><span class="line"><span class="built_in">CFStringRef</span> cfStr = (__bridge <span class="built_in">CFStringRef</span>)nsStr;</span><br><span class="line"><span class="built_in">CFUseCFString</span>(cfStr);</span><br><span class="line"><span class="comment">// CFRelease(cfStr); 不需要</span></span><br></pre></td></tr></table></figure></p>
<p>在这里，编译器会继续负责nsStr的内存管理的事情，不会在 bridge 的时候 retain 对象，所以也不需要开发者在 CF 一端释放。需要注意的是，当nsStr被释放的时候（比如出了作用域），意味着cfStr指向的对象被释放了，这时如果继续使用cfStr将会引起程序崩溃。</p>
<p>例子2:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cf to objc</span></span><br><span class="line"><span class="built_in">CFStringRef</span> hello = <span class="built_in">CFStringCreateWithCString</span>(k<span class="built_in">CFAllocatorDefault</span>, <span class="string">"hello"</span>, k<span class="built_in">CFStringEncodingUTF8</span>);</span><br><span class="line"><span class="built_in">NSString</span> *world = (__bridge <span class="built_in">NSString</span> *)(hello);</span><br><span class="line"><span class="built_in">CFRelease</span>(hello); <span class="comment">// 需要</span></span><br><span class="line">[<span class="keyword">self</span> use<span class="built_in">NSString</span>:world];</span><br></pre></td></tr></table></figure></p>
<p>在这里，bridge 的时候编译器不会做任何内存管理的事情，bridge 之后，会负责 ObjC 一端的内存管理的事情 。同时，开发者需要负责管理 CF 一端的内存管理的事情，需要再 bridge 之后，负责 release 对象。</p>
<h3 id="__bridge_retained">__bridge_retained</h3><p>接<code>__bridge</code>一节的第一个例子，objc to cf。为了防止nsStr被释放，引起我们使用cfStr的时候程序崩溃，可以使用<code>__bridge_retained</code>修饰符。这意味着，在 bridge 的时候，编译器会 retain 对象，而由开发者在 CF 一端负责 release。这样，就算nsStr在 objc 一端被释放，只要开发者不手动去释放cfStr，其指向的对象就不会被真的销毁。但同时，开发者也必须保证和负责对象的释放。例如：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc to cf</span></span><br><span class="line"><span class="built_in">NSString</span> *nsStr = [<span class="keyword">self</span> createSome<span class="built_in">NSString</span>];</span><br><span class="line"><span class="built_in">CFStringRef</span> cfStr = (__bridge_retained <span class="built_in">CFStringRef</span>)nsStr;</span><br><span class="line"><span class="built_in">CFUseCFString</span>(cfStr);</span><br><span class="line"><span class="built_in">CFRelease</span>(cfStr); <span class="comment">// 需要</span></span><br></pre></td></tr></table></figure></p>
<h3 id="__bridge_transfer">__bridge_transfer</h3><p>接<code>__bridge</code>一节的第二个例子，cf to objc。我们发现如果使用<strong>bridge修饰符在cf转objc的时候非常的麻烦，我们既需要一个CFTypeRef的变量，还需要在 bridge 之后负责释放。这时我们可以使用`</strong>bridge_transfer`，意味着在 bridge 的时候，编译器转移了对象的所有权，开发者不再需要负责对象的释放。例如：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cf to objc</span></span><br><span class="line"><span class="built_in">CFStringRef</span> hello = <span class="built_in">CFStringCreateWithCString</span>(k<span class="built_in">CFAllocatorDefault</span>, <span class="string">"hello"</span>, k<span class="built_in">CFStringEncodingUTF8</span>);</span><br><span class="line"><span class="built_in">NSString</span> *world = (__bridge_transfer <span class="built_in">NSString</span> *)(hello);</span><br><span class="line"><span class="comment">// CFRelease(hello); 不需要</span></span><br><span class="line">[<span class="keyword">self</span> use<span class="built_in">NSString</span>:world];</span><br></pre></td></tr></table></figure></p>
<p>甚至可以这么写：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cf to objc</span></span><br><span class="line"><span class="built_in">NSString</span> *world = (__bridge_transfer <span class="built_in">NSString</span> *)<span class="built_in">CFStringCreateWithCString</span>(k<span class="built_in">CFAllocatorDefault</span>, <span class="string">"hello"</span>, k<span class="built_in">CFStringEncodingUTF8</span>);</span><br><span class="line">[<span class="keyword">self</span> use<span class="built_in">NSString</span>:world];</span><br></pre></td></tr></table></figure></p>
<h2 id="小结">小结</h2><ul>
<li><code>(__bridge T) op</code>：告诉编译器在 bridge 的时候不要做任何事情</li>
<li><code>(__bridge_retained T) op</code>：（ ObjC 转 CF 的时候使用）告诉编译器在 bridge 的时候 retain 对象，开发者需要在CF一端负责释放对象</li>
<li><code>(__bridge_transfer T) op：</code>（ CF 转 ObjC 的时候使用）告诉编译器转移 CF 对象的所有权，开发者不再需要在CF一端负责释放对象</li>
</ul>
<h2 id="参考">参考</h2><p><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html" target="_blank" rel="external">Concepts in Objective-C Programming</a><br><a href="https://developer.apple.com/library/ios/documentation/corefoundation/Conceptual/CFDesignConcepts/Articles/tollFreeBridgedTypes.html#//apple_ref/doc/uid/TP40010677" target="_blank" rel="external">Core Foundation Design Concepts</a><br><a href="https://mikeash.com/pyblog/friday-qa-2010-01-22-toll-free-bridging-internals.html" target="_blank" rel="external">Toll Free Bridging Internals</a><br><a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#bridged-casts" target="_blank" rel="external">Clang documentation: Objective-C Automatic Reference Counting (ARC)</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://gracelancy.com/blog/2014/04/21/toll-free-bridging/" target="_blank" rel="external">reference</a></p>
<h2 id="Toll-Free_Br]]>
    </summary>
    
      <category term="Memory" scheme="http://ytlvy.com/tags/Memory/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS attribute objc_designated_initializer]]></title>
    <link href="http://ytlvy.com/2015/08/04/iOS-attribute-objc-designated-initializer/"/>
    <id>http://ytlvy.com/2015/08/04/iOS-attribute-objc-designated-initializer/</id>
    <published>2015-08-04T13:27:14.000Z</published>
    <updated>2015-08-04T13:27:33.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://leafduo.com/articles/2014/03/20/objc-designated-initializer/" target="_blank" rel="external">reference</a></p>
<h2 id="attribute((objc_designated_initializer))"><strong>attribute</strong>((objc_designated_initializer))</h2><p>指定初始化器（<code>designated initializer</code>）是 Objective-C 中的一个重要的概念，但是很可惜的是，很多开发者（不知道为什么）并没能正确遵守关于指定初始化器的一些惯例。 </p>
<p>之前，我们只能通过 code review 之类的方法来找出、修正这些问题；现在，clang 为我们提供了编译器级别的支持，能够找出不遵守管理的地方并给出警告，我们需要做的是标记出哪个初始化器是指定初始化器，例如：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">interface</span> FTBObject</span><br><span class="line"></span><br><span class="line">- (instancetype)init __<span class="function">attribute__</span>((objc_designated_initializer))</span>;</span><br><span class="line"></span><br><span class="line"><span class="at_rule">@<span class="keyword">end</span></span></span><br></pre></td></tr></table></figure></p>
<p>通过在接口定义中指定指定初始化器，不仅编译器能够给出相关的警告，而且需要继承该类的开发者也可以不参考文档就知道哪个初始化器是指定初始化器。</p>
<p>目前，clang 可以提供一系列警告，例如非指定初始化器没有调用其他初始化器、指定初始化器没有调用父类的指定初始化器、指定初始化器调用了非指定初始化器、子类没有复写父类的指定初始化器等。 具体的例子可以看这个<a href="https://llvm.org/svn/llvm-project/cfe/trunk/test/SemaObjC/attr-designated-init.m" target="_blank" rel="external">测试用例</a>。</p>
<p>不幸的是，目前系统库的接口还没有这个属性，也就是说只有继承自己的代码和标记了这个指令的第三方库中的类才有用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://leafduo.com/articles/2014/03/20/objc-designated-initializer/" target="_blank" rel="external">reference</a></p>
<h2 id="a]]>
    </summary>
    
      <category term="attribute" scheme="http://ytlvy.com/tags/attribute/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ios GPUImage simple use]]></title>
    <link href="http://ytlvy.com/2015/08/04/ios-GPUImage-simple-use/"/>
    <id>http://ytlvy.com/2015/08/04/ios-GPUImage-simple-use/</id>
    <published>2015-08-04T13:26:07.000Z</published>
    <updated>2015-08-04T13:26:36.000Z</updated>
    <content type="html"><![CDATA[<h2 id="GPUImage">GPUImage</h2><p>GPUImage 作者是 Brad Larson，以 BSD 协议放出，能够在图像、实时摄像头影像和视频上使用 GPU 加速的滤镜和其他效果.</p>
<h3 id="GPU_vs-_CPU">GPU vs. CPU</h3><p>每只 iPhone 都有两个处理器：一个 CPU，也就是中央处理器，和一个 GPU，也就是图形处理器。每个处理器都有它自己的优势，现代芯片架构（例如 Apple A4）把 CPU 和 GPU 集成在一个物理封装里。</p>
<p>在 Xcode 里面写 C 和 Objective-C 的时候，产生的指令绝大部分会被 CPU 执行。相对地，GPU 是一枚专用芯片，专门用来做独立的小操作，例如图形渲染。GPU 执行的指令和 CPU 是有很大区别的，因此用特殊的语言来编写：OpenGL（特别地，在 iPhone 和 iPad 上使用 OpenGL ES）</p>
<h3 id="渲染管线">渲染管线</h3><p><img src="http://nshipster.s3.amazonaws.com/gpuimage-pipeline.png" alt=""></p>
<p>GPUImage 从本质上来说是一个渲染管线的 <code>Objective-C</code>抽象。从相机、网络或者磁盘上加载的源图像，在经过一系列滤镜处理后，最终输出到了 <code>view</code>、<code>graphics context</code> 或是数据流中。</p>
<p>例如说，摄像头中的图像可以应用一个 Color Levels 滤镜，来模拟各种色盲效果，然后实时显示在一个 view 中。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GPUImageVideoCamera *videoCamera = [[GPUImageVideoCamera alloc]</span><br><span class="line"><span class="label">    initWithSessionPreset:</span>AVCaptureSessionPreset640x480</span><br><span class="line"><span class="label">           cameraPosition:</span>AVCaptureDevicePositionBack];</span><br><span class="line">videoCamera.outputImageOrientation = UIInterfaceOrientationPortrait;</span><br><span class="line"></span><br><span class="line">GPUImageFilter *filter = [[GPUImageLevelsFilter alloc] </span><br><span class="line"><span class="label">                            initWithFragmentShaderFromFile:</span>@<span class="string">"CustomShader"</span>];</span><br><span class="line">[filter <span class="string">setRedMin:</span><span class="number">0.299</span> <span class="string">gamma:</span><span class="number">1.0</span> <span class="string">max:</span><span class="number">1.0</span> <span class="string">minOut:</span><span class="number">0.0</span> <span class="string">maxOut:</span><span class="number">1.0</span>];</span><br><span class="line">[filter <span class="string">setGreenMin:</span><span class="number">0.587</span> <span class="string">gamma:</span><span class="number">1.0</span> <span class="string">max:</span><span class="number">1.0</span> <span class="string">minOut:</span><span class="number">0.0</span> <span class="string">maxOut:</span><span class="number">1.0</span>];</span><br><span class="line">[filter <span class="string">setBlueMin:</span><span class="number">0.114</span> <span class="string">gamma:</span><span class="number">1.0</span> <span class="string">max:</span><span class="number">1.0</span> <span class="string">minOut:</span><span class="number">0.0</span> <span class="string">maxOut:</span><span class="number">1.0</span>];</span><br><span class="line">[videoCamera <span class="string">addTarget:</span>filter];</span><br><span class="line"></span><br><span class="line">GPUImageView *filteredVideoView = [[GPUImageView alloc] <span class="string">initWithFrame:</span>self.view.bounds)];</span><br><span class="line">[filter <span class="string">addTarget:</span>filteredVideoView];</span><br><span class="line">[self.view <span class="string">addSubView:</span>filteredVideoView];</span><br><span class="line"></span><br><span class="line">[videoCamera startCameraCapture];</span><br></pre></td></tr></table></figure></p>
<p>或者，结合不同的颜色混合模式，图像效果和一些调整，你可以把静止图像转变成可以分享给你时髦的朋友们看看的精美图像（例子来自基于 GPUImage 的 FilterKit）。<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GPUImageFilterGroup *filter = <span class="comment">[<span class="comment">[FKGPUFilterGroup alloc]</span> init]</span>;</span><br><span class="line"></span><br><span class="line">GPUImageSaturationFilter *saturationFilter = <span class="comment">[<span class="comment">[GPUImageSaturationFilter alloc]</span> init]</span>;</span><br><span class="line"><span class="comment">[saturationFilter setSaturation:0.5]</span>;</span><br><span class="line"></span><br><span class="line">GPUImageMonochromeFilter *monochromeFilter = <span class="comment">[<span class="comment">[GPUImageMonochromeFilter alloc]</span> init]</span>;</span><br><span class="line"><span class="comment">[monochromeFilter setColor:(GPUVector4)&#123;0.0f, 0.0f, 1.0f, 1.0f&#125;]</span>;</span><br><span class="line"><span class="comment">[monochromeFilter setIntensity:0.2]</span>;</span><br><span class="line"></span><br><span class="line">GPUImageVignetteFilter *vignetteFilter = <span class="comment">[<span class="comment">[GPUImageVignetteFilter alloc]</span> init]</span>;</span><br><span class="line"><span class="comment">[vignetteFilter setVignetteEnd:0.7]</span>;</span><br><span class="line"></span><br><span class="line">GPUImageExposureFilter *exposureFilter = <span class="comment">[<span class="comment">[GPUImageExposureFilter alloc]</span> init]</span>;</span><br><span class="line"><span class="comment">[exposureFilter setExposure:0.3]</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">[filter addGPUFilter:exposureFilter]</span>;</span><br><span class="line"><span class="comment">[filter addGPUFilter:monochromeFilter]</span>;</span><br><span class="line"><span class="comment">[filter addGPUFilter:saturationFilter]</span>;</span><br><span class="line"><span class="comment">[filter addGPUFilter:vignetteFilter]</span>;</span><br></pre></td></tr></table></figure></p>
<p>看完了 GPUImage 的功能，一定很兴奋吧。GPUImage 非常简单，可以马上开始使用（不需要了解 OpenGL），性能上也足够完成你想要的一切。不止是这样，它还自带了非常多的积木一样的部件 — 色彩调整，混合模式，你能想到的想不到的一切视觉效果。</p>
<p>GPUImage 是开源社区少有的好东西，我们 Mac 和 iOS 开发者非常幸运的能拥有它。用 GPUImage 做些牛逼的东西，向其他人展示一个崭新的世界</p>
<h3 id="吐槽">吐槽</h3><p>我自己也用过一点 GPUImage，方便是很方便，不光是省掉了 AVFoundation 的许多烦人的 setup 代码，还内置了许多滤镜效果。不过它也有不少坑，我遇到的一个就是占用太多内存，一段时间后就 crash 掉了，毕竟是处理视频，需要不少内存，iPhone 的内存又不太多，就要更加注意。我当时是加了一个 @autoreleasepool 就好多了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="GPUImage">GPUImage</h2><p>GPUImage 作者是 Brad Larson，以 BSD 协议放出，能够在图像、实时摄像头影像和视频上使用 GPU 加速的滤镜和其他效果.</p>
<h3 id="GPU_vs-_CPU">GPU vs. C]]>
    </summary>
    
      <category term="Vendor" scheme="http://ytlvy.com/tags/Vendor/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C programe memory management]]></title>
    <link href="http://ytlvy.com/2015/08/04/C-programe-memory-management/"/>
    <id>http://ytlvy.com/2015/08/04/C-programe-memory-management/</id>
    <published>2015-08-04T13:25:04.000Z</published>
    <updated>2015-08-04T13:25:48.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://casatwy.com/ccheng-xu-de-nei-cun-guan-li.html" target="_blank" rel="external">reference</a></p>
<h2 id="C程序的内存管理">C程序的内存管理</h2><h3 id="简述">简述</h3><p>自从自动内存管理嵌入到各种各样的语言之后，我们就很少会去关注这方面的事情了，这些功能的设计者和实现者们为此付出的努力值得我们称赞，期间也涌现了多种不同的内存管理方案。目前大部分语言的主流内存管理方案是Garbage Collector。苹果推出的Auto Reference Count也因为基于编译器自动添加手工计数的代码而带来了更好的性能提升。我在这里总结了一些从上古时代到如今在C程序下进行内存管理的技术。同时，也为你更深入地了解其他语言中内存管理模块的原理提供了知识背景。</p>
<h3 id="管理固定大小的内存">管理固定大小的内存</h3><h4 id="栈内存">栈内存</h4><p>栈内存应该是最容易管理的了，只要理解<code>生存域</code>就能理解占内存的管理方式。生存域就是这样：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int main ()</span><br><span class="line">    &#123;</span><br><span class="line">        int array[] = &#123;1,2,3,4,5&#125;;</span><br><span class="line">                              ------------------|<span class="string"></span><br><span class="line">        if ( i &gt; 0 ) &#123;                          </span>|</span><br><span class="line">            ...                                 |<span class="string"></span><br><span class="line">            ...                                 </span>|</span><br><span class="line">        &#125;                                       |<span class="string"></span><br><span class="line">        foo(array);                             </span>|</span><br><span class="line">                                                |<span class="string"></span><br><span class="line">        &#123;                                       </span>|</span><br><span class="line">            int k = 9;        ---               |<span class="string"></span><br><span class="line">            array[1] = k;       </span>|<span class="string">-&gt;k的生存域     </span>|<span class="string">-&gt;array的生存域</span><br><span class="line">            ...               ---               </span>|</span><br><span class="line">        &#125;                                       |<span class="string"></span><br><span class="line">    &#125;                                           </span>|</span><br><span class="line">                                                |<span class="string"></span><br><span class="line">    void foo(int * const number) &#123;              </span>|</span><br><span class="line">        int j = 0;                              |<span class="string"></span><br><span class="line">                              ---               </span>|</span><br><span class="line">        ...                     |<span class="string">               </span>|</span><br><span class="line">        number[2] = j;          |<span class="string">-&gt;j的生存域     </span>|</span><br><span class="line">        ...                     |<span class="string">               </span>|</span><br><span class="line">                              -------------------</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>基本上就是变量所处{和}之间的区域都叫这个变量的生存域。当程序执行到对应}的时候，就会将这个}对应生存域内的所有变量的内存释放给操作系统。</p>
<h4 id="优点">优点</h4><p>1) 程序员不需要为此做任何额外的事情，不用添加变量记录使用轨迹，也不用在内存中额外记录引用次数，程序自己会帮你处理好这些问题的</p>
<p>2) 在setjmp和longjmp中，栈内存是安全的<br><code>setjmp</code>和<code>longjmp</code>是C99引入的可以模仿C++的exception行为的一种方案。一般情况下，所有在longjmp的内存在声明的时候都需要加volatile，让程序每次都从内存读取数值而不是在cache中读取。然而对于栈内存而言，可以不用volatile。</p>
<p>3) 在多线程环境，递归环境，异步信号处理中，栈内存都是安全的</p>
<h4 id="缺点">缺点</h4><p>1) 一般情况下，程序中都会有栈内存和堆内存混合使用，当函数在使用指针类的形参时，因为难以区分这个指针对应的内存是栈内存还是堆内存，因此就很难采取正确的内存管理措施。</p>
<p>上面的例子中，foo函数接收了一个指针参数，如果这个指针是堆内存，那么就需要进行引用计数加一的操作（具体操作取决于内存管理方式），但现在在foo函数中其实无法区分这到底是栈内存还是堆内存，境况就比较尴尬了。</p>
<p>2) 你必须要知道你的栈内存应当分配多大才合适，否则会引发安全问题</p>
<p>函数调用栈和变量内存栈其实是共用的，当内存溢出的时候，会覆盖掉对应的函数调用栈，这种覆盖不会引起程序中止或其他情况，十分安静。当函数执行完毕后，操作系统会取栈顶第一个元素作为跳转地址，然后就会直接跳转到被溢出的地址上了。举个例子：</p>
<p>exploit.c:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">string</span>[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"here i am"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, <span class="built_in">string</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第一步程序进入main，然后为string分配了一个栈内存，此时栈内情况：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">       |<span class="string">--------</span>|</span><br><span class="line">top -&gt; |<span class="string"> string </span>|</span><br><span class="line">       |<span class="string">________</span>|</span><br></pre></td></tr></table></figure></p>
<p>然后进入scanf函数，记住，操作系统记录函数调用的栈和存放栈变量的栈是同一个！此时栈内情况：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        |<span class="string">--------------</span>|</span><br><span class="line">top -&gt;  |<span class="string"> back address </span>|<span class="string">  # 此时back address指向main函数中的 return 0; 这一指令的地址:0x1234</span><br><span class="line">        </span>|<span class="string">    0x1234    </span>|</span><br><span class="line">        |<span class="string">______________</span>|</span><br><span class="line">        |<span class="string">              </span>|</span><br><span class="line">        |<span class="string">    string    </span>|</span><br><span class="line">        |<span class="string">______________</span>|</span><br></pre></td></tr></table></figure></p>
<p>然后你在终端输入远大于string长度的数据，比如’npppp…’，然后回车，此时已经内存溢出，但scanf函数还未结束，此时程序也不会中止。此时栈内情况：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">       |<span class="string">--------</span>|</span><br><span class="line">top -&gt; |<span class="string"> pppppp </span>|<span class="string">   # 原来的back address被溢出成pppppp，而不是原来的0x1234了</span><br><span class="line">       </span>|<span class="string">________</span>|</span><br><span class="line">       |<span class="string">        </span>|</span><br><span class="line">       |<span class="string"> string </span>|</span><br><span class="line">       |<span class="string">________</span>|</span><br></pre></td></tr></table></figure></p>
<p>然后<code>scanf</code>函数完成任务，取栈顶地址返回，此时就会将<code>ppppp</code>取出，作为地址返回。由于这个地址是非法地址，程序此时就会报<code>can&#39;t access</code>的错误，程序终止。我们可以更加别有用心一点，计算好溢出长度（一般情况下溢出长度跟栈内存的长度不一样，需要通过fuzz手段来确定对应长度），将溢出后覆盖的地址设为可以访问的地址，比如这里假设<code>printf(&quot;here i am&quot;)</code>;的地址为0x1230，我们在输入string的时候输入<code>npp...pp1230</code>(此处的1230其实是对应1230这个数字的ASCII码)，那么栈内情况就会变成：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">       |<span class="string">--------</span>|</span><br><span class="line">top -&gt; |<span class="string"> 0x1230 </span>|<span class="string">   # printf("here i am");</span><br><span class="line">       </span>|<span class="string">________</span>|</span><br><span class="line">       |<span class="string">        </span>|</span><br><span class="line">       |<span class="string"> string </span>|</span><br><span class="line">       |<span class="string">________</span>|</span><br></pre></td></tr></table></figure></p>
<p>输入完毕按回车，你会看到程序就跑到printf那边去了，又输出了一次”here i am”。这就是一个典型的内存溢出漏洞，及其攻击方式。如果使用的是堆内存，在内存溢出之后因为溢出的那部分的内存使用权在管态，程序会直接中止，并且报address can’t access的错误。</p>
<p>3) 内存的合法访问范围被限制在一个固定的区域中<br>大多数情况我们其实是希望在另一个生存域中也能访问到对应内存的，使用栈内存就很容易出现野指针，因为你不知道什么时候它就被回收了。只有在递归调用的时候，栈内存才相对比较安全。</p>
<p>4) 拥有这个栈内存的函数不能将这个栈内存的指针返回出去<br>这同样也是由于在这个函数以外的地方已经超出了变量生存域的原因。return出去的就变成野指针了。</p>
<h4 id="总结">总结</h4><p>由于栈内存有以上这些优缺点（特点），我们一半都不太会用栈变量来管理广泛使用的内存和大片内存。一方面是由于栈变量有生存域限制，广泛使用的内存基本上都不能有这些限制。另一方面也是C程序调用参数的方案主要是值传递，大片内存一般都不会传整个变量，这样会导致操作系统copy的时候开销太大，如果使用传址调用，则会遇到被调用函数不知道如何管理指针所对应的那片内存的尴尬。</p>
<h3 id="静态分配内存">静态分配内存</h3><p>所谓静态分配内存，就是在最外面的地方使用static来声明变量，由于这个变量被声明成了全局静态变量，这个变量所占有的内存也就变成了全局静态内存，即使是跨文件的情况也能通过变量名访问这片内存。这种做法突破了栈内存关于生存域的限制。</p>
<h4 id="优点-1">优点</h4><p>1) 这是解决生存域问题最简单的方案，全局可用。<br>由于这个是全局变量，任何地方想要用到它，只要<code>extern</code>一下就好。它在程序刚起来的时候（正式调用main函数之前）就会被操作系统分配，直到程序退出才会被操作系统回收。如果你的这个变量是一个全局单例，使用这种方案就不太容易会出错。</p>
<p>2) 由于这是单独的一片内存区域，函数可以将最终结果存放在这个区域，然后返回指针，避免了值传递的低效率。</p>
<p>实际做法可以先申请一大片内存，比如<code>uint8_t buffer[65536]</code>;，然后函数把生产出来的结果存放在buffer的某个位置，比如<code>buffer[10]</code>，然后把<code>buffer[10]</code>的指针作为结果return出去。<code>buffer[20]</code>或者其他的地方就可以给其他函数使用了。只要调用者和被调用者约定好偏移，这么做问题就不大。但如果涉及多线程、信号处理、递归等情况时，这种做法就不行了。另外一种情况就是这样的做法内存利用效率也不高，内存碎片会比较多，因为我们往往在约定的时候会划一个比较大的范围，大部分情况下，这一块很少是被完整利用的。</p>
<p>你也可以用循环使用的方法，比如说这一次使用0-9，下一次使用10-19，再下一次使用20-29这样，然后用完了再回头从0开始用，这样风险和成本都会不小，你要协调好各自函数操作这个buffer的关系，尽量少出bug。不过这正是编程的乐趣所在，不是么？:D</p>
<p>还有一种终极方案，需要结合下面提到的类似引用计数的方案来操作：在申请了这片buffer的同时，维护一个bitmap，1表示对应位置内存有用，0表示对应位置内存可以另作他用。通过引用计数的方案来维护这个bitmap，这样每次需要使用内存的时候，通过bitmap就可以找到有效内存的偏移，这样就总能保证取出的内存是可以使用的。这种方案相对而言还是比较广泛的，能在分配偏移的时候根据bitmap的情况采取一些策略来减少碎片的产生。但由于是静态buffer，因此就要求程序使用内存的数量可预测。</p>
<p>3) 在静态内存中存的值会一直都在，你可以拿它作为多线程交换数据用，或者作为跨函数的中间结果的缓存用。</p>
<p>举个例子：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> globalVariable;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> foo() &#123;</span><br><span class="line">    ...</span><br><span class="line">    globalVariable = mid_result;    // globalVariable存储了foo()函数运行过程中的一个中间结果</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">result</span>;                  // foo()函数的真正任务是返回<span class="literal">result</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> bar() &#123;</span><br><span class="line">    ...</span><br><span class="line">    something = count + globalVariable; // bar()函数需要使用foo()函数的某个中间结果来完成任务，foo()正好存储了这个中间结果，可以直接拿来给bar()用</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="缺点-1">缺点</h4><p>1) 这是解决生存域问题最粗暴的方案，业界喷的也比较多</p>
<p>它虽然保证了内存全局可用，但由于只有程序结束之后对应的内存才能被回收，这导致内存的使用效率不高。另一方面，全局变量很容易造成代码恶化，当这个变量被多个使用者使用的时候，你就不能保证你每次从这里取出来的数据一定是你期望的数据，因此在设计的时候我们一般都是需要谨慎考虑是否要引入全局变量的。</p>
<p>2) 容易引发命名空间的问题</p>
<p>由于全局变量哪儿都有用，一旦出现两个重名的全局变量就坑爹了，这样的bug还特别难调，只有特别熟悉整个项目代码的人才能想到可能是重名导致了问题。</p>
<p>3) 多线程情况下会有坑</p>
<p>由于它全局变量的特点，我们可能会想到使用它来作为不同线程交换数据的地方。这是可以做到的，但是需要对这个变量进行临界区改造，不光要保证同一时间只有一个线程使用它，还要根据具体需求，保证同一功能区块内，只有一个线程使用它。否则就会出现1号线程还没完全跑完这个变量相关的代码。就被2号线程给把值改了，后面1号线程怎么跑就都不会出正确结果了。做临界区改造的成本还是蛮大的，一般都是使用PV操作来执行这样的任务，需要为此额外开辟内存来记录变量引用次数，以及设计一个runloop使之能够让其他线程执行wait()操作。</p>
<hr>
<h3 id="动态分配内存，并使用引用计数来管理">动态分配内存，并使用引用计数来管理</h3><p>这是相对简单且容易采用的办法，实现方案有很多。实际使用时候的体验就类似于苹果在没推出ARC (Automatic Reference Count) 时候的MRC(Manual Reference Count)。具体原理是这样：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 使用<span class="function"><span class="title">malloc</span><span class="params">()</span></span>或<span class="function"><span class="title">calloc</span><span class="params">()</span></span>申请内存，并为这个内存初始化引用次数为<span class="number">1</span></span><br><span class="line"><span class="number">2</span>. 在内存使用过程中，如果当前片段需要成为这块内存的拥有者，那就调用一个方法使得这个内存的引用值加一</span><br><span class="line"><span class="number">3</span>. 当拥有者使用这块内存完毕，就再调用一个方法使得这个内存的引用值减一</span><br><span class="line"><span class="number">4</span>. 当引用值为<span class="number">0</span>时，调用<span class="function"><span class="title">free</span><span class="params">()</span></span>，让操作系统将内存回收</span><br></pre></td></tr></table></figure>
<p>然后具体的实现方案也可以是以下这些：</p>
<p>1) 让引用计数跟随指针的方案<br>可以将内存、存储引用计数的变量打包成一个struct，然后以这个struct为单位去向操作系统要内存。操作引用计数的函数就只要修改这个struct的引用计数变量就好了，当引用计数变量值为0时，自动调用free()函数就好。</p>
<p>2) 引用计数不跟随指针的方案<br>先申请一大片内存，然后再开辟一个bitmap负责维护这一大片内存的使用情况，bitmap中的0表示某一区域的内存可用，其它数字则表示这片区域内存的引用计数。每次代码需要申请内存的时候，根据bitmap的情况从它维护的这一大片内存中挖出一块来给出去。当那一大片内存不够用的时候，就再申请一大片，然后再开辟一个bitmap来维护这片新的内存，当某一大片内存使用过后，bitmap数值全都是0的时候，就把这一大片内存一起回收掉。总的来看就是一大片内存由bitmap维护，然后bitmap通过引用计数来维护。</p>
<h4 id="方案1的优点">方案1的优点</h4><p>1) 内存碎片极小，约等于没有<br>因为是随用随取，基本上不太可能出现有内存碎片的情况，内存使用效率高。</p>
<p>2) 实现方案简单<br>其实只要定义一个struct，然后写一个<code>retain()</code>函数（用于增加引用计数），和一个<code>release()</code>函数（用于减小引用计数），把相关逻辑都封装在这两个方法里面就好了。特别简单。</p>
<h4 id="方案1的缺点">方案1的缺点</h4><p>1) 性能低下<br>这种方案有潜在的可能去频繁申请和释放内存，然而这两种操作，尤其是内存申请，是很消耗性能的。对于一般的客户端程序来说，或许可以忍受，但是在服务端程序中，往往都会因为这个缺点而采取方案2。</p>
<h4 id="方案2的优点">方案2的优点</h4><p>1) 性能好<br>由于一次申请了一大片内存，只要这片内存还够，后续的内存需求都可以不需要通过向操作系统来申请，性能就好很多。</p>
<h4 id="方案2的缺点">方案2的缺点</h4><p>1) 长时间运行后，内存会有大量内存碎片的存在<br>第一轮使用内存的时候，差不多是可以做到内存碎片很小的。随着运行时间的增长，bitmap中维护的内存来来回回地被重用之后，就会出很多的内存碎片。而且这时往往不适合进行内存碎片整理，否则会造成很多野指针。假设运行期间一共分了10片大内存，极端情况就是10片大内存每片都只是使用了很小的一块，由于不能做内存整理，就导致内存浪费比较大。某种程度上讲，这属于内存泄漏。</p>
<p>2) 实现方案相对复杂<br>你要实现一个bitmap，以及bitmap相关的维护函数，比方案1会复杂很多。</p>
<h4 id="关于方案1和方案2的总结">关于方案1和方案2的总结</h4><p>你会发现，方案1的优点就是方案2的缺点，方案1的缺点就是方案2的优点，具体采用哪种方案，是要通过实际情况考虑的。如果考虑性能更多，那就选择方案2，如果考虑内存更加高效，那就选择方案1。事实上针对方案2容易导致的内存碎片问题，也有一个优化方案，就是再额外做一层抽象，让逻辑上连续的内存在实际上可以不连续。于是我们存放数据的时候可以根据bitmap的碎片进行见缝插针式的内存使用。这个优化方案看上去很好，但实际上增大了代码的复杂度，你需要维护一个B树来进行这个抽象，在实际应用中有点儿得不偿失。</p>
<p>这一类目还没结束，上面只是讨论了实现引用计数的两种方案的优缺点，下面我要说一下使用<code>引用计数</code>来进行内存管理其自身的优缺点。这些优缺点在方案1和方案2中都是普遍存在的。</p>
<h4 id="引用计数方案的优点">引用计数方案的优点</h4><p>1) 提高内存使用效率<br>从宏观上看，引用计数方案能够提高内存使用效率，程序能够通过引用计数来知道哪片内存不再使用了，这片不再使用的内存就能够及时被操作系统回收。</p>
<p>2) 没有生存域限制，没有命名空间限制<br>内存只要被malloc后，就一直可用，除非被free。由于不通过一个全局变量来hold住这块内存，我们可以不用关心命名空间冲突的问题</p>
<h4 id="引用计数方案的缺点">引用计数方案的缺点</h4><p>1) 对程序员有更加高的要求<br>相比于栈内存来说，进行动态内存分配要写的代码量要更大一些，管理要更细致一些，否则很容易出内存泄漏或者野指针的问题。何时进行引用计数的加一，何时进行引用计数的减一，这些需要程序员能够了解得非常清楚，有时候忘记调用增一或减一的方案，就会引发bug。调用这些辅助方法本身跟业务逻辑无关，但它们确实会影响业务逻辑。</p>
<p>在某些情况下也容易出现循环引用，从而导致内存无法被回收，比如这样：<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">A</span>: <span class="string">&#123; ... B.a ... &#125;</span></span><br><span class="line"><span class="attribute">B</span>: <span class="string">&#123; ... A.a ... &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>当要回收A的内存时，由于它声明了B.a的所有权，A的内存是不能被回收的，只有等B被回收后，A才能被回收。然而此时B又对A.a声明了所有权，B是不能被回收的，因此形成了一个死循环（有一个术语专门用来描述这种死循环：retain cycle），造成A和B都不能被回收，从而导致内存泄漏。一般情况下要避免这个问题，就要分清楚内存所对应的变量在你的程序中的逻辑层级关系。一般是高层级的变量拥有低层级的变量（对该变量进行引用加一），低层级的变量不拥有高层级的变量（引用计数不加一），遵守这个原则就能够避免retian cycle的出现。</p>
<p>2) longjmp、setjmp的情况下很难处理引用计数对应的内存<br>前面说过longjmp、setjmp就类似于exception机制。在某一段代码触发longjmp的时候，这段代码所相关的变量对应的内存其实就已经不需要再用了，这时候这些内存的引用计数往往都大于0，甚至在当前上下文你都不一定能够确定哪些变量是有用哪些变量是无用的，这时你就无法通过引用计数机制来回收内存。</p>
<p>不过说起来exception机制在刚从C++诞生的时候业界都很欢乐，终于有了一种程序出错而可以不中止程序的方案了。但随着时间的推进，人们越来越认识到exception机制有很多坑，近年大家都不推荐在程序中使用exception机制来处理运行时错误，更多的是采用error number，error对象的机制。这方面具体的讨论不在本文范围内，大家可以各自Google一下</p>
<hr>
<h3 id="链式内存分配">链式内存分配</h3><p>这是为了解决引用计数在longjmp和setjmp情况下内存不容易管理的缺点。它是这样实现的：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1. </span>实现一个链表</span><br><span class="line"><span class="bullet">2. </span>链表的节点包含指向已经申请内存的指针、这块内存的引用计数、这块内存当前所处的函数指针（用于标志作用域）</span><br><span class="line"><span class="bullet">3. </span>每次申请内存的时候都生成一个这样的节点，然后挂在链表上</span><br><span class="line"><span class="bullet">4. </span>每次释放内存的时候都将这个节点删除，并free()对应的内存</span><br><span class="line"><span class="bullet">5. </span>longjmp之后根据函数指针遍历链表，找到所有对应函数指针的节点，计数减一，若减一之后计数为0，则释放内存</span><br></pre></td></tr></table></figure></p>
<p>实质上就是用链表来进行内存使用的跟踪，这样的链表在程序中可以一个也可以多个，然后由一个总表去维护这些链表，这么做可以防止遍历太长的链表造成太大的性能消耗。</p>
<h4 id="优点-2">优点</h4><p>1) longjmp、setjmp有效<br>这个自然不必多说，这个方案就是为解决这个问题而诞生的。</p>
<p>2) 链表带来了非常好的灵活性<br>实际操作中，可以每个模块一个链表，甚至每个功能一个链表。链表不光可以用于longjmp，你也可以写一个仅在debug模式下启用的功能，这个功能用于统计每个函数内存的使用量，这在调试优化的时候是个非常好的数据来源。</p>
<h4 id="缺点-2">缺点</h4><p>1) 依旧不能解决retain cycle的问题<br>链式内存分配的方案本质上还是属于引用计数，只是解决了exception情况下的内存处理，但并没有解决retain cycle，程序员依旧需要当心这种情况。</p>
<hr>
<h3 id="管理不是固定大小的内存">管理不是固定大小的内存</h3><h4 id="长度可变的数组">长度可变的数组</h4><p>这个是C99引入的新特性，就是这样：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[n];</span><br><span class="line">    <span class="built_in">array</span>[n-<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, <span class="built_in">array</span>(n-<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>大部分C语言教程会说这种写法是错误的。因为array占用的是栈内存，栈内存是不能在运行期间动态分配的。但自从C99标准之后，这种写法就不会引起编译错误了。长度可变的数组倒是一个蛮不错的功能，以前要实现长度可变的数组，大部分都会用链表去做，使用这个功能之后就省事儿很多了。而且栈内存也是内存呀，当然可以拿它来做别的事情了～</p>
<h4 id="优点-3">优点</h4><p>1) 栈内存的所有优点它都有<br>多线程，安全。exception，安全。递归，安全。异步信号处理，安全。不用写额外的内存管理代码，方便。</p>
<p>2) 类似动态内存分配的效果<br>你可以将长度作为参数去构建你的数组，然后将这片内存另做它用。这是原始的栈内存分配不能做到的。</p>
<h4 id="缺点-3">缺点</h4><p>1) 栈内存的所有缺点它都有<br>生存域限制，接收参数的内存管理方案易混淆，这些都依旧是缺点。唯一好的地方就是你可以不用知道传递的数据有多大了，但是即便这样，还是不能做到真正动态内存那般随用随取，因此使用的时候也还是会有颇多限制。</p>
<h3 id="动态内存重分配">动态内存重分配</h3><p>有时候一片内存不够大，但是又不适合再开辟一个新内存，你就会需要将原来的内存进行重新分配。比如说你有一个缓冲区用于存放数据，当数据大于缓冲区容量时，你需要让缓冲区容量变大。如果开辟一个新内存，缓冲区的连续性就破被破坏了，所以你会对缓冲区进行内存的重新分配，这样就能放得下数据了。一般来说，这是对未知长度的数据的一种处理方案，重分配的函数就是realloc()。重分配时，操作系统会将旧的那片内存的数据复制到新的扩展过的内存里，这样就能保证连续性了。</p>
<h4 id="优点-4">优点</h4><p>1) 能够跟前面提到的动态内存管理方案相结合，提供连续的，更大片的内存</p>
<p>2) 因为本质还是动态内存操作，所以动态内存所有的优点它都有</p>
<p>3) 可以引申一种新的内存管理方案</p>
<p>我们可以约定由函数的调用者负责申请和管理内存，然后将指针传递进去，子函数发现内存不够的时候，重新分配一下就行。然后这片内存的管理工作就由调用者来管理，子函数运行期间，内存都是可用的。子函数运行完毕，父函数拿到结果之后，一般来说也就是直接free了。这种方案其实也是相对使用比较广泛的一种内存管理方案。</p>
<h4 id="缺点-4">缺点</h4><p>1) 性能消耗厉害<br>因为有一个额外的copy操作，如果你频繁进行重分配的话，copy和内存申请都会带来更多的性能消耗，一半儿而言重分配的时候也尽量大片大片地扩展，免得出现经常不够用然后经常要重分配的情况。</p>
<p>2) 动态内存管理的缺点也都有<br>你还是需要引入其他的内存管理方案来管理重分配的内存，前面提到了很多动态内存管理的方案，在这个时候也都需要根据情况采用，而且在扩展内存方面，由于扩展后是一片新内存，旧的指针变量保存的地址就会失效成为野指针。</p>
<hr>
<h3 id="内存回收器（GC，Garbage_Collector）">内存回收器（GC，Garbage Collector）</h3><p>GC的话题太大，实现方案也多种多样，有跟踪内存使用路径的，也有基于引用计数的。C环境下有一个libgc库实现了一个内存回收器，惠普也搞过一个GC，<a href="http://sourceforge.net/projects/bdwgc/" target="_blank" rel="external">BDWgc</a>，使用的人也很多。目前业界大部分语言是自带GC的，java，python，php，javascript都有，各自实现的方案也不一样，改造改造移植到C来也不是不行。所以真要评个优点缺点很难，因为不太好拿一个具象的东西进行分析。一般认为GC是内存管理的终极方案，虽然也有优缺点，但是基本上都优于上面提到的各种方案，而且还省时省力。只是我们要注意的是，同一套程序里不能同时存在两种GC，然而同一套程序里是可以存在多种内存管理方案的，这算是相对普适的一个特点了吧。</p>
<h2 id="总结-1">总结</h2><p>C环境下面做内存管理其实是个苦力活，而且也没有什么全能方案能够解决所有的问题。我个人倾向使用引用计数，同时不使用exception机制来处理程序错误。写这篇文章的目的也是为了总结一下各种情况下的内存管理方案。文末推荐一篇文章，是教你如何写一个属于自己的Memory Manager的，虽然不是GC，但也属于相对成熟的一种内存管理方案。比较长，也有点儿难度，但你都把我文章看完了，相信你再看那篇文章应该不是问题。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://casatwy.com/ccheng-xu-de-nei-cun-guan-li.html">reference</a></p>
<h2 id="C程序的内存管理">C程序的内存管理</h2><h3 id="简述">简述</h3><p>自从自动内存管理嵌入到各种各样的语言之后，我们就很少会去关注这方面的事情了，这些功能的设计者和实现者们为此付出的努力值得我们称赞，期间也涌现了多种不同的内存管理方案。目前大部分语言的主流内存管理方案是Garbage Collector。苹果推出的Auto Reference Count也因为基于编译器自动添加手工计数的代码而带来了更好的性能提升。我在这里总结了一些从上古时代到如今在C程序下进行内存管理的技术。同时，也为你更深入地了解其他语言中内存管理模块的原理提供了知识背景。</p>
<h3 id="管理固定大小的内存">管理固定大小的内存</h3><h4 id="栈内存">栈内存</h4><p>栈内存应该是最容易管理的了，只要理解<code>生存域</code>就能理解占内存的管理方式。生存域就是这样：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int main ()</span><br><span class="line">    &#123;</span><br><span class="line">        int array[] = &#123;1,2,3,4,5&#125;;</span><br><span class="line">                              ------------------|<span class="string"></span><br><span class="line">        if ( i &gt; 0 ) &#123;                          </span>|</span><br><span class="line">            ...                                 |<span class="string"></span><br><span class="line">            ...                                 </span>|</span><br><span class="line">        &#125;                                       |<span class="string"></span><br><span class="line">        foo(array);                             </span>|</span><br><span class="line">                                                |<span class="string"></span><br><span class="line">        &#123;                                       </span>|</span><br><span class="line">            int k = 9;        ---               |<span class="string"></span><br><span class="line">            array[1] = k;       </span>|<span class="string">-&gt;k的生存域     </span>|<span class="string">-&gt;array的生存域</span><br><span class="line">            ...               ---               </span>|</span><br><span class="line">        &#125;                                       |<span class="string"></span><br><span class="line">    &#125;                                           </span>|</span><br><span class="line">                                                |<span class="string"></span><br><span class="line">    void foo(int * const number) &#123;              </span>|</span><br><span class="line">        int j = 0;                              |<span class="string"></span><br><span class="line">                              ---               </span>|</span><br><span class="line">        ...                     |<span class="string">               </span>|</span><br><span class="line">        number[2] = j;          |<span class="string">-&gt;j的生存域     </span>|</span><br><span class="line">        ...                     |<span class="string">               </span>|</span><br><span class="line">                              -------------------</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Memory" scheme="http://ytlvy.com/tags/Memory/"/>
    
      <category term="Memory" scheme="http://ytlvy.com/categories/Memory/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS application framework -- network layer]]></title>
    <link href="http://ytlvy.com/2015/08/04/iOS-application-framework-network-layer/"/>
    <id>http://ytlvy.com/2015/08/04/iOS-application-framework-network-layer/</id>
    <published>2015-08-04T13:22:22.000Z</published>
    <updated>2015-08-04T13:22:50.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://casatwy.com/iosying-yong-jia-gou-tan-wang-luo-ceng-she-ji-fang-an.html" target="_blank" rel="external">reference</a></p>
<h2 id="iOS应用架构谈_网络层设计方案">iOS应用架构谈 网络层设计方案</h2><h3 id="前言">前言</h3><p>网络层在一个App中也是一个不可缺少的部分，工程师们在网络层能够发挥的空间也比较大。另外，苹果对网络请求部分已经做了很好的封装，业界的AFNetworking也被广泛使用。其它的ASIHttpRequest，MKNetworkKit啥的其实也都还不错，但前者已经弃坑，后者也在弃坑的边缘。在实际的App开发中，Afnetworking已经成为了事实上各大App的标准配置。</p>
<p>网络层在一个App中承载了API调用，用户操作日志记录，甚至是即时通讯等任务。我接触过一些App（开源的和不开源的）的代码，在看到网络层这一块时，尤其是在看到各位架构师各显神通展示了各种技巧，我非常为之感到兴奋。但有的时候，往往也对于其中的一些缺陷感到失望。</p>
<p>关于网络层的设计方案会有很多，需要权衡的地方也会有很多，甚至于争议的地方都会有很多。但无论如何，我都不会对这些问题做出任何逃避，我会在这篇文章中给出我对它们的看法和解决方案，观点绝不中立，不会跟大家打太极。</p>
<p>这篇文章就主要会讲这些方面：</p>
<ul>
<li>网络层跟业务对接部分的设计</li>
<li>网络层的安全机制实现</li>
<li>网络层的优化方案</li>
</ul>
<a id="more"></a>
<h3 id="网络层跟业务对接部分的设计">网络层跟业务对接部分的设计</h3><p>在安居客App的架构更新换代的时候，我深深地感觉到网络层跟业务对接部分的设计有多么重要，因此我对它做的最大改变就是针对网络层跟业务对接部分的改变。网络层跟业务层对接部分设计的好坏，会直接影响到业务工程师实现功能时的心情。</p>
<p>在正式开始讲设计之前，我们要先讨论几个问题：</p>
<ul>
<li>使用哪种交互模式来跟业务层做对接？</li>
<li>是否有必要将API返回的数据封装成对象然后再交付给业务层？</li>
<li>使用集约化调用方式还是离散型调用方式去调用API？</li>
</ul>
<p>这些问题讨论完毕之后，我会给出一个完整的设计方案来给大家做参考，设计方案是鱼，讨论的这些问题是渔，我什么都授了，大家各取所需。</p>
<h4 id="使用哪种交互模式来跟业务层做对接？">使用哪种交互模式来跟业务层做对接？</h4><p>这里其实有两个问题：</p>
<ul>
<li>以什么方式将数据交付给业务层？</li>
<li>交付什么样的数据给业务层？</li>
</ul>
<h3 id="以什么方式将数据交付给业务层？">以什么方式将数据交付给业务层？</h3><p>iOS开发领域有很多对象间数据的传递方式，我看到的大多数App在网络层所采用的方案主要集中于这三种：Delegate，Notification，Block。KVO和Target-Action我目前还没有看到有使用的。</p>
<p>目前我知道边锋主要是采用的block，大智慧主要采用的是Notification，安居客早期以Block为主，后面改成了以Delegate为主，阿里没发现有通过Notification来做数据传递的地方（可能有），Delegate、Block以及target-action都有，阿里iOS App网络层的作者说这是为了方便业务层选择自己合适的方法去使用。这里大家都是各显神通，每次我看到这部分的时候，我都喜欢问作者为什么采用这种交互方案，但很少有作者能够说出个条条框框来。</p>
<p>然而在我这边，我的意见是以Delegate为主，Notification为辅。原因如下：</p>
<ul>
<li>尽可能减少跨层数据交流的可能，限制耦合</li>
<li>统一回调方法，便于调试和维护</li>
<li>在跟业务层对接的部分只采用一种对接手段（在我这儿就是只采用delegate这一个手段）限制灵活性，以此来交换应用的可维护性</li>
</ul>
<h4 id="尽可能减少跨层数据交流的可能，限制耦合">尽可能减少跨层数据交流的可能，限制耦合</h4><p>什么叫跨层数据交流？就是某一层（或模块）跟另外的与之没有直接对接关系的层（或模块）产生了数据交换。为什么这种情况不好？严格来说应该是大部分情况都不好，有的时候跨层数据交流确实也是一种需求。之所以说不好的地方在于，<code>它会导致代码混乱，破坏模块的封装性</code>。我们在做分层架构的目的其中之一就在于下层对上层有一次抽象，让上层可以不必关心下层细节而执行自己的业务。</p>
<p>所以，如果下层细节被跨层暴露，一方面你很容易因此失去邻层对这个暴露细节的保护；另一方面，你又不可能不去处理这个细节，所以处理细节的相关代码就会散落各地，最终难以维护。</p>
<p>说得具象一点就是，我们考虑这样一种情况：A&lt;-B&lt;-C。当C有什么事件，通过某种方式告知B，然后B执行相应的逻辑。一旦告知方式不合理，让A有了跨层知道C的事件的可能，你 就很难保证A层业务工程师在将来不会对这个细节作处理。一旦业务工程师在A层产生处理操作，有可能是补充逻辑，也有可能是执行业务，那么这个细节的相关处理代码就会有一部分散落在A层。然而前者是不应该散落在A层的，后者有可能是需求。另外，因为B层是对A层抽象的，执行补充逻辑的时候，有可能和B层针对这个事件的处理逻辑产生冲突，这是我们很不希望看到的。</p>
<p>那么什么情况跨层数据交流会成为需求？在网络层这边，信号从2G变成3G变成4G变成Wi-Fi，这个是跨层数据交流的其中一个需求。不过其他的跨层数据交流需求我暂时也想不到了，哈哈，应该也就这一个吧。</p>
<hr>
<p>严格来说，使用Notification来进行网络层和业务层之间数据的交换，并不代表这一定就是跨层数据交流，但是使用Notification给跨层数据交流开了一道口子，因为Notification的影响面不可控制，只要存在实例就存在被影响的可能。另外，这也会导致谁都不能保证相关处理代码就在唯一的那个地方，进而带来维护灾难。作为架构师，在这里给业务工程师限制其操作的灵活性是必要的。另外，Notification也支持一对多的情况，这也给代码散落提供了条件。同时，Notification所对应的响应方法很难在编译层面作限制，不同的业务工程师会给他取不同的名字，这也会给代码的可维护性带来灾难。</p>
<p>手机淘宝架构组的侠武同学曾经给我分享过一个问题，在这里我也分享给大家：曾经有一个工程师在监听Notification之后，没有写释放监听的代码，当然，找到这个原因又是很漫长的一段故事，现在找到原因了，然而监听这个Notification的对象有那么多，不知道具体是哪个Notificaiton，也不知道那个没释放监听的对象是谁。后来折腾了很久大家都没办法的时候，有一个经验丰富的工程师提出用hook（Method Swizzling）的方式，最终找到了那个没释放监听的对象，bug修复了。</p>
<p>我分享这个问题的目的并不是想强调Notification多么多么不好，Notification本身就是一种设计模式，在属于他的问题领域内，Notification是非常好的一种解决方案。但我想强调的是，对于网络层这个问题领域内来看，架构师首先一定要限制代码的影响范围，在能用影响范围小的方案的时候就尽量采用这种小的方案，否则将来要是有什么奇怪需求或者出了什么小问题，维护起来就非常麻烦。因此Notification这个方案不能作为首选方案，只能作为备选。</p>
<p>那么Notification也不是完全不能使用，当需求要求跨层时，我们就可以使用Notification，比如前面提到的网络条件切换，而且这个需求也是需要满足一对多的。</p>
<p>所以，为了符合前面所说的这些要求，使用Delegate能够很好地避免跨层访问，同时限制了响应代码的形式，相比Notification而言有更好的可维护性。</p>
<hr>
<h4 id="然后我们顺便来说说为什么尽量不要用block。">然后我们顺便来说说为什么尽量不要用block。</h4><p>1) block很难追踪，难以维护</p>
<p>我们在调试的时候经常会单步追踪到某一个地方之后，发现尼玛这里有个block，如果想知道这个block里面都做了些什么事情，这时候就比较蛋疼了。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="subst">-</span> (<span class="literal">void</span>)someFunctionWithBlock:(SomeBlock <span class="subst">*</span>)block</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">...</span> <span class="attribute">...</span></span><br><span class="line"></span><br><span class="line"> <span class="subst">-&gt; </span>block();  <span class="comment">//当你单步走到这儿的时候，要想知道block里面都做了哪些事情的话，就很麻烦。</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">...</span> <span class="attribute">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2) block会延长相关对象的生命周期</p>
<p>block会给内部所有的对象引用计数加一，这一方面会带来潜在的retain cycle，不过我们可以通过Weak Self的手段解决。另一方面比较重要就是，它会延长对象的生命周期。</p>
<p>在网络回调中使用block，是block导致对象生命周期被延长的其中一个场合，当ViewController从window中卸下时，如果尚有请求带着block在外面飞，然后block里面引用了ViewController（这种场合非常常见），那么ViewController是不能被及时回收的，即便你已经取消了请求，那也还是必须得等到请求着陆之后才能被回收。</p>
<p>然而使用delegate就不会有这样的问题，delegate是弱引用，哪怕请求仍然在外面飞，，ViewController还是能够及时被回收的，回收之后指针自动被置为了nil，无伤大雅。</p>
<p>所以平时尽量不要滥用block，尤其是在网络层这里。</p>
<h4 id="统一回调方法，便于调试和维护">统一回调方法，便于调试和维护</h4><p>前面讲的是跨层问题，区分了Delegate和Notification，顺带谈了一下Block。然后现在谈到的这个情况，就是另一个采用Block方案不是很合适的情况。首先，Block本身无好坏对错之分，只有合适不合适。在这一节要讲的情况里，Block无法做到回调方法的统一，调试和维护的时候也很难在调用栈上显示出来，找的时候会很蛋疼。</p>
<p>在网络请求和网络层接受请求的地方时，使用Block没问题。但是在获得数据交给业务方时，最好还是通过Delegate去通知到业务方。因为Block所包含的回调代码跟调用逻辑放在同一个地方，会导致那部分代码变得很长，因为这里面包括了调用前和调用后的逻辑。从另一个角度说，这在一定程度上违背了<code>single function，single task</code>的原则，在需要调用API的地方，就只要写API调用相关的代码，在回调的地方，写回调的代码。</p>
<p>然后我看到大部分App里，当业务工程师写代码写到这边的时候，也意识到了这个问题。因此他们会在block里面写个一句话的方法接收参数，然后做转发，然后就可以把这个方法放在其他地方了，绕过了<code>Block的回调着陆点不统一</code>的情况。比如这样：<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[API callApiWithParam:param successed:^<span class="list">(<span class="keyword">Response</span> *response)</span><span class="collection">&#123;</span><br><span class="line">       <span class="collection">[self successedWithResponse:response]</span><span class="comment">;</span></span><br><span class="line">   &#125;</span> failed:^<span class="list">(<span class="keyword">Request</span> *request, NSError *error)</span><span class="collection">&#123;</span><br><span class="line">       <span class="collection">[self failedWithRequest:request error:error]</span><span class="comment">;</span></span><br><span class="line">   &#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>这实质上跟使用Delegate的手段没有什么区别，只是绕了一下，不过还是没有解决统一回调方法的问题，因为block里面写的方法名字可能在不同的ViewController对象中都会不一样，毕竟业务工程师也是很多人，各人有各人的想法。所以架构师在这边不要贪图方便，还是使用delegate的手段吧，业务工程师那边就能不用那么绕了。Block是目前大部分第三方网络库都采用的方式，因为在发送请求的那一部分，使用Block能够比较简洁，因此在请求那一层是没有问题的，只是在交换数据之后，还是转变成delegate比较好，比如AFNetworking里面：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr_selector">[AFNetworkingAPI callApiWithParam:self.param successed:^(Response *response)&#123;</span><br><span class="line">    if ([self.delegate respondsToSelector:@selector(successWithResponse:)]</span>) &#123;</span><br><span class="line">        <span class="attr_selector">[self.delegate successedWithResponse:response]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="tag">failed</span>:^(Request *request, NSError *error)&#123;</span><br><span class="line">    <span class="tag">if</span> ([self.delegate <span class="attribute">respondsToSelector</span>:<span class="variable">@selector</span>(<span class="attribute">failedWithResponse</span>:)]) &#123;</span><br><span class="line">        <span class="attr_selector">[self failedWithRequest:request error:error]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p>这样在业务方这边回调函数就能够比较统一，便于维护。</p>
<hr>
<p>综上，对于以什么方式将数据交付给业务层？这个问题的回答是这样：</p>
<p>尽可能通过Delegate的回调方式交付数据，这样可以避免不必要的跨层访问。当出现跨层访问的需求时（比如信号类型切换），通过Notification的方式交付数据。正常情况下应该是避免使用Block的。</p>
<h3 id="交付什么样的数据给业务层？">交付什么样的数据给业务层？</h3><p>我见过非常多的App的网络层在拿到JSON数据之后，会将数据转变成对应的对象原型。注意，我这里指的不是NSDictionary，而是类似Item这样的对象。这种做法是能够提高后续操作代码的可读性的。在比较直觉的思路里面，是需要这部分转化过程的，但这部分转化过程的成本是很大的，主要成本在于：</p>
<ul>
<li>数组内容的转化成本较高：数组里面每项都要转化成Item对象，如果Item对象中还有类似数组，就很头疼。</li>
<li>转化之后的数据在大部分情况是不能直接被展示的，为了能够被展示，还需要第二次转化。</li>
<li>只有在API返回的数据高度标准化时，这些对象原型（Item）的可复用程度才高，否则容易出现类型爆炸，提高维护成本。</li>
<li>调试时通过对象原型查看数据内容不如直接通过NSDictionary/NSArray直观。</li>
<li>同一API的数据被不同View展示时，难以控制数据转化的代码，它们有可能会散落在任何需要的地方。</li>
</ul>
<p>其实我们的理想情况是希望API的数据下发之后就能够直接被View所展示。首先要说的是，这种情况非常少。另外，这种做法使得View和API联系紧密，也是我们不希望发生的。</p>
<p>在设计安居客的网络层数据交付这部分时，我添加了reformer（名字而已，叫什么都好）这个对象用于封装数据转化的逻辑，这个对象是一个独立对象，事实上，它是作为Adaptor模式存在的。我们可以这么理解：想象一下我们洗澡时候使用的莲蓬头，水管里出来的水是API下发的原始数据。reformer就是莲蓬头上的不同水流挡板，需要什么模式，就拨到什么模式。</p>
<p>在实际使用时，代码观感是这样的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">先定义一个protocol：</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ReformerProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line">- (<span class="built_in">NSDictionary</span>)reformDataWithManager:(APIManager *)manager;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在Controller里是这样：</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span>&lt;ReformerProtocol&gt; XXXReformer;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span>&lt;ReformerProtocol&gt; YYYReformer;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - APIManagerDelegate</span></span><br><span class="line">- (<span class="keyword">void</span>)apiManagerDidSuccess:(APIManager *)manager</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *reformedXXXData = [manager fetchDataWithReformer:<span class="keyword">self</span><span class="variable">.XXXReformer</span>];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.XXXView</span> configWithData:reformedXXXData];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSDictionary</span> *reformedYYYData = [manager fetchDataWithReformer:<span class="keyword">self</span><span class="variable">.YYYReformer</span>];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.YYYView</span> configWithData:reformedYYYData];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在APIManager里面，fetchDataWithReformer是这样：</span><br><span class="line">- (<span class="built_in">NSDictionary</span>)fetchDataWithReformer:(<span class="keyword">id</span>&lt;ReformerProtocol&gt;)reformer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (reformer == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.rawData</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [reformer reformDataWithManager:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1) 要点1：reformer是一个符合ReformerProtocol的对象，它提供了通用的方法供Manager使用。</p>
<p>2) 要点2：API的原始数据（JSON对象）由Manager实例保管，reformer方法里面取Manager的原始数据(manager.rawData)做转换，然后交付出去。莲蓬头的水管部分是Manager，负责提供原始水流（数据流），reformer就是不同的模式，换什么reformer就能出来什么水流。</p>
<p>3) 要点3：例子中举的场景是一个API数据被多个View使用的情况，体现了reformer的一个特点：可以根据需要改变同一数据来源的展示方式。比如API数据展示的是“附近的小区”，那么这个数据可以被列表（XXXView）和地图（YYYView）共用，不同的view使用的数据的转化方式不一样，这就通过不同的reformer解决了。</p>
<p>4) 要点4：在一个view用来同一展示不同API数据的情况，reformer是绝佳利器。比如安居客的列表view的数据来源可能有三个：二手房列表API，租房列表API，新房列表API。这些API返回来的数据的value可能一致，但是key都是不一致的。这时候就可以通过同一个reformer来做数据的标准化输出，这样就使得view代码复用成为可能。这体现了reformer另外一个特点：同一个reformer出来的数据是高度标准化的。形象点说就是：只要莲蓬头不换，哪怕水管的水变成海水或者污水了，也依旧能够输出符合洗澡要求的淡水水流。举个例子：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="typename">void</span>)<span class="string">apiManagerDidSuccess:</span>(APIManager *)manager</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这个回调方法有可能是来自二手房列表APIManager的回调，也有可能是租房，也有可能是新房。但是在Controller层面我们不需要对它做额外区分，只要是同一个reformer出来的数据，我们就能保证是一定能被self.<span class="doctag">XXX</span>View使用的。这样的保证由reformer的实现者来提供。</span></span><br><span class="line">    NSDictionary *reformedXXXData = [manager <span class="string">fetchDataWithReformer:</span>self.XXXReformer];</span><br><span class="line">    [self.XXXView <span class="string">configWithData:</span>reformedXXXData];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5) 要点5：有没有发现，使用reformer之后，Controller的代码简洁了很多？而且，数据原型在这种情况下就没有必要存在了，随之而来的成本也就被我们绕过了。</p>
<hr>
<p>reformer本质上就是一个符合某个protocol的对象，在controller需要从api manager中获得数据的时候，顺便把reformer传进去，于是就能获得经过reformer重新洗过的数据，然后就可以直接使用了。</p>
<p>更抽象地说，reformer其实是对数据转化逻辑的一个封装。在controller从manager中取数据之后，并且把数据交给view之前，这期间或多或少都是要做一次数据转化的，有的时候不同的view，对应的转化逻辑还不一样，但是展示的数据是一样的。而且往往这一部分代码都非常复杂，且跟业务强相关，直接上代码，将来就会很难维护。所以我们可以考虑采用不同的reformer封装不同的转化逻辑，然后让controller根据需要选择一个合适的reformer装上，就像洗澡的莲蓬头，需要什么样的水流（数据的表现形式）就换什么样的头，然而水（数据）都是一样的。这种做法能够大大提高代码的可维护性，以及减少ViewController的体积。</p>
<p>总结一下，reformer事实上是把转化的代码封装之后再从主体业务中拆分了出来，拆分出来之后不光降低了原有业务的复杂度，更重要的是，它提高了数据交付的灵活性。另外，由于Controller负责调度Manager和View，因此它是知道Manager和View之间的关系的，Controller知道了这个关系之后，就有了充要条件来为不同的View选择不同的Reformer，并用这个Reformer去改造Mananger的数据，然后ViewController获得了经过reformer处理过的数据之后，就可以直接交付给view去使用。Controller因此得到瘦身，负责业务数据转化的这部分代码也不用写在Controller里面，提高了可维护性。</p>
<hr>
<p>所以reformer机制能够带来以下好处：</p>
<p>1) 好处1：绕开了API数据原型的转换，避免了相关成本。</p>
<p>2) 好处2：在处理单View对多API，以及在单API对多View的情况时，reformer提供了非常优雅的手段来响应这种需求，隔离了转化逻辑和主体业务逻辑，避免了维护灾难。</p>
<p>3) 好处3：转化逻辑集中，且将转化次数转为只有一次。使用数据原型的转化逻辑至少有两次，第一次是把JSON映射成对应的原型，第二次是把原型转变成能被View处理的数据。reformer一步到位。另外，转化逻辑在reformer里面，将来如果API数据有变，就只要去找到对应reformer然后改掉就好了。</p>
<p>4) 好处4：Controller因此可以省去非常多的代码，降低了代码复杂度，同时提高了灵活性，任何时候切换reformer而不必切换业务逻辑就可以应对不同View对数据的需要。</p>
<p>5) 好处5：业务数据和业务有了适当的隔离。这么做的话，将来如果业务逻辑有修改，换一个reformer就好了。如果其他业务也有相同的数据转化逻辑，其他业务直接拿这个reformer就可以用了，不用重写。另外，如果controller有修改（比如UI交互方式改变），可以放心换controller，完全不用担心业务数据的处理。</p>
<hr>
<h4 id="在不使用特定对象表征数据的情况下，如何保持数据可读性？">在不使用特定对象表征数据的情况下，如何保持数据可读性？</h4><p>不使用对象来表征数据的时候，事实上就是使用NSDictionary的时候。事实上，这个问题就是，如何在NSDictionary表征数据的情况下保持良好的可读性？</p>
<p>苹果已经给出了非常好的做法，用固定字符串做key，比如你在接收到KeyBoardWillShow的Notification时，带了一个userInfo，他的key就都是类似UIKeyboardAnimationCurveUserInfoKey这样的，所以我们采用这样的方案来维持可读性。下面我举一个例子：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PropertyListReformerKeys<span class="variable">.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPropertyListDataKeyID;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPropertyListDataKeyName;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPropertyListDataKeyTitle;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kPropertyListDataKeyImage;</span><br></pre></td></tr></table></figure>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PropertyListReformer<span class="class">.h</span></span><br><span class="line"></span><br><span class="line"><span class="id">#import</span> <span class="string">"PropertyListReformerKeys.h"</span></span><br><span class="line"></span><br><span class="line">... ...</span><br></pre></td></tr></table></figure>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="name">PropertyListReformer</span>.<span class="atom">m</span></span><br><span class="line"></span><br><span class="line"><span class="name">NSString</span> * <span class="atom">const</span> <span class="atom">kPropertyListDataKeyID</span> = @<span class="string">"kPropertyListDataKeyID"</span>;</span><br><span class="line"><span class="name">NSString</span> * <span class="atom">const</span> <span class="atom">kPropertyListDataKeyName</span> = @<span class="string">"kPropertyListDataKeyName"</span>;</span><br><span class="line"><span class="name">NSString</span> * <span class="atom">const</span> <span class="atom">kPropertyListDataKeyTitle</span> = @<span class="string">"kPropertyListDataKeyTitle"</span>;</span><br><span class="line"><span class="name">NSString</span> * <span class="atom">const</span> <span class="atom">kPropertyListDataKeyImage</span> = @<span class="string">"kPropertyListDataKeyImage"</span>;</span><br><span class="line"></span><br><span class="line">- (<span class="name">NSDictionary</span> *)<span class="atom">reformData</span>:(<span class="name">NSDictionary</span> *)<span class="atom">originData</span> <span class="atom">fromManager</span>:(<span class="name">APIManager</span> *)<span class="atom">manager</span></span><br><span class="line">&#123;</span><br><span class="line">    ... ...</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="name">NSDictionary</span> *<span class="atom">resultData</span> = <span class="atom">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="atom">if</span> ([<span class="atom">manager</span> <span class="atom">isKindOfClass</span>:[<span class="name">ZuFangListAPIManager</span> <span class="atom">class</span>]]) &#123;</span><br><span class="line">        <span class="atom">resultData</span> = @&#123;</span><br><span class="line">            <span class="atom">kPropertyListDataKeyID</span>:<span class="atom">originData</span>[@<span class="string">"id"</span>],</span><br><span class="line">            <span class="atom">kPropertyListDataKeyName</span>:<span class="atom">originData</span>[@<span class="string">"name"</span>],</span><br><span class="line">            <span class="atom">kPropertyListDataKeyTitle</span>:<span class="atom">originData</span>[@<span class="string">"title"</span>],</span><br><span class="line">            <span class="atom">kPropertyListDataKeyImage</span>:[<span class="name">UIImage</span> <span class="atom">imageWithUrlString</span>:<span class="atom">originData</span>[@<span class="string">"imageUrl"</span>]]</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="atom">if</span> ([<span class="atom">manager</span> <span class="atom">isKindOfClass</span>:[<span class="name">XinFangListAPIManager</span> <span class="atom">class</span>]]) &#123;</span><br><span class="line">        <span class="atom">resultData</span> = @&#123;</span><br><span class="line">            <span class="atom">kPropertyListDataKeyID</span>:<span class="atom">originData</span>[@<span class="string">"xinfang_id"</span>],</span><br><span class="line">            <span class="atom">kPropertyListDataKeyName</span>:<span class="atom">originData</span>[@<span class="string">"xinfang_name"</span>],</span><br><span class="line">            <span class="atom">kPropertyListDataKeyTitle</span>:<span class="atom">originData</span>[@<span class="string">"xinfang_title"</span>],</span><br><span class="line">            <span class="atom">kPropertyListDataKeyImage</span>:[<span class="name">UIImage</span> <span class="atom">imageWithUrlString</span>:<span class="atom">originData</span>[@<span class="string">"xinfang_imageUrl"</span>]]</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="atom">if</span> ([<span class="atom">manager</span> <span class="atom">isKindOfClass</span>:[<span class="name">ErShouFangListAPIManager</span> <span class="atom">class</span>]]) &#123;</span><br><span class="line">        <span class="atom">resultData</span> = @&#123;</span><br><span class="line">            <span class="atom">kPropertyListDataKeyID</span>:<span class="atom">originData</span>[@<span class="string">"esf_id"</span>],</span><br><span class="line">            <span class="atom">kPropertyListDataKeyName</span>:<span class="atom">originData</span>[@<span class="string">"esf_name"</span>],</span><br><span class="line">            <span class="atom">kPropertyListDataKeyTitle</span>:<span class="atom">originData</span>[@<span class="string">"esf_title"</span>],</span><br><span class="line">            <span class="atom">kPropertyListDataKeyImage</span>:[<span class="name">UIImage</span> <span class="atom">imageWithUrlString</span>:<span class="atom">originData</span>[@<span class="string">"esf_imageUrl"</span>]]</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="atom">return</span> <span class="atom">resultData</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PropertListCell</span>.m</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import "PropertyListReformerKeys.h"</span></span><br><span class="line"></span><br><span class="line">- (void)configWithData:(<span class="type">NSDictionary</span> *)<span class="typedef"><span class="keyword">data</span></span></span><br><span class="line">&#123;</span><br><span class="line">    self.imageView.image = <span class="typedef"><span class="keyword">data</span>[kPropertyListDataKeyImage];</span></span><br><span class="line">    self.idLabel.text = <span class="typedef"><span class="keyword">data</span>[kPropertyListDataKeyID];</span></span><br><span class="line">    self.nameLabel.text = <span class="typedef"><span class="keyword">data</span>[kPropertyListDataKeyName];</span></span><br><span class="line">    self.titleLabel.text = <span class="typedef"><span class="keyword">data</span>[kPropertyListDataKeyTitle];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一大段代码看下来，我如果不说一下要点，那基本上就白写了哈：</p>
<p>我们先看一下结构：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------          -----------------------------------------</span><br><span class="line">|<span class="string">                                </span>|<span class="string">          </span>|<span class="string">                                       </span>|</span><br><span class="line">|<span class="string"> PropertyListReformer.m         </span>|<span class="string">          </span>|<span class="string"> PropertyListReformer.h                </span>|</span><br><span class="line">|<span class="string">                                </span>|<span class="string">          </span>|<span class="string">                                       </span>|</span><br><span class="line">|<span class="string"> #import PropertyListReformer.h </span>|<span class="string"> &lt;------- </span>|<span class="string">  #import "PropertyListReformerKeys.h" </span>|</span><br><span class="line">|<span class="string"> NSString * const key = @"key"  </span>|<span class="string">          </span>|<span class="string">                                       </span>|</span><br><span class="line">|<span class="string">                                </span>|<span class="string">          </span>|<span class="string">                                       </span>|</span><br><span class="line">----------------------------------          -----------------------------------------</span><br><span class="line">                                                                .</span><br><span class="line">                                                               /|<span class="string">\</span><br><span class="line">                                                                </span>|</span><br><span class="line">                                                                |<span class="string"></span><br><span class="line">                                                                </span>|</span><br><span class="line">                                                                |<span class="string"></span><br><span class="line">                                                ---------------------------------</span><br><span class="line">                                                </span>|<span class="string">                               </span>|</span><br><span class="line">                                                |<span class="string"> PropertyListReformerKeys.h    </span>|</span><br><span class="line">                                                |<span class="string">                               </span>|</span><br><span class="line">                                                |<span class="string"> extern NSString * const key;  </span>|</span><br><span class="line">                                                |<span class="string">                               </span>|</span><br><span class="line">                                                ---------------------------------</span><br></pre></td></tr></table></figure></p>
<p>使用Const字符串来表征Key，字符串的定义跟着reformer的实现文件走，字符串的extern声明放在独立的头文件内。</p>
<p>这样reformer生成的数据的key都使用Const字符串来表示，然后每次别的地方需要使用相关数据的时候，把PropertyListReformerKeys.h这个头文件import进去就好了。</p>
<p>另外要注意的一点是，如果一个OriginData可能会被多个Reformer去处理的话，Key的命名规范需要能够表征出其对应的reformer名字。如果reformer是<code>PropertyListReformer</code>，那么Key的名字就是<code>PropertyListKeyXXXX</code>。</p>
<p>这么做的好处就是，将来迁移的时候相当方便，只要扔头文件就可以了，只扔头文件是不会导致拔出萝卜带出泥的情况的。而且也避免了自定义对象带来的额外代码体积。</p>
<hr>
<p>另外，关于交付的NSDictionary，其实具体还是看view的需求，reformer的设计初衷是：<code>通过reformer转化出来的可以直接是View，或者是view直接可以使用的对象（包括NSDictionary）</code>。比如地图标点列表API的数据，通过reformer转化之后就可以直接变成MKAnnotation，然后MKMapView就可以直接使用了。这里说的只是当你的需求是交付NSDictionary时，如何保证可读性的情况，再强调一下哈，reformer交付的是view直接可以使用的对象，交付出去的可以是NSDictionary，也可以是UIView，跟DataSource结合之后交付的甚至可以是UITableViewCell/UICollectionViewCell。不要被NSDictionary或所谓的<code>转化成model</code>再交付的思想局限。</p>
<hr>
<p>综上，我对<code>交付什么样的数据给业务层</code>？这个问题的回答就是这样：</p>
<p>对于业务层而言，由Controller根据View和APIManager之间的关系，选择合适的reformer将View可以直接使用的数据（甚至reformer可以用来直接生成view）转化好之后交付给View。对于网络层而言，只需要保持住原始数据即可，不需要主动转化成数据原型。然后数据采用NSDictionary加Const字符串key来表征，避免了使用对象来表征带来的迁移困难，同时不失去可读性。</p>
<h4 id="集约型API调用方式和离散型API调用方式的选择？">集约型API调用方式和离散型API调用方式的选择？</h4><p>集约型API调用其实就是所有API的调用只有一个类，然后这个类接收API名字，API参数，以及回调着陆点（可以是target-action，或者block，或者delegate等各种模式的着陆点）作为参数。然后执行类似<code>startRequest</code>这样的方法，它就会去根据这些参数起飞去调用API了，然后获得API数据之后再根据指定的着陆点去着陆。比如这样：</p>
<p>集约型API调用方式：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[APIRequest <span class="string">startRequestWithApiName:</span>@<span class="string">"itemList.v1"</span> <span class="string">params:</span>params <span class="string">success:</span><span class="annotation">@selector</span>(<span class="string">success:</span>) <span class="string">fail:</span><span class="annotation">@selector</span>(<span class="string">fail:</span>) <span class="string">target:</span>self];</span><br></pre></td></tr></table></figure></p>
<p>离散型API调用是这样的，一个API对应于一个APIManager，然后这个APIManager只需要提供参数就能起飞，API名字、着陆方式都已经集成入APIManager中。比如这样：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">离散型API调用方式：</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) ItemListAPIManager *itemListAPIManager;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getter</span></span><br><span class="line">- (ItemListAPIManager *)itemListAPIManager</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_itemListAPIManager == <span class="literal">nil</span>) &#123;</span><br><span class="line">        _itemListAPIManager = [[ItemListAPIManager alloc] init];</span><br><span class="line">        _itemListAPIManager<span class="variable">.delegate</span> = <span class="keyword">self</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _itemListAPIManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用的时候就这么写：</span></span><br><span class="line">[<span class="keyword">self</span><span class="variable">.itemListAPIManager</span> loadDataWithParams:params];</span><br></pre></td></tr></table></figure>
<p>集约型API调用和离散型API调用这两者实现方案不是互斥的，单看下层，大家都是集约型。因为发起一个API请求之后，除去业务相关的部分（比如参数和API名字等），剩下的都是要统一处理的：加密，URL拼接，API请求的起飞和着陆，这些处理如果不用集约化的方式来实现，作者非癫即痴。然而对于整个网络层来说，尤其是业务方使用的那部分，我倾向于提供离散型的API调用方式，并不建议在业务层的代码直接使用集约型的API调用方式。原因如下：</p>
<p>1) 原因1：当前请求正在外面飞着的时候，根据不同的业务需求存在两种不同的请求起飞策略：一个是取消新发起的请求，等待外面飞着的请求着陆。另一个是取消外面飞着的请求，让新发起的请求起飞。集约化的API调用方式如果要满足这样的需求，那么每次要调用的时候都要多写一部分判断和取消的代码，手段就做不到很干净。</p>
<p>前者的业务场景举个例子就是刷新页面的请求，刷新详情，刷新列表等。后者的业务场景举个例子是列表多维度筛选，比如你先筛选了商品类型，然后筛选了价格区间。当然，后者的情况不一定每次筛选都要调用API，我们先假设这种筛选每次都必须要通过调用API才能获得数据。</p>
<p>如果是离散型的API调用，在编写不同的APIManager时候就可以针对不同的API设置不同的起飞策略，在实际使用的时候，就可以不必关心起飞策略了，因为APIMananger里面已经写好了。</p>
<p>2) 原因2：便于针对某个API请求来进行AOP。在集约型的API调用方式下，如果要针对某个API请求的起飞和着陆过程进行AOP，这代码得写成什么样。。。噢，尼玛这画面太美别说看了，我都不敢想。</p>
<p>3) 原因3：当API请求的着陆点消失时，离散型的API调用方式能够更加透明地处理这种情况。</p>
<p>当一个页面的请求正在天上飞的时候，用户等了好久不耐烦了，小手点了个back，然后ViewController被pop被回收。此时请求的着陆点就没了。这是很危险的情况，着陆点要是没了，就很容易crash的。一般来说处理这个情况都是在dealloc的时候取消当前页面所有的请求。如果是集约型的API调用，这个代码就要写到ViewController的dealloc里面，但如果是离散型的API调用，这个代码写到APIManager里面就可以了，然后随着ViewController的回收进程，APIManager也会被跟着回收，这部分代码就得到了调用的机会。这样业务方在使用的时候就可以不必关心着陆点消失的情况了，从而更加关注业务。</p>
<p>4) 原因4：离散型的API调用方式能够最大程度地给业务方提供灵活性，比如reformer机制就是基于离散型的API调用方式的。另外，如果是针对提供翻页机制的API，APIManager就能简单地提供loadNextPage方法去加载下一页，页码的管理就不用业务方去管理了。还有就是，如果要针对业务请求参数进行验证，比如用户填写注册信息，在离散型的APIManager里面实现就会非常轻松。</p>
<p>综上，关于集约型的API调用和离散型的API调用，我倾向于这样：对外提供一个BaseAPIManager来给业务方做派生，在BaseManager里面采用集约化的手段组装请求，放飞请求，然而业务方调用API的时候，则是以离散的API调用方式来调用。如果你的App只提供了集约化的方式，而没有离散方式的通道，那么我建议你再封装一层，便于业务方使用离散的API调用方式来放飞请求。</p>
<hr>
<h4 id="怎么做APIManager的继承？">怎么做APIManager的继承？</h4><p>如果要做成离散型的API调用，那么使用继承是逃不掉的。BaseAPIManager里面负责集约化的部分，外部派生的XXXAPIManager负责离散的部分，对于BaseAPIManager来说，离散的部分有一些是必要的，比如API名字等，而我们派生的目的，也是为了提供这些数据。</p>
<p>我在<a href="http://casatwy.com/tiao-chu-mian-xiang-dui-xiang-si-xiang-yi-ji-cheng.html" target="_blank" rel="external">这篇文章</a>里面列举了种种继承的坏处，呼吁大家尽量不要使用继承。但是现在到了不得不用继承的时候，所以我得提醒一下大家别把继承用坏了。</p>
<p>在APIManager的情况下，我们最直觉的思路是BaseAPIManager提供一些空方法来给子类做重载，比如<code>apiMethodName</code>这样的函数，然而我的建议是，不要这么做。我们可以用IOP的方式来限制派生类的重载。</p>
<p>大概就是长这样：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">BaseAPIManager的init方法里这么写：</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意是weak。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span>&lt;APIManager&gt; child;</span><br><span class="line"></span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> confirmsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">APIManager</span>)]) </span>&#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.child</span> = (<span class="keyword">id</span>&lt;APIManager&gt;)<span class="keyword">self</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不遵守这个protocol的就让他crash，防止派生类乱来。</span></span><br><span class="line">        <span class="built_in">NSAssert</span>(<span class="literal">NO</span>, <span class="string">"子类必须要实现APIManager这个protocol。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol这么写，把原本要重载的函数都定义在这个protocol里面，就不用在父类里面写空方法了：</span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">APIManager</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)apiMethodName;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">然后在父类里面如果要使用的话，就这么写：</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span> requestWithAPIName:[<span class="keyword">self</span><span class="variable">.child</span> apiMethodName] ......];</span><br></pre></td></tr></table></figure></p>
<p>简单说就是在init的时候检查自己是否符合预先设计的子类的protocol，这就要求所有子类必须遵守这个protocol，所有针对父类的重载、覆盖也都以这个protocol为准，protocol以外的方法不允许重载、覆盖。而在父类的代码里，可以不必遵守这个protocol，保持了未来维护的灵活性。</p>
<p>这么做的好处就是避免了父类写空方法，同时也给子类带上了紧箍咒：要想当我的孩子，就要遵守这些规矩，不能乱来。业务方在实现子类的时候，就可以根据protocol中的方法去一一实现，然后约定就比较好做了：不允许重载父类方法，只允许选择实现或不实现protocol中的方法。</p>
<p>关于这个的具体的论述在<a href="http://casatwy.com/tiao-chu-mian-xiang-dui-xiang-si-xiang-er-duo-tai.html" target="_blank" rel="external">这篇文章</a>里面有，感兴趣的话可以看看。</p>
<h4 id="网络层与业务层对接部分的小总结">网络层与业务层对接部分的小总结</h4><p>这一节主要是讲了以下这些点：</p>
<ul>
<li>使用delegate来做数据对接，仅在必要时采用Notification来做跨层访问</li>
<li>交付NSDictionary给业务层，使用Const字符串作为Key来保持可读性</li>
<li>提供reformer机制来处理网络层反馈的数据，这个机制很重要，好处极多</li>
<li>网络层上部分使用离散型设计，下部分使用集约型设计</li>
<li>设计合理的继承机制，让派生出来的APIManager受到限制，避免混乱</li>
<li>应该不止这5点…</li>
</ul>
<h3 id="网络层的安全机制">网络层的安全机制</h3><h4 id="判断API的调用请求是来自于经过授权的APP">判断API的调用请求是来自于经过授权的APP</h4><p>使用这个机制的目的主要有两点：</p>
<ul>
<li>确保API的调用者是来自你自己的APP，防止竞争对手爬你的API</li>
<li>如果你对外提供了需要注册才能使用的API平台，那么你需要有这个机制来识别是否是注册用户调用了你的API</li>
</ul>
<h4 id="解决方案：设计签名">解决方案：设计签名</h4><p>要达到第一个目的其实很简单，服务端需要给你一个密钥，每次调用API时，你使用这个密钥再加上API名字和API请求参数算一个hash出来，然后请求的时候带上这个hash。服务端收到请求之后，按照同样的密钥同样的算法也算一个hash出来，然后跟请求带来的hash做一个比较，如果一致，那么就表示这个API的调用者确实是你的APP。为了不让别人也获取到这个密钥，你最好不要把这个密钥存储在本地，直接写死在代码里面就好了。另外适当增加一下求Hash的算法的复杂度，那就是各种Hash算法（比如MD5）加点盐，再回炉跑一次Hash啥的。这样就能解决第一个目的了：确保你的API是来自于你自己的App。</p>
<p>一般情况下大部分公司不会出现需要满足第二种情况的需求，除非公司开发了自己的API平台给第三方使用。这个需求跟上面的需求有一点不同：符合授权的API请求者不只是一个。所以在这种情况下，需要的安全机制会更加复杂一点。</p>
<p>这里有一个较容易实现的方案：客户端调用API的时候，把自己的密钥通过一个可逆的加密算法加密后连着请求和加密之后的Hash一起送上去。当然，这个可逆的加密算法肯定是放在在调用API的SDK里面，编译好的。然后服务端拿到加密后的密钥和加密的Hash之后，解码得到原始密钥，然后再用它去算Hash，最后再进行比对。</p>
<h4 id="保证传输数据的安全">保证传输数据的安全</h4><p>使用这个机制的主要目的有两点：</p>
<ul>
<li>防止中间人攻击，比如说运营商很喜欢往用户的Http请求里面塞广告…</li>
<li>SPDY依赖于HTTPS，而且是未来HTTP/2的基础，他们能够提高你APP在网络层整体的性能。</li>
</ul>
<h4 id="解决方案：HTTPS">解决方案：HTTPS</h4><p>目前使用HTTPS的主要目的在于防止运营商往你的Response Data里面加广告啥的（中间人攻击），面对的威胁范围更广。从2011年开始，国外业界就已经提倡所有的请求（不光是API，还有网站）都走HTTPS，国内差不多晚了两年（2013年左右）才开始提倡这事，天猫是这两个月才开始做HTTPS的全APP迁移。</p>
<p>关于速度，HTTPS肯定是比HTTP慢的，毕竟多了一次握手，但挂上SPDY之后，有了链接复用，这方面的性能就有了较大提升。这里的性能提升并不是说一个请求原来要500ms能完成，然后现在只要300ms，这是不对的。所谓整体性能是基于大量请求去讨论的：同样的请求量（假设100个）在短期发生时，挂上SPDY之后完成这些任务所要花的时间比不用SPDY要少。SPDY还有Header压缩的功能，不过因为一个API请求本身已经比较小了，压缩数据量所带来的性能提升不会特别明显，所以就单个请求来看，性能的提升是比较小的。不过这是下一节要讨论的事儿了，这儿只是顺带说一下。</p>
<h4 id="安全机制小总结">安全机制小总结</h4><p>这一节说了两种安全机制，一般来说第一种是标配，第二种属于可选配置。不过随着我国互联网基础设施的完善，移动设备性能的提高，以及优化技术的提高，第二种配置的缺点（速度慢）正在越来越微不足道，因此HTTPS也会成为不久之后的未来App的网络层安全机制标配。各位架构师们，如果你的App还没有挂HTTPS，现在就已经可以开始着手这件事情了。</p>
<hr>
<h3 id="网络层的优化方案">网络层的优化方案</h3><p>网络层的优化手段主要从以下三方面考虑：</p>
<ul>
<li>针对链接建立环节的优化</li>
<li>针对链接传输数据量的优化</li>
<li>针对链接复用的优化</li>
</ul>
<p>这三方面是所有优化手段的内容，各种五花八门的优化手段基本上都不会逃脱这三方面，下面我就会分别针对这三方面讲一下各自对应的优化手段。</p>
<h4 id="1-_针对链接建立环节的优化">1. 针对链接建立环节的优化</h4><p>在API发起请求建立链接的环节，大致会分这些步骤：</p>
<ul>
<li>发起请求</li>
<li>DNS域名解析得到IP</li>
<li>根据IP进行三次握手（HTTPS四次握手），链接建立成功</li>
</ul>
<p>其实第三步的优化手段跟第二步的优化手段是一致的，我会在讲第二步的时候一起讲掉。</p>
<h5 id="1-1_针对发起请求的优化手段">1.1 针对发起请求的优化手段</h5><p>其实要解决的问题就是网络层该不该为此API调用发起请求。</p>
<p>1) 1.1.1 使用缓存手段减少请求的发起次数</p>
<p>对于大部分API调用请求来说，有些API请求所带来的数据的时效性是比较长的，比如商品详情，比如App皮肤等。那么我们就可以针对这些数据做本地缓存，这样下次请求这些数据的时候就可以不必再发起新的请求。</p>
<p>一般是把API名字和参数拼成一个字符串然后取MD5作为key，存储对应返回的数据。这样下次有同样请求的时候就可以直接读取这里面的数据。关于这里有一个缓存策略的问题需要讨论：<code>什么时候清理缓存？</code>要么就是根据超时时间限制进行清理，要么就是根据缓存数据大小进行清理。这个策略的选择要根据具体App的操作日志来决定。</p>
<p>比如安居客App，日志数据记录显示用户平均使用时长不到3分钟，但是用户查看房源详情的次数比较多，而房源详情数据量较大。那么这个时候，就适合根据使用时长来做缓存，我当时给安居客设置的缓存超时时间就是3分钟，这样能够保证这个缓存能够在大部分用户使用时间产生作用。嗯，极端情况下做什么缓存手段不考虑，只要能够服务好80%的用户就可以了，而且针对极端情况采用的优化手段对大部分普通用户而言是不必要的，做了反而会对他们有影响。</p>
<p>再比如网络图片缓存，数据量基本上都特别大，这种就比较适合针对缓存大小来清理缓存的策略。</p>
<p>另外，之前的缓存的前提都是基于内存的。我们也可以把需要清理的缓存存储在硬盘上（APP的本地存储，我就先用硬盘来表示了，虽然很少有手机硬盘的说法，哈哈），比如前面提到的图片缓存，因为图片很有可能在很长时间之后，再被显示的，那么原本需要被清理的图片缓存，我们就可以考虑存到硬盘上去。当下次再有显示网络图片的需求的时候，我们可以先从内存中找，内存找不到那就从硬盘上找，这都找不到，那就发起请求吧。</p>
<p>当然，有些时效性非常短的API数据，就不能使用这个方法了，比如用户的资金数据，那就需要每次都调用了。</p>
<p>2) 1.1.2 使用策略来减少请求的发起次数</p>
<p>这个我在前面提到过，就是针对重复请求的发起和取消，是有对应的请求策略的。我们先说取消策略。</p>
<p>如果是界面刷新请求这种，而且存在重复请求的情况（下拉刷新时，在请求着陆之前用户不断执行下拉操作），那么这个时候，后面重复操作导致的API请求就可以不必发送了。</p>
<p>如果是条件筛选这种，那就取消前面已经发送的请求。虽然很有可能这个请求已经被执行了，那么取消所带来的性能提升就基本没有了。但如果这个请求还在队列中待执行的话，那么对应的这次链接就可以省掉了。</p>
<p>以上是一种，另外一种情况就是请求策略：类似用户操作日志的请求策略。</p>
<p>用户操作会触发操作日志上报Server，这种请求特别频繁，但是是暗地里进行的，不需要用户对此有所感知。所以也没必要操作一次就发起一次的请求。在这里就可以采用这样的策略：在本地记录用户的操作记录，当记录满30条的时候发起一次请求将操作记录上传到服务器。然后每次App启动的时候，上传一次上次遗留下来没上传的操作记录。这样能够有效降低用户设备的耗电量，同时提升网络层的性能。</p>
<h4 id="小总结">小总结</h4><p>针对建立连接这部分的优化就是这样的原则：能不发请求的就尽量不发请求，必须要发请求时，能合并请求的就尽量合并请求。然而，任何优化手段都是有前提的，而且也不能保证对所有需求都能起作用，有些API请求就是不符合这些优化手段前提的，那就老老实实发请求吧。不过这类API请求所占比例一般不大，大部分的请求都或多或少符合优化条件，所以针对发送请求的优化手段还是值得做的。</p>
<h4 id="1-2_&amp;_1-3_针对DNS域名解析做的优化，以及建立链接的优化">1.2 &amp; 1.3 针对DNS域名解析做的优化，以及建立链接的优化</h4><p>其实在整个DNS链路上也是有DNS缓存的，理论上也是能够提高速度的。这个链路上的DNS缓存在PC用户上效果明显，因为PC用户的DNS链路相对稳定，信号源不会变来变去。但是在移动设备的用户这边，链路上的DNS缓存所带来的性能提升就不太明显了。因为移动设备的实际使用场景比较复杂，网络信号源会经常变换，信号源每变换一次，对应的DNS解析链路就会变换一次，那么原链路上的DNS缓存就不起作用了。而且信号源变换的情况特别特别频繁，所以对于移动设备用户来说，链路的DNS缓存我们基本上可以默认为没有。所以大部分时间是手机系统自带的本地DNS缓存在起作用，但是一般来说，移动设备上网的需求也特别频繁，专门为我们这个App所做的DNS缓存很有可能会被别的DNS缓存给挤出去被清理掉，这种情况是特别多的，用户看一会儿知乎刷一下微博查一下地图逛一逛点评再聊个Q，回来之后很有可能属于你自己的App的本地DNS缓存就没了。这还没完，这里还有一个只有在中国特色社会主义的互联网环境中才会有的问题：国内的互联网环境由于GFW的存在，就使得DNS服务速度会比正常情况慢不少。</p>
<p>基于以上三个原因所导致的最终结果就是，API请求在DNS解析阶段的耗时会很多。</p>
<p>那么针对这个的优化方案就是，索性直接走IP请求，那不就绕过DNS服务的耗时了嘛。</p>
<hr>
<p>另外一个，就是上面提到的建立链接时候的第三步，国内的网络环境分北网通南电信（当然实际情况更复杂，这里随便说说），不同服务商之间的连接，延时是很大的，我们需要想办法让用户在最适合他的IP上给他提供服务，那么就针对我们绕过DNS服务的手段有一个额外要求：尽可能不要让用户使用对他来说很慢的IP。</p>
<p>所以综上所述，方案就应该是这样：本地有一份IP列表，这些IP是所有提供API的服务器的IP，每次应用启动的时候，针对这个列表里的所有IP取ping延时时间，然后取延时时间最小的那个IP作为今后发起请求的IP地址。</p>
<hr>
<p>针对建立连接的优化手段其实是跟DNS域名解析的优化手段是一样的。不过这需要你的服务器提供服务的网络情况要多，一般现在的服务器都是双网卡，电信和网通。由于中国特色的互联网ISP分布，南北网络之间存在瓶颈，而我们App针对链接的优化手段主要就是着手于如何减轻这个瓶颈对App产生的影响，所以需要维护一个IP列表，这样就能就近连接了，就起到了优化的效果。</p>
<p>我们一般都是在应用启动的时候获得本地列表中所有IP的ping值，然后通过NSURLProtocol的手段将URL中的HOST修改为我们找到的最快的IP。另外，这个本地IP列表也会需要通过一个API来维护，一般是每天第一次启动的时候读一次API，然后更新到本地。</p>
<p>如果你还不熟悉<code>NSURLProtocol</code>应该怎么玩，看完<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSURLProtocol_Class/" target="_blank" rel="external">官方文档</a>和<a href="http://nshipster.com/nsurlprotocol/" target="_blank" rel="external">这篇文章</a>以及这个Demo之后，你肯定就会了，其实很简单的。另外，刚才提到那篇文章的作者(mattt)还写了<a href="https://github.com/mattt/NSEtcHosts" target="_blank" rel="external">这个基于NSURLProtocol的工具</a>，相当好用，是可以直接拿来集成到项目中的。</p>
<p>不用NSURLProtocol的话，用其他手段也可以做到这一点，但那些手段未免又比较愚蠢。</p>
<h4 id="2-_针对链接传输数据量的优化">2. 针对链接传输数据量的优化</h4><p>这个很好理解，传输的数据少了，那么自然速度就上去了。这里没什么花样可以讲的，就是压缩呗。各种压缩。</p>
<h4 id="3-_针对链接复用的优化">3. 针对链接复用的优化</h4><p>建立链接本身是属于比较消耗资源的操作，耗电耗时。SPDY自带链接复用以及数据压缩的功能，所以服务端支持SPDY的时候，App直接挂SPDY就可以了。如果服务端不支持SPDY，也可以使用PipeLine，苹果原生自带这个功能。</p>
<p>一般来说业界内普遍的认识是SPDY优于PipeLine，然后即便如此，SPDY能够带来的网络层效率提升其实也没有文献上的图表那么明显，但还是有性能提升的。还有另外一种比较笨的链接复用的方法，就是维护一个队列，然后将队列里的请求压缩成一个请求发出去，之所以会存在滞留在队列中的请求，是因为在上一个请求还在外面飘的时候。这种做法最终的效果表面上看跟链接复用差别不大，但并不是真正的链接复用，只能说是请求合并。</p>
<p>还是说回来，我建议最好是用SPDY，SPDY和pipeline虽然都属于链接复用的范畴，但是pipeline并不是真正意义上的链接复用，SPDY的链接复用相对pipeline而言更为彻底。SPDY目前也有现成的客户端SDK可以使用，一个是twitter的<a href="https://github.com/twitter/CocoaSPDY" target="_blank" rel="external"><code>CocoaSPDY</code></a>，另一个是<a href="https://github.com/Voxer/iSPDY" target="_blank" rel="external">Voxer/<code>iSPDY</code></a>，这两个库都很活跃，大家可以挑合适的采用。</p>
<p>不过目前业界趋势是倾向于使用HTTP/2.0来代替SPDY，不过目前HTTP/2.0还没有正式出台，相关实现大部分都处在demo阶段，所以我们还是先SPDY搞起就好了。未来很有可能会放弃SPDY，转而采用HTTP/2.0来实现网络的优化。这是要提醒各位架构师注意的事情。嗯，我也不知道HTTP/2.0什么时候能出来。</p>
<hr>
<h4 id="渔说完了，鱼来了">渔说完了，鱼来了</h4><p><a href="https://github.com/casatwy/RTNetworking" target="_blank" rel="external">这里</a>是我当年设计并实现的安居客的网络层架构代码。当然，该脱敏的地方我都已经脱敏了，所以编不过是正常的，哈哈哈。但是代码比较齐全，重要地方注释我也写了很多。另外，为了让大家能够把这些代码看明白，我还附带了当年介绍这个框架演讲时的PPT。(<code>补充说明一下，评论区好多人问PPT找不着在哪儿，PPT也在上面提到的repo里面，是个key后缀名的文件，用keynote打开</code>)</p>
<p>然后就是，当年也有很多问题其实考虑得并没有现在清楚，所以有些地方还是做得不够好，比如拦截器和继承。而且当时的优化手段只有本地cache，安居客没有那么多IP可以给我ping，当年也没流行SPDY，而且API也还不支持HTTPS，所以当时的代码里面没有在这些地方做优化，比较原始。然而整个架构的基本思路一直没有变化：优先服务于业务方。另外，安居客的网络层多了一个service的概念，这是我这篇文章中没有讲的。主要是因为安居客的API提供方很多，二手房，租房，新房，X项目等等API都是不同的API team提供的，以service作区分，如果你的app也是类似的情况，我也建议你设计一套service机制。现在这些service被我删得只剩下一个google的service，因为其他service都属于敏感内容。</p>
<p>另外，这里面提供的PPT我很希望大家能够花时间去看看，在PPT里面有些更加细的东西我在博客里没有写，主要是我比较懒，然后这篇文章拖的时间比较长了，花时间搬运这个没什么意思，不过内容还是值得各位读者去看的。关于PPT里面大家有什么问题的，也可以在评论区问，我都会回答。</p>
<h3 id="总结">总结</h3><p>第一部分主要讲了网络层应当如何跟业务层进行数据交互，进行数据交互时采用怎样的数据格式，以及设计时代码结构上的一些问题，诸如继承的处理，回调的处理，交互方式的选择，reformer的设计，保持数据可读性等等等等，主要偏重于设计（这可是艺术活，哈哈哈）。</p>
<p>第二部分讲了网络安全上，客户端要做的两点。当然，从网络安全的角度上讲，服务端也要做很多很多事情，客户端要做的一些边角细节的事情也还会有很多，比如做一些代码混淆，尽可能避免代码中明文展示key。不过大头主要就是这两个，而且也都是需要服务端同学去配合的。主要偏重于介绍。（主要是也没啥好实践的，google一下教程照着来就好了）。</p>
<p>第三部分讲了优化，优化的所有方面都已经列出来了，如果业界再有七七八八的别的手段，也基本逃离不出本文的范围。这里有些优化手段是需要服务端同学配合的，有些不需要，大家看各自情况来决定。主要偏重于实践。</p>
<p>最后给出了我之前在安居客做的网络层架构的主要代码，以及当时演讲时的PPT。关于代码或PPT中有任何问题，都可以在评论区问我。</p>
<p>这一篇文章出得比较晚，因为公司的事情，中间间隔了一个礼拜，希望大家谅解。另外，隔了一个礼拜之后我再写，发现有些地方我已经想不起来当初是应该怎么行文下去的了，然后发之前我把文章又看了几遍，尽可能把断片的地方抹平了，如果大家读起来有什么地方感觉奇怪的，或者讲到一半就没了的，那应该就是断片了。在评论区跟我说一下，我补上去。</p>
<p>然后如果有需要勘误的地方，也请在评论区指出，帮助我把错的地方订正回来，如果有没讲到的地方，但你又特别想要了解的，也可以在评论区提出来，我会补上去。说不定看完之后你脑袋里还会有很多个问号，也请在评论区问出来哈，说不定别人也有跟你一样的问题，他就能在评论区找到答案了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://casatwy.com/iosying-yong-jia-gou-tan-wang-luo-ceng-she-ji-fang-an.html">reference</a></p>
<h2 id="iOS应用架构谈_网络层设计方案">iOS应用架构谈 网络层设计方案</h2><h3 id="前言">前言</h3><p>网络层在一个App中也是一个不可缺少的部分，工程师们在网络层能够发挥的空间也比较大。另外，苹果对网络请求部分已经做了很好的封装，业界的AFNetworking也被广泛使用。其它的ASIHttpRequest，MKNetworkKit啥的其实也都还不错，但前者已经弃坑，后者也在弃坑的边缘。在实际的App开发中，Afnetworking已经成为了事实上各大App的标准配置。</p>
<p>网络层在一个App中承载了API调用，用户操作日志记录，甚至是即时通讯等任务。我接触过一些App（开源的和不开源的）的代码，在看到网络层这一块时，尤其是在看到各位架构师各显神通展示了各种技巧，我非常为之感到兴奋。但有的时候，往往也对于其中的一些缺陷感到失望。</p>
<p>关于网络层的设计方案会有很多，需要权衡的地方也会有很多，甚至于争议的地方都会有很多。但无论如何，我都不会对这些问题做出任何逃避，我会在这篇文章中给出我对它们的看法和解决方案，观点绝不中立，不会跟大家打太极。</p>
<p>这篇文章就主要会讲这些方面：</p>
<ul>
<li>网络层跟业务对接部分的设计</li>
<li>网络层的安全机制实现</li>
<li>网络层的优化方案</li>
</ul>]]>
    
    </summary>
    
      <category term="Framework" scheme="http://ytlvy.com/tags/Framework/"/>
    
      <category term="Framework" scheme="http://ytlvy.com/categories/Framework/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS application framework -- view layer]]></title>
    <link href="http://ytlvy.com/2015/08/04/iOS-application-framework-view-layer/"/>
    <id>http://ytlvy.com/2015/08/04/iOS-application-framework-view-layer/</id>
    <published>2015-08-04T13:21:34.000Z</published>
    <updated>2015-08-04T13:22:05.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html" target="_blank" rel="external">reference</a></p>
<h2 id="iOS应用架构谈_view层的组织和调用方案">iOS应用架构谈 view层的组织和调用方案</h2><h3 id="前言">前言</h3><p>《iOS应用架构谈 开篇》出来之后，很多人来催我赶紧出第二篇。这一篇文章出得相当艰难，因为公司里的破事儿特别多，我自己又有点私事儿，以至于能用来写博客的时间不够充分。</p>
<p>现在好啦，第二篇出来了。</p>
<hr>
<p>当我们开始设计View层的架构时，往往是这个App还没有开始开发，或者这个App已经发过几个版本了，然后此时需要做非常彻底的重构。</p>
<p>一般也就是这两种时机会去做View层架构，基于这个时机的特殊性，我们在这时候必须清楚认识到：View层的架构一旦实现或定型，在App发版后可修改的余地就已经非常之小了。因为它跟业务关联最为紧密，所以哪怕稍微动一点点，它所引发的蝴蝶效应都不见得是业务方能够hold住的。这样的情况，就要求我们在实现这个架构时，代码必须得改得勤快，不能偷懒。也必须抱着充分的自我怀疑态度，做决策时要拿捏好尺度。</p>
<hr>
<p>View层的架构非常之重要，在我看来，这部分架构是这系列文章涉及4个方面最重要的一部分，没有之一。为什么这么说？</p>
<a id="more"></a>
<h4 id="View层架构是影响业务方迭代周期的因素之一">View层架构是影响业务方迭代周期的因素之一</h4><p>产品经理产生需求的速度会非常快，尤其是公司此时仍处于创业初期，在规模稍大的公司里面，产品经理也喜欢挖大坑来在leader面前刷存在感，比如阿里。这就导致业务工程师任务非常繁重。正常情况下让产品经理砍需求是不太可能的，因此作为架构师，在架构里有一些可做可不做的事情，最好还是能做就做掉，不要偷懒。这可以帮业务方减负，编写代码的时候也能更加关注业务。</p>
<p>我跟一些朋友交流的时候，他们都会或多或少地抱怨自己的团队迭代速度不够快，或者说，迭代速度不合理地慢。我认为迭代速度不是想提就能提的，迭代速度的影响因素有很多，一期PRD里的任务量和任务复杂度都会影响迭代周期能达到什么样的程度。抛开这些外在的不谈，从内在可能导致迭代周期达不到合理的速度的原因来看，其中有一个原因很有可能就是View层架构没有做好，让业务工程师完成一个不算复杂的需求时，需要处理太多额外的事情。当然，开会多，工程师水平烂也属于迭代速度提不上去的内部原因，但这个不属于本文讨论范围。还有，<code>加班不是优化迭代周期的正确方式</code>，嗯。</p>
<p>一般来说，一个不够好的View层架构，主要原因有以下五种：</p>
<ul>
<li>代码混乱不规范</li>
<li>过多继承导致的复杂依赖关系</li>
<li>模块化程度不够高，组件粒度不够细</li>
<li>横向依赖</li>
<li>架构设计失去传承</li>
</ul>
<p>这五个地方会影响业务工程师实现需求的效率，进而拖慢迭代周期。View架构的其他缺陷也会或多或少地产生影响，但在我看来这里五个是比较重要的影响因素。如果大家觉得还有什么因素比这四个更高的，可以在评论区提出来我补上去。</p>
<p>对于第五点我想做一下强调：架构的设计是一定需要有传承的，有传承的架构从整体上看会非常协调。但实际情况有可能是一个人走了，另一个顶上，即便任务交接得再完整，都不可避免不同的人有不同的架构思路，从而导致整个架构的流畅程度受到影响。要解决这个问题，一方面要尽量避免单点问题，让架构师做架构的时候再带一个人。另一方面，架构要设计得尽量简单，平缓接手人的学习曲线。我离开安居客的时候，做过保证：<code>凡是从我手里出来的代码，终身保修</code>。所以不要想着离职了就什么事儿都不管了，这不光是职业素养问题，还有一个是你对你的代码是否足够自信的问题。传承性对于View层架构非常重要，因为它距离业务最近，改动余地最小。</p>
<p>所以当各位CTO、技术总监、TeamLeader们觉得迭代周期不够快时，你可以先不忙着急吼吼地去招新人，《人月神话》早就说过加人不能完全解决问题。这时候如果你可以回过头来看一下是不是View层架构不合理，把这个弄好也是优化迭代周期的手段之一。</p>
<p>嗯，至于本系列其他三项的架构方案对于迭代周期的影响程度，我认为都不如View层架构方案对迭代周期的影响高，所以这是我认为View层架构是最重要的其中一个理由。</p>
<h4 id="View层架构是最贴近业务的底层架构">View层架构是最贴近业务的底层架构</h4><p>View层架构虽然也算底层，但还没那么底层，它跟业务的对接面最广，影响业务层代码的程度也最深。在所有的底层都牵一发的时候，在View架构上牵一发导致业务层动全身的面积最大。</p>
<p>所以View架构在所有架构中一旦定型，可修改的空间就最小，我们在一开始考虑View相关架构时，不光要实现功能，还要考虑更多规范上的东西。制定规范的目的一方面是防止业务工程师的代码腐蚀View架构，另一方面也是为了能够有所传承。按照规范来，总还是不那么容易出差池的。</p>
<p>还有就是，架构师一开始考虑的东西也会有很多，不可能在第一版就把它们全部实现，对于一个尚未发版的App来说，第一版架构往往是最小完整功能集，那么在第二版第三版的发展过程中，架构的迭代任务就很有可能不只是你一个人的事情了，相信你一个人也不见得能搞定全部。所以你要跟你的合作者们有所约定。另外，第一版出去之后，业务工程师在使用过程中也会产生很多修改意见，哪些意见是合理的，哪些意见是不合理的，也要通过事先约定的规范来进行筛选，最终决定如何采纳。</p>
<p>规范也不是一成不变的，什么时候枪毙意见，什么时候改规范，这就要靠各位的技术和经验了。</p>
<hr>
<p>以上就是前言。</p>
<h3 id="这篇文章讲什么？">这篇文章讲什么？</h3><ul>
<li>View代码结构的规定</li>
<li>关于view的布局</li>
<li>何时使用storyboard，何时使用nib，何时使用代码写View</li>
<li>是否有必要让业务方统一派生ViewController？</li>
<li>方便View布局的小工具</li>
<li>MVC、MVVM、MVCS、VIPER</li>
<li>本门心法</li>
<li>跨业务时View的处理</li>
<li>留给评论区各种补</li>
<li>总结</li>
</ul>
<h3 id="View代码结构的规定">View代码结构的规定</h3><p>架构师不是写SDK出来交付业务方使用就没事儿了的，每家公司一定都有一套代码规范，架构师的职责也包括定义代码规范。按照道理来讲，定代码规范应该是属于通识，放在这里讲的原因只是因为我这边需要为View添加一个规范。</p>
<p>制定代码规范严格来讲不属于View层架构的事情，但它对View层架构未来的影响会比较大，也是属于架构师在设计View层架构时需要考虑的事情。制定View层规范的重要性在于：</p>
<ul>
<li>提高业务方View层的可读性可维护性</li>
<li>防止业务代码对架构产生腐蚀</li>
<li>确保传承</li>
<li>保持架构发展的方向不轻易被不合理的意见所左右</li>
</ul>
<p>在这一节里面我不打算从头开始定义一套规范，苹果有一套<code>Coding Guidelines</code>，当我们定代码结构或规范的时候，首先一定要符合这个规范。</p>
<p>然后，相信大家各自公司里面也都有一套自己的规范，具体怎么个规范法其实也是根据各位架构师的经验而定，我这边只是建议各位在各自规范的基础上再加上下面这一点。</p>
<hr>
<p>viewController的代码应该差不多是这样：</p>
<p><img src="http://casatwy.com/pics/iOSView/pic1.png" alt=""></p>
<p>要点如下：</p>
<h4 id="所有的属性都使用getter和setter">所有的属性都使用getter和setter</h4><p>不要在viewDidLoad里面初始化你的view然后再add，这样代码就很难看。在viewDidload里面只做addSubview的事情，然后在viewWillAppear里面做布局的事情（勘误1），最后在viewDidAppear里面做Notification的监听之类的事情。至于属性的初始化，则交给getter去做。</p>
<p>比如这样：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - life cycle&#10;- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;&#10;    self.view.backgroundColor = [UIColor whiteColor];&#10;    [self.view addSubview:self.firstTableView];&#10;    [self.view addSubview:self.secondTableView];&#10;    [self.view addSubview:self.firstFilterLabel];&#10;    [self.view addSubview:self.secondFilterLabel];&#10;    [self.view addSubview:self.cleanButton];&#10;    [self.view addSubview:self.originImageView];&#10;    [self.view addSubview:self.processedImageView];&#10;    [self.view addSubview:self.activityIndicator];&#10;    [self.view addSubview:self.takeImageButton];&#10;&#125;&#10;&#10;- (void)viewWillAppear:(BOOL)animated&#10;&#123;&#10;    [super viewWillAppear:animated];&#10;&#10;    CGFloat width = (self.view.width - 30) / 2.0f;&#10;&#10;    self.originImageView.size = CGSizeMake(width, width);&#10;    [self.originImageView topInContainer:70 shouldResize:NO];&#10;    [self.originImageView leftInContainer:10 shouldResize:NO];&#10;&#10;    self.processedImageView.size = CGSizeMake(width, width);&#10;    [self.processedImageView right:10 FromView:self.originImageView];&#10;    [self.processedImageView topEqualToView:self.originImageView];&#10;&#10;    CGFloat labelWidth = self.view.width - 100;&#10;    self.firstFilterLabel.size = CGSizeMake(labelWidth, 20);&#10;    [self.firstFilterLabel leftInContainer:10 shouldResize:NO];&#10;    [self.firstFilterLabel top:10 FromView:self.originImageView];&#10;&#10;    ... ...&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样即便在属性非常多的情况下，还是能够保持代码整齐，view的初始化都交给getter去做了。总之就是尽量不要出现以下的情况：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad&#10;&#123;&#10;    [super viewDidLoad];&#10;&#10;    self.textLabel = [[UILabel alloc] init];&#10;    self.textLabel.textColor = [UIColor blackColor];&#10;    self.textLabel ... ...&#10;    self.textLabel ... ...&#10;    self.textLabel ... ...&#10;    [self.view addSubview:self.textLabel];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这种做法就不够干净，都扔到getter里面去就好了。关于这个做法，在唐巧的技术博客里面有一篇文章和我所提倡的做法不同，这个我会放在后面详细论述。</p>
<h4 id="getter和setter全部都放在最后">getter和setter全部都放在最后</h4><p>因为一个ViewController很有可能会有非常多的view，就像上面给出的代码样例一样，如果getter和setter写在前面，就会把主要逻辑扯到后面去，其他人看的时候就要先划过一长串getter和setter，这样不太好。然后要求业务工程师写代码的时候按照顺序来分配代码块的位置，先是<code>life cycle</code>，然后是<code>Delegate</code>方法实现，然后是<code>event response</code>，然后才是<code>getters and setters</code>。这样后来者阅读代码时就能省力很多。</p>
<h4 id="每一个delegate都把对应的protocol名字带上，delegate方法不要到处乱写，写到一块区域里面去">每一个delegate都把对应的protocol名字带上，delegate方法不要到处乱写，写到一块区域里面去</h4><p>比如UITableViewDelegate的方法集就老老实实写上#pragma mark - UITableViewDelegate。这样有个好处就是，当其他人阅读一个他并不熟悉的Delegate实现方法时，他只要按住command然后去点这个protocol名字，Xcode就能够立刻跳转到对应这个Delegate的protocol定义的那部分代码去，就省得他到处找了。</p>
<h4 id="event_response专门开一个代码区域">event response专门开一个代码区域</h4><p>所有button、gestureRecognizer的响应事件都放在这个区域里面，不要到处乱放。</p>
<h4 id="关于private_methods，正常情况下ViewController里面不应该写">关于private methods，正常情况下ViewController里面不应该写</h4><p>不是delegate方法的，不是event response方法的，不是life cycle方法的，就是private method了。对的，正常情况下ViewController里面一般是不会存在private methods的，这个private methods一般是用于日期换算、图片裁剪啥的这种小功能。这种小功能要么把它写成一个category，要么把他做成一个模块，哪怕这个模块只有一个函数也行。</p>
<p>ViewController基本上是大部分业务的载体，本身代码已经相当复杂，所以跟业务关联不大的东西能不放在ViewController里面就不要放。另外一点，这个private method的功能这时候只是你用得到，但是将来说不定别的地方也会用到，一开始就独立出来，有利于将来的代码复用。</p>
<h4 id="为什么要这样要求？">为什么要这样要求？</h4><p>我见过无数ViewController，代码布局乱得一塌糊涂，这里一个delegate那里一个getter，然后ViewController的代码一般都死长死长的，看了就让人头疼。</p>
<p>定义好这个规范，就能使得ViewController条理清晰，业务方程序员很能够区分哪些放在ViewController里面比较合适，哪些不合适。另外，也可以提高代码的可维护性和可读性。</p>
<h3 id="关于View的布局">关于View的布局</h3><p>业务工程师在写View的时候一定逃不掉的就是这个命题。用Frame也好用Autolayout也好，如果没有精心设计过，布局部分一定惨不忍睹。</p>
<p>直接使用CGRectMake的话可读性很差，光看那几个数字，也无法知道view和view之间的位置关系。用Autolayout可读性稍微好点儿，但生成Constraint的长度实在太长，代码观感不太好。</p>
<p>Autolayout这边可以考虑使用Masonry，代码的可读性就能好很多。如果还有使用Frame的，可以考虑一下使用这个<a href="https://github.com/casatwy/HandyAutoLayout" target="_blank" rel="external">项目</a>。</p>
<p>这个项目里面提供了Frame相关的方便方法(<code>UIView+LayoutMethods</code>)，里面的方法也基本涵盖了所有布局的需求，可读性非常好，使用它之后基本可以和CGRectMake说再见了。因为天猫在最近才切换到支持iOS6，所以之前天猫都是用Frame布局的，在天猫App中，首页，范儿部分页面的布局就使用了这些方法。使用这些方便方法能起到事半功倍的效果。</p>
<p>这个项目也提供了Autolayout方案下生产Constraints的方便方法(UIView+AEBHandyAutoLayout)，可读性比原生好很多。我当时在写这系列方法的时候还不知道有Masonry。知道有Masonry之后我特地去看了一下，发现Masonry功能果然强大。不过这系列方法虽然没有Masonry那么强大，但是也够用了。当时安居客iPad版App全部都是Autolayout来做的View布局，就是使用的这个项目里面的方法。可读性很好。</p>
<p>让业务工程师使用良好的工具来做View的布局，能提高他们的工作效率，也能减少bug发生的几率。架构师不光要关心那些高大上的内容，也要多给业务工程师提供方便易用的小工具，才能发挥架构师的价值。</p>
<h3 id="何时使用storyboard，何时使用nib，何时使用代码写View">何时使用storyboard，何时使用nib，何时使用代码写View</h3><p>这个问题唐巧的博客里<a href="http://blog.devtang.com/blog/2015/03/22/ios-dev-controversy-2/" target="_blank" rel="external">这篇文章</a>也提到过，我的意见和他是基本一致的。</p>
<p>在这里我还想补充一些内容：</p>
<p>具有一定规模的团队化iOS开发（10人以上）有以下几个特点：</p>
<ol>
<li>同一份代码文件的作者会有很多，不同作者同时修改同一份代码的情况也不少见。因此，使用Git进行代码版本管理时出现Conflict的几率也比较大。</li>
<li>需求变化非常频繁，产品经理一时一个主意，为了完成需求而针对现有代码进行微调的情况，以及针对现有代码的部分复用的情况也比较多。</li>
<li>复杂界面元素、复杂动画场景的开发任务比较多。</li>
</ol>
<p>如果这三个特点你一看就明白了，下面的解释就可以不用看了。如果你针对我的倾向愿意进一步讨论的，可以先看我下面的解释，看完再说。</p>
<h4 id="同一份代码文件的作者会有很多，不同作者同时修改同一份代码的情况也不少见。因此，使用Git进行代码版本管理时出现Conflict的几率也比较大。">同一份代码文件的作者会有很多，不同作者同时修改同一份代码的情况也不少见。因此，使用Git进行代码版本管理时出现Conflict的几率也比较大。</h4><p>iOS开发过程中，会遇到最蛋疼的两种Conflict一个是<code>project.pbxproj</code>，另外一个就是<code>StoryBoard</code>或<code>XIB</code>。因为这些文件的内容的可读性非常差，虽然苹果在XCode5（现在我有点不确定是不是这个版本了）中对<code>StoryBoard</code>的文件描述方式做了一定的优化，但只是把可读性从非常差提升为很差。</p>
<p>然而在StoryBoard中往往包含了多个页面，这些页面基本上不太可能都由一个人去完成，如果另一个人在做StoryBoard的操作的时候，出于某些目的动了一下不属于他的那个页面，比如为了美观调整了一下位置。然后另外一个人也因为要添加一个页面，而在Storyboard中调整了一下某个其他页面的位置。那么针对这个情况我除了说个呵呵以外，我就只能说：祝你好运。看清楚哦，这还没动具体的页页面内容呢。</p>
<p>但如果使用代码绘制View，Conflict一样会发生，但是这种Conflict就好解很多了，你懂的。</p>
<h4 id="需求变化非常频繁，产品经理一时一个主意，为了完成需求而针对现有代码进行微调的情况，以及针对现有代码的部分复用的情况也比较多。">需求变化非常频繁，产品经理一时一个主意，为了完成需求而针对现有代码进行微调的情况，以及针对现有代码的部分复用的情况也比较多。</h4><p>我觉得产品经理一时一个主意不是他的错，他说不定也是被逼的，比如谁都会来掺和一下产品的设计，公司里的所有人，上至CEO，下至基层员工都有可能对产品设计评头论足，只要他个人有个地方用得不爽（极大可能是个人喜好）然后又正好跟产品经理比较熟悉能够搭得上话，都会提出各种意见。产品经理躲不起也惹不起，有时也是没办法，嗯。</p>
<p>但落实到工程师这边来，这种情况就很蛋疼。因为这种改变有时候不光是UI，UI所对应的逻辑也有要改的可能，工程师就会两边文件都改，你原来link的那个view现在不link了，然后你的outlet对应也要删掉，这两部分只要有一个没做，编译通过之后跑一下App，一会儿就crash了。看起来这不是什么大事儿，但很影响心情。</p>
<p>另外，如果出现部分的代码复用，比如说某页面下某个View也希望放在另外一个页面里，相关的操作就不是复制粘贴这么简单了，你还得重新link一遍。也很影响心情。</p>
<h4 id="复杂界面元素，复杂动画交互场景的开发任务比较多。">复杂界面元素，复杂动画交互场景的开发任务比较多。</h4><p>要是想在基于StoryBoard的项目中做一个动画，很烦。做几个复杂界面元素，也很烦。有的时候我们挂Custom View上去，其实在StoryBoard里面看来就是一个空白View。然后另外一点就是，当你的layout出现问题需要调整的时候，还是挺难找到问题所在的，尤其是在复杂界面元素的情况下。</p>
<p>所以在针对View层这边的要求时，我也是建议不要用StoryBoard。实现简单的东西，用Code一样简单，实现复杂的东西，Code比StoryBoard更简单。所以我更加提倡用code去画view而不是storyboard。</p>
<h3 id="是否有必要让业务方统一派生ViewController">是否有必要让业务方统一派生ViewController</h3><p>有的时候我们出于记录用户操作行为数据的需要，或者统一配置页面的目的，会从UIViewController里面派生一个自己的ViewController，来执行一些通用逻辑。比如天猫客户端要求所有的ViewController都要继承自TMViewController。这个统一的父类里面针对一个ViewController的所有生命周期都做了一些设置，至于这里都有哪些设置对于本篇文章来说并不重要。在这里我想讨论的是，在设计View架构时，如果为了能够达到统一设置或执行统一逻辑的目的，使用派生的手段是有必要的吗？</p>
<p>我觉得没有必要，为什么没有必要？</p>
<ol>
<li>使用派生比不使用派生更容易增加业务方的使用成本</li>
<li>不使用派生手段一样也能达到统一设置的目的</li>
</ol>
<p>这两条原因是我认为没有必要使用派生手段的理由，如果两条理由你都心领神会，那么下面的就可以不用看了。如果你还有点疑惑，请看下面我来详细讲一下原因。</p>
<h4 id="为什么使用了派生，业务方的使用成本会提升？">为什么使用了派生，业务方的使用成本会提升？</h4><p>其实不光是业务方的使用成本，架构的维护成本也会上升。那么具体的成本都来自于哪里呢？</p>
<p>1) 集成成本<br>这里讲的集成成本是这样的：如果业务方自己开了一个独立demo，快速完成了某个独立流程，现在他想把这个现有流程集合进去。那么问题就来了，他需要把所有独立的UIViewController改变成TMViewController。那为什么不是一开始就立刻使用TMViewController呢？因为要想引入TMViewController，就要引入整个天猫App所有的业务线，所有的基础库，因为这个父类里面涉及很多天猫环境才有的内容，所谓拔出萝卜带出泥，你要是想简单继承一下就能搞定的事情，搭环境就要搞半天，然后这个小Demo才能跑得起来。</p>
<p>对于业务层存在的所有父类来说，它们是很容易跟项目中的其他代码纠缠不清的，这使得业务方开发时遇到一个两难问题：<code>要么把所有依赖全部搞定，然后基于App环境（比如天猫）下开发Demo，要么就是自己Demo写好之后，按照环境要求改代码</code>。这里的两难问题都会带来成本，都会影响业务方的迭代进度。</p>
<p>我不确定各位所在公司是否会有这样的情况，但我可以在这里给大家举一个我在阿里的真实的例子：我最近在开发某滤镜Demo和相关页面流程，最终是要合并到天猫这个App里面去的。使用天猫环境进行开发的话，pod install完所有依赖差不多需要10分钟，然后打开workspace之后，差不多要再等待1分钟让xcode做好索引，然后才能正式开始工作。在这里要感谢一下则平，因为他在此基础上做了很多优化，使得这个1分钟已经比原来的时间短很多了。但如果天猫环境有更新，你就要再重复一次上面的流程，否则 就很有可能编译不过。</p>
<p>拜托，我只是想做个Demo而已，不想搞那么复杂。</p>
<p>2) 上手接受成本<br>新来的业务工程师有的时候不见得都记得每一个ViewController都必须要派生自TMViewController而不是直接的UIViewController。新来的工程师他不能直接按照苹果原生的做法去做事情，他需要额外学习，比如说：所有的ViewController都必须继承自TMViewController。</p>
<p>3) 架构的维护难度<br>尽可能少地使用继承能提高项目的可维护性，具体内容我在<a href="http://casatwy.com/tiao-chu-mian-xiang-dui-xiang-si-xiang-yi-ji-cheng.html" target="_blank" rel="external">《跳出面向对象思想（一） 继承》</a>里面说了，在这里我想偷懒不想把那篇文章里说过的东西再说一遍。</p>
<p>其实对于业务方来说，主要还是第一个集成成本比较蛋疼，因为这是长痛，每次要做点什么事情都会遇到。第二点倒还好，短痛。第三点跟业务工程师没啥关系。</p>
<h4 id="那么如果不使用派生，我们应该使用什么手段？">那么如果不使用派生，我们应该使用什么手段？</h4><p>我的建议是使用AOP。</p>
<p>在架构师实现具体的方案之前，必须要想清楚几个问题，然后才能决定采用哪种方案。是哪几个问题？</p>
<ul>
<li>方案的效果，和最终要达到的目的是什么？</li>
<li>在自己的知识体系里面，是否具备实现这个方案的能力？</li>
<li>在业界已有的开源组件里面，是否有可以直接拿来用的轮子？</li>
</ul>
<p>这三个问题按照顺序一一解答之后，具体方案就能出来了。</p>
<h4 id="我们先看第一个问题：方案的效果，和最终要达到的目的是什么？">我们先看第一个问题：方案的效果，和最终要达到的目的是什么？</h4><p>方案的效果应该是：</p>
<ol>
<li>业务方可以不用通过继承的方法，然后框架能够做到对ViewController的统一配置。</li>
<li>业务方即使脱离框架环境，不需要修改任何代码也能够跑完代码。业务方的ViewController一旦丢入框架环境，不需要修改任何代码，框架就能够起到它应该起的作用。</li>
</ol>
<p>其实就是要实现<code>不通过业务代码上对框架的主动迎合，使得业务能够被框架感知</code>这样的功能。细化下来就是两个问题，框架要能够拦截到ViewController的生命周期，另一个问题就是，拦截的定义时机。</p>
<p>对于方法拦截，很容易想到<code>Method Swizzling</code>，那么我们可以写一个实例，在App启动的时候添加针对UIViewController的方法拦截，这是一种做法。还有另一种做法就是，使用NSObject的load函数，在应用启动时自动监听。使用后者的好处在于，这个模块只要被项目包含，就能够发挥作用，不需要在项目里面添加任何代码。</p>
<hr>
<p>然后另外一个要考虑的事情就是，原有的TMViewController（所谓的父类）也是会提供额外方法方便子类使用的，<code>Method Swizzling</code>只支持针对现有方法的操作，拓展方法的话，嗯，当然是用Category啦。</p>
<p>我本人不赞成Category的过度使用，但鉴于Category是最典型的化继承为组合的手段，在这个场景下还是适合使用的。还有的就是，关于Method Swizzling手段实现方法拦截，业界也已经有了现成的开源库：<a href="https://github.com/steipete/Aspects" target="_blank" rel="external">Aspects</a>，我们可以直接拿来使用。</p>
<hr>
<p>我这边有个非常非常小的Demo可以放出来给大家，这个<a href="https://gitcafe.com/casatwy/iOSViewArchDemo1" target="_blank" rel="external">Demo</a>只是一个点睛之笔，有一些话我也写在这个Demo里面了，各位架构师们你们可以基于各自公司App的需求去拓展。</p>
<p>这个Demo不包含Category，毕竟Category还是得你们自己去写啊～然后这套方案能够完成原来通过派生手段所有可以完成的任务，但同时又允许业务方不必添加任何代码，直接使用原生的UIViewController。</p>
<p>然后另外要提醒的是，这方案的目的是消除不必要的继承，虽然不限定于UIViewController，但它也是有适用范围的，在适用继承的地方，还是要老老实实使用继承。比如你有一个数据模型，是由基本模型派生出的一整套模型，那么这个时候还是老老实实使用继承。至于拿捏何时使用继承，相信各位架构师一定能够处理好，或者你也可以参考我前面提到的<a href="http://casatwy.com/tiao-chu-mian-xiang-dui-xiang-si-xiang-yi-ji-cheng.html" target="_blank" rel="external">那篇文章</a>来控制拿捏的尺度。</p>
<h3 id="关于MVC、MVVM等一大堆思想">关于MVC、MVVM等一大堆思想</h3><p>其实这些都是相对通用的思想，万变不离其宗的还是在开篇里面我提到的那三个角色：<code>数据管理者</code>，<code>数据加工者</code>，<code>数据展示者</code>。这些五花八门的思想，不外乎就是制订了一个规范，规定了这三个角色应当如何进行数据交换。但同时这些也是争议最多的话题，所以我在这里来把几个主流思想做一个梳理，当你在做View层架构时，能够有个比较好的参考。</p>
<h3 id="MVC">MVC</h3><p>MVC（Model-View-Controller）是最老牌的的思想，老牌到4人帮的书里把它归成了一种模式，其中<code>Model</code>就是作为<code>数据管理者</code>，View作为<code>数据展示者</code>，Controller作为<code>数据加工者</code>，Model和View又都是由Controller来根据业务需求调配，所以<code>Controller</code>还负担了一个数据流调配的功能。正在我写这篇文章的时候，我看到InfoQ发了<a href="http://www.infoq.com/cn/news/2015/04/symposium-web-mvc" target="_blank" rel="external">这篇文章</a>，里面提到了一个移动开发中的痛点是：对MVC架构划分的理解。我当时没能够去参加这个座谈会，也没办法发表个人意见，所以就只能在这里写写了。</p>
<h4 id="在iOS开发领域，我们应当如何进行MVC的划分？">在iOS开发领域，我们应当如何进行MVC的划分？</h4><p>这里面其实有两个问题： </p>
<ol>
<li>为什么我们会纠结于iOS开发领域中MVC的划分问题？</li>
<li>在iOS开发领域中，怎样才算是划分的正确姿势？</li>
</ol>
<h4 id="为什么我们会纠结于iOS开发领域中MVC的划分问题？">为什么我们会纠结于iOS开发领域中MVC的划分问题？</h4><p>关于这个，每个人纠结的点可能不太一样，我也不知道当时座谈会上大家的观点。但请允许我猜一下：<code>是不是因为UIViewController中自带了一个View，且控制了View的整个生命周期（viewDidLoad,viewWillAppear...），而在常识中我们都知道Controller不应该和View有如此紧密的联系，所以才导致大家对划分产生困惑？</code>，下面我会针对这个猜测来给出我的意见。</p>
<p>在服务端开发领域，Controller和View的交互方式一般都是这样，比如Yii：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">       ...</span><br><span class="line">           数据库取数据</span><br><span class="line">       ...</span><br><span class="line">           处理数据</span><br><span class="line">       ...</span><br><span class="line">   */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 此处$this就是Controller</span></span><br><span class="line">   <span class="variable">$this</span>-&gt;render(<span class="string">"plan"</span>,<span class="keyword">array</span>(</span><br><span class="line">       <span class="string">'planList'</span> =&gt; <span class="variable">$planList</span>,</span><br><span class="line">       <span class="string">'plan_id'</span> =&gt; <span class="variable">$_GET</span>[<span class="string">'id'</span>],</span><br><span class="line">   ));</span><br></pre></td></tr></table></figure></p>
<p>这里Controller和View之间区分得非常明显，Controller做完自己的事情之后，就把所有关于View的工作交给了页面渲染引擎去做，Controller不会去做任何关于View的事情，包括生成View，这些都由渲染引擎代劳了。这是一个区别，但其实服务端View的概念和Native应用View的概念，真正的区别在于：<code>从概念上严格划分的话，服务端其实根本没有View，拜HTTP协议所赐，我们平时所讨论的View只是用于描述View的字符串（更实质的应该称之为数据）</code>，真正的View是浏览器。。</p>
<p>所以服务端只管生成对View的描述，至于对View的长相，UI事件监听和处理，都是浏览器负责生成和维护的。但是在Native这边来看，原本属于浏览器的任务也逃不掉要自己做。那么这件事情由谁来做最合适？苹果给出的答案是：UIViewController。</p>
<p>鉴于苹果在这一层做了很多艰苦卓绝的努力，让iOS工程师们不必亲自去实现这些内容。而且，它把所有的功能都放在了UIView上，并且把UIView做成不光可以展示UI，还可以作为容器的一个对象。</p>
<p>看到这儿你明白了吗？UIView的另一个身份其实是容器！UIViewController中自带的那个view，它的主要任务就是作为一个容器。如果它所有的相关命名都改成ViewContainer，那么代码就会变成这样：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (void)<span class="tag">viewContainerDidLoad</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr_selector">[self.viewContainer addSubview:self.label]</span>;</span><br><span class="line">    <span class="attr_selector">[self.viewContainer addSubview:self.tableView]</span>;</span><br><span class="line">    <span class="attr_selector">[self.viewContainer addSubview:self.button]</span>;</span><br><span class="line">    <span class="attr_selector">[self.viewContainer addSubview:self.textField]</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">... ...</span><br></pre></td></tr></table></figure></p>
<p>仅仅改了个名字，现在是不是感觉清晰了很多？如果再要说详细一点，我们平常所认为的服务端MVC是这样划分的：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">               ---------------------------</span><br><span class="line">               |<span class="string"> C                       </span>|</span><br><span class="line">               |<span class="string">        Controller       </span>|</span><br><span class="line">               |<span class="string">                         </span>|</span><br><span class="line">               ---------------------------</span><br><span class="line">              /                           \</span><br><span class="line">             /                             \</span><br><span class="line">            /                               \</span><br><span class="line">------------                                 ---------------------</span><br><span class="line">|<span class="string"> M        </span>|<span class="string">                                 </span>|<span class="string"> V                 </span>|</span><br><span class="line">|<span class="string">   Model  </span>|<span class="string">                                 </span>|<span class="string">    Render Engine  </span>|</span><br><span class="line">|<span class="string">          </span>|<span class="string">                                 </span>|<span class="string">          +        </span>|</span><br><span class="line">------------                                 |<span class="string">      HTML Files   </span>|</span><br><span class="line">                                             ---------------------</span><br></pre></td></tr></table></figure></p>
<p>但事实上，整套流程的MVC划分是这样：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">               ---------------------------</span><br><span class="line">               |<span class="string"> C                       </span>|</span><br><span class="line">               |<span class="string">   Controller            </span>|</span><br><span class="line">               |<span class="string">           \             </span>|</span><br><span class="line">               |<span class="string">           Render Engine </span>|</span><br><span class="line">               |<span class="string">                 +       </span>|</span><br><span class="line">               |<span class="string">             HTML Files  </span>|</span><br><span class="line">               ---------------------------</span><br><span class="line">              /                           \</span><br><span class="line">             /                             \ HTML String</span><br><span class="line">            /                               \</span><br><span class="line">------------                                 ---------------</span><br><span class="line">|<span class="string"> M        </span>|<span class="string">                                 </span>|<span class="string"> V           </span>|</span><br><span class="line">|<span class="string">   Model  </span>|<span class="string">                                 </span>|<span class="string">    Browser  </span>|</span><br><span class="line">|<span class="string">          </span>|<span class="string">                                 </span>|<span class="string">             </span>|</span><br><span class="line">------------                                 ---------------</span><br></pre></td></tr></table></figure></p>
<p>由图中可以看出，我们服务端开发在这个概念下，其实只涉及M和C的开发工作，浏览器作为View的容器，负责View的展示和事件的监听。那么对应到iOS客户端的MVC划分上面来，就是这样：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">               ----------------------------</span><br><span class="line">               |<span class="string"> C                        </span>|</span><br><span class="line">               |<span class="string">   Controller             </span>|</span><br><span class="line">               |<span class="string">           \              </span>|</span><br><span class="line">               |<span class="string">           View Container </span>|</span><br><span class="line">               ----------------------------</span><br><span class="line">              /                            \</span><br><span class="line">             /                              \</span><br><span class="line">            /                                \</span><br><span class="line">------------                                  ----------------------</span><br><span class="line">|<span class="string"> M        </span>|<span class="string">                                  </span>|<span class="string"> V                  </span>|</span><br><span class="line">|<span class="string">   Model  </span>|<span class="string">                                  </span>|<span class="string">    UITableView     </span>|</span><br><span class="line">|<span class="string">          </span>|<span class="string">                                  </span>|<span class="string">    YourCustomView  </span>|</span><br><span class="line">------------                                  |<span class="string">         ...        </span>|</span><br><span class="line">                                              ----------------------</span><br></pre></td></tr></table></figure></p>
<p>唯一区别在于，View的容器在服务端，是由Browser负责，在整个网站的流程中，这个容器放在Browser是非常合理的。在iOS客户端，View的容器是由UIViewController中的view负责，我也觉得苹果做的这个选择是非常正确明智的。</p>
<p>因为浏览器和服务端之间的关系非常松散，而且他们分属于两个不同阵营，服务端将对View的描述生成之后，交给浏览器去负责展示，然而一旦view上有什么事件产生，基本上是很少传递到服务器（也就是所谓的Controller）的（要传也可以：AJAX），都是在浏览器这边把事情都做掉，所以在这种情况下，View容器就适合放在浏览器（V）这边。</p>
<p>但是在iOS开发领域，虽然也有让View去监听事件的做法，但这种做法非常少，都是把事件回传给Controller，然后Controller再另行调度。所以这时候，View的容器放在Controller就非常合适。Controller可以因为不同事件的产生去很方便地更改容器内容，比如加载失败时，把容器内容换成失败页面的View，无网络时，把容器页面换成无网络的View等等。</p>
<h4 id="在iOS开发领域中，怎样才算是MVC划分的正确姿势？">在iOS开发领域中，怎样才算是MVC划分的正确姿势？</h4><p>这个问题其实在上面已经解答掉一部分了，那么这个问题的答案就当是对上面问题的一个总结吧。</p>
<p>1) M应该做的事：</p>
<ul>
<li>给ViewController提供数据</li>
<li>给ViewController存储数据提供接口</li>
<li>提供经过抽象的业务基本组件，供Controller调度</li>
</ul>
<p>2) C应该做的事：</p>
<ul>
<li>管理View Container的生命周期</li>
<li>负责生成所有的View实例，并放入View Container</li>
<li>监听来自View与业务有关的事件，通过与Model的合作，来完成对应事件的业务。</li>
</ul>
<p>3) V应该做的事：</p>
<ul>
<li>响应与业务无关的事件，并因此引发动画效果，点击反馈（如果合适的话，尽量还是放在View去做）等。</li>
<li>界面元素表达</li>
</ul>
<hr>
<p>我通过与服务端MVC划分的对比来回答了这两个问题，之所以这么做，是因为我知道有很多iOS工程师之前是从服务端转过来的。我也是这样，在进安居客之前，我也是做服务端开发的，在学习iOS的过程中，我也曾经对iOS领域的MVC划分问题产生过疑惑，我疑惑的点就是前面开篇我猜测的点。如果有人问我iOS中应该怎么做MVC的划分，我就会像上面这么回答。</p>
<h3 id="MVCS">MVCS</h3><p>苹果自身就采用的是这种架构思路，从名字也能看出，也是基于MVC衍生出来的一套架构。从概念上来说，它拆分的部分是Model部分，拆出来一个Store。这个Store专门负责数据存取。但从实际操作的角度上讲，它拆开的是Controller。</p>
<hr>
<p>这算是瘦Model的一种方案，瘦Model只是专门用于表达数据，然后存储、数据处理都交给外面的来做。MVCS使用的前提是，它假设了你是瘦Model，同时数据的存储和处理都在Controller去做。所以对应到MVCS，它在一开始就是拆分的Controller。因为Controller做了数据存储的事情，就会变得非常庞大，那么就把Controller专门负责存取数据的那部分抽离出来，交给另一个对象去做，这个对象就是Store。这么调整之后，整个结构也就变成了真正意义上的MVCS。</p>
<h4 id="关于胖Model和瘦Model">关于胖Model和瘦Model</h4><p>我在面试和跟别人聊天时，发现知道胖Model和瘦Model的概念的人不是很多。大约两三年前国外业界曾经对此有过非常激烈的讨论，主题就是<code>Fat model, skinny controller</code>。现在关于这方面的讨论已经不多了，然而直到今天胖Model和瘦Model哪个更好，业界也还没有定论，所以这算是目前业界悬而未解的一个争议。我很少看到国内有讨论这个的资料，所以在这里我打算补充一下什么叫胖Model什么叫瘦Model。以及他们的争论来源于何处。</p>
<p>什么叫胖Model？<br><code>胖Model包含了部分弱业务逻辑</code>。胖Model要达到的目的是，<code>Controller从胖Model这里拿到数据之后，不用额外做操作或者只要做非常少的操作，就能够将数据直接应用在View上</code>。举个例子：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Raw Data:</span><br><span class="line">    timestamp:<span class="number">1234567</span></span><br><span class="line"></span><br><span class="line">FatModel:</span><br><span class="line">    <span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> timestamp;</span><br><span class="line">    - (<span class="built_in">NSString</span> *)ymdDateString; <span class="comment">// 2015-04-20 15:16</span></span><br><span class="line">    - (<span class="built_in">NSString</span> *)gapString; <span class="comment">// 3分钟前、1小时前、一天前、2015-3-13 12:34</span></span><br><span class="line"></span><br><span class="line">Controller:</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.dateLabel</span><span class="variable">.text</span> = [FatModel ymdDateString];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.gapLabel</span><span class="variable">.text</span> = [FatModel gapString];</span><br></pre></td></tr></table></figure>
<p>把timestamp转换成具体业务上所需要的字符串，这属于业务代码，算是弱业务。FatModel做了这些弱业务之后，Controller就能变得非常skinny，Controller只需要关注强业务代码就行了。众所周知，强业务变动的可能性要比弱业务大得多，弱业务相对稳定，所以弱业务塞进Model里面是没问题的。另一方面，弱业务重复出现的频率要大于强业务，对复用性的要求更高，如果这部分业务写在Controller，类似的代码会洒得到处都是，一旦弱业务有修改（弱业务修改频率低不代表就没有修改），这个事情就是一个灾难。如果塞到Model里面去，改一处很多地方就能跟着改，就能避免这场灾难。</p>
<p>然而其缺点就在于，胖Model相对比较难移植，虽然只是包含弱业务，但好歹也是业务，迁移的时候很容易拔出萝卜带出泥。另外一点，MVC的架构思想更加倾向于Model是一个Layer，而不是一个Object，不应该把一个Layer应该做的事情交给一个Object去做。最后一点，软件是会成长的，FatModel很有可能随着软件的成长越来越Fat，最终难以维护。</p>
<p>什么叫瘦Model？</p>
<p>瘦Model只负责业务数据的表达，所有业务无论强弱一律扔到Controller。瘦Model要达到的目的是，尽一切可能去编写细粒度Model，然后配套各种helper类或方法来对弱业务做抽象，强业务依旧交给Controller。举个例子：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">Raw</span> <span class="rule"><span class="attribute">Data</span>:<span class="value"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"name"</span>:<span class="string">"casa"</span>,</span><br><span class="line">    <span class="string">"sex"</span>:<span class="string">"male"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SlimModel:</span><br><span class="line">    @property (nonatomic, strong) NSString *name</span></span>;</span><br><span class="line">    <span class="at_rule">@<span class="keyword">property</span> (nonatomic, strong) NSString *sex</span>;</span><br><span class="line"></span><br><span class="line"><span class="rule"><span class="attribute">Helper</span>:<span class="value"></span><br><span class="line">    <span class="hexcolor">#def</span>ine Male <span class="number">1</span></span></span>;</span><br><span class="line">    <span class="id">#define</span> <span class="tag">Female</span> 0;</span><br><span class="line">    + (<span class="tag">BOOL</span>)<span class="rule"><span class="attribute">sexWithString</span>:<span class="value">(NSString *)sex</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="rule"><span class="attribute">Controller</span>:<span class="value"></span><br><span class="line">    if ([Helper sexWithString:SlimModel.sex] == Male) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span></span></span><br></pre></td></tr></table></figure>
<p>由于SlimModel跟业务完全无关，它的数据可以交给任何一个能处理它数据的Helper或其他的对象，来完成业务。在代码迁移的时候独立性很强，很少会出现拔出萝卜带出泥的情况。另外，由于SlimModel只是数据表达，对它进行维护基本上是0成本，软件膨胀得再厉害，SlimModel也不会大到哪儿去。</p>
<p>缺点就在于，Helper这种做法也不见得很好，这里有一篇文章批判了这个事情。另外，由于Model的操作会出现在各种地方，SlimModel在一定程度上违背了DRY（Don’t Repeat Yourself）的思路，Controller仍然不可避免在一定程度上出现代码膨胀。</p>
<p>我的态度？嗯，我会在本门心法这一节里面说。</p>
<p>说回来，MVCS是基于瘦Model的一种架构思路，把原本Model要做的很多事情中的其中一部分关于数据存储的代码抽象成了Store，在一定程度上降低了Controller的压力。</p>
<h4 id="MVVM">MVVM</h4><p>MVVM去年在业界讨论得非常多，无论国内还是国外都讨论得非常热烈，尤其是在ReactiveCocoa这个库成熟之后，ViewModel和View的信号机制在iOS下终于有了一个相对优雅的实现。MVVM本质上也是从MVC中派生出来的思想，MVVM着重想要解决的问题是尽可能地减少Controller的任务。不管MVVM也好，MVCS也好，他们的共识都是<code>Controller会随着软件的成长，变很大很难维护很难测试</code>。只不过两种架构思路的前提不同，MVCS是认为Controller做了一部分Model的事情，要把它拆出来变成Store，MVVM是认为Controller做了太多数据加工的事情，所以MVVM把<code>数据加工</code>的任务从Controller中解放了出来，使得Controller只需要专注于数据调配的工作，ViewModel则去负责数据加工并通过通知机制让View响应ViewModel的改变。</p>
<p>MVVM是<code>基于胖Model的架构思路建立的，然后在胖Model中拆出两部分：Model和ViewModel</code>。关于这个观点我要做一个额外解释：胖Model做的事情是先为Controller减负，然后由于Model变胖，再在此基础上拆出ViewModel，跟业界普遍认知的<code>MVVM本质上是为Controller减负</code>这个说法并不矛盾，因为胖Model做的事情也是为Controller减负。</p>
<p>另外，我前面说<code>MVVM把数据加工的任务从Controller中解放出来</code>，跟MVVM拆分的是胖Model也不矛盾。要做到解放Controller，首先你得有个胖Model，然后再把这个胖Model拆成Model和ViewModel。</p>
<h4 id="那么MVVM究竟应该如何实现？">那么MVVM究竟应该如何实现？</h4><p>这很有可能是大多数人纠结的问题，我打算凭我的个人经验试图在这里回答这个问题，欢迎大家在评论区交流。</p>
<p>在iOS领域大部分MVVM架构都会使用ReactiveCocoa，但是使用ReactiveCocoa的iOS应用就是基于MVVM架构的吗？那当然不是，我觉得很多人都存在这个误区，我面试过的一些人提到了ReactiveCocoa也提到了MVVM，但他们对此的理解肤浅得让我忍俊不禁。嗯，在网络层架构我会举出不使用ReactiveCocoa的例子，现在举我感觉有点儿早。</p>
<h4 id="MVVM的关键是要有View_Model！而不是ReactiveCocoa(勘误2)">MVVM的关键是要有View Model！而不是ReactiveCocoa(勘误2)</h4><p>ViewModel做什么事情？就是把RawData变成直接能被View使用的对象的一种Model。举个例子：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Raw Data:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="params">(</span><br><span class="line">            <span class="params">(<span class="number">123</span>, <span class="number">456</span>)</span>,</span><br><span class="line">            <span class="params">(<span class="number">234</span>, <span class="number">567</span>)</span>,</span><br><span class="line">            <span class="params">(<span class="number">345</span>, <span class="number">678</span>)</span></span><br><span class="line">        )</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里的RawData我们假设是经纬度，数字我随便写的不要太在意。然后你有一个模块是地图模块，把经纬度数组全部都转变成MKAnnotation或其派生类对于Controller来说是弱业务，（记住，胖Model就是用来做弱业务的），因此我们用ViewModel直接把它转变成MKAnnotation的NSArray，交给Controller之后Controller直接就可以用了。</p>
<p>嗯，这就是ViewModel要做的事情，是不是觉得很简单，看不出优越性？</p>
<p>安居客Pad应用也有一个地图模块，在这里我设计了一个对象叫做reformer（其实就是ViewModel），专门用来干这个事情。那么这么做的优越性体现在哪儿呢？</p>
<p>安居客分三大业务：租房、二手房、新房。这三个业务对应移动开发团队有三个API开发团队，他们各自为政，这就造成了一个结果：三个API团队回馈给移动客户端的数据内容虽然一致，但是数据格式是不一致的，也就是相同value对应的key是不一致的。但展示地图的ViewController不可能写三个，所以肯定少不了要有一个API数据兼容的逻辑，这个逻辑我就放在reformer里面去做了，于是业务流程就变成了这样：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">         用户进入地图页发起地图API请求</span><br><span class="line">                       |<span class="string"></span><br><span class="line">                       </span>|</span><br><span class="line">                       |<span class="string"></span><br><span class="line">   -----------------------------------------</span><br><span class="line">   </span>|<span class="string">                   </span>|<span class="string">                   </span>|</span><br><span class="line">   |<span class="string">                   </span>|<span class="string">                   </span>|</span><br><span class="line">新房API            二手房API            租房API</span><br><span class="line">   |<span class="string">                   </span>|<span class="string">                   </span>|</span><br><span class="line">   |<span class="string">                   </span>|<span class="string">                   </span>|</span><br><span class="line">   -----------------------------------------</span><br><span class="line">                       |<span class="string"></span><br><span class="line">                       </span>|</span><br><span class="line">                       |<span class="string"></span><br><span class="line">                获得原始地图数据</span><br><span class="line">                       </span>|</span><br><span class="line">                       |<span class="string"></span><br><span class="line">                       </span>|</span><br><span class="line">  [APIManager fetchDataWithReformer:reformer]</span><br><span class="line">                       |<span class="string"></span><br><span class="line">                       </span>|</span><br><span class="line">                       |<span class="string"></span><br><span class="line">               MKAnnotationList</span><br><span class="line">                       </span>|</span><br><span class="line">                       |<span class="string"></span><br><span class="line">                       </span>|</span><br><span class="line">                  Controller</span><br></pre></td></tr></table></figure></p>
<p>这么一来，原本复杂的MKAnnotation组装逻辑就从Controller里面拆分了出来，Controller可以直接拿着Reformer返回的数据进行展示。APIManager就属于Model，reformer就属于ViewModel。具体关于reformer的东西我会放在网络层架构来详细解释。Reformer此时扮演的ViewModel角色能够很好地给Controller减负，同时，维护成本也大大降低，经过reformer产出的永远都是MKAnnotation，Controller可以直接拿来使用。</p>
<p>然后另外一点，还有一个业务需求是取附近的房源，地图API请求是能够hold住这个需求的，那么其他地方都不用变，在fetchDataWithReformer的时候换一个reformer就可以了，其他的事情都交给reformer。</p>
<h4 id="那么ReactiveCocoa应该扮演什么角色？">那么ReactiveCocoa应该扮演什么角色？</h4><p>不用ReactiveCocoa也能MVVM，用ReactiveCocoa能更好地体现MVVM的精髓。前面我举到的例子只是数据从API到View的方向，View的操作也会产生”数据”，只不过这里的”数据”更多的是体现在表达用户的操作上，比如输入了什么内容，那么数据就是text、选择了哪个cell，那么数据就是indexPath。那么在数据从view走向API或者Controller的方向上，就是ReactiveCocoa发挥的地方。</p>
<p>我们知道，ViewModel本质上算是Model层（因为是胖Model里面分出来的一部分），所以View并不适合直接持有ViewModel，那么View一旦产生数据了怎么办？扔信号扔给ViewModel，用谁扔？ReactiveCocoa。</p>
<p>在MVVM中使用ReactiveCocoa的第一个目的就是如上所说，View并不适合直接持有ViewModel。第二个目的就在于，ViewModel有可能并不是只服务于特定的一个View，使用更加松散的绑定关系能够降低ViewModel和View之间的耦合度。</p>
<h4 id="那么在MVVM中，Controller扮演什么角色？">那么在MVVM中，Controller扮演什么角色？</h4><p>大部分国内外资料阐述MVVM的时候都是这样排布的：<code>View &lt;-&gt; ViewModel &lt;-&gt; Model</code>，造成了MVVM不需要Controller的错觉，现在似乎发展成业界开始出现MVVM是不需要Controller的。的声音了。其实<code>MVVM是一定需要Controller</code>的参与的，虽然MVVM在一定程度上弱化了Controller的存在感，并且给Controller做了减负瘦身（这也是MVVM的主要目的）。但是，这并不代表MVVM中不需要Controller，MMVC和MVVM他们之间的关系应该是这样：</p>
<p><img src="http://casatwy.com/pics/iOSView/MCVMVMV.gif" alt="来源：http://www.sprynthesis.com/2014/12/06/reactivecocoa-mvvm-introduction/"></p>
<p><code>View &lt;-&gt; C &lt;-&gt; ViewModel &lt;-&gt; Model</code>，所以<code>使用MVVM之后，就不需要Controller</code>的说法是不正确的。严格来说MVVM其实是MVCVM。从图中可以得知，Controller夹在View和ViewModel之间做的其中一个主要事情就是将View和ViewModel进行绑定。在逻辑上，Controller知道应当展示哪个View，Controller也知道应当使用哪个ViewModel，然而View和ViewModel它们之间是互相不知道的，所以Controller就负责控制他们的绑定关系，所以叫Controller/控制器就是这个原因。</p>
<hr>
<p>前面扯了那么多，其实归根结底就是一句话：在<code>MVC的基础上，把C拆出一个ViewModel专门负责数据处理的事情</code>，就是MVVM。然后，为了让View和ViewModel之间能够有比较松散的绑定关系，于是我们使用ReactiveCocoa，因为苹果本身并没有提供一个比较适合这种情况的绑定方法。iOS领域里KVO，Notification，block，delegate和target-action都可以用来做数据通信，从而来实现绑定，但都不如ReactiveCocoa提供的RACSignal来的优雅，如果不用ReactiveCocoa，绑定关系可能就做不到那么松散那么好，但并不影响它还是MVVM。</p>
<p>在实际iOS应用架构中，MVVM应该出现在了大部分创业公司或者老牌公司新App的iOS应用架构图中，据我所知易宝支付旗下的某个iOS应用就整体采用了MVVM架构，他们抽出了一个Action层来装各种ViewModel，也是属于相对合理的结构。</p>
<p>所以Controller在MVVM中，一方面负责View和ViewModel之间的绑定，另一方面也负责常规的UI逻辑处理。</p>
<h3 id="VIPER">VIPER</h3><p><a href="http://mutualmobile.github.io/blog/2013/12/04/viper-introduction/" target="_blank" rel="external">VIPER</a>（View，Interactor，Presenter，Entity，Routing）。VIPER我并没有实际使用过，我是在objc.io上第13期看到的。</p>
<p>但凡出现一个新架构或者我之前并不熟悉的新架构，有一点我能够非常肯定，这货一定又是把MVC的哪个部分给拆开了（坏笑，做这种判断的理论依据在第一篇文章里面我已经讲过了）。事实情况是VIPER确实拆了很多很多，除了View没拆，其它的都拆了。</p>
<p>我提到的这两篇文章关于VIPER都讲得很详细，一看就懂。但具体在使用VIPER的时候会有什么坑或者会有哪些争议我不是很清楚，硬要写这一节的话我只能靠YY，所以我想想还是算了。如果各位读者有谁在实际App中采用VIPER架构的或者对VIPER很有兴趣的，可以评论区里面提出来，我们交流一下。</p>
<h3 id="本门心法">本门心法</h3><blockquote>
<p>重剑无锋，大巧不工。 —— 《神雕侠侣》</p>
</blockquote>
<p>这是杨过在挑剑时，玄铁重剑旁边写的一段话。对此我深表认同。提到这段话的目的是想告诉大家，在具体做View层架构的设计时，不需要拘泥于MVC、MVVM、VIPER等规矩。这些都是招式，告诉你你就知道了，然后怎么玩都可以。但是心法不是这样的，心法是大巧，说出来很简单，但是能不能在实际架构设计时牢记心法，并且按照规矩办事，就都看个人了。</p>
<h4 id="拆分的心法">拆分的心法</h4><blockquote>
<p>天下功夫出少林，天下架构出MVC。 —— Casa Taloyum</p>
</blockquote>
<p>MVC其实是非常高Level的抽象，意思也就是，在MVC体系下还可以再衍生无数的架构方式，但万变不离其宗的是，它一定符合MVC的规范。这句话不是我说的，是我在某个英文资料上看到的，但时过境迁，我已经找不到出处了，我很赞同这句话。我采用的架构严格来说也是MVC，但也做了很多的拆分。根据前面几节的洗礼，相信各位也明白了这样的道理：<code>拆分方式的不同诞生了各种不同的衍生架构方案（MVCS拆胖Controller，MVVM拆胖Model，VIPER什么都拆）</code>，但即便拆分方式再怎么多样，那都只是招式。而拆分的规范，就是心法。这一节我就讲讲我在做View架构时，做拆分的心法。</p>
<p>1) 第一心法：保留最重要的任务，拆分其它不重要的任务<br>在iOS开发领域内，UIViewController承载了非常多的事情，比如View的初始化，业务逻辑，事件响应，数据加工等等，当然还有更多我现在也列举不出来，但是我们知道有一件事情Controller肯定逃不掉要做：协调V和M。也就是说，不管怎么拆，协调工作是拆不掉的。</p>
<p>那么剩下的事情我们就可以拆了，比如UITableView的DataSource。唐巧的博客有一篇文章提到他和另一个工程师关于是否要拆分DataSource争论了好久。拆分DataSource这个做法应该也算是通用做法，在不复杂的应用里面，它可能确实看上去只是一个数组而已，但在复杂的情况下，它背后可能涉及了文件内容读取，数据同步等等复杂逻辑，这篇文章的第一节就提倡了这个做法，我其实也蛮提倡的。</p>
<p>前面的文章里面也提了很多能拆的东西，我就不搬运了，大家可以进去看看。除了这篇文章提到的内容以外，任何比较大的，放在ViewController里面比较脏的，只要不是Controller的核心逻辑，都可以考虑拆出去，然后在架构的时候作为一个独立模块去定义，以及设计实现。</p>
<p>2) 第二心法：拆分后的模块要尽可能提高可复用性，尽量做到DRY</p>
<p>根据第一心法拆开来的东西，很有可能还是强业务相关的，这种情况有的时候无法避免。但我们拆也要拆得好看，拆出来的部分最好能够归成某一类对象，然后最好能够抽象出一个通用逻辑出来，使他能够复用。即使不能抽出通用逻辑，那也尽量抽象出一个protocol，来实现IOP。这里有篇关于<a href="http://casatwy.com/tiao-chu-mian-xiang-dui-xiang-si-xiang-er-duo-tai.html" target="_blank" rel="external">IOP</a>的文章，大家看了就明白优越性了。</p>
<p>3) 第三心法：要尽可能提高拆分模块后的抽象度</p>
<p>也就是说，拆分的粒度要尽可能大一点，封装得要透明一些。唐巧说<code>一切隐藏都是对代码复杂性的增加，除非它带来了好处</code>，这在一定程度上有点道理，没有好处的隐藏确实都不好（笑）。提高抽象度事实上就是增加封装的力度，将一个负责的业务抽象成只需要很少的输入就能完成，就是高度抽象。嗯，继承很多层，这种做法虽然也提高了抽象程度，但我不建议这么玩。我不确定唐巧在这里说的隐藏跟我说的封装是不是同一个概念，但我在这里想提倡的是尽可能提高抽象程度。</p>
<p>提高抽象程度的好处在于，对于业务方来说，他只需要收集很少的信息（最小充要条件），做很少的调度（Controller负责大模块调度，大模块里面再去做小模块的调度），就能够完成任务，这才是给Controller减负的正确姿势。</p>
<p>如果拆分出来的模块抽象程度不够，模块对外界要求的参数比较多，那么在Controller里面，关于收集参数的代码就会多了很多。如果一部分参数的收集逻辑能够由模块来完成，那也可以做到帮Controller减轻负担。否则就感觉拆得不太干净，因为Controller里面还是多了一些不必要的参数收集逻辑。</p>
<p>如果拆分出来的粒度太小，Controller在完成任务的时候调度代码要写很多，那也不太好。导致拆分粒度小的首要因素就是业务可能本身就比较复杂，<code>拆分粒度小并不是不好，能大就大一点，如果小了，那也没问题</code>。针对这种情况的处理，就需要采用strategy模式。</p>
<hr>
<p>针对拆分粒度小的情况，我来举个实际例子，这个例子来源于我的一个朋友他在做聊天应用的消息发送模块。当消息是文字时，直接发送。当消息是图片时，需要先向服务器申请上传资源，获得资源ID之后再上传图片，上传图片完成之后拿到图片URL，后面带着URL再把信息发送出去。</p>
<p>这时候我们拆模块，可以拆成：数据发送（叫A模块），上传资源申请（叫B模块），内容上传（叫C模块）。那么要发送文字消息，Controller调度A就可以了。如果要发送图片消息，Controller调度<code>B-&gt;C-&gt;A</code>，假设将来还有上传别的类型消息的任务，他们又要依赖D/E/F模块，那这个事情就很蛋疼，因为逻辑复杂了，Controller要调度的东西要区分的情况就多了，Controller就膨胀了。</p>
<p>那么怎么处理呢？可以采用Strategy模式。我们再来分析一下，Controller要完成任务，它初始情况下所具有的条件是什么？它有这条消息的所有数据，也知道这个消息的类型。那么它最终需要的是什么呢？消息发送的结果：发送成功或失败。</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                send msg</span><br><span class="line">Controller ------------------&gt; MessageSender</span><br><span class="line">    ^                                |<span class="string"></span><br><span class="line">    </span>|<span class="string">                                </span>|</span><br><span class="line">    |<span class="string">                                </span>|</span><br><span class="line">    ----------------------------------</span><br><span class="line">             success / fail</span><br></pre></td></tr></table></figure>
<p>上面就是我们要实现的最终结果，Controller只要把消息丢给MessageSender，然后让MessageSender去做事情，做完了告诉Controller就好了。那么MessageSender里面怎么去调度逻辑？MessageSender里面可以有一个StrategyList，里面存放了表达各种逻辑的Block或者Invocation（Target－Action）。那么我们先定义一个Enum，里面规定了每种任务所需要的调度逻辑。</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM (NSUInteger, MessageSendStrategy)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">MessageSendStrategyText =</span> <span class="number">0</span>,</span><br><span class="line">    <span class="variable">MessageSendStrategyImage =</span> <span class="number">1</span>,</span><br><span class="line">    <span class="variable">MessageSendStrategyVoice =</span> <span class="number">2</span>,</span><br><span class="line">    <span class="variable">MessageSendStrategyVideo =</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在MessageSender里面的StrategyList是这样：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> *strategyList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span><span class="variable">.strategyList</span> = @[TextSenderInvocation, ImageSenderInvocation, VoiceSenderInvocation, VideoSenderInvocation];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后对外提供一个这样的接口，同时有一个delegate用来回调</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sendMessage:(BaseMessage *)message withStrategy:(MessageSendStrategy)strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span>&lt;MessageSenderDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">MessageSenderDelegate</span>&lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">@required</span></span><br><span class="line">      - (<span class="keyword">void</span>)messageSender:(MessageSender *)messageSender</span><br><span class="line">      didSuccessSendMessage:(BaseMessage *)message</span><br><span class="line">                   strategy:(MessageSendStrategy)strategy;</span><br><span class="line"></span><br><span class="line">      - (<span class="keyword">void</span>)messageSender:(MessageSender *)messageSender</span><br><span class="line">         didFailSendMessage:(BaseMessage *)message</span><br><span class="line">                   strategy:(MessageSendStrategy)strategy</span><br><span class="line">                      error:(<span class="built_in">NSError</span> *)error;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>Controller里面是这样使用的：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.messageSender <span class="string">sendMessage:</span>message <span class="string">withStrategy:</span>MessageSendStrategyText];</span><br></pre></td></tr></table></figure></p>
<p>MessageSender里面是这样的：<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[self.strategyList<span class="collection">[strategy]</span> invoke]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>然后在某个Invocation里面，就是这样的：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">[A invoke]</span><span class="comment">;</span></span><br><span class="line"><span class="title">[B invoke]</span><span class="comment">;</span></span><br><span class="line"><span class="title">[C invoke]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>这样就好啦，即便拆分粒度因为客观原因无法细化，那也能把复杂的判断逻辑和调度逻辑从Controller中抽出来，真正为Controller做到了减负。总之能够做到大粒度就尽量大粒度，实在做不到那也行，用Strategy把它hold住。这个例子是小粒度的情况，大粒度的情况太简单，我就不举了。</p>
<h3 id="设计心法">设计心法</h3><p>针对View层的架构不光是看重如何合理地拆分MVC来给UIViewController减负，另外一点也要照顾到业务方的使用成本。最好的情况是业务方什么都不知道，然后他把代码放进去就能跑，同时还能获得框架提供的种种功能。</p>
<blockquote>
<p>比如天安门广场上的观众看台，就是我觉得最好的设计，因为没人会注意到它。</p>
</blockquote>
<p>1) 第一心法：尽可能减少继承层级，涉及苹果原生对象的尽量不要继承</p>
<p>继承是罪恶，尽量不要继承。就我目前了解到的情况看，除了安居客的Pad App没有在框架级针对UIViewController有继承的设计以外，其它公司或多或少都针对UIViewController有继承，包括安居客iPhone app（那时候我已经对此无能为力，可见View的架构在一开始就设计好有多么重要）。甚至有的还对UITableView有继承，这是一件多么令人发指，多么惨绝人寰，多么丧心病狂的事情啊。虽然不可避免的是有些情况我们不得不从苹果原生对象中继承，比如UITableViewCell。但我还是建议尽量不要通过继承的方案来给原生对象添加功能，前面提到的Aspect方案和Category方案都可以使用。用Aspect＋load来实现重载函数，用Category来实现添加函数，当然，耍点手段用Category来添加property也是没问题的。这些方案已经覆盖了继承的全部功能，而且非常好维护，对于业务方也更加透明，何乐而不为呢。</p>
<p>不用继承可能在思路上不会那么直观，但是对于不使用继承带来的好处是足够顶得上使用继承的坏处的。顺便在此我要给Category正一下名：业界对于Category的态度比较暧昧，在多种场合（讲座、资料文档）都宣扬过尽可能不要使用Category。它们说的都有一定道理，但我认为Category是苹果提供的最好的使用集合代替继承的方案，但针对Category的设计对架构师的要求也很高，请合理使用。而且苹果也在很多场合使用Category，来把一个原本可能很大的对象，根据不同场景拆分成不同的Category，从而提高可维护性。</p>
<p>不使用继承的好处我在<a href="http://casatwy.com/tiao-chu-mian-xiang-dui-xiang-si-xiang-yi-ji-cheng.html" target="_blank" rel="external">这里</a>已经说了，放到iOS应用架构来看，还能再多额外两个好处：1. 在业务方做业务开发或者做Demo时，可以脱离App环境，或花更少的时间搭建环境。2. 对业务方来说功能更加透明，也符合业务方在开发时的第一直觉。</p>
<p>2) 第二心法：做好代码规范，规定好代码在文件中的布局，尤其是ViewController</p>
<p>这主要是为了提高可维护性。在一个文件非常大的对象中，尤其要限制好不同类型的代码在文件中的布局。比如在写ViewController时，我之前给团队制定的规范就是前面一段全部是getter setter，然后接下来一段是life cycle，viewDidLoad之类的方法都在这里。然后下面一段是各种要实现的Delegate，再下面一段就是event response，Button的或者GestureRecognizer的都在这里。然后后面是private method。一般情况下，如果做好拆分，ViewController的private method那一段是没有方法的。后来随着时间的推移，我发现开头放getter和setter太影响阅读了，所以后面改成全放在ViewController的最后。</p>
<p>3) 第三心法：能不放在Controller做的事情就尽量不要放在Controller里面去做</p>
<p>Controller会变得庞大的原因，一方面是因为Controller承载了业务逻辑，MVC的总结者（在正式提出MVC之前，或多或少都有人这么设计，所以说MVC的设计者不太准确）对Controller下的定义也是承载业务逻辑，所以Controller就是用来干这事儿的，天经地义。另一方面是因为在MVC中，关于Model和View的定义都非常明确，很少有人会把一个属于M或V的东西放到其他地方。然后除了Model和View以外，还会剩下很多模棱两可的东西，这些东西从概念上讲都算Controller，而且由于M和V定义得那么明确，所以直觉上看，这些东西放在M或V是不合适的，于是就往Controller里面塞咯。</p>
<p>正是由于上述两方面原因导致了Controller的膨胀。我们再细细思考一下，Model膨胀和View膨胀，要针对它们来做拆分其实都是相对容易的，Controller膨胀之后，拆分就显得艰难无比。所以如果能够在一开始就尽量把能不放在Controller做的事情放到别的地方去做，这样在第一时间就可以让你的那部分将来可能会被拆分的代码远离业务逻辑。所以我们要稍微转变一下思路：<code>模棱两可的模块，就不要塞到Controller去了，塞到V或者塞到M或者其他什么地方都比塞进Controller好，便于将来拆分</code>。</p>
<p>所以关于前面我按下不表的关于胖Model和瘦Model的选择，我的态度是更倾向于胖Model。客观地说，业务膨胀之后，代码规模肯定少不了的，不管你技术再好，经验再丰富，代码量最多只能优化，该膨胀还是要膨胀的，而且优化之后代码往往也比较难看，使用各种奇技淫巧也是有代价的。所以，针对代码量优化的结果，往往要么就是牺牲可读性，要么就是牺牲可移植性（通用性），<code>Every magic always needs a pay, you have to make a trade-off.。</code></p>
<p>那么既然膨胀出来的代码，或者将来有可能膨胀的代码，不管放在MVC中的哪一个部分，最后都是要拆分的，既然迟早要拆分，那不如放Model里面，这样将来拆分胖Model也能比拆分胖Cotroller更加容易。在我还在安居客的时候，安居客Pad app承载最复杂业务的ViewController才不到600行，其他多数Controller都是在300-400行之间，这就为后面接手的人降低了非常多的上手难度和维护复杂度。拆分出来的东西都是可以直接迁移给iPhone app使用的。现在看天猫的ViewControler，动不动就几千行，看不了多久头就晕了，问了一下，大家都表示很习惯这样的代码长度，摊手。</p>
<p>4) 第四心法：架构师是为业务工程师服务的，而不是去使唤业务工程师的</p>
<p>架构师在公司里的职级和地位往往都是要高于业务工程师的，架构师的技术实力和经验往往也都是高于业务工程师的。所以你值得在公司里获得较高的地位，但是<code>在公司里的地位高不代表在软件工程里面的角色地位也高</code>。架构师是要为业务工程师服务的，是<code>他们使唤你而不是你使唤他们</code>。另外，制定规范一方面是起到约束业务工程师的代码，但更重要的一点是，这其实是利用你的能力帮助业务工程师避免他无法预见的危机，所以地位高有一定的好处，毕竟夏虫不可语冰，有的时候不见得能够解释得通，因此高地位随之而来的就是说服力会比较强。但在软件工程里，一定要保持谦卑，一定要多为业务工程师考虑。</p>
<p>一个不懂这个道理的架构师，设计出来的东西往往复杂难用，因为他只愿意做核心的东西，周边不愿意做的都期望交给业务工程师去做，甚至有的时候就只做了个Demo，然后就交给业务工程师了，业务工程师变成给他打工的了。但是一个懂得这个道理的架构师，设计出来的东西会非常好用，业务方只需要扔很少的参数然后拿结果就好了，这样的架构才叫好的架构。</p>
<p>举一个保存图片到本地的例子，一种做法是提供这样的接口：<code>- (NSString *)saveImageWithData:(NSData *)imageData，另一种是- (NSString *)saveImage:(UIImage *)image</code>。后者更好，原因自己想。</p>
<p>你的态度越谦卑，就越能设计出好的架构，这是我设计心法里的最后一条，也是最重要的一条。即使你现在技术实力不是业界大牛级别的，但只要保持这个心态去做架构，去做设计，就已经是合格的架构师了，要成为业界大牛也会非常快。</p>
<h4 id="小总结">小总结</h4><p>其实针对View层的架构设计，还是要做好三点：<code>代码规范</code>，<code>架构模式</code>，<code>工具集</code>。</p>
<p>代码规范对于View层来说意义重大，毕竟View层非常重业务，如果代码布局混乱，后来者很难接手，也很难维护。</p>
<p>架构模式具体如何选择，完全取决于业务复杂度。如果业务相当相当复杂，那就可以使用VIPER，如果相对简单，那就直接MVC稍微改改就好了。每一种已经成为定式的架构模式不见得都适合各自公司对应的业务，所以需要各位架构师根据情况去做一些拆分或者改变。拆分一般都不会出现问题，改变的时候，只要别把MVC三个角色搞混就好了，M该做啥做啥，C该做啥做啥，V该做啥做啥，不要乱来。关于大部分的架构模式应该是什么样子，这篇文章里都已经说过了，不过我认为最重要的还是后面的心法，模式只是招术，熟悉了心法才能大巧不工。</p>
<p>View层的工具集主要还是集中在如何对View进行布局，以及一些特定的View，比如带搜索提示的搜索框这种。这篇文章只提到了View布局的工具集，其它的工具集相对而言是更加取决于各自公司的业务的，各自实现或者使用CocoaPods里现成的都不是很难。</p>
<p>对于小规模或者中等规模iOS开发团队来说，做好以上三点就足够了。在大规模团队中，有一个额外问题要考虑，就是跨业务页面调用方案的设计。</p>
<h3 id="跨业务页面调用方案的设计">跨业务页面调用方案的设计</h3><p>跨业务页面调用是指，当一个App中存在A业务，B业务等多个业务时，B业务有可能会需要展示A业务的某个页面，A业务也有可能会调用其他业务的某个页面。在小规模的App中，我们直接import其他业务的某个ViewController然后或者push或者present，是不会产生特别大的问题的。但是如果App的规模非常大，涉及业务数量非常多，再这么直接import就会出现问题。<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--------------             --------------             --------------</span><br><span class="line">|<span class="string">            </span>|<span class="string">  page call  </span>|<span class="string">            </span>|<span class="string">  page call  </span>|<span class="string">            </span>|</span><br><span class="line">|<span class="string"> Buisness A </span>|<span class="string"> &lt;---------&gt; </span>|<span class="string"> Buisness B </span>|<span class="string"> &lt;---------&gt; </span>|<span class="string"> Buisness C </span>|</span><br><span class="line">|<span class="string">            </span>|<span class="string">             </span>|<span class="string">            </span>|<span class="string">             </span>|<span class="string">            </span>|</span><br><span class="line">--------------             --------------             --------------</span><br><span class="line">              \                   |<span class="string">                  /</span><br><span class="line">               \                  </span>|<span class="string">                 /</span><br><span class="line">                \                 </span>|<span class="string">                /</span><br><span class="line">                 \                </span>|<span class="string">               /</span><br><span class="line">                  \               </span>|<span class="string">              /</span><br><span class="line">                  --------------------------------</span><br><span class="line">                  </span>|<span class="string">                              </span>|</span><br><span class="line">                  |<span class="string">              App             </span>|</span><br><span class="line">                  |<span class="string">                              </span>|</span><br><span class="line">                  --------------------------------</span><br></pre></td></tr></table></figure></p>
<p>可以看出，跨业务的页面调用在多业务组成的App中会导致横向依赖。那么像这样的横向依赖，如果不去设法解决，会导致什么样的结果？</p>
<p>1) 当一个需求需要多业务合作开发时，如果直接依赖，会导致某些依赖层上端的业务工程师在前期空转，依赖层下端的工程师任务繁重，而整个需求完成的速度会变慢，影响的是团队开发迭代速度。</p>
<p>2) 当要开辟一个新业务时，如果已有各业务间直接依赖，新业务又依赖某个旧业务，就导致新业务的开发环境搭建困难，因为必须要把所有相关业务都塞入开发环境，新业务才能进行开发。影响的是新业务的响应速度。</p>
<p>3) 当某一个被其他业务依赖的页面有所修改时，比如改名，涉及到的修改面就会特别大。影响的是造成任务量和维护成本都上升的结果。</p>
<p>当然，如果App规模特别小，这三点带来的影响也会特别小，但是在阿里这样大规模的团队中，像天猫／淘宝这样大规模的App，一旦遇上这里面哪怕其中一件事情，就特么很坑爹。</p>
<h3 id="那么应该怎样处理这个问题？">那么应该怎样处理这个问题？</h3><p>让依赖关系下沉。</p>
<p>怎么让依赖关系下沉？引入Mediator模式。</p>
<p>所谓引入Mediator模式来让依赖关系下沉，实质上就是每次呼唤页面的时候，通过一个中间人来召唤另外一个页面，这样只要每个业务依赖这个中间人就可以了，中间人的角色就可以放在业务层的下面一层，这就是依赖关系下沉。</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">--------------             --------------             --------------</span><br><span class="line">|<span class="string">            </span>|<span class="string">             </span>|<span class="string">            </span>|<span class="string">             </span>|<span class="string">            </span>|</span><br><span class="line">|<span class="string"> Buisness A </span>|<span class="string">             </span>|<span class="string"> Buisness B </span>|<span class="string">             </span>|<span class="string"> Buisness C </span>|</span><br><span class="line">|<span class="string">            </span>|<span class="string">             </span>|<span class="string">            </span>|<span class="string">             </span>|<span class="string">            </span>|</span><br><span class="line">--------------             --------------             --------------</span><br><span class="line">              \                   |<span class="string">                  /</span><br><span class="line">               \                  </span>|<span class="string">                 /</span><br><span class="line">                \                 </span>|<span class="string">                /  通过Mediater来召唤页面</span><br><span class="line">                 \                </span>|<span class="string">               /</span><br><span class="line">                  \               </span>|<span class="string">              /</span><br><span class="line">                  --------------------------------</span><br><span class="line">                  </span>|<span class="string">                              </span>|</span><br><span class="line">                  |<span class="string">            Mediater          </span>|</span><br><span class="line">                  |<span class="string">                              </span>|</span><br><span class="line">                  --------------------------------</span><br><span class="line">                                  |<span class="string"></span><br><span class="line">                                  </span>|</span><br><span class="line">                                  |<span class="string"></span><br><span class="line">                                  </span>|</span><br><span class="line">                                  |<span class="string"></span><br><span class="line">                  --------------------------------</span><br><span class="line">                  </span>|<span class="string">                              </span>|</span><br><span class="line">                  |<span class="string">              App             </span>|</span><br><span class="line">                  |<span class="string">                              </span>|</span><br><span class="line">                  --------------------------------</span><br></pre></td></tr></table></figure>
<p>当A业务需要调用B业务的某个页面的时候，将请求交给Mediater，然后由Mediater通过某种手段获取到B业务页面的实例，交还给A就行了。在具体实现这个机制的过程中，有以下几个问题需要解决：</p>
<ol>
<li>设计一套通用的请求机制，请求机制需要跟业务剥离，使得不同业务的页面请求都能够被Mediater处理</li>
<li>设计Mediater根据请求如何获取其他业务的机制，Mediater需要知道如何处理请求，上哪儿去找到需要的页面</li>
</ol>
<p>这个看起来就非常像我们web开发时候的URL机制，发送一个Get或Post请求，CGI调用脚本把请求分发给某个Controller下的某个Action，然后返回HTML字符串到浏览器去解析。苹果本身也实现了一套跨App调用机制，它也是基于URL机制来运转的，只不过它想要解决的问题是跨App的数据交流和页面调用，我们想要解决的问题是降低各业务的耦合度。</p>
<p>不过我们还不能直接使用苹果原生的这套机制，因为这套机制不能够返回对象实例。而我们希望能够拿到对象实例，这样不光可以做跨业务页面调用，也可以做跨业务的功能调用。另外，我们又希望我们的Mediater也能够跟苹果原生的跨App调用兼容，这样就又能帮业务方省掉一部分开发量。</p>
<p>就我目前所知道的情况，AutoCad旗下某款iOS应用（时间有点久我不记得是哪款应用了，如果你是AutoCad的iOS开发，可以在评论区补充一下。）就采用了这种页面调用方式。天猫里面目前也在使用这套机制，只是这一块由于历史原因存在新老版本混用的情况，因此暂时还没能够很好地发挥应有的作用。</p>
<p>嗯，想问我要Demo的同学，我可以很大方地告诉你，没有。不过我打算抽时间写一个出来，现在除了已经想好名字叫Summon以外，其它什么都没做，哈哈。</p>
<h3 id="关于Getter和Setter？">关于Getter和Setter？</h3><p>我比较习惯一个对象的”私有”属性写在extension里面，然后这些属性的初始化全部放在getter里面做，在init和dealloc之外，是不会出现任何类似<code>_property</code>这样的写法的。<br>就是这样：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CustomObject</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UILabel</span> *label;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">@implement</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - life cycle</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addSubview:<span class="keyword">self</span><span class="variable">.label</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillAppear:animated];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.label</span><span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - getters and setters</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UILabel</span> *)label</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_label == <span class="literal">nil</span>) &#123;</span><br><span class="line">        _label = [[<span class="built_in">UILabel</span> alloc] init];</span><br><span class="line">        _label<span class="variable">.text</span> = <span class="string">@"1234"</span>;</span><br><span class="line">        _label<span class="variable">.font</span> = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">12</span>];</span><br><span class="line">        ... ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _label;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>唐巧说他喜欢的做法是用_property这种，然后关于_property的初始化通过[self setupProperty]这种做法去做。从刚才上面的代码来看，就是要在viewDidLoad里面多调用一个setup方法而已，然后我推荐的方法就是不用多调一个setup方法，直接走getter。</p>
<p>嗯，怎么说呢，其实两种做法都能完成需求。但是从另一个角度看，苹果之所以选择让[self getProperty]和self.property可以互相通用，这种做法已经很明显地表达了苹果的倾向：<code>希望每个property都是通过getter方法来获得</code>。</p>
<p>早在2003年，Allen Holub就发了篇文章《<a href="http://www.javaworld.com/article/2073723/core-java/why-getter-and-setter-methods-are-evil.html" target="_blank" rel="external">Why getter and setter methods are evil</a>》，自此之后，业界就对此产生了各种争议，虽然是从Java开始说的，但是发展到后面各种语言也参与了进来。然后虽然现在关于这个问题讨论得少了，但是依旧属于没有定论的状态。setter的情况比较复杂，也不是我这一节的重点，我这边还是主要说getter。我们从objc的设计来看，苹果的设计者更加倾向于<code>getter is not evil</code>。</p>
<p>认为<code>getter is evil</code>的原因有非常之多，或大或小，随着争论的进行，大家慢慢就聚焦到这样的一个原因：<code>Getter和Setter提供了一个能让外部修改对象内部数据的方式，这是evil的，正常情况下，一个对象自己私有的变量应该是只有自己关心</code>。</p>
<p>然后我们回到iOS领域来，objc也同样面临了这样的问题，甚至更加严重：<code>objc并没有像Java那么严格的私有概念</code>。但在实际工作中，我们不太会去操作头文件里面没有的变量，这是从规范上就被禁止的。</p>
<p>认为getter is not evil的原因也可以聚焦到一个：<code>高度的封装性</code>。getter事实上是工厂方法，有了getter之后，业务逻辑可以更加专注于调用，而不必担心当前变量是否可用。我们可以想一下，假设一个ViewController有20个subview要加入view中，这20个subview的初始化代码是肯定逃不掉的，放在哪里比较好？放在哪里都比放在addsubview的地方好，我个人认为最好的地方还是放在getter里面，结合单例模式之后，代码会非常整齐，生产的地方和使用的地方得到了很好的区分。</p>
<p>所以放到iOS来说，我还是觉得使用getter会比较好，因为evil的地方在iOS这边基本都避免了，not evil的地方都能享受到，还是不错的。</p>
<h3 id="总结">总结</h3><p>要做一个View层架构，主要就是从以下三方面入手：</p>
<ul>
<li>制定良好的规范</li>
<li>选择好合适的模式（MVC、MVCS、MVVM、VIPER）</li>
<li>根据业务情况针对ViewController做好拆分，提供一些小工具方便开发</li>
</ul>
<p>当然，你还会遇到其他的很多问题，这时候你可以参考这篇文章里提出的心法，在后面提到的跨业务页面调用方案的设计中，你也能够看到我的一些心法的影子。</p>
<p>对于iOS客户端来说，它并不像其他语言诸如Python、PHP他们有那么多的非官方通用框架。客观原因在于，苹果已经为我们做了非常多的事情，做了很多的努力。在苹果已经做了这么多事情的基础上，架构师要做针对View层的方案时，最好还是尽量遵守苹果已有的规范和设计思想，然后根据自己过去开发iOS时的经验，尽可能给业务方在开发业务时减负，提高业务代码的可维护性，就是View层架构方案的最大目标。</p>
<h3 id="2015-04-28_09:28补：关于AOP">2015-04-28 09:28补：关于AOP</h3><p>AOP（Aspect Oriented Programming），面向切片编程，这也是面<code>向XX编程</code>系列术语之一哈，但它跟我们熟知的面向对象编程没什么关系。</p>
<h4 id="什么是切片？">什么是切片？</h4><p>程序要完成一件事情，一定会有一些步骤，1，2，3，4这样。这里分解出来的每一个步骤我们可以认为是一个切片。</p>
<h4 id="什么是面向切片编程？">什么是面向切片编程？</h4><p>你针对每一个切片的间隙，塞一些代码进去，在程序正常进行1，2，3，4步的间隙可以跑到你塞进去的代码，那么你写这些代码就是面向切片编程。</p>
<h4 id="为什么会出现面向切片编程？">为什么会出现面向切片编程？</h4><p>你要想做到在每一个步骤中间做你自己的事情，不用AOP也一样可以达到目的，直接往步骤之间塞代码就好了。但是事实情况往往很复杂，直接把代码塞进去，主要问题就在于：<code>塞进去的代码很有可能是跟原业务无关的代码，在同一份代码文件里面掺杂多种业务，这会带来业务间耦合</code>。为了降低这种耦合度，我们引入了AOP。</p>
<h4 id="如何实现AOP？">如何实现AOP？</h4><p>AOP一般都是需要有一个拦截器，然后在每一个切片运行之前和运行之后（或者任何你希望的地方），通过调用拦截器的方法来把这个jointpoint扔到外面，在外面获得这个jointpoint的时候，执行相应的代码。</p>
<p>在iOS开发领域，<code>objective-C</code>的runtime有提供了一系列的方法，能够让我们拦截到某个方法的调用，来实现拦截器的功能，这种手段我们称为<code>Method Swizzling</code>。<code>Aspects</code>通过这个手段实现了针对某个类和某个实例中方法的拦截。</p>
<p>另外，也可以使用protocol的方式来实现拦截器的功能，具体实现方案就是这样：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@protocol RTAPIManagerInterceptor &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">@optional</span><br><span class="line">- <span class="params">(void)</span>manager:<span class="params">(RTA<span class="literal">PI</span>BaseManager *)</span>manager beforePerformSuccessWithResponse:<span class="params">(AIFURLResponse *)</span>response;</span><br><span class="line">- <span class="params">(void)</span>manager:<span class="params">(RTA<span class="literal">PI</span>BaseManager *)</span>manager afterPerformSuccessWithResponse:<span class="params">(AIFURLResponse *)</span>response;</span><br><span class="line"></span><br><span class="line">- <span class="params">(void)</span>manager:<span class="params">(RTA<span class="literal">PI</span>BaseManager *)</span>manager beforePerformFailWithResponse:<span class="params">(AIFURLResponse *)</span>response;</span><br><span class="line">- <span class="params">(void)</span>manager:<span class="params">(RTA<span class="literal">PI</span>BaseManager *)</span>manager afterPerformFailWithResponse:<span class="params">(AIFURLResponse *)</span>response;</span><br><span class="line"></span><br><span class="line">- <span class="params">(BOOL)</span>manager:<span class="params">(RTA<span class="literal">PI</span>BaseManager *)</span>manager shouldCallAPIWithParams:<span class="params">(NSDictionary *)</span>params;</span><br><span class="line">- <span class="params">(void)</span>manager:<span class="params">(RTA<span class="literal">PI</span>BaseManager *)</span>manager afterCallingAPIWithParams:<span class="params">(NSDictionary *)</span>params;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface RTAPIBaseManager : NSObject</span><br><span class="line"></span><br><span class="line">@property <span class="params">(nonatomic, weak)</span> id&lt;RTAPIManagerInterceptor&gt; interceptor;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>这么做对比Method Swizzling有个额外好处就是，你可以通过拦截器来给拦截器的实现者提供更多的信息，便于外部实现更加了解当前切片的情况。另外，你还可以更精细地对切片进行划分。Method Swizzling的切片粒度是函数粒度的，自己实现的拦截器的切片粒度可以比函数更小，更加精细。</p>
<p>缺点就是，你得自己在每一个插入点把调用拦截器方法的代码写上（笑），通过Aspects（本质上就是Mehtod Swizzling）来实现的AOP，就能轻松一些。</p>
<h3 id="2015-4-29_14:25_补：关于在哪儿写Constraints？">2015-4-29 14:25 补：关于在哪儿写Constraints？</h3><p>文章发出来之后，很多人针对<code>勘误1</code>有很多看法，以至于我觉得很有必要在这里做一份补。期间过程很多很复杂，这篇文章也已经很长了，我就直接说结果了哈。</p>
<p><img src="http://casatwy.com/pics/iOSView/autolayout.png" alt=""></p>
<p>苹果在文档中指出，<code>updateViewConstraints</code>是用来做add constraints的地方。</p>
<p>但是在这里有一个回答者说<code>updateViewConstraints</code>并不适合做添加Constraints的事情。</p>
<p>综合我自己和评论区各位关心这个问题的兄弟们的各种测试和各种文档，我现在觉得还是在<code>viewDidLoad</code>里面开一个<code>layoutPageSubviews</code>的方法，然后在这个里面创建Constraints并添加，会比较好。就是像下面这样：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (void)<span class="tag">viewDidLoad</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr_selector">[super viewDidLoad]</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attr_selector">[self.view addSubview:self.firstView]</span>;</span><br><span class="line">    <span class="attr_selector">[self.view addSubview:self.secondView]</span>;</span><br><span class="line">    <span class="attr_selector">[self.view addSubview:self.thirdView]</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attr_selector">[self layoutPageSubviews]</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">layoutPageSubviews</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr_selector">[self.view addConstraints:xxxConstraints]</span>;</span><br><span class="line">    <span class="attr_selector">[self.view addConstraints:yyyConstraints]</span>;</span><br><span class="line">    <span class="attr_selector">[self.view addConstraints:zzzConstraints]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，要感谢评论区各位关心这个问题，并提出自己意见，甚至是自己亲自测试然后告诉我结果的各位兄弟：@fly2never，@Wythe，@wtlucky，@lcddhr，@李新星，@Meigan Fang，@匿名，@Xiao Moch。</p>
<p>这个做法是目前我自己觉得可能比较合适的做法，当然也欢迎其他同学继续拿出自己的看法，我们来讨论</p>
<h3 id="勘误">勘误</h3><p>我的前同事@ddaajing看了这篇文章之后，给我提出了以下两个勘误，和很多行文上的问题。在这里我对他表示非常感谢：</p>
<p>勘误1：其实在viewWillAppear这里改变UI元素不是很可靠，Autolayout发生在viewWillAppear之后，严格来说这里通常不做视图位置的修改，而用来更新Form数据。改变位置可以放在viewWilllayoutSubview或者didLayoutSubview里，而且在viewDidLayoutSubview确定UI位置关系之后设置autoLayout比较稳妥。另外，viewWillAppear在每次页面即将显示都会调用，viewWillLayoutSubviews虽然在lifeCycle里调用顺序在viewWillAppear之后，但是只有在页面元素需要调整时才会调用，避免了Constraints的重复添加。</p>
<p>勘误2：MVVM要有ViewModel，以及ReactiveCocoa带来的信号通知效果，在ReactiveCocoa里就是RAC等相关宏来实现。另外，使用ReactiveCocoa能够比较优雅地实现MVVM模式，就是因为有RAC等相关宏的存在。就像它的名字一样Reactive-响应式，这也是区分MVVM的VM和MVC的C和MVP的P的一个重要方面。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html">reference</a></p>
<h2 id="iOS应用架构谈_view层的组织和调用方案">iOS应用架构谈 view层的组织和调用方案</h2><h3 id="前言">前言</h3><p>《iOS应用架构谈 开篇》出来之后，很多人来催我赶紧出第二篇。这一篇文章出得相当艰难，因为公司里的破事儿特别多，我自己又有点私事儿，以至于能用来写博客的时间不够充分。</p>
<p>现在好啦，第二篇出来了。</p>
<hr>
<p>当我们开始设计View层的架构时，往往是这个App还没有开始开发，或者这个App已经发过几个版本了，然后此时需要做非常彻底的重构。</p>
<p>一般也就是这两种时机会去做View层架构，基于这个时机的特殊性，我们在这时候必须清楚认识到：View层的架构一旦实现或定型，在App发版后可修改的余地就已经非常之小了。因为它跟业务关联最为紧密，所以哪怕稍微动一点点，它所引发的蝴蝶效应都不见得是业务方能够hold住的。这样的情况，就要求我们在实现这个架构时，代码必须得改得勤快，不能偷懒。也必须抱着充分的自我怀疑态度，做决策时要拿捏好尺度。</p>
<hr>
<p>View层的架构非常之重要，在我看来，这部分架构是这系列文章涉及4个方面最重要的一部分，没有之一。为什么这么说？</p>]]>
    
    </summary>
    
      <category term="Framework" scheme="http://ytlvy.com/tags/Framework/"/>
    
      <category term="Framework" scheme="http://ytlvy.com/categories/Framework/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS application framework -- first]]></title>
    <link href="http://ytlvy.com/2015/08/04/iOS-application-framework-first/"/>
    <id>http://ytlvy.com/2015/08/04/iOS-application-framework-first/</id>
    <published>2015-08-04T13:20:25.000Z</published>
    <updated>2015-08-04T13:21:08.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://casatwy.com/iosying-yong-jia-gou-tan-kai-pian.html" target="_blank" rel="external">reference</a></p>
<h2 id="iOS应用架构谈_开篇">iOS应用架构谈 开篇</h2><h3 id="缘由">缘由</h3><p>之前安居客iOS app的第二版架构大部分内容是我做的，期间有总结了一些经验。在将近一年之后，前同事zzz在微信朋友圈上发了一个问题：假如问你一个<code>iOS or Android app</code>的架构，你会从哪些方面来说呢？</p>
<p>当时看到这个问题正好在乘公车回家的路上，闲来无聊就答了一把。在zzz在微信朋友圈上追问了几个问题之后，我觉得有必要开个博客专门来讲讲一些个人见解。</p>
<p>其实对于iOS客户端应用的架构来说，复杂度不亚于服务端，但侧重点和入手点却跟服务端不太一样。比如客户端应用就不需要考虑类似C10K的问题，正常的app就根本不需要考虑。</p>
<p>这系列文章我会主要专注在iOS应用架构方面，很多方案也是基于iOS技术栈的特点而建立的。因为我个人不是很喜欢写Java，所以Android这边的我就不太了解了。如果你是Android开发者，你可以侧重看我提出的一些架构思想，毕竟不管做什么，思路是相通的，实现手段不同罢了。</p>
<h3 id="当我们讨论客户端应用架构的时候，我们在讨论什么？">当我们讨论客户端应用架构的时候，我们在讨论什么？</h3><p>其实市面上大部分应用不外乎就是颠过来倒过去地做以下这些事情：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---------------     ---------------     ---------------     ---------------</span><br><span class="line">|<span class="string">             </span>|<span class="string">     </span>|<span class="string">             </span>|<span class="string">     </span>|<span class="string">             </span>|<span class="string">     </span>|<span class="string">             </span>|</span><br><span class="line">|<span class="string"> 调用网络API  </span>|<span class="string"> --&gt; </span>|<span class="string">   展现列表    </span>|<span class="string"> --&gt; </span>|<span class="string">  选择列表    </span>|<span class="string"> --&gt; </span>|<span class="string">   展现单页   </span>|</span><br><span class="line">|<span class="string">             </span>|<span class="string">     </span>|<span class="string">             </span>|<span class="string">     </span>|<span class="string">             </span>|<span class="string">     </span>|<span class="string">             </span>|</span><br><span class="line">---------------     ---------------     ---------------     ---------------</span><br><span class="line">                           ^                                        |<span class="string"></span><br><span class="line">                           </span>|<span class="string">                                        </span>|</span><br><span class="line">                           |<span class="string">                                        </span>|</span><br><span class="line">                           ------------------------------------------</span><br></pre></td></tr></table></figure></p>
<p>简单来说就是调API，展示页面，然后跳转到别的地方再调API，再展示页面。</p>
<a id="more"></a>
<h3 id="那这特么有毛好架构的？">那这特么有毛好架构的？</h3><blockquote>
<p>非也，非也。 —— 包不同 《天龙八部》</p>
</blockquote>
<p>App确实就是主要做这些事情，但是支撑这些事情的基础，就是做架构要考虑的事情。</p>
<ul>
<li>调用网络API</li>
<li>页面展示</li>
<li>数据的本地持久化</li>
<li>动态部署方案</li>
</ul>
<p>上面这四大点，稍微细说一下就是：</p>
<ul>
<li>如何让业务开发工程师方便安全地调用网络API？然后尽可能保证用户在各种网络环境下都能有良好的体验？</li>
<li>页面如何组织，才能尽可能降低业务方代码的耦合度？尽可能降低业务方开发界面的复杂度，提高他们的效率？</li>
<li>当数据有在本地存取的需求的时候，如何能够保证数据在本地的合理安排？如何尽可能地减小性能消耗？</li>
<li>iOS应用有审核周期，如何能够通过不发版本的方式展示新的内容给用户？如何修复紧急bug？</li>
</ul>
<p>上面几点是针对App说的，下面还有一些是针对团队说的：</p>
<ul>
<li>收集用户数据，给产品和运营提供参考</li>
<li>合理地组织各业务方开发的业务模块，以及相关基础模块</li>
<li>每日app的自动打包，提供给QA工程师的测试工具</li>
</ul>
<p>一时半会儿我还是只能想到上面这三点，事实上应该还会有很多，想不起来了。</p>
<p>所以当我们讨论客户端应用架构的时候，我们讨论的差不多就是这些问题。</p>
<h3 id="这系列文章要回答那些问题？">这系列文章要回答那些问题？</h3><ul>
<li>网络层设计方案？设计网络层时要考虑哪些问题？对网络层做优化的时候，可以从哪些地方入手？</li>
<li>页面的展示、调用和组织都有哪些设计方案？我们做这些方案的时候都要考虑哪些问题？</li>
<li>本地持久化层的设计方案都有哪些？优劣势都是什么？不同方案间要注意的问题分别都是什么？</li>
<li>要实现动态部署，都有哪些方案？不同方案之间的优劣点，他们的侧重点？</li>
</ul>
<h3 id="本文要回答那些问题？">本文要回答那些问题？</h3><p>上面细分出来的四个问题，我会分别在四篇文章里面写。那么这篇文章就是来讲一些通识啥的，也是开个坑给大家讨论通识问题的。</p>
<h3 id="架构设计的方法">架构设计的方法</h3><p>所有事情最难的时候都是开始做的时候，当你开始着手设计并实现某一层的架构乃至整个app的架构的时候，很有可能会出现暂时的无从下手的情况。以下方法论是我这些年总结出来的经验，每个架构师也一定都有一套自己的方法论，但一样的是，不管你采用什么方法，全局观、高度的代码审美能力、灵活使用各种设计模式一定都是贯穿其中的。欢迎各位在评论区讨论。</p>
<blockquote>
<p>第一步：搞清楚要解决哪些问题，并找到解决这些问题的充要条件</p>
</blockquote>
<p>你必须得清楚你要做什么，业务方希望要什么。而不是为了架构而架构，也不是为了体验新技术而改架构方案。以前是MVC，最近流行MVVM，如果过去的MVC是个好架构，没什么特别大的缺陷，就不要推倒然后搞成MVVM。</p>
<p>关于充要条件我也要说明一下，有的时候系统提供的函数是需要额外参数的，比如read函数。还有翻页的时候，当前页码也是充要条件。但对于业务方来说，这些充要条件还能够再缩减。</p>
<p>比如read，需要给出file descriptor，需要给出buf，需要给出size。但是对于业务方来说，充要条件就只要file descriptor就够了。再比如翻页，其实业务方并不需要记录当前页号，你给他暴露一个<code>loadNextPage</code>这样的方法就够了。</p>
<p>搞清楚对于业务方而言的真正充要条件很重要！这决定了你的架构是否足够易用。另外，传的参数越少，耦合度相对而言就越小，你替换模块或者升级模块所花的的代价就越小。</p>
<blockquote>
<p>第二步：问题分类，分模块</p>
</blockquote>
<p>这个不用多说了吧。</p>
<blockquote>
<p>第三步：搞清楚各问题之间的依赖关系，建立好模块交流规范并设计模块</p>
</blockquote>
<p>关键在于建立一套统一的交流规范。这一步很能够体现架构师在软件方面的价值观，虽然存在一定程度上的好坏优劣（比如胖Model和瘦Model），但既然都是架构师了，基本上是不会设计出明显很烂的方案的，除非这架构师还不够格。所以这里是架构师价值观输出的一个窗口，从这一点我们是能够看出架构师的素质的。</p>
<p>另外要注意的是，一定是建立一套统一的交流规范，不是两套，不是多套。你要坚持你的价值观，不要摇摆不定。要是搞出各种五花八门的规范出来，一方面有不切实际的炫技嫌疑，另一方面也会带来后续维护的灾难。</p>
<blockquote>
<p>第四步：推演预测一下未来可能的走向，必要时添加新的模块，记录更多的基础数据以备未来之需</p>
</blockquote>
<p>很多称职的架构师都会在这时候考虑架构未来的走向，以及考虑做完这一轮架构之后，接下来要做的事情。一个好的架构虽然是功在当代利在千秋的工程，但绝对不是一个一劳永逸的工程。软件是有生命的，你做出来的架构决定了这个软件它这一生是坎坷还是幸福。</p>
<blockquote>
<p>第五步：先解决依赖关系中最基础的问题，实现基础模块，然后再用基础模块堆叠出整个架构</p>
</blockquote>
<p>这一步也是验证你之前的设计是否合理的一步，随着这一步的推进，你很有可能会遇到需要对架构进行调整的情况。这个阶段一定要吹毛求疵高度负责地去开发，不要得过且过，发现架构有问题就及时调整。否则以后调整的成本就非常之大了。</p>
<blockquote>
<p>第六步：打点，跑单元测试，跑性能测试，根据数据去优化对应的地方</p>
</blockquote>
<p>你得用这些数据去向你的boss邀功，你也得用这些数据去不断调整你的架构。</p>
<p>总而言之就是要遵循这些原则：自顶向下设计（1，2，3，4步），自底向上实现（5），先测量，后优化（6）。</p>
<h3 id="什么样的架构师是好架构师？">什么样的架构师是好架构师？</h3><p>1) 每天都在学习，新技术新思想上手速度快，理解速度快<br>做不到这点，你就是码农</p>
<p>2) 业务出身，或者至少非常熟悉公司所处行业或者本公司的业务<br>做不到这点，你就是运维</p>
<p>3) 熟悉软件工程的各种规范，踩过无数坑。不会为了完成需求不择手段，不推崇quick &amp; dirty<br>做不到这点，你比较适合去竞争对手那儿当工程师</p>
<p>4) 及时承认错误，不要觉得承认错误会有损你架构师的身份<br>做不到这点，公关行业比较适合你</p>
<p>5) 不为了炫技而炫技<br>做不到这点，你就是高中编程爱好者</p>
<p>6) 精益求精<br>做不到这点，（我想了好久，但我还是不知道你适合去干什么。）</p>
<h3 id="什么样的架构叫好架构？">什么样的架构叫好架构？</h3><ul>
<li>代码整齐，分类明确，没有common，没有core</li>
<li>不用文档，或很少文档，就能让业务方上手</li>
<li>思路和方法要统一，尽量不要多元</li>
<li>没有横向依赖，万不得已不出现跨层访问</li>
<li>对业务方该限制的地方有限制，该灵活的地方要给业务方创造灵活实现的条件</li>
<li>易测试，易拓展</li>
<li>保持一定量的超前性</li>
<li>接口少，接口参数少</li>
<li>高性能</li>
</ul>
<p>以上是我判断一个架构是不是好架构的标准，这是根据重要性来排列的。客户端架构跟服务端架构要考虑的问题和侧重点是有一些区别的。下面我会针对每一点详细讲解一下：</p>
<blockquote>
<p>代码整齐，分类明确，没有common，没有core</p>
</blockquote>
<p>代码整齐是每一个工程师的基本素质，先不说你搞定这个问题的方案有多好，解决速度有多快，如果代码不整齐，一切都白搭。因为你的代码是要给别人看的，你自己也要看。如果哪一天架构有修改，正好改到这个地方，你很容易自己都看不懂。另外，破窗理论提醒我们，如果代码不整齐分类不明确，整个架构会随着一次一次的拓展而越来越混乱。</p>
<p>分类明确的字面意思大家一定都了解，但还有一个另外的意思，那就是：不要让一个类或者一个模块做两种不同的事情。如果有类或某模块做了两种不同的事情，一方面不适合未来拓展，另一方面也会造成分类困难。</p>
<p>不要搞Common，Core这些东西。每家公司的架构代码库里面，最恶心的一定是这两个名字命名的文件夹，我这么说一定不会错。不要开Common，Core这样的文件夹，开了之后后来者一定会把这个地方搞得一团糟，最终变成Common也不Common，Core也不Core。要记住，架构是不断成长的，是会不断变化的。不是每次成长每次变化，都是由你去实现的。如果真有什么东西特别小，那就索性为了他单独开辟一个模块就好了，小就小点，关键是要有序。</p>
<blockquote>
<p>不用文档，或很少文档，就能让业务方上手</p>
</blockquote>
<p>谁特么会去看文档啊，业务方他们已经被产品经理逼得很忙了。所以你要尽可能让你的API名字可读性强，对于iOS来说，objc这门语言的特性把这个做到了极致，函数名长就长一点，不要紧。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">好的函数名：</span><br><span class="line">    - (<span class="built_in">NSDictionary</span> *)exifDataOfImage:(<span class="built_in">UIImage</span> *)image atIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath;</span><br><span class="line"></span><br><span class="line">坏的函数名：</span><br><span class="line">    - (<span class="keyword">id</span>)exifData:(<span class="built_in">UIImage</span> *)image position:(<span class="keyword">id</span>)indexPath callback:(<span class="keyword">id</span>&lt;ErrorDelegate&gt;)delegate;</span><br><span class="line"></span><br><span class="line">为什么坏？</span><br><span class="line">    <span class="number">1.</span> 不要直接返回<span class="keyword">id</span>或者传入<span class="keyword">id</span>，实在不行，用<span class="keyword">id</span>&lt;protocol&gt;也比<span class="keyword">id</span>好。如果连这个都做不到，你要好好考虑你的架构是不是有问题。</span><br><span class="line">    <span class="number">2.</span> 要告知业务方要传的东西是什么，比如要传Image，那就写上ofImage。如果要传位置，那就要写上IndexPath，而不是用position这么笼统的东西</span><br><span class="line">    <span class="number">3.</span> 没有任何理由要把delegate作为参数传进去，一定不会有任何情况不得不这么做的。而且delegate这个参数根本不是这个函数要解决的问题的充要条件，如果你发现你不得不这么做，那一定是架构有问题！</span><br></pre></td></tr></table></figure>
<blockquote>
<p>思路和方法要统一，尽量不要多元</p>
</blockquote>
<p>解决一个问题会有很多种方案，但是一旦确定了一种方案，就不要在另一个地方采用别的方案了。也就是做架构的时候，你得时刻记住当初你决定要处理这样类型的问题的方案是什么，以及你的初衷是什么，不要摇摆不定。</p>
<p>另外，你当初设立这个模块一定是有想法有原因的，要记录下你的解决思路，不要到时候换个地方你又灵光一现啥的，引入了其他方案，从而导致异构。</p>
<p>要是一个框架里面解决同一种类似的问题有各种五花八门的方法或者类，我觉得做这个架构的架构师一定是自己都没想清楚就开始搞了。</p>
<blockquote>
<p>没有横向依赖，万不得已不出现跨层访问</p>
</blockquote>
<p>没有横向依赖是很重要的，这决定了你将来要对这个架构做修补所需要的成本有多大。要做到没有横向依赖，这是很考验架构师的模块分类能力和是否熟悉业务的。</p>
<p>跨层访问是指数据流向了跟自己没有对接关系的模块。有的时候跨层访问是不可避免的，比如网络底层里面信号从2G变成了3G变成了4G，这是有可能需要跨层通知到View的。但这种情况不多，一旦出现就要想尽一切办法在本层搞定或者交给上层或者下层搞定，尽量不要出现跨层的情况。跨层访问同样也会增加耦合度，当某一层需要整体替换的时候，牵涉面就会很大。</p>
<blockquote>
<p>对业务方该限制的地方有限制，该灵活的地方要给业务方创造灵活实现的条件</p>
</blockquote>
<p>把这点做好，很依赖于架构师的经验。架构师必须要有能力区分哪些情况需要限制灵活性，哪些情况需要创造灵活性。比如对于Core Data技术栈来说，ManagedObject理论上是可以出现在任何地方的，那就意味着任何地方都可以修改ManagedObject，这就导致ManagedObjectContext在同步修改的时候把各种不同来源的修改同步进去。这时候就需要限制灵活性，只对外公开一个修改接口，不暴露任何ManagedObject在外面。</p>
<p>如果是设计一个ABTest相关的API的时候，我们又希望增加它的灵活性。使得业务方不光可以通过Target-Action的模式实现ABtest，也要可以通过Block的方式实现ABTest，要尽可能满足灵活性，减少业务方的使用成本。</p>
<blockquote>
<p>易测试易拓展</p>
</blockquote>
<p>老生常谈，要实现易测试易拓展，那就要提高模块化程度，尽可能减少依赖关系，便于mock。另外，如果是高度模块化的架构，拓展起来将会是一件非常容易的事情。</p>
<blockquote>
<p>保持一定量的超前性</p>
</blockquote>
<p>这一点能看出架构师是否关注行业动态，是否能准确把握技术走向。保持适度的技术上的超前性，能够使得你的架构更新变得相对轻松。</p>
<p>另外，这里的超前性也不光是技术上的，还有产品上的。谁说架构师就不需要跟产品经理打交道了，没事多跟产品经理聊聊天，听听他对产品未来走向的畅想，你就可以在合理的地方为他的畅想留一条路子。同时，在创业公司的环境下，很多产品需求其实只是为了赶产品进度而产生的妥协方案，最后还是会转到正轨的。这时候业务方可以不实现转到正规的方案，但是架构这边，是一定要为这种可预知的改变做准备的。</p>
<blockquote>
<p>接口少，接口参数少</p>
</blockquote>
<p>越少的接口越少的参数，就能越降低业务方的使用成本。当然，充要条件还是要满足的，如何在满足充要条件的情况下尽可能地减少接口和参数数量，这就能看出架构师的功力有多深厚了。</p>
<blockquote>
<p>高性能</p>
</blockquote>
<p>为什么高性能排在最后一位？</p>
<p>高性能非常重要，但是在客户端架构中，它不是第一考虑因素。原因有下：</p>
<ul>
<li>客户端业务变化非常之快，做架构时首要考虑因素应当是便于业务方快速满足产品需求，因此需要尽可能提供简单易用效果好的接口给业务方，而不是提供高性能的接口给业务方。</li>
<li>苹果平台的性能非常之棒，正常情况下很少会出现由于性能不够导致的用户体验问题。</li>
<li>苹果平台的优化手段相对有限，甚至于有些时候即便动用了无所不用其极的手段乃至不择手段牺牲了稳定性，性能提高很有可能也只不过是100ms到90ms的差距。10%的性能提升对于服务端来说很不错了，因为服务端动不动就是几十万上百万的访问量，几十万上百万个10ms是很可观的。但是对于客户端的用户来说，他无法感知这10ms的差别，如果从10s优化成9s用户还是有一定感知的，但是100ms变90ms，我觉得吧，还是别折腾了。</li>
</ul>
<p>但是！不重要不代表用不着去做，关于性能优化的东西，我会对应放到各系列文章里面去。比如网络层优化，那就会在网络层方案的那篇文章里面去写，对应每层架构都有每层架构的不同优化方案，我都会在各自文章里面一一细说。</p>
<h3 id="2015-4-2_11:28_补:_关于架构分层？">2015-4-2 11:28 补: 关于架构分层？</h3><p>昨晚上志豪看了这篇文章之后说，看到你这个题目本来我是期望看到关于架构分层相关的东西的，但是你没写。</p>
<p>嗯，确实没写，当时没写的原因是感觉这个没什么好写的。前面谈论到架构的方法的时候，关于问题分类分模块这一步时，架构分层也属于这一部分，给我一笔带过了。</p>
<p>既然志豪提出来了这个问题，我想可能大家关于这个也会有一些想法和问题，那么我就在这儿讲讲吧。</p>
<blockquote>
<p>其实分层这种东西，真没啥技术含量，全凭架构师的经验和素质。</p>
</blockquote>
<p>我们常见的分层架构，有三层架构的：展现层、业务层、数据层。也有四层架构的：展现层、业务层、网络层、本地数据层。这里说三层、四层，跟TCP/IP所谓的五层或者七层不是同一种概念。再具体说就是：你这个架构在逻辑上是几层那就几层，具体每一层叫什么，做什么，没有特定的规范。这主要是针对模块分类而言的。</p>
<p>也有说MVC架构，MVVM架构的，这种层次划分，主要是针对数据流动的方向而言的。</p>
<p>在实际情况中，针对数据流动方向做的设计和针对模块分类做的设计是会放在一起的，也就是说，一个MVC架构可以是四层：展现层、业务层、网络层、本地数据层。</p>
<p>那么，为什么我要说这个？</p>
<p>大概在五六年前，业界很流行三层架构这个术语。然后各种文档资料漫天的三层架构，并且喜欢把它与MVC放在一起说，MVC三层架构/三层架构MVC，以至于很多人就会认为三层架构就是MVC，MVC就是三层架构。其实不是的。三层架构里面其实没有Controller的概念，而且三层架构描述的侧重点是模块之间的逻辑关系。MVC有Controller的概念，它描述的侧重点在于数据流动方向。</p>
<blockquote>
<p>好，为什么流行起来的是三层架构，而不是四层架构或五层架构？</p>
</blockquote>
<p>因为所有的模块角色只会有三种：数据管理者、数据加工者、数据展示者，意思也就是，笼统说来，软件只会有三层，每一层扮演一个角色。其他的第四层第五层，一般都是这三层里面的其中之一分出来的，最后都能归纳进这三层的某一层中去，所以用三层架构来描述就比较普遍。</p>
<blockquote>
<p>那么我们怎么做分层？</p>
</blockquote>
<p>应该如何做分层，不是在做架构的时候一开始就考虑的问题。虽然我们要按照自顶向下的设计方式来设计架构，但是一般情况下不适合直接从三层开始。一般都是先确定所有要解决的问题，先确定都有哪些模块，然后再基于这些模块再往下细化设计。然后再把这些列出来的问题和模块做好分类。分类之后不出意外大多数都是三层。如果发现某一层特别庞大，那就可以再拆开来变成四层，变成五层。</p>
<p>举个例子：<code>你要设计一个即时通讯的服务端架构，怎么分层？</code></p>
<p>记住，不要一上来就把<code>三层架构</code>的规范套上去，这样做是做不出好架构的。</p>
<p>你要先确定都需要解决哪些问题。这里只是举例子，我随意列出一点意思意思就好了：</p>
<ul>
<li>要解决用户登录、退出的问题</li>
<li>解决不同用户间数据交流的问题</li>
<li>解决用户数据存储的问题</li>
<li>如果是多台服务器的集群，就要解决用户连接的寻址问题</li>
</ul>
<p>1) 解决第一个问题需要一个链接管理模块，链接管理模块一般是通过链接池来实现。<br>2) 解决第二个问题需要有一个数据交换模块，从A接收来的数据要给到B，这个事情由这个模块来做。<br>3) 解决第三个问题需要有个数据库，如果是服务于大量用户，那么就需要一个缓冲区，只有当需要存储的数据达到一定量时才执行写操作。<br>4) 解决第四个问题可以有几种解决方案，一个是集群中有那么几台服务器作为寻路服务器，所有寻路的服务交给那几台去做，那么你需要开发一个寻路服务的Daemon。或者用广播方式寻路，但如果寻路频次非常高，会造成集群内部网络负载特别大。这是你要权衡的地方，目前流行的思路是去中心化，那么要解决网络负载的问题，你就可以考虑配置一个缓存。</p>
<p>于是我们有了这些模块：<br>链接管理、数据交换、数据库及其配套模块、寻路模块</p>
<p>做到这里还远远没有结束，你要继续针对这四个模块继续往下细分，直到足够小为止。但是这里只是举例子，所以就不往下深究了。</p>
<p>另外，我要提醒你的是，直到这时，还是跟几层架构毫无关系的。当你把所有模块都找出来之后，就要开始整理你的这些模块，很有可能架构图就是这样：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">链接管理  收发数据                     收发数据</span><br><span class="line">    数据交换                       /        <span class="string">\</span> </span><br><span class="line">                        <span class="string">\</span>   链接管理        数据交换</span><br><span class="line">寻路服务          ========<span class="string">\</span>                   /  <span class="string">\</span></span><br><span class="line">                ========/            数据库服务   寻路服务</span><br><span class="line">    数据库服务           /</span><br></pre></td></tr></table></figure></p>
<p>然后这些模块分完之后你看一下图，嗯，1、2、3，一共三层，所以那就是三层架构啦。在这里最消耗脑力最考验架构师功力的地方就在于：<code>找到所有需要的模块, 把模块放在该放的地方</code></p>
<p>这个例子侧重点在于如何分层，性能优化、数据交互规范和包协议、数据采集等其他一系列必要的东西都没有放进去，但看到这里，相信你应该了解架构师是怎么对待分层问题的了吧？</p>
<blockquote>
<p>对的，答案就是没有分层。所谓的分层都是出架构图之后的事情了。所以你看别的架构师在演讲的时候，上来第一句话差不多都是：”这个架构分为以下几层…”。但考虑分层的问题的时机绝对不是一开始就考虑的。另外，模块一定要把它设计得独立性强，这其实是门艺术活。</p>
</blockquote>
<p>另外，这虽然是服务端架构，但是思路跟客户端架构是一样的，侧重点不同罢了。之所以不拿客户端架构举例子，是因为这方面的客户端架构苹果已经帮你做好了绝大部分事情，没剩下什么值得说的了。</p>
<h3 id="2015-4-5_12:15_补：关于Common文件夹？">2015-4-5 12:15 补：关于Common文件夹？</h3><p>评论区MatrixHero提到一点：</p>
<blockquote>
<p>关于common文件夹的问题，仅仅是文件夹而已，别无他意。如果后期维护出了代码混乱可能是因为，和服务器沟通协议不统一，或代码review不及时。应该有专人维护公共类。</p>
</blockquote>
<p>这是针对我前面提出的<code>不要Common，不要Core</code>而言的，为什么我建议大家不要开Common文件夹？我打算分几种情况给大家解释一下。</p>
<p>一般情况下，我们都会有一些属于这个项目的公共类，比如取定位坐标，比如图像处理。这些模块可能非常小，就h和m两个文件。单独拎出来成为一个模块感觉不够格，但是又不属于其他任何一个模块。于是大家很有可能就会把它们放入Common里面，我目前见到的大多数工程和大多数文档里面的代码都喜欢这么做。在当时来看，这么做看不出什么问题，但关键在于：<code>软件是有生命，会成长的</code>。当时分出来的小模块，很有可能会随着业务的成长，逐渐发展成大模块，发展成大模块后，可以再把它从Common移出来单独成立一个模块。这个在理论上是没有任何问题的，然而在实际操作过程中，工程师在拓张这个小模块的时候，不太容易会去考虑<code>横向依赖</code>的问题，因为当时这些模块都在Common里面，直接进行互相依赖是非常符合直觉的，而且也不算是不遵守规范。然而要注意的是，这才是Commom代码混乱的罪魁祸首，Common文件夹纵容了<code>不精心管理依赖</code>的做法。当Common里面的模块依赖关系变得复杂，再想要移出来单独成立一个模块，就不是当初设置Common时想的<code>等规模大了再移除</code>也不迟那么简单了。</p>
<blockquote>
<p>另外，Common有的时候也不仅仅是一个文件夹。</p>
</blockquote>
<p>在使用Cocoapods来管理项目库的时候，Common往往就是一个pod。这个pod里面会有A/B/C/D/E这些函数集或小模块。如果要新开一个app或者Demo，势必会使用到Common这个pod，这么做，往往会把不需要包含的代码也包含进去，我对项目有高度洁癖，这种情况会让我觉得非常不舒服。</p>
<p>举个例子：早年安居客的app还不是集齐所有<code>新房</code>、<code>二手房</code>、<code>租房</code>业务的。当你刚开始写新房这个app的时候，创建了一个Common这个pod，这里面包含了一些对于新房来说比较Common的代码，也包含了对于这个app来说比较Common的代码。过了半年或者一年，你要开始二手房这个app，我觉得大多数人都会选择让二手房也包含这个Common，于是这个Common很有可能自己走上另一条发展的道路。等到了租房这个业务要开app的时候，Common已经非常之庞大，相信这时候的你也不会去想整理Common的事情了，先把租房搞定，于是Common最终就变成了一坨屎。</p>
<p>就对于上面的例子来说，还有一个要考虑的是，分出来的三个业务很有可能会有三个Common，假设三个Common里面都有公共的功能，交给了三个团队去打理，如果遇到某个子模块需要升级，那么三个Common里面的这个子模块都要去同步升级，这是个很不效率的事情。另外，很有可能三个Common到最后发展成彼此不兼容，但是代码相似度非常之高，这个在架构上，是属于<code>分类条理不清</code>。</p>
<p>就在去年年中的时候，安居客决定将三个业务归并到同一个App。好了，如果你是架构师，面对这三个Common，你打算怎么办？要想最快出成果，那就只好忍受代码冗余，赶紧先把架子搭起来再说，否则你面对的就是剪不断理还乱的Common。此时Common就已经很无奈地变成一坨屎了。这样的Common，你自己说不定也搞不清楚它里面到底都有些什么了，交给任何一个人去打理，他都不敢做彻底的整理的。</p>
<hr>
<p>还有就是，Common本身就是一个粒度非常大的模块。在阿里这样大规模的团队中，即便新开一个业务，都需要在整个app的环境下开发，为什么？因为模块拆分粒度不够，要想开一个新业务，必须把其他业务的代码以及依赖全部拉下来，然后再开新入口，你的新业务才能进行正常的代码编写和调试。然而你的新业务其实只依赖首页入口、网络库等这几个小模块，不需要依赖其他那么多的跟你没关系的业务。现在每次打开天猫的项目，我都要等个两三分钟，这非常之蛋疼。</p>
<p>但是大家真的不知道这个原因吗？知道了这个原因，为什么没人去把这些粒度不够细的模块整理好？在我看来，这件事没人敢做。</p>
<p>原来大家用的好好的，手段烂就烂一点，你改了你能保证不出错？<br>这么复杂的东西，短期之内你肯定搞不好，任务量和工时都不好估，你leader会觉得你在骗工时玩自己的事情。<br>就算你搞定了，QA这边肯定再需要做一次全面的回归测试，任务量极大，难以说服他们配合你的工作。<br>花这么大的成本只是为了减少开启项目时候等待IDE打开时的那几分钟时间？我想如果我是你leader，我也应该不会批准你做这样的事情的。所以，与其到了后面吃这个苦头，不如一开始做架构的时候就不要设置Common，到后面就能省力很多。架构师的工作为什么是功在当代利在千秋，架构师的素质为什么对团队这么重要？我觉得这里就是一个最好的体现。</p>
<hr>
<p>简而言之，不建议开Common的原因如下：</p>
<ul>
<li>Common不仅仅是一个文件夹，它也会是一个Pod。不管是什么，在Common里面很容易形成错综复杂的小模块依赖，在模块成长过程中，会纵容工程师不注意依赖的管理，乃至于将来如果要将模块拆分出去，会非常的困难。</li>
<li>Common本身与细粒度模块设计的思想背道而驰，属于一种不合适的偷懒手段，在将来业务拓张会成为阻碍。</li>
<li>一旦设置了Common，就等于给地狱之门打开了一个小缝，每次业务迭代都会有一些不太好分类的东西放入Common，这就给维护Common的人带来了非常大的工作量，而且这些工作量全都是体力活，非常容易出错。</li>
</ul>
<blockquote>
<p>那么，不设Common会带来哪些好处？</p>
</blockquote>
<ul>
<li>强迫工程师在业务拓张的时候将依赖管理的事情考虑进去，让模块在一开始发展的时候就有自己的土壤，成长空间和灵活度非常大。</li>
<li>减少各业务模块或者Demo的体积，不需要的模块不会由于Common的存在而包含在内。</li>
<li>可维护性大大提高，模块升级之后要做的同步工作非常轻松，解放了那个苦逼的Common维护者，更多的时间可以用在更实质的开发工作上。</li>
<li>符合细粒度模块划分的架构思想。</li>
</ul>
<p>Common的好处只有一个，就是前期特别省事儿。然而它的坏处比好处要多太多。不设置Common，再小的模块再小的代码也单独拎出来，最多就是Podfile里面要多写几行，多写几行最多只花费几分钟。但若要消除Common所带来的罪孽，不是这几分钟就能搞定的事情。既然不用Common的好处这么多，那何乐而不为呢？</p>
<p>假设将来你的项目中有一个类是用来做Location的，哪怕只有两个文件，也给他开一个模块就叫Location。如果你的项目中有一个类是用来做ImageProcess的，那也开一个模块就叫ImageProcess。不要都放到Common里面去，将来你再开新的项目或者新的业务，用Location就写依赖Location，用ImageProcess就写依赖ImageProcess，不要再依赖Common了，这样你的项目也好管理，管理Common的那个人日子过得也轻松（这个人其实都可以不需要了，把他的工资加到你头上不是更好？:D），将来要升级，顾虑也少。</p>
<h3 id=""> </h3>]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://casatwy.com/iosying-yong-jia-gou-tan-kai-pian.html">reference</a></p>
<h2 id="iOS应用架构谈_开篇">iOS应用架构谈 开篇</h2><h3 id="缘由">缘由</h3><p>之前安居客iOS app的第二版架构大部分内容是我做的，期间有总结了一些经验。在将近一年之后，前同事zzz在微信朋友圈上发了一个问题：假如问你一个<code>iOS or Android app</code>的架构，你会从哪些方面来说呢？</p>
<p>当时看到这个问题正好在乘公车回家的路上，闲来无聊就答了一把。在zzz在微信朋友圈上追问了几个问题之后，我觉得有必要开个博客专门来讲讲一些个人见解。</p>
<p>其实对于iOS客户端应用的架构来说，复杂度不亚于服务端，但侧重点和入手点却跟服务端不太一样。比如客户端应用就不需要考虑类似C10K的问题，正常的app就根本不需要考虑。</p>
<p>这系列文章我会主要专注在iOS应用架构方面，很多方案也是基于iOS技术栈的特点而建立的。因为我个人不是很喜欢写Java，所以Android这边的我就不太了解了。如果你是Android开发者，你可以侧重看我提出的一些架构思想，毕竟不管做什么，思路是相通的，实现手段不同罢了。</p>
<h3 id="当我们讨论客户端应用架构的时候，我们在讨论什么？">当我们讨论客户端应用架构的时候，我们在讨论什么？</h3><p>其实市面上大部分应用不外乎就是颠过来倒过去地做以下这些事情：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---------------     ---------------     ---------------     ---------------</span><br><span class="line">|<span class="string">             </span>|<span class="string">     </span>|<span class="string">             </span>|<span class="string">     </span>|<span class="string">             </span>|<span class="string">     </span>|<span class="string">             </span>|</span><br><span class="line">|<span class="string"> 调用网络API  </span>|<span class="string"> --&gt; </span>|<span class="string">   展现列表    </span>|<span class="string"> --&gt; </span>|<span class="string">  选择列表    </span>|<span class="string"> --&gt; </span>|<span class="string">   展现单页   </span>|</span><br><span class="line">|<span class="string">             </span>|<span class="string">     </span>|<span class="string">             </span>|<span class="string">     </span>|<span class="string">             </span>|<span class="string">     </span>|<span class="string">             </span>|</span><br><span class="line">---------------     ---------------     ---------------     ---------------</span><br><span class="line">                           ^                                        |<span class="string"></span><br><span class="line">                           </span>|<span class="string">                                        </span>|</span><br><span class="line">                           |<span class="string">                                        </span>|</span><br><span class="line">                           ------------------------------------------</span><br></pre></td></tr></table></figure></p>
<p>简单来说就是调API，展示页面，然后跳转到别的地方再调API，再展示页面。</p>]]>
    
    </summary>
    
      <category term="Framework" scheme="http://ytlvy.com/tags/Framework/"/>
    
      <category term="Framework" scheme="http://ytlvy.com/categories/Framework/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jump out of OOP -- Package]]></title>
    <link href="http://ytlvy.com/2015/08/04/jump-out-of-OOP-Package/"/>
    <id>http://ytlvy.com/2015/08/04/jump-out-of-OOP-Package/</id>
    <published>2015-08-04T13:18:44.000Z</published>
    <updated>2015-08-04T13:19:17.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://casatwy.com/tiao-chu-mian-xiang-dui-xiang-si-xiang-san-feng-zhuang.html" target="_blank" rel="external">reference</a></p>
<h2 id="跳出面向对象思想(三)_封装">跳出面向对象思想(三) 封装</h2><h3 id="简述">简述</h3><p>我认为”封装”的概念在面向对象思想中是最基础的概念，它实质上是通过将相关的一堆函数和一堆对象放在一起，对外有函数作为操作通道，对内则以变量作为操作原料。只留给外部程序员操作方式，而不暴露具体执行细节。大部分书举的典型例子就是汽车和灯泡的例子：你不需要知道不同车子的发动机原理，只要踩油门就可以跑；你不需要知道你的灯泡是那种灯泡，打开开关就会亮。我们都会很直觉地认为这种做法非常棒，是吧？</p>
<p>但是有的时候还是会觉得有哪些地方不对劲，使用面向对象语言的时候，我隐约觉得封装也许并没有我们直觉中认为的那么好，也就是说，面向对象其实并没有我们直觉中的那么好，虽然它已经流行了很多很多年。</p>
<h3 id="1-_将数据结构和函数放在一起是否真的合理？">1. 将数据结构和函数放在一起是否真的合理？</h3><p>函数就是做事情的，它们有输入，有执行逻辑，有输出。 数据结构就是用来表达数据的，要么作为输入，要么作为输出。</p>
<p>两者本质上是属于完全不同的东西，面向对象思想将他们放到一起，使得函数的作用被限制在某一个区域里，这样做虽然能够很好地将操作归类，但是这种归类方法是根据”作用领域”来归类的，在现实世界中可以，但在程序的世界中，有些不妥。</p>
<p>不妥的理由有如下几个：</p>
<blockquote>
<p>在并行计算时，由于执行部分和数据部分被绑定在一起，这就使得这种方案制约了并行程度。在为了更好地实现并行的时候，业界的工程师们发现了一个新的思路：函数式编程。将函数作为数据来使用，这样就能保证执行的功能在时序上的正确性了。但你不觉得，只要把数据表达和执行部分分开，形成流水线，这不就能够非常方便地将并行数提高了么？</p>
</blockquote>
<p>我来举个例子： 在数据和函数没有分开时，程序的执行流程是这样：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.<span class="function"><span class="title">function1</span><span class="params">()</span></span> -&gt; A.<span class="function"><span class="title">function2</span><span class="params">()</span></span> -&gt; A.<span class="function"><span class="title">function3</span><span class="params">()</span></span>     最后得到经过处理的A</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>当处于并发环境时，假设有这么多任务同时到达<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A.<span class="function"><span class="title">f1</span><span class="params">()</span></span> -&gt; A.<span class="function"><span class="title">f2</span><span class="params">()</span></span> -&gt; A.<span class="function"><span class="title">f3</span><span class="params">()</span></span>     最后得到经过处理的A</span><br><span class="line">B.<span class="function"><span class="title">f1</span><span class="params">()</span></span> -&gt; B.<span class="function"><span class="title">f2</span><span class="params">()</span></span> -&gt; B.<span class="function"><span class="title">f3</span><span class="params">()</span></span>     最后得到经过处理的B</span><br><span class="line">C.<span class="function"><span class="title">f1</span><span class="params">()</span></span> -&gt; C.<span class="function"><span class="title">f2</span><span class="params">()</span></span> -&gt; C.<span class="function"><span class="title">f3</span><span class="params">()</span></span>     最后得到经过处理的C</span><br><span class="line">D.<span class="function"><span class="title">f1</span><span class="params">()</span></span> -&gt; D.<span class="function"><span class="title">f2</span><span class="params">()</span></span> -&gt; D.<span class="function"><span class="title">f3</span><span class="params">()</span></span>     最后得到经过处理的D</span><br><span class="line">E.<span class="function"><span class="title">f1</span><span class="params">()</span></span> -&gt; E.<span class="function"><span class="title">f2</span><span class="params">()</span></span> -&gt; E.<span class="function"><span class="title">f3</span><span class="params">()</span></span>     最后得到经过处理的E</span><br><span class="line">F.<span class="function"><span class="title">f1</span><span class="params">()</span></span> -&gt; F.<span class="function"><span class="title">f2</span><span class="params">()</span></span> -&gt; F.<span class="function"><span class="title">f3</span><span class="params">()</span></span>     最后得到经过处理的F</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>假设并发数是3，那么完成上面类似的很多个任务，时序就是这样<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string"> time </span>|<span class="string"> 1   </span>|<span class="string"> 2   </span>|<span class="string"> 3   </span>|<span class="string"> 4   </span>|<span class="string"> 5   </span>|<span class="string"> 6   </span>|<span class="string"> 7   </span>|<span class="string"> 8   </span>|<span class="string"> 9   </span>|<span class="string"> 10  </span>|<span class="string"> 11  </span>|<span class="string"> 12  </span>|</span><br><span class="line">|<span class="string">------</span>|<span class="string">-----</span>|<span class="string">-----</span>|<span class="string">-----</span>|<span class="string">-----</span>|<span class="string">-----</span>|<span class="string">-----</span>|<span class="string">-----</span>|<span class="string">-----</span>|<span class="string">-----</span>|<span class="string">-----</span>|<span class="string">-----</span>|<span class="string">-----</span>|</span><br><span class="line">|<span class="string"> A    </span>|<span class="string"> A.1 </span>|<span class="string"> A.2 </span>|<span class="string"> A.3 </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|</span><br><span class="line">|<span class="string"> B    </span>|<span class="string"> B.1 </span>|<span class="string"> B.2 </span>|<span class="string"> B.3 </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|</span><br><span class="line">|<span class="string"> C    </span>|<span class="string"> C.1 </span>|<span class="string"> C.2 </span>|<span class="string"> C.3 </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|</span><br><span class="line">|<span class="string"> D    </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string"> D.1 </span>|<span class="string"> D.2 </span>|<span class="string"> D.3 </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|</span><br><span class="line">|<span class="string"> E    </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string"> E.1 </span>|<span class="string"> E.2 </span>|<span class="string"> E.3 </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|</span><br><span class="line">|<span class="string"> F    </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string"> F.1 </span>|<span class="string"> F.2 </span>|<span class="string"> F.3 </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|</span><br><span class="line">|<span class="string"> G    </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string"> G.1 </span>|<span class="string"> G.2 </span>|<span class="string"> G.3 </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|</span><br><span class="line">|<span class="string"> H    </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string"> H.1 </span>|<span class="string"> H.2 </span>|<span class="string"> H.3 </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|</span><br><span class="line">|<span class="string"> I    </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string"> I.2 </span>|<span class="string"> I.2 </span>|<span class="string"> I.3 </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|</span><br><span class="line">|<span class="string"> J    </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string"> J.1 </span>|<span class="string"> J.2 </span>|<span class="string"> J.3 </span>|</span><br><span class="line">|<span class="string"> K    </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string"> K.1 </span>|<span class="string"> K.2 </span>|<span class="string"> K.3 </span>|</span><br><span class="line">|<span class="string"> L    </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string">     </span>|<span class="string"> L.1 </span>|<span class="string"> L.2 </span>|<span class="string"> L.3 </span>|</span><br></pre></td></tr></table></figure></p>
<p>当数据和函数分开时，并发数同样是3，就能形成流水线了，有没有发现吞吐量一下子上来了？<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string"> time </span>|<span class="string"> 1 </span>|<span class="string"> 2 </span>|<span class="string"> 3 </span>|<span class="string"> 4 </span>|<span class="string"> 5 </span>|<span class="string"> 6 </span>|<span class="string"> 7 </span>|<span class="string"> 8 </span>|<span class="string"> 9 </span>|<span class="string"> 10</span>|<span class="string"> 11</span>|<span class="string"> 12</span>|</span><br><span class="line">|<span class="string">------</span>|<span class="string">---</span>|<span class="string">---</span>|<span class="string">---</span>|<span class="string">---</span>|<span class="string">---</span>|<span class="string">---</span>|<span class="string">---</span>|<span class="string">---</span>|<span class="string">---</span>|<span class="string">---</span>|<span class="string">---</span>|<span class="string">---</span>|</span><br><span class="line">|<span class="string"> f1() </span>|<span class="string"> A </span>|<span class="string"> B </span>|<span class="string"> C </span>|<span class="string"> D </span>|<span class="string"> E </span>|<span class="string"> F </span>|<span class="string"> G </span>|<span class="string"> H </span>|<span class="string"> I </span>|<span class="string"> J </span>|<span class="string"> K </span>|<span class="string"> L </span>|</span><br><span class="line">|<span class="string"> f2() </span>|<span class="string"> Z </span>|<span class="string"> A </span>|<span class="string"> B </span>|<span class="string"> C </span>|<span class="string"> D </span>|<span class="string"> E </span>|<span class="string"> F </span>|<span class="string"> G </span>|<span class="string"> H </span>|<span class="string"> I </span>|<span class="string"> J </span>|<span class="string"> K </span>|</span><br><span class="line">|<span class="string"> f3() </span>|<span class="string"> Y </span>|<span class="string"> Z </span>|<span class="string"> A </span>|<span class="string"> B </span>|<span class="string"> C </span>|<span class="string"> D </span>|<span class="string"> E </span>|<span class="string"> F </span>|<span class="string"> G </span>|<span class="string"> H </span>|<span class="string"> I </span>|<span class="string"> J </span>|</span><br></pre></td></tr></table></figure></p>
<p>你要是粗看一下，诶？怎么到了第13个周期K才刚刚结束？上面一种方案在第12个周期的时候就结束了？不能这么看的哦，其实在12个周期里面，Y、Z也已经交付了。因为流水线吞吐量的提升是有过程的，我截取的片段应该是机器在持续运算过程中的一个片段。</p>
<p>我们不能单纯地去看ABCD，要看交付的任务数量。在12个周期里面，大家都能够完成12个任务，在11个周期里面，流水线完成了11个任务，前面一种只完成了9个任务，流水线的优势在这里就体现出来了：每个时间段都能稳定地交付任务，吞吐量很大。而且并发数越多，跟第一种方案比起来的优势就越大，具体的大家也可以通过画图来验证。</p>
<blockquote>
<p>数据部分就是数据部分，执行部分就是执行部分，不同类的东西放在一起是不合适的</p>
</blockquote>
<p>函数就是一个执行黑盒，只要满足函数调用的充要条件（给够参数），就是能够确定输出结果的。面向对象思想将函数和数据绑在一起，这样的封装扩大了代码重用时的粒度。如果将函数和数据拆开，代码重用的基本元素就由对象变为了函数，这样才能更灵活更方便地进行代码重用。</p>
<p>嗯，谁都经历过重用对象时，要把这个对象所依赖的所有东西都要移过来，哪怕你想用的只是这个对象里的一个方法，然而很有可能你的这些依赖是跟你所需要的方法无关的。</p>
<p>但如果是函数的话，由于函数自身已经是天然完美封装的了，所以如果你要用到这个函数，那么这个函数所有的依赖你都需要，这才是合理的。</p>
<h3 id="2-_是否所有的东西都需要对象化？">2. 是否所有的东西都需要对象化？</h3><p>面向对象语言一直以自己做到”一切皆对象”为荣，但事实是：是否所有的东西都需要对象化？</p>
<p>在iOS开发中，有一个类叫做NSNumber，它封装了所有数值：double，float，unsigned int, int…等等类型，在使用的时候它弱化了数值的类型，使得非常方便。但问题也来了，计算的时候是不能直接对这个对象做运算的，你得把它们拆成数值，然后进行运算，然后再把结果变成NSNumber对象，然后返回。这是第一点不合理。第二点不合理的地方在于，运算的时候你不知道原始数据的类型是什么，拆箱装箱过程中难免会导致内存的浪费（比如原来uint8_t的数据变成unsigned int），这也十分没有必要。</p>
<p>还有就是我们的file descriptor，它本身是一个资源的标识号，如果将资源抽象成对象，那么不可避免的就会使得这个对象变得非常庞大，资源有非常多的用法，你需要将这些函数都放到对象里去。在真正传递资源的时候，其实我们也只是关心资源标识而已，其它的真的无需关心。</p>
<p>我们已经有函数作为黑盒了，拿着数据塞到黑盒里就够了。</p>
<h3 id="3-_类型爆炸">3. 类型爆炸</h3><p>由于数据和函数绑定到了一起，在逻辑上有派生关系的两种对象往往可以当作一种，以派生链最上端的那个对象为准。单纯地看这个现象直觉上会觉得非常棒，父亲有的儿子都有。但在实际工程中，派生是非常不好控制的，它导致同一类类型在工程中泛滥：ViewController、AViewController、BViewController、ThisViewController、ThatViewController…</p>
<p>你有没有发现，一旦把执行和数据拆解开，就不需要这么多ViewController了，派生只是给对象添加属性和方法。但事实上是这样：<br><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> </span>&#123;              Class A <span class="keyword">extends</span> B</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">B</span> b;         </span>&#123;</span><br><span class="line">    int number;             int number;</span><br><span class="line">&#125;</span><br><span class="line">                        &#123;</span><br></pre></td></tr></table></figure></p>
<p>前者和后者的相同点是：在内存中，它们的数值部分的布局是一模一样的。不同点是：前者更强烈地表达了组合，后者更强烈地表达的是继承。然而我们都知道一个常识：组合要比继承更加合适，这在我这一系列的第一篇文章中有提到。</p>
<p>上两者的表达在内存中没有任何不同，但在实际开发阶段中，后者会更容易把项目引入一个坏方向。</p>
<h3 id="总结">总结</h3><p>为什么面向对象会如此流行？我想了一下业界关于这个谈论的最多的是以下几点：</p>
<ul>
<li>它能够非常好地进行代码复用</li>
<li>它能够非常方便地应对复杂代码</li>
<li>在进行程序设计时，面向对象更加符合程序员的直觉</li>
</ul>
<p>第一点在理论上确实成立，但实际上大家都懂，在面向对象的大背景下，写一段便于复用的代码比面向过程背景下难多了。关于第二点，你不觉得正是面向对象，才把工程变复杂的么？如果层次清晰，调用规范，无论面向对象还是面向过程，处理复杂业务都是一样好，等真的到了非常复杂的时候，对象间错综复杂的关系只会让你处理起来更加头疼，不如面向过程来得简洁。关于第三点，这其实是一个障眼法，因为无论面向什么的设计，最终落实下来，还是要面向过程的，面向对象只是在处理调用关系时符合直觉，在架构设计时，理清需求是第一步，理清调用关系是第二步，理清实现过程是第三步。面向对象让你在第二步时就产生了设计完成的错觉，只有再往下落地到实现过程的时候，你才会发现第二步中都有哪些错误。</p>
<p>所以综上所述，我的观点是：面向对象是在架构设计时非常好的思想，但如果只是简单映射到程序实现上来，引入的缺点会让我们得不偿失。</p>
<hr>
<h3 id="后记">后记</h3><p>距离上一次博文更新已经快要一个月了，不是我偷懒，实在是太忙，现在终于有时间可以把”跳出面向对象”系列完成了。针对面向对象的3个支柱概念我写了三篇文章来挑它的刺，看上去有一种全盘否定的感觉，而我倒不至于希望大家回去下一个项目就开始面向过程的开发，我希望大家能够针对这一系列文章提出的面向对象的弊端，严格规范代码的行为，知道哪些可行哪些不可行。过去的工作中我深受其苦，往往没有时间去详细解释为什么这么直觉的东西实际上不可行，要想解释这些东西就得需要各种长篇大论。最痛苦的是，即便长篇大论说完了，最后对方还无法理解，照样写出垃圾代码出来害人。</p>
<p>现在好了，长篇大论落在纸上了，说的时候听不懂，回去总可以翻文章慢慢理解了吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://casatwy.com/tiao-chu-mian-xiang-dui-xiang-si-xiang-san-feng-zhuang.html">reference</a></p>
<h2 id="跳出面向对象思想(三)_封装">跳出面向对象思想(三) 封装</h2><h3 id="简述">简述</h3><p>我认为”封装”的概念在面向对象思想中是最基础的概念，它实质上是通过将相关的一堆函数和一堆对象放在一起，对外有函数作为操作通道，对内则以变量作为操作原料。只留给外部程序员操作方式，而不暴露具体执行细节。大部分书举的典型例子就是汽车和灯泡的例子：你不需要知道不同车子的发动机原理，只要踩油门就可以跑；你不需要知道你的灯泡是那种灯泡，打开开关就会亮。我们都会很直觉地认为这种做法非常棒，是吧？</p>
<p>但是有的时候还是会觉得有哪些地方不对劲，使用面向对象语言的时候，我隐约觉得封装也许并没有我们直觉中认为的那么好，也就是说，面向对象其实并没有我们直觉中的那么好，虽然它已经流行了很多很多年。</p>
<h3 id="1-_将数据结构和函数放在一起是否真的合理？">1. 将数据结构和函数放在一起是否真的合理？</h3><p>函数就是做事情的，它们有输入，有执行逻辑，有输出。 数据结构就是用来表达数据的，要么作为输入，要么作为输出。</p>
<p>两者本质上是属于完全不同的东西，面向对象思想将他们放到一起，使得函数的作用被限制在某一个区域里，这样做虽然能够很好地将操作归类，但是这种归类方法是根据”作用领域”来归类的，在现实世界中可以，但在程序的世界中，有些不妥。</p>
<p>不妥的理由有如下几个：</p>
<blockquote>
<p>在并行计算时，由于执行部分和数据部分被绑定在一起，这就使得这种方案制约了并行程度。在为了更好地实现并行的时候，业界的工程师们发现了一个新的思路：函数式编程。将函数作为数据来使用，这样就能保证执行的功能在时序上的正确性了。但你不觉得，只要把数据表达和执行部分分开，形成流水线，这不就能够非常方便地将并行数提高了么？</p>
</blockquote>
<p>我来举个例子： 在数据和函数没有分开时，程序的执行流程是这样：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.<span class="function"><span class="title">function1</span><span class="params">()</span></span> -&gt; A.<span class="function"><span class="title">function2</span><span class="params">()</span></span> -&gt; A.<span class="function"><span class="title">function3</span><span class="params">()</span></span>     最后得到经过处理的A</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Framework" scheme="http://ytlvy.com/tags/Framework/"/>
    
      <category term="Framework" scheme="http://ytlvy.com/categories/Framework/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jump out of OOP -- Polymorphic]]></title>
    <link href="http://ytlvy.com/2015/08/04/jump-out-of-OOP-Polymorphic/"/>
    <id>http://ytlvy.com/2015/08/04/jump-out-of-OOP-Polymorphic/</id>
    <published>2015-08-04T13:17:31.000Z</published>
    <updated>2015-08-04T13:18:16.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://casatwy.com/tiao-chu-mian-xiang-dui-xiang-si-xiang-er-duo-tai.html" target="_blank" rel="external">reference</a></p>
<h2 id="跳出面向对象思想(二)_多态">跳出面向对象思想(二) 多态</h2><h3 id="简述">简述</h3><p>多态一般都要跟继承结合起来说，其本质是子类通过覆盖或重载（在下文里我会多次用到覆盖或重载，我打算把它简化成覆重，意思到就好，不要太纠结这种名词。）父类的方法，来使得对同一类对象同一方法的调用产生不同的结果。这里需要辨析的地方在：同一类对象指的是继承层级再上一层的对象，更加泛化。</p>
<p>举个例子：<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Animal</span> -&gt; Cat</span><br><span class="line"><span class="keyword">Animal</span> -&gt; Dog</span><br><span class="line"></span><br><span class="line"><span class="keyword">Animal</span>.speak()  // I'm an <span class="keyword">Animal</span></span><br><span class="line">Cat.speak()     // I'm a Cat</span><br><span class="line">Dog.speak()     // I'm a Dog</span><br></pre></td></tr></table></figure></p>
<p>此处Cat和Dog虽然不是同一种对象，但它们算是同一类对象，因为他们的父类都是Animal。种和类的表达可能不是很对，其实我也不知道谁更大一点，在文章中我打算用这样的符号来表示两者区别：^和^^</p>
<a id="more"></a>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">^ 表示他们是同一类</span><br><span class="line">^^ 表示他们同种同类</span><br><span class="line"></span><br><span class="line"><span class="keyword">Animal</span> -&gt; Cat</span><br><span class="line"><span class="keyword">Animal</span> -&gt; Dog</span><br><span class="line"></span><br><span class="line">Cat kitty, kate</span><br><span class="line">Dog lucky, lucy</span><br><span class="line"></span><br><span class="line">我们可以这么说：</span><br><span class="line"></span><br><span class="line">    kitty ^^ kate       同种同类，他们都是猫</span><br><span class="line">    kitty ^ lucy        同类不同种，他们都是<span class="keyword">Animal</span></span><br><span class="line">    kitty !^^ lucy      因为kitty是猫，lucy是狗</span><br><span class="line">    kitty ^ kate        他们当然同种啦，都是<span class="keyword">Animal</span></span><br></pre></td></tr></table></figure>
<p>应该算是能够描述清楚了吧？嗯，我们开始了。</p>
<h3 id="多态">多态</h3><p>一般来说我们采用多态的场景还是很多的，有些在设计的时候就是用于继承的父类，希望子类覆盖自己的某些方法，然后才能够使程序正常运行下去。比如：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BaseController需要它的子类去覆盖loadView等方法来执行view的显示逻辑</span><br><span class="line"></span><span class="keyword">BaseApiManager需要它的子类去覆盖methodName等方法来执行具体的API请求</span></span><br></pre></td></tr></table></figure>
<p>以上是我列举的应用多态的几个场景，在基于上面提到的需求，以及站在代码观感的立场，我们在实际采用多态的时候会有下面四种情况：</p>
<ul>
<li>父类有部分public的方法是不需要，也不允许子类覆重</li>
<li>父类有一些特别的方法是必须要子类去覆重的，在父类的方法其实是个空方法</li>
<li>父类有一些方法是可选覆重的，一旦覆重，则以子类为准</li>
<li>父类有一些方法即便被覆重，父类原方法还是要执行的</li>
</ul>
<p>这四种情况在大多数支持多态的语言里面都没有做很好的原生限制，在程序规模逐渐变大的时候，会给维护代码的程序员带来各种各样的坑。</p>
<blockquote>
<p>父类有部分public的方法是不需要，也不允许子类覆重</p>
</blockquote>
<p>对于客户程序员来说，他们是有动机去覆重那些不需要覆重的方法的，比如需要在某个方法调用的时候做UserTrack，或者希望在方法调用之前做一些额外的事情，但是又找不到外面应该在哪儿做，于是就索性覆重一个了。这样做的缺点在于<code>使得一个对象引入了原本不属于它的业务逻辑</code>。如果在引入的这些额外逻辑中又对其他模块产生依赖，那么这个对象在将来的代码复用中就会面临一个艰难的选择：</p>
<ul>
<li>是把这些不必要的逻辑删干净然后移过去？</li>
<li>还是所以把依赖连带着这个对象一起copy过去？</li>
</ul>
<p>前者太累，后者太蠢。</p>
<p>如果是要针对原来的对象进行功能拓展，但拓展的时候发现是需要针对<code>原本不允许覆重</code>的函数进行操作，那么这时候就有理由怀疑父类当初是不是没有设计好了。</p>
<blockquote>
<p>父类有一些特别的方法是必须要子类去覆重的，在父类的方法其实是个空方法</p>
</blockquote>
<p>这非常常见，由于逻辑的主要代码在父类中，若要跑完整个逻辑，则需要调用一些特定的方法来基于不同的子类获得不同的数据，这个特定的方法最终交由子类通过覆重来实现。如果不在父类里面写好这个方法吧，父类中的代码在执行逻辑的时候就调用不到。如果写了吧，一个空函数放在那儿十分难看。</p>
<p>也有的时候客户程序员会不知道在派生之后需要覆重某个方法才能完成完整逻辑，因为空函数在那儿不会导致warning或error，只有在发现程序运行结果不对的时候，才会感觉哪儿有错。如果这时候程序员发现原来是有个方法没覆重，一定会拍桌子骂娘。</p>
<p>总结一下，其实就是代码不好看，以及有可能忘记覆重。</p>
<blockquote>
<p>父类有一些方法是可选覆重的，一旦覆重，则以子类为准</p>
</blockquote>
<p>这是大多数面向对象语言默认的行为。设计可选覆重的动机其中有一个就是可能要做拦截器，在每个父类方法调用时，先调一个willDoSomething()，然后调用完了再调一个didFinishedSomething()，由子类根据具体情况进行覆重。</p>
<p>一般来说这类情况如果正常应用的话，不会有什么问题，就算有问题，也是前面提到的<code>容易使得一个对象引入原本不属于它的业务逻辑</code>。</p>
<blockquote>
<p>父类有一些方法即便被覆重，父类原方法还是要执行的</p>
</blockquote>
<p>这个是经典的坑，尤其是交付给客户程序员的时候是以链接库的模式交付的。父类的方法是放在覆重函数的第一句调用呢还是放在最后一句调用？这是个值得深思的问题。更有甚者索性就直接忘记调用了，各种傻傻分不清楚。</p>
<h3 id="解决方案">解决方案</h3><p>面向接口编程（Interface Oriented Programming, IOP）是解决这类问题比较好的一种思路。下面我给大家看看应该如何使用IOP来解决上面四种情况的困境:</p>
<p>(示例里面有些表达的约定，可以在这里看完整的上下文规范。)<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&lt;ManagerInterface&gt;</span> : APIName()                我们先定义一个ManagerInterface接口，这个接口里面含有原本需要被覆重的方法。</span><br><span class="line"><span class="variable">&lt;Interceptor&gt;</span> : willRun(), didRun()         我们再定义一个Interceptor的接口，它用来做拦截器。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BaseManager.child<span class="variable">&lt;ManagerInterface&gt;</span>         在BaseController里面添加一个property，叫做child，这就要求这个child必须要满足<span class="variable">&lt;ManagerInterface&gt;</span><span class="variable">&lt;/ManagerInterface&gt;</span>这个接口，但是BaseManager不需要满足<span class="variable">&lt;ManagerInterface&gt;</span>这个接口。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BaseManager.init() &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="literal">self</span>.child = <span class="literal">self</span>                       在init的时候把child设置成自己</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果语言支持反射，那么我们可以这么写：</span></span><br><span class="line">    if <span class="literal">self</span>.child implemented <span class="variable">&lt;ManagerInterface&gt;</span> &#123;</span><br><span class="line">        <span class="literal">self</span>.child = <span class="literal">self</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 如上的写法就能够保证我们的子类能够基于这些接口有对应的实现</span></span><br><span class="line"></span><br><span class="line">    <span class="literal">self</span>.interceptor = <span class="literal">self</span>                 <span class="comment"># interceptor可以是自己，也可以在初始化的时候设为别的对象，这个都可以根据需求不同而决定。</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BaseManager.run() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="literal">self</span>.interceptor.willRun()</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    apiName = <span class="literal">self</span>.child.APIName()          <span class="comment"># 原本是self.APIName(),然后这个方法是需要子类覆重的，现在可以改为self.child.APIName()了，就不需要覆重了。</span></span><br><span class="line">    request with apiName</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="literal">self</span>.interceptor.didRun()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过引入这样面向接口编程的做法，就能相对好地解决上面提到的困境，下面我来解释一下是如何解决困境的：</p>
<p>1) 父类有部分public的方法是不需要，也不允许子类覆重</p>
<p>由于子类必须要遵从<code>&lt;ManagerInterface&gt;</code>，架构师可以跟客户程序员约定<code>所有的public方法在一般情况下都是不需要覆重的</code>。除非特殊需要，则可以覆重，其他情况都通过实现接口中定义的方法解决。由于这是接口方法，所以<code>即便引入了原本不需要的逻辑，也能很容易将其剥离</code>。</p>
<p>2) 父类有一些特别的方法是必须要子类去覆重的，在父类的方法其实是个空方法</p>
<p>因为引入了<code>child</code>，父类不再需要摆一个空方法在那儿了，直接从<code>child</code>调用即可，因为child是实现了对应接口的，所以可以放心调用。空方法就消灭了。</p>
<p>3) 父类有一些方法是可选覆重的，一旦覆重，则以子类为准</p>
<p>我们可以通过在接口中设置哪些方法是必须要实现，哪些方法是可选实现的来处理对应的问题。这本身倒不是缺陷，正是多态希望的样子。</p>
<p>4) 父类有一些方法即便被覆重，父类原方法还是要执行的</p>
<p>由于我们通过接口规避了多态，那么这些其实是可以通过在接口中定义可选方法来实现的，由父类方法调用child的可选方法，调用时机就可以由父类决定。这两个方法不必重名，因此也不存在多态时，不能分辨调用时机或是否需要调用父类方法的情况。</p>
<hr>
<p>总结一下，通过IOP，我们做好了两件事：</p>
<ol>
<li>将子类与可能被子类引入的不相关逻辑剥离开来，提高了子类的可重用性，降低了迁移时可能的耦合。</li>
<li>接口实际上是子类头上的金箍，规范了子类哪些必须实现，哪些可选实现。那些不在接口定义的方法列表里的父类方法，事实上就是不建议覆重的方法。</li>
</ol>
<h3 id="什么时候用多态">什么时候用多态</h3><p>由于多态和继承紧密地结合在了一起，我们假设父类是架构师去设计，子类由客户程序员去实现，那么这个问题实际上是这样的两个问题：</p>
<ol>
<li>作为架构师，我何时要为多态提供接入点？</li>
<li>作为客户程序员，我何时要去覆重父类方法？</li>
</ol>
<p>这本质上需要程序员针对对象建立一个<code>角色</code>的概念。</p>
<p>举个例子：当一个对象的主要业务功能是搜索，那么它在整个程序里面扮演的角色是搜索者的角色。在基于搜索派生出的业务中，会做一些跟搜索无关的事情，比如搜索后进行人工加权重排列表，搜索前进行关键词分词（假设分词方案根据不同的派生类而不同）。那么这时候如果采用多态的方案，就是由子类覆重父类关于重排列表的方法，覆重分词方法。如果在编写子类的程序员忘记这些必要的覆重或者覆重了不应该覆重的方法，就会进入上面提到的四个困境。所以这时候需要提供一套接口，规范子类去做覆重，从而避免之前提到的四种困境：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Search : &#123; <span class="built_in">search</span><span class="params">()</span>, split<span class="params">()</span>, resort<span class="params">()</span>&#125;</span><br><span class="line"></span><br><span class="line">采用多态的方案：</span><br><span class="line">Search -&gt; ClothSearch : &#123; [ Search ], @split<span class="params">()</span>, @resort<span class="params">()</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span><span class="params">()</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    self.split<span class="params">()</span>    <span class="built_in">#</span> 如果子类没有覆重这个方法而父类提供的只是空方法，这里就很容易出问题。如果子类在覆重的时候引入了其他不相关逻辑，那么这个对象就显得不够单纯，角色复杂了。</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    self.resort<span class="params">()</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">采用IOP的方案：</span><br><span class="line">&lt;SearchManager&gt; : &#123;split<span class="params">()</span>, resort<span class="params">()</span>&#125;</span><br><span class="line">Search&lt;SearchManager&gt; : &#123; <span class="built_in">search</span><span class="params">()</span>, assistant&lt;SearchManager&gt; &#125;      <span class="built_in">#</span> 也可以是这样：Search : &#123; <span class="built_in">search</span><span class="params">()</span>, assistant&lt;SearchManager&gt; &#125;，这么做的话，则要求子类必须实现&lt;SearchManager&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span><span class="params">()</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    self.assistant.split<span class="params">()</span>  <span class="built_in">#</span> self.assistant可以就是self，也可以由初始化时候指定为其他对象，将来进行业务剥离的时候，只要将assistant里面的方法剥离或者讲assistant在初始化时指定为其他对象也好。</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    self.assistant.resort<span class="params">()</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Search -&gt; ClothSearch&lt;SearchManager&gt; : &#123; [ Search ], split<span class="params">()</span>, resort<span class="params">()</span> &#125;    <span class="built_in">#</span> 由于子类被接口要求必须实现split<span class="params">()</span>和resort<span class="params">()</span>方法，因而规避了前文提到的风险，在剥离业务的时候也能非常方便。</span><br><span class="line"></span><br><span class="line">外面使用对象时：ClothSearch.<span class="built_in">search</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>如果示例中不同的子类对于search()方法有不同的实现，那么这个时候就适用多态。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Search : &#123; <span class="built_in">search</span><span class="params">()</span> &#125;</span><br><span class="line"></span><br><span class="line">ClothSearch : &#123; [Search], @<span class="built_in">search</span><span class="params">()</span> &#125;</span><br><span class="line"></span><br><span class="line">此时适用多态，外面使用对象时：ClothSearch.<span class="built_in">search</span><span class="params">()</span></span><br></pre></td></tr></table></figure></p>
<p>总结是否决定应当使用多态的两个要素：</p>
<ol>
<li>如果引入多态之后导致对象角色不够单纯，那就不应当引入多态，如果引入多态之后依旧是单纯角色，那就可以引入多态</li>
<li>如果要覆重的方法是角色业务的其中一个组成部分，例如split()和resort()，那么就最好不要用多态的方案，用IOP，因为在外界调用的时候其实并不需要通过多态来满足定制化的需求。</li>
</ol>
<p>其实这是一个<code>角色</code>问题，越单纯的角色就越容易维护。还有一个就是区分被覆重的方法是否需要被外界调用的问题。好了，现在我们回到这一节前面提出的两个问题：何时引入接入点和何时采用覆重。针对第一个问题架构师一定要分清楚角色，在保证角色单纯的情况下可以引入多态。另外一点要考虑<code>被覆重的方法是否需要被外界使用</code>，还是只是父类运行时需要子类通过覆重提供中间数据的。如果是<code>只要子类通过覆重提供中间数据的，一律应当采用IOP而不是多态</code>。</p>
<hr>
<p>针对第二个问题，在必须要覆重的场合下就采取覆重的方案好了，主要是可覆重可不覆重的情况下，客户程序员主要还是要遵守：</p>
<ol>
<li>覆重的方法本身是跟逻辑密切相关的，不要在覆重方法里做跟这个方法本意不相关的事情</li>
<li>如果要覆重一系列的方法，那么就要考虑角色问题和外界是否需要调用的问题，这些方法是不是这个对象的角色应当承担的任务</li>
</ol>
<p>比如说不要在一个原本要跑步的函数里面去做吃饭的事情，如果真的要吃饭，父类又没有，实在不行的时候，就<code>需要在覆重的方法里面启用IOP</code>，在子类里面弥补架构师的设计缺陷。把这个不属于跑步的事情IOP出去，负责实现对应接口的可以是self，也可以是别人。只要不是强耦合地去覆重，这样在代码迁移的时候，由于IOP的存在，使得代码接收方也可以接受并实现对应的interface，从而不影响整体功能，又能提供迁移的灵活性。</p>
<h3 id="总结">总结</h3><p>多态在面向对象程序中的应用相当广泛，只要有继承的地方，或多或少都会用到多态。然而多态比起继承来，更容易被不明不白地使用，一切看起来都那么顺其自然。在客户程序员这边，一般是只要多态是可行方案的一种，到最后大部分都会采用多态的方案来解决问题。</p>
<p>然而多态正如它名字中所暗示的，它有非常大的潜在可能引入不属于对象初衷的逻辑，巨大的灵活性也导致客户程序员在面对问题的时候不太愿意采用其他相对更优的方案，比如IOP。在决定是否采用多态时，我们要有一个清晰的角色概念，做好角色细分，不要角色混乱。该是拦截器的，就给他制定一个拦截器接口，由另一个对象（逻辑上的另一个对象，当然也可以是自己）去实现接口里的方法集。不要让一个对象在逻辑上既是拦截器又是业务模块。这样才方便未来的维护。另外也要注意被覆重方法的作用，如果只是单纯为了提供父类所需要的中间数据的，一律都用IOP，这是比直接采用多态更优的方案。</p>
<p>IOP能够带来的好处当然不止文中写到的这些，它在其他场合也有非常好的应用，它最主要的好处就在于分离了定义和实现，并且能够带来更高的灵活性，灵活到既可以对语言过高的自由度有一个限制，也可以灵活到允许同一接口的不同实现能够合理地组合。在架构设计方面是个非常重要的思想。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://casatwy.com/tiao-chu-mian-xiang-dui-xiang-si-xiang-er-duo-tai.html">reference</a></p>
<h2 id="跳出面向对象思想(二)_多态">跳出面向对象思想(二) 多态</h2><h3 id="简述">简述</h3><p>多态一般都要跟继承结合起来说，其本质是子类通过覆盖或重载（在下文里我会多次用到覆盖或重载，我打算把它简化成覆重，意思到就好，不要太纠结这种名词。）父类的方法，来使得对同一类对象同一方法的调用产生不同的结果。这里需要辨析的地方在：同一类对象指的是继承层级再上一层的对象，更加泛化。</p>
<p>举个例子：<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Animal</span> -&gt; Cat</span><br><span class="line"><span class="keyword">Animal</span> -&gt; Dog</span><br><span class="line"></span><br><span class="line"><span class="keyword">Animal</span>.speak()  // I'm an <span class="keyword">Animal</span></span><br><span class="line">Cat.speak()     // I'm a Cat</span><br><span class="line">Dog.speak()     // I'm a Dog</span><br></pre></td></tr></table></figure></p>
<p>此处Cat和Dog虽然不是同一种对象，但它们算是同一类对象，因为他们的父类都是Animal。种和类的表达可能不是很对，其实我也不知道谁更大一点，在文章中我打算用这样的符号来表示两者区别：^和^^</p>]]>
    
    </summary>
    
      <category term="Framework" scheme="http://ytlvy.com/tags/Framework/"/>
    
      <category term="Framework" scheme="http://ytlvy.com/categories/Framework/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jump out of OOP -- Inherit]]></title>
    <link href="http://ytlvy.com/2015/08/04/jump-out-of-OOP-Inherit/"/>
    <id>http://ytlvy.com/2015/08/04/jump-out-of-OOP-Inherit/</id>
    <published>2015-08-04T13:16:01.000Z</published>
    <updated>2015-08-04T13:17:04.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://casatwy.com/tiao-chu-mian-xiang-dui-xiang-si-xiang-yi-ji-cheng.html" target="_blank" rel="external">reference</a></p>
<h2 id="跳出面向对象思想(一)_继承">跳出面向对象思想(一) 继承</h2><h3 id="简述">简述</h3><p>这一系列文章中谈谈面向对象思想的几个部分，并且给出对应的解决方案，这些解决方案有些是用面向过程的思路解决的，有些也还是停留在面向对象中。到最后我会给大家一个比较，然后给出结论。</p>
<h4 id="上下文规范">上下文规范</h4><p>在进一步地讨论这些概念之前，我需要跟大家达成一个表达上的共识，我会采用下面的语法来表达对象相关的信息<br><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">所有的大写字母都是类或对象，小写字母表示属性或方法。</span><br><span class="line"></span><br><span class="line"><span class="type">FOO</span>:&#123; isLoading, _data, render<span class="literal">()</span>, _switch<span class="literal">()</span> &#125;   这表示一个<span class="type">FOO</span>对象，isLoading、_data是它的属性，render<span class="literal">()</span>、_switch<span class="literal">()</span>是它的方法，加下划线表示私有。</span><br><span class="line"></span><br><span class="line"><span class="type">A</span> -&gt; <span class="type">B</span>                                          这表示从<span class="type">A</span>派生出了<span class="type">B</span>，<span class="type">A</span>是父类。</span><br><span class="line"></span><br><span class="line"><span class="type">A</span> -&gt; <span class="type">B</span>:&#123; [a, b, c<span class="literal">()</span>, d<span class="literal">()</span>], e, f<span class="literal">()</span> &#125;             <span class="literal">[]</span>里面是父类的东西，e、f<span class="literal">()</span>是派生类的东西</span><br><span class="line"></span><br><span class="line"><span class="type">B</span>:&#123; [ <span class="type">A</span> ], e, f<span class="literal">()</span> &#125;                             省略了对父类的描述，用类名<span class="type">A</span>代替，其他同上</span><br><span class="line"></span><br><span class="line"><span class="type">B</span>:&#123; [ <span class="type">A</span> ], e, f<span class="literal">()</span>, @c<span class="literal">()</span> &#125;                       省略了对父类的描述，函数前加@表示重载了父类的方法。</span><br><span class="line"></span><br><span class="line"><span class="type">B</span>:&#123; [ <span class="type">A</span>,<span class="type">D</span> ], e, f<span class="literal">()</span> &#125;                           多继承，<span class="type">B</span>继承了<span class="type">A</span>和<span class="type">D</span></span><br><span class="line"></span><br><span class="line"><span class="type">B</span>&lt;protocol&gt;                                     符合某个protocol接口的对象。</span><br><span class="line"></span><br><span class="line">&lt;protocol&gt;:&#123;foo<span class="literal">()</span>, bar&#125;                         protocol这个接口中包含foo<span class="literal">()</span>这个方法，bar这个属性。</span><br><span class="line"></span><br><span class="line">foo(<span class="type">A</span>, <span class="built_in">int</span>)                                     foo这个函数，接收<span class="type">A</span>类和<span class="built_in">int</span>类型作为参数。</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="来，我们谈谈对象">来，我们谈谈对象</h3><p>面向对象思想三大支柱：继承、封装、多态。这篇文章说的是继承。当然面向对象和面向过程都会有好有坏，但是做决定的时候，更多地还是去权衡值得不值得放弃。关于这样的立场问题，我都会给出非常明确的倾向，不会跟你们打太极。<br>如果说这个也好那个也好，那还发表毛个观点，那叫没有观点。</p>
<h3 id="继承">继承</h3><p>继承从代码复用的角度来说，特别好用，也特别容易被滥用和被错用。不恰当地使用继承导致的最大的一个缺陷特征就是高耦合。<br>在这里我要补充一点，耦合是一个特征，虽然大部分情况是缺陷的特征，但是当耦合成为需求的时候，耦合就不是缺陷了。耦合成为需求的例子在后面会提到。<br>我们来看下面这个场景：</p>
<p>有一天，产品经理Yuki说:</p>
<blockquote>
<p>我们不光首页要有一个搜索框，在进去的这个页面，也要有一个搜索框，只不过这个搜索框要多一些功能，它是可以即时给用户搜索提示的。</p>
</blockquote>
<p>Casa接到这个任务，他研究了一下代码，说:OK，没问题~<br>Casa知道代码里已经有了一个现成的搜索框，Casa立刻从HOME_SEARCH_BAR派生出PAGE_SEARCH_BAR<br>嗯，目前事情进展到这里还不错：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">HOME_SEARCH_BAR</span>:&#123;<span class="tag">textField</span>, <span class="tag">search</span>(), <span class="tag">init</span>()&#125;</span><br><span class="line"><span class="tag">PAGE_SEARCH_BAR</span>:&#123; <span class="attr_selector">[ HOME_SEARCH_BAR ]</span>, <span class="tag">overlay</span>, <span class="tag">prompt</span>() &#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>过了几天，产品经理Yuki要求:</p>
<blockquote>
<p>用户收藏的东西太多了，我们的app需要有一个本地搜索的功能。</p>
</blockquote>
<p>Casa轻松通过方法覆盖摆平了这事儿:<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">HOME_SEARCH_BAR</span>:&#123;<span class="tag">textField</span>, <span class="tag">search</span>()&#125;</span><br><span class="line"><span class="tag">PAGE_SEARCH_BAR</span>:&#123; <span class="attr_selector">[ HOME_SEARCH_BAR ]</span>, <span class="tag">overlay</span>, <span class="tag">prompt</span>() &#125;</span><br><span class="line"><span class="tag">LOCAL_SEARCH_BAR</span>:&#123; <span class="attr_selector">[ HOME_SEARCH_BAR ]</span>, @<span class="tag">search</span>() &#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>app上线一段时间之后，UED不知哪根筋搭错了，决定要修改搜索框的UI，UED跟Casa说:</p>
<blockquote>
<p>把HOME_SEARCH_BAR的样式改成这样吧，里面PAGE_SEARCH_BAR还是老样子就OK。</p>
</blockquote>
<p>Casa表示这个看似简单的修改其实很蛋碎，<code>HOME_SEARCH_BAR</code>的样式一改，<code>PAGE_SEARCH_BAR</code>和<code>LOCAL_SEARCH_BAR</code>都会改变，怎么办呢？ 与其每个手工修一遍，Casa不得已只能给<code>HOME_SEARCH_BAR</code>添加了一个函数：<code>initWithStyle()</code></p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">HOME_SEARCH_BAR</span>:&#123; <span class="tag">textField</span>, <span class="tag">search</span>(), <span class="tag">init</span>(), <span class="tag">initWithStyle</span>() &#125;</span><br><span class="line"><span class="tag">PAGE_SEARCH_BAR</span>:&#123; <span class="attr_selector">[ HOME_SEARCH_BAR ]</span>, <span class="tag">overlay</span>, <span class="tag">prompt</span>() &#125;</span><br><span class="line"><span class="tag">LOCAL_SEARCH_BAR</span>:&#123; <span class="attr_selector">[ HOME_SEARCH_BAR ]</span>, @<span class="tag">search</span>() &#125;</span><br></pre></td></tr></table></figure>
<p>于是代码里面就出现了各种init()和initWithStyle()混用的情况。</p>
<blockquote>
<p>无所谓了，先把需求应付过去再说。</p>
</blockquote>
<p>Casa这么想。</p>
<hr>
<p>有一天，另外一个team的leader来对Casa抱怨:</p>
<blockquote>
<p>搞什么玩意儿？为毛我要把LOCAL_SEARCH_BAR独立出来还特么连带着把那么多文件都弄出来？我就只是想要个本地搜索的功能而已！！</p>
</blockquote>
<p>这是因为<code>LOCAL_SEARCH_BA</code>R依赖于它的父类<code>HOME_SEARCH_BAR</code>,然而<code>HOME_SEARCH_BAR</code>本身也带着API相关的对象，同时还有数据解析的对象。 也就是说，要想把<code>LOCAL_SEARCH_BAR</code>移植给另外一个TEAM，拔出萝卜带出泥，差不多整个Networking框架都要移植过去。 嗯，Casa又要为了解耦开始一个不眠之夜了～</p>
<hr>
<p>以上是典型的错误使用继承的案例，虽然继承是代码复用的一种方案，但是使用继承仍然是需要好好甄别代码复用的方式的，不是所有场景的代码复用都适用于继承。</p>
<blockquote>
<p>继承是紧耦合的一种模式，主要的体现就在于牵一发动全身。</p>
</blockquote>
<ul>
<li>第一种类型的问题是改了一处，到处都要改，但解决方案还算方便，多添加一个特定的函数(initWithStyle())就好了。只是代码里面难看一点。</li>
<li>第二种类型的问题是代码复用的时候，要跟着把父类以及父类所有的相关依赖也复制过去，高耦合在复用的时候造成了冗余。</li>
</ul>
<hr>
<p>对于这样的问题，业界其实早就给出了解决方案：用组合替代继承。将Textfield和search模块拆开，然后通过定义好的接口进行交互，一般来说可以选择Delegate模式来交互。</p>
<p>解决方案：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;search_protocol&gt;:<span class="list">&#123;search()&#125;</span></span><br><span class="line"></span><br><span class="line">SEARCH_LOGIC&lt;search_protocol&gt;</span><br><span class="line"></span><br><span class="line">SEARCH_BAR:<span class="list">&#123;textField, SEARCH_LOGIC&lt;search_protocol&gt;&#125;</span></span><br><span class="line"></span><br><span class="line">HOME_SEARCH_BAR:<span class="list">&#123;SearchBar1, SearchLogic1&#125;</span></span><br><span class="line">PAGE_SEARCH_BAR:<span class="list">&#123;SearchBar2, SearchLogic1&#125;</span></span><br><span class="line">LOCAL_SEARCH_BAR:<span class="list">&#123;SearchBar2, SearchLogic2&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>这样一来，搜索框和搜索逻辑分别形成了两个不同的组件，分别在<code>HOME_SEARCH_BAR</code>, <code>PAGE_SEARCH_BAR</code>, <code>LOCAL_SEARCH_BAR</code>中以不同的形态组合而成。 <code>textField</code>和<code>SEARCH_LOGIC&lt;search_protocol&gt;</code>之间通过delegate的模式进行数据交互。 这样就解决了上面提到的两种类型的问题。 大部分我们通过代码复用来选择继承的情况，其实都是变成组合比较好。 因此我在团队中一直在推动使用组合来代替继承的方案。 那么什么时候继承才有用呢？</p>
<p>纠结了一下，貌似实在是没什么地方非要用继承不可的。但事实上使用继承，我们得要分清楚层次，使用继承其实是如何给一类对象划分层次的问题。在正确的继承方式中，父类应当扮演的是底层的角色，子类是上层的业务。举两个例子：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">Object </span>-&gt; <span class="constant">Model</span></span><br><span class="line"><span class="constant">Object </span>-&gt; <span class="constant">View</span></span><br><span class="line"><span class="constant">Object </span>-&gt; <span class="constant">Controller</span></span><br><span class="line"></span><br><span class="line"><span class="constant">ApiManager </span>-&gt; <span class="constant">DetailManager</span></span><br><span class="line"><span class="constant">ApiManager </span>-&gt; <span class="constant">ListManager</span></span><br><span class="line"><span class="constant">ApiManager </span>-&gt; <span class="constant">CityManager</span></span><br></pre></td></tr></table></figure>
<hr>
<p>这里是有非常明确的层次关系的，我在这里也顺便提一下使用继承的3大要点：</p>
<blockquote>
<p>父类只是给子类提供服务，并不涉及子类的业务逻辑</p>
</blockquote>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>并不影响Model, View, Controller的执行逻辑和业务  </span><br><span class="line">    <span class="built_in">Object</span>为子类提供基础服务，例如内存计数等</span><br><span class="line"></span><br><span class="line">    ApiManager并不影响其他的Manager  </span><br><span class="line">    ApiManager只是给派生的Manager提供服务而已,ApiManager做的只会是份内的是，对于子类做的事情不参与。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>层级关系明显，功能划分清晰，父类和子类各做各的。</p>
</blockquote>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>并不参与MVC的管理中，那些都只是各自派生类自己要处理的事情</span><br><span class="line"></span><br><span class="line">DetailManager, ListManager, CityManager都只是处理各自业务的对象  </span><br><span class="line">ApiManager并不应该涉足对应的业务。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>父类的所有变化，都需要在子类中体现，也就是说此时耦合已经成为需求</p>
</blockquote>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>对类的描述，对内存引用的计数方式等，都是普遍影响派生类的。  </span><br><span class="line">ApiManager中对于网络请求的发起，网络状态的判断，是所有派生类都需要的。  </span><br><span class="line">此时，牵一发动全身就已经成为了需求，是适用继承的</span><br></pre></td></tr></table></figure>
<hr>
<p>此时我们回过头来看为什么<code>HOME_SEARCH_BAR</code>, <code>PAGE_SEARCH_BAR</code>, <code>LOCAL_SEARCH_BAR</code>采用继承的方案是不恰当的：</p>
<p>1) 他们的父类是HOME_SEARCH_BAR，父类不只提供了服务，也在一定程度上影响了子类的业务逻辑。派生出的子类也是为了要做搜索，虽然搜索的逻辑不同，但是互相涉及到搜索这一块业务了。</p>
<p>2) 子类做搜索，父类也做搜索，虽然处理逻辑不同，但是这是同一个业务，与父类在业务上的联系密切。在层级关系上，HOME_SEARCH_BAR和其派生出的LOCAL_SEARCH_BAR, PAGE_SEARCH_BAR其实是并列关系，并不是上下层级关系。</p>
<p>3) 由于这里所谓的父类和子类其实是并列关系而不是父子关系，且并没有需要耦合的需求，相反，每个派生子类其实都不希望跟父类有耦合，此时耦合不是需求，是缺陷。</p>
<hr>
<h3 id="总结">总结</h3><p>可见，代码复用也是分类别的，如果当初只是出于代码复用的目的而不区分类别和场景，就采用继承是不恰当的。我们应当考虑以上3点要素看是否符合，才能决定是否使用继承。就目前大多数的开发任务来看，继承出现的场景不多，主要还是代码复用的场景比较多，然而通过组合去进行代码复用显得要比继承麻烦一些，因为组合要求你有更强的抽象能力，继承则比较符合直觉。然而从未来可能产生的需求变化和维护成本来看，使用组合其实是很值得的。另外，<code>当你发现你的继承超过2层的时候，你就要好好考虑是否这个继承的方案</code>了，第三层继承正是滥用的开端。确定有必要之后，再进行更多层次的继承。</p>
<p>所以我的态度是：<code>万不得已不要用继承，优先考虑组合</code></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://casatwy.com/tiao-chu-mian-xiang-dui-xiang-si-xiang-yi-ji-cheng.html">reference</a></p>
<h2 id="跳出面向对象思想(一)_继承">跳出面向对象思想(一) 继承</h2><h3 id="简述">简述</h3><p>这一系列文章中谈谈面向对象思想的几个部分，并且给出对应的解决方案，这些解决方案有些是用面向过程的思路解决的，有些也还是停留在面向对象中。到最后我会给大家一个比较，然后给出结论。</p>
<h4 id="上下文规范">上下文规范</h4><p>在进一步地讨论这些概念之前，我需要跟大家达成一个表达上的共识，我会采用下面的语法来表达对象相关的信息<br><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">所有的大写字母都是类或对象，小写字母表示属性或方法。</span><br><span class="line"></span><br><span class="line"><span class="type">FOO</span>:&#123; isLoading, _data, render<span class="literal">()</span>, _switch<span class="literal">()</span> &#125;   这表示一个<span class="type">FOO</span>对象，isLoading、_data是它的属性，render<span class="literal">()</span>、_switch<span class="literal">()</span>是它的方法，加下划线表示私有。</span><br><span class="line"></span><br><span class="line"><span class="type">A</span> -&gt; <span class="type">B</span>                                          这表示从<span class="type">A</span>派生出了<span class="type">B</span>，<span class="type">A</span>是父类。</span><br><span class="line"></span><br><span class="line"><span class="type">A</span> -&gt; <span class="type">B</span>:&#123; [a, b, c<span class="literal">()</span>, d<span class="literal">()</span>], e, f<span class="literal">()</span> &#125;             <span class="literal">[]</span>里面是父类的东西，e、f<span class="literal">()</span>是派生类的东西</span><br><span class="line"></span><br><span class="line"><span class="type">B</span>:&#123; [ <span class="type">A</span> ], e, f<span class="literal">()</span> &#125;                             省略了对父类的描述，用类名<span class="type">A</span>代替，其他同上</span><br><span class="line"></span><br><span class="line"><span class="type">B</span>:&#123; [ <span class="type">A</span> ], e, f<span class="literal">()</span>, @c<span class="literal">()</span> &#125;                       省略了对父类的描述，函数前加@表示重载了父类的方法。</span><br><span class="line"></span><br><span class="line"><span class="type">B</span>:&#123; [ <span class="type">A</span>,<span class="type">D</span> ], e, f<span class="literal">()</span> &#125;                           多继承，<span class="type">B</span>继承了<span class="type">A</span>和<span class="type">D</span></span><br><span class="line"></span><br><span class="line"><span class="type">B</span>&lt;protocol&gt;                                     符合某个protocol接口的对象。</span><br><span class="line"></span><br><span class="line">&lt;protocol&gt;:&#123;foo<span class="literal">()</span>, bar&#125;                         protocol这个接口中包含foo<span class="literal">()</span>这个方法，bar这个属性。</span><br><span class="line"></span><br><span class="line">foo(<span class="type">A</span>, <span class="built_in">int</span>)                                     foo这个函数，接收<span class="type">A</span>类和<span class="built_in">int</span>类型作为参数。</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Framework" scheme="http://ytlvy.com/tags/Framework/"/>
    
      <category term="Framework" scheme="http://ytlvy.com/categories/Framework/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Chun notes]]></title>
    <link href="http://ytlvy.com/2015/07/28/Chun-notes/"/>
    <id>http://ytlvy.com/2015/07/28/Chun-notes/</id>
    <published>2015-07-28T13:42:26.000Z</published>
    <updated>2015-07-28T13:43:12.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://blog.callmewhy.com/2015/05/25/note-about-chun/" target="_blank" rel="external">转自</a></p>
<h2 id="Chun_阅读笔记_-_如何做一个图片缓存库">Chun 阅读笔记 - 如何做一个图片缓存库</h2><p><a href="https://github.com/yechunjun/Chun" target="_blank" rel="external">Chun</a> 是 <a href="http://chun.tips/" target="_blank" rel="external">叶纯俊</a> 在 Github 上开源的一个图片缓存库，基于 Swift 编写。学习 Swift 有一段时间了，记录一些阅读源码的一些收获。</p>
<h3 id="代码组织">代码组织</h3><p>Swift 中通过 <code>extension</code> 组织代码会让整个类更加清晰可读，尤其是对于 <code>UITableViewDataSource</code> 和 <code>UITableViewDelegate</code> 这种情况。在 Chun 这个项目中的 Demo 文件就是这样的：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UITableViewDataSource</span>, <span class="title">UITableViewDelegate</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>在 <code>viewDidLoad</code> 中，为了避免初始化代码过长导致难以阅读，可以通过内嵌函数将代码分段：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">loadTableView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loadTableView()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加属性">添加属性</h3><p>在给 <code>UIImageView</code> 加载图片的时候，我们最好可以在对象中存储它所要加载的 URL ，可以通过 <code>AssociatedObject</code> 来实现。在 Swift 中，可以用一个私有计算量来封装一下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="variable"><span class="keyword">var</span> imageURLForChun</span>: NSURL? &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> objc_getAssociatedObject(self, &amp;key) <span class="keyword">as</span>? NSURL</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> (url) &#123;</span><br><span class="line">        objc_setAssociatedObject(self, &amp;key, url, UInt(OBJC_ASSOCIATION_RETAIN_NONATOMIC))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样在调用的时候就和真实属性没什么区别了：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> imageURL <span class="subst">=</span> <span class="built_in">self</span><span class="built_in">.</span>imageURLForChun &#123;</span><br><span class="line">    <span class="attribute">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="weak_和_unowned">weak 和 unowned</h3><p>在避免循环强引用的时候，如果某些时候引用没有值，那就用 <code>weak</code> ，如果引用总是有值，则用 <code>unowned</code> 。</p>
<p>在 Chun 这个项目中，获取图片之后的回调里用的是 <code>weak</code> ，因为有可能图片加载完了但是 <code>UIImageView</code> 已经销毁了：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Chun.sharedInstance.fetchImageWithURL(url, complete: &#123; [<span class="link_label">weak self</span>](<span class="link_url">result: Result</span>) -&gt; Void in</span><br><span class="line"><span class="code">    ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>然后在查询本地缓存的时候，用的是 <code>unowned</code> ，因为这里的 <code>self</code> 是单例，永远不会销毁：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cache.diskImageExistsWithKey(key, completion: &#123; [<span class="link_label">unowned self</span>](<span class="link_url">exist: Bool, diskURL: NSURL?</span>) -&gt; Void in</span><br><span class="line"><span class="code">    ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="枚举的正确打开方式">枚举的正确打开方式</h3><p>使用枚举来表示返回结果是个不错的方案，在面向轨道编程 - Swift 中的异常处理中有过详细的探讨。在 Chun 中是这样使用的：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Result</span> &#123;</span></span><br><span class="line">    <span class="keyword">case</span> Success(<span class="string">image:</span> UIImage, <span class="string">fetchedImageURL:</span> NSURL)</span><br><span class="line">    <span class="keyword">case</span> Error(<span class="string">error:</span> NSError)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>加载图片完成之后的回调则是这样：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public func fetchImageWithURL(url: <span class="type">NSURL</span>, complete: (<span class="type">Result</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> key = cacheKeyForRemoteURL(url)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> image = cache.imageForMemeoryCacheWithKey(key) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="literal">result</span> = <span class="type">Result</span>.<span class="type">Success</span>(image: image, fetchedImageURL: url)</span><br><span class="line">        complete(<span class="literal">result</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="图片渲染">图片渲染</h3><p>直接从网上下载获取到的图片并不能直接使用，先解码成位图然后再渲染可以减少开销：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">func decodedImageWithImage(image: <span class="built_in">UIImage</span>) -&gt; <span class="built_in">UIImage</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> image<span class="variable">.images</span> != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> image</span><br><span class="line">    &#125;</span><br><span class="line">    let imageRef = image<span class="variable">.CGImage</span></span><br><span class="line">    let imageSize: <span class="built_in">CGSize</span> = <span class="built_in">CGSizeMake</span>(<span class="built_in">CGFloat</span>(<span class="built_in">CGImageGetWidth</span>(imageRef)), <span class="built_in">CGFloat</span>(<span class="built_in">CGImageGetHeight</span>(imageRef)))</span><br><span class="line">    let imageRect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, imageSize<span class="variable">.width</span>, imageSize<span class="variable">.height</span>)</span><br><span class="line">    let colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>()</span><br><span class="line"></span><br><span class="line">    let originalBitmapInfo = <span class="built_in">CGImageGetBitmapInfo</span>(imageRef)</span><br><span class="line">    let alphaInfo = <span class="built_in">CGImageGetAlphaInfo</span>(imageRef)</span><br><span class="line"></span><br><span class="line">    var bitmapInfo = originalBitmapInfo</span><br><span class="line">    <span class="keyword">switch</span> (alphaInfo) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="variable">.None</span>:</span><br><span class="line">        bitmapInfo &amp;= ~<span class="built_in">CGBitmapInfo</span><span class="variable">.AlphaInfoMask</span></span><br><span class="line">        bitmapInfo |= <span class="built_in">CGBitmapInfo</span>(<span class="built_in">CGImageAlphaInfo</span><span class="variable">.NoneSkipFirst</span><span class="variable">.rawValue</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="variable">.PremultipliedFirst</span>, <span class="variable">.PremultipliedLast</span>, <span class="variable">.NoneSkipFirst</span>, <span class="variable">.NoneSkipLast</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="variable">.Only</span>, <span class="variable">.Last</span>, <span class="variable">.First</span>:</span><br><span class="line">        <span class="keyword">return</span> image</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> let context = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">nil</span>, <span class="built_in">CGImageGetWidth</span>(imageRef), <span class="built_in">CGImageGetHeight</span>(imageRef), <span class="built_in">CGImageGetBitsPerComponent</span>(imageRef), <span class="number">0</span> , colorSpace, bitmapInfo) &#123;</span><br><span class="line">        <span class="built_in">CGContextDrawImage</span>(context, imageRect, imageRef)</span><br><span class="line">        let decompressedImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(context)</span><br><span class="line">        <span class="keyword">if</span> let decompressedImage = <span class="built_in">UIImage</span>(<span class="built_in">CGImage</span>: decompressedImageRef, scale: image<span class="variable">.scale</span>, orientation: image<span class="variable">.imageOrientation</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> decompressedImage</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> image</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> image</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="从_NSData判断图片类型">从 NSData判断图片类型</h3><p>在判断图片格式的时候，通过不同格式的第一个字节进行判断，在 <code>contentTypeForImageData(data: NSData) -&gt; String?</code> 方法里实现了获取 NSData 类型的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">contentTypeForImageData</span><span class="params">(data: NSData)</span></span> -&gt; <span class="type">String</span>? &#123;</span><br><span class="line">    <span class="keyword">var</span> value : <span class="type">Int16</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> data.length &gt;= <span class="built_in">sizeof</span>(<span class="type">Int16</span>) &#123;</span><br><span class="line">        data.getBytes(&amp;value, length:<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">switch</span> (value) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xff</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"image/jpeg"</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x89</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"image/png"</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x47</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"image/gif"</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x49</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"image/tiff"</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x4D</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"image/tiff"</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x52</span>:</span><br><span class="line">            <span class="keyword">if</span> (data.length &lt; <span class="number">12</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> temp = <span class="type">NSString</span>(data: data.subdataWithRange(<span class="type">NSMakeRange</span>(<span class="number">0</span>, <span class="number">12</span>)), encoding: <span class="type">NSASCIIStringEncoding</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp.hasPrefix(<span class="string">"RIFF"</span>) &amp;&amp; temp.hasSuffix(<span class="string">"WEBP"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"image/webp"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断的依据是不同图片格式的前几个字节都是特殊且唯一的，具体在 <a href="http://www.astro.keele.ac.uk/oldusers/rno/Computing/File_magic.html" target="_blank" rel="external">File magic numbers</a> 里有个比较完整的表，可以对照看下。比如 jpeg 的前四个字节都是 ff d8 ff e0 。</p>
<h3 id="Fetcher_的玩儿法">Fetcher 的玩儿法</h3><p>在获取图片的时候都是通过 <code>Fetcher</code> 获取，根据任务不同，区分是从服务器下载还是从本地加载。</p>
<p>首先是 <code>ImageFetcher</code> 这个大基类，封装了一些基本的属性和方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">lass <span class="type">ImageFetcher</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">CompeltionClosure</span> = (<span class="type">FetcherResult</span>) -&gt; <span class="type">Void</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> imageURL: <span class="type">NSURL</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(imageURL: <span class="type">NSURL</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.imageURL = imageURL</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.completion = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> cancelled = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> completion: <span class="type">CompeltionClosure</span>?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">fetchImage</span><span class="params">(url: NSURL, completion: CompeltionClosure?)</span></span> -&gt; <span class="type">ImageFetcher</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> fetcher: <span class="type">ImageFetcher</span></span><br><span class="line">        <span class="keyword">if</span> url.fileURL &#123;</span><br><span class="line">            fetcher = <span class="type">DiskImageFetcher</span>(imageURL: url)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fetcher = <span class="type">RemoteImageFetcher</span>(imageURL: url)</span><br><span class="line">        &#125;</span><br><span class="line">        fetcher.completion = completion</span><br><span class="line">        fetcher.startFetch()</span><br><span class="line">        <span class="keyword">return</span> fetcher</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">cancelFetch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.cancelled = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">startFetch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fatalError(<span class="string">"Subclass need to override this method called: \"startFetch\" "</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final <span class="func"><span class="keyword">func</span> <span class="title">failedWithError</span><span class="params">(error: NSError)</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final <span class="func"><span class="keyword">func</span> <span class="title">succeedWithData</span><span class="params">(imageData: NSData)</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>fetchImage</code> 这个方法里，通过 <code>url.fileURL</code> 判断是网络请求还是本地请求，然后初始化不同的 <code>fetcher</code> 。然后对于一定需要子类实现的方法，用 <code>fatalError</code> 报错提醒；对于一定不能让子类重写的方法，用 <code>final</code> 保护起来。比如请求成功之后的回调方法 <code>succeedWithData(imageData: NSData) ：</code></p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">final func succeedWithData(<span class="attribute">imageData</span>: NSData) &#123;</span><br><span class="line"></span><br><span class="line">    dispatch_async<span class="function"><span class="params">(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), &#123; [weak self]() -&gt; Void <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> strongSelf = self &#123;</span><br><span class="line">            <span class="keyword">var</span> finalImage: UIImage!</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> image = imageWithData(imageData) &#123;</span><br><span class="line">                finalImage = scaledImage(image)</span><br><span class="line">                finalImage = decodedImageWithImage(finalImage)</span><br><span class="line">                dispatch_main_async_safe &#123;</span><br><span class="line">                    <span class="keyword">if</span> !strongSelf.cancelled &#123;</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">let</span> completionClosure = strongSelf.completion &#123;</span><br><span class="line">                            <span class="keyword">let</span> result = FetcherResult.Success(image: finalImage, imageData: imageData)</span><br><span class="line">                            completionClosure(result)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> error = NSError(domain: CHUN_ERROR_DOMAIN, code: <span class="number">404</span>, userInfo: [NSLocalizedDescriptionKey: <span class="string">"create Image with data failed"</span>])</span><br><span class="line">                strongSelf.failedWithError(error)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>不管是从本地加载还是从远程获取的，最终的返回结果都是 <code>NSData</code> ，所以在这里统一处理。然后对于取消了的事件，其实并没有取消下载任务，而是在下载成功之后通过 <code>strongSelf.cancelled</code> 判断是不是要调用加载成功的回调方法。</p>
<p>然后再分别看下本地加载和网络获取的部分。本地加载相对而言简单一些，通过 <code>NSData(contentsOfURL: self.imageURL)</code>就可以加载图片了。然后对于网络请求则使用了 <code>NSURLSession</code> 来实现。 对 <code>NSURLSession</code> 不熟悉的同学可以阅读《从 NSURLConnection 到 NSURLSession》了解一下。</p>
<p>网络请求成功之后做了如下操作：</p>
<ul>
<li>检查 <code>self</code> 是否还活着</li>
<li>检查当前任务是否被取消了</li>
<li>检查回调的 <code>error</code> 是否不为空</li>
<li>获取 <code>response</code> 并查看状态码是否为 <code>200</code></li>
</ul>
<p>在一切正常的前提下，还进行了如下操作：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">let expected = response.expectedContentLength</span><br><span class="line">var <span class="string">validateLengthOfData:</span> Bool &#123;</span><br><span class="line">    <span class="keyword">if</span> expected &gt; -<span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> Int64(data!.length) &gt;= expected &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> validateLengthOfData &#123;</span><br><span class="line">    strongSelf.succeedWithData(data!)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    let error = NSError(<span class="string">domain:</span> CHUN_ERROR_DOMAIN, <span class="string">code:</span> response.statusCode, <span class="string">userInfo:</span> [<span class="string">NSLocalizedDescriptionKey:</span> <span class="string">"Received bytes are not fit with expected"</span>])</span><br><span class="line">    strongSelf.failedWithError(error)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主要是检查实际获取到的数据大小是否等于应有大小，通过 <code>validateLengthOfData</code> 这个计算量标记是否校验通过。</p>
<h3 id="缓存">缓存</h3><p>图片的缓存都是通过 <code>ImageCache</code> 这个类进行统一处理。初始化的时候新建了 <code>ioQueue</code> 这个用来专门进行 <code>IO</code> 操作的队列，然后用 <code>NSCache</code> 在内存中缓存图片。对于 <code>NSCache</code> 在 <code>NSHipster</code> 上有些吐槽，但这并没有太大影响，基本可以满足日常开发的需要。</p>
<h3 id="系统事件的处理">系统事件的处理</h3><p>在收到 <code>UIApplicationDidEnterBackgroundNotification</code> 的通知的时候，做了 <code>backgroundCleanDisk</code> 的处理：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">private</span> func <span class="keyword">backgroundCleanDisk() </span>&#123;</span><br><span class="line"></span><br><span class="line">    let application = UIApplication.sharedApplication()</span><br><span class="line">    var <span class="keyword">backgroundTask: </span>UIBackgroundTaskIdentifier!</span><br><span class="line">    <span class="keyword">backgroundTask </span>= application.<span class="keyword">beginBackgroundTaskWithExpirationHandler </span>&#123;</span><br><span class="line">        application.endBackgroundTask(<span class="keyword">backgroundTask)</span><br><span class="line"></span>        <span class="keyword">backgroundTask </span>= UIBackgroundTaskInvalid</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self.cleanDisk </span>&#123;</span><br><span class="line">        application.endBackgroundTask(<span class="keyword">backgroundTask)</span><br><span class="line"></span>        <span class="keyword">backgroundTask </span>= UIBackgroundTaskInvalid</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>beginBackgroundTaskWithExpirationHandler</code> 在退到后台之后清空了本地的过期文件。</p>
<h3 id="过期文件">过期文件</h3><p>判断过期文件的关键在于这个方法：<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> expirationDate = NSDate<span class="params">(timeIntervalSinceNow: ImageCache.defaultCacheMaxAge)</span></span><br><span class="line"><span class="built_in">let</span> modificationDate = resourceValues[NSURLContentModificationDateKey] as<span class="built_in">!</span> NSDate</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> modificationDate.laterDate<span class="params">(expirationDate)</span>.isEqualToDate<span class="params">(expirationDate)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过遍历检查所有的过期文件，存到 cacheFiles 数组中，然后统一删除。</p>
<h2 id="小结">小结</h2><p>通过 Chun 这个项目学习了如何实现一个简单的图片缓存库，包括图片加载和本地缓存两个核心功能。然后通过 public class 把一些公用接口封装并暴露出去。也看到了很多 Swift 中的小技巧，总之就是， Excited 嗯！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://blog.callmewhy.com/2015/05/25/note-about-chun/">转自</a></p>
<h2 id="Chun_阅读笔记_-_如何做一个图片缓存库">Chun 阅读笔记 - 如何做一个图片缓存库</h2><p><a href="https://github.com/yechunjun/Chun">Chun</a> 是 <a href="http://chun.tips/">叶纯俊</a> 在 Github 上开源的一个图片缓存库，基于 Swift 编写。学习 Swift 有一段时间了，记录一些阅读源码的一些收获。</p>
<h3 id="代码组织">代码组织</h3><p>Swift 中通过 <code>extension</code> 组织代码会让整个类更加清晰可读，尤其是对于 <code>UITableViewDataSource</code> 和 <code>UITableViewDelegate</code> 这种情况。在 Chun 这个项目中的 Demo 文件就是这样的：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UITableViewDataSource</span>, <span class="title">UITableViewDelegate</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://ytlvy.com/tags/Swift/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS NSTimer Overflow]]></title>
    <link href="http://ytlvy.com/2015/07/28/iOS-NSTimer-Overflow/"/>
    <id>http://ytlvy.com/2015/07/28/iOS-NSTimer-Overflow/</id>
    <published>2015-07-28T13:41:45.000Z</published>
    <updated>2015-07-28T13:47:15.000Z</updated>
    <content type="html"><![CDATA[<h2 id="NSTimer">NSTimer</h2><h3 id="fire">fire</h3><p>我们先用 NSTimer 来做个简单的计时器，每隔5秒钟在控制台输出 Fire 。比较想当然的做法是这样的：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DetailViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSTimer</span> *timer;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DetailViewController</span></span></span><br><span class="line">- (<span class="keyword">IBAction</span>)fireButtonPressed:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    _timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">3.0</span>f</span><br><span class="line">                                              target:<span class="keyword">self</span></span><br><span class="line">                                            selector:<span class="keyword">@selector</span>(timerFire:)</span><br><span class="line">                                            userInfo:<span class="literal">nil</span></span><br><span class="line">                                             repeats:<span class="literal">YES</span>];</span><br><span class="line">    [_timer fire];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)timerFire:(<span class="keyword">id</span>)userinfo &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Fire"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>运行之后确实在控制台每隔3秒钟输出一次 <code>Fire</code> ，然而当我们从这个界面跳转到其他界面的时候却发现：控制台还在源源不断的输出着 Fire 。看来 Timer 并没有停止。</p>
<a id="more"></a>
<h3 id="invalidate">invalidate</h3><p>既然没有停止，那我们在 DemoViewController 的 dealloc 里加上 invalidate 的方法：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [_timer invalidate];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ dealloc"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> class]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再次运行，还是没有停止。原因是 Timer 添加到 Runloop 的时候，会被 Runloop 强引用：</p>
<blockquote>
<p>Note in particular that run loops maintain strong references to their timers, so you don’t have to maintain your own strong reference to a timer after you have added it to a run loop.</p>
</blockquote>
<p>然后 Timer 又会有一个对 Target 的强引用（也就是 self ）：</p>
<blockquote>
<p>Target is the object to which to send the message specified by aSelector when the timer fires. The timer maintains a strong reference to target until it (the timer) is invalidated.</p>
</blockquote>
<p>也就是说 <code>NSTimer</code> 强引用了 <code>self</code> ，导致 <code>self</code> 一直不能被释放掉，所以也就走不到 <code>self</code> 的 <code>dealloc</code> 里。</p>
<p>既然如此，那我们可以再加个 invalidate 按钮：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (IBAction)<span class="tag">invalidateButtonPressed</span>:(id)<span class="tag">sender</span> &#123;</span><br><span class="line">    <span class="attr_selector">[_timer invalidate]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 <code>invalidate</code> 方法的文档里还有这这样一段话：</p>
<blockquote>
<p>You must send this message from the thread on which the timer was installed. If you send this message from another thread, the input source associated with the timer may not be removed from its run loop, which could prevent the thread from exiting properly.<br>NSTimer 在哪个线程创建就要在哪个线程停止，否则会导致资源不能被正确的释放。看起来各种坑还不少。</p>
</blockquote>
<h3 id="dealloc">dealloc</h3><p>那么问题来了：如果我就是想让这个 NSTimer 一直输出，直到 DemoViewController 销毁了才停止，我该如何让它停止呢？</p>
<ul>
<li>NSTimer 被 Runloop 强引用了，如果要释放就要调用 invalidate 方法。</li>
<li>但是我想在 DemoViewController 的 dealloc 里调用 invalidate 方法，但是 self 被 NSTimer 强引用了。</li>
<li>所以我还是要释放 NSTimer 先，然而不调用 invalidate 方法就不能释放它。</li>
<li>然而你不进入到 dealloc 方法里我又不能调用 invalidate 方法。</li>
</ul>
<h3 id="解决方案">解决方案</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  NSTimer+EZ_Helper.m</span></span><br><span class="line"><span class="comment">//  EZToolKit</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by yangjun zhu on 15/5/20.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2015年 Cactus. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line">#<span class="keyword">import</span> <span class="string">"NSTimer+EZ_Helper.h"</span></span><br><span class="line"></span><br><span class="line"><span class="annotation">@implementation</span> NSTimer (EZ_Helper)</span><br><span class="line">+ (NSTimer *)<span class="string">ez_scheduledTimerWithTimeInterval:</span>(NSTimeInterval)inTimeInterval <span class="string">block:</span>(<span class="typename">void</span> (^)())inBlock <span class="string">repeats:</span>(BOOL)inRepeats</span><br><span class="line">&#123;</span><br><span class="line">    <span class="typename">void</span> (^block)() = [inBlock copy];</span><br><span class="line">    NSTimer * timer = [self <span class="string">scheduledTimerWithTimeInterval:</span>inTimeInterval <span class="string">target:</span>self <span class="string">selector:</span><span class="annotation">@selector</span>(<span class="string">__executeTimerBlock:</span>) <span class="string">userInfo:</span>block <span class="string">repeats:</span>inRepeats];</span><br><span class="line">    <span class="keyword">return</span> timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (NSTimer *)<span class="string">ez_timerWithTimeInterval:</span>(NSTimeInterval)inTimeInterval <span class="string">block:</span>(<span class="typename">void</span> (^)())inBlock <span class="string">repeats:</span>(BOOL)inRepeats</span><br><span class="line">&#123;</span><br><span class="line">    <span class="typename">void</span> (^block)() = [inBlock copy];</span><br><span class="line">    NSTimer * timer = [self <span class="string">timerWithTimeInterval:</span>inTimeInterval <span class="string">target:</span>self <span class="string">selector:</span><span class="annotation">@selector</span>(<span class="string">__executeTimerBlock:</span>) <span class="string">userInfo:</span>block <span class="string">repeats:</span>inRepeats];</span><br><span class="line">    <span class="keyword">return</span> timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="typename">void</span>)<span class="string">__executeTimerBlock:</span>(NSTimer *)inTimer;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>([inTimer userInfo])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="typename">void</span> (^block)() = (<span class="typename">void</span> (^)())[inTimer userInfo];</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="annotation">@end</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="NSTimer">NSTimer</h2><h3 id="fire">fire</h3><p>我们先用 NSTimer 来做个简单的计时器，每隔5秒钟在控制台输出 Fire 。比较想当然的做法是这样的：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DetailViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSTimer</span> *timer;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DetailViewController</span></span></span><br><span class="line">- (<span class="keyword">IBAction</span>)fireButtonPressed:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    _timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">3.0</span>f</span><br><span class="line">                                              target:<span class="keyword">self</span></span><br><span class="line">                                            selector:<span class="keyword">@selector</span>(timerFire:)</span><br><span class="line">                                            userInfo:<span class="literal">nil</span></span><br><span class="line">                                             repeats:<span class="literal">YES</span>];</span><br><span class="line">    [_timer fire];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)timerFire:(<span class="keyword">id</span>)userinfo &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Fire"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>运行之后确实在控制台每隔3秒钟输出一次 <code>Fire</code> ，然而当我们从这个界面跳转到其他界面的时候却发现：控制台还在源源不断的输出着 Fire 。看来 Timer 并没有停止。</p>]]>
    
    </summary>
    
      <category term="NSTimer" scheme="http://ytlvy.com/tags/NSTimer/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift Exception Handle]]></title>
    <link href="http://ytlvy.com/2015/07/28/Swift-Exception-Handle/"/>
    <id>http://ytlvy.com/2015/07/28/Swift-Exception-Handle/</id>
    <published>2015-07-28T13:40:42.000Z</published>
    <updated>2015-07-28T13:41:27.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://blog.callmewhy.com/2015/04/20/error-handling-in-swift/" target="_blank" rel="external">转自</a></p>
<h2 id="Swift_中的异常处理">Swift 中的异常处理</h2><h3 id="问题">问题</h3><p>在开发过程中，异常处理算是比较常见的问题了。</p>
<p>举一个比较常见的例子：用户修改注册的邮箱，大概分为以下几个步骤：</p>
<ul>
<li>接收到一个用户的请求：我要修改邮箱地址</li>
<li>验证一下请求是否合法，将请求进行格式转化</li>
<li>更新以前的邮箱地址记录</li>
<li>给新的邮箱地址发送验证邮件</li>
<li>将结果返回给用户</li>
</ul>
<p>上面的步骤如果一切顺利，那代码肯定干净利落，但是人生不如意十有八九，上面的步骤很容易出现问题：</p>
<ul>
<li>用户把邮箱地址填成了家庭地址</li>
<li>用户是个黑客，没登录就发送了更新请求</li>
<li>发送验证邮件的时候服务器爆炸了，发送邮件失败</li>
</ul>
<p>各种异常都会导致这次操作的失败。</p>
<h3 id="方案一">方案一</h3><p>在传统的处理方案里，一般是遇到异常就往上抛：<br><img src="http://segmentfault.com/img/bVlsK9" alt=""></p>
<p>这种方案想必大家都不陌生，比如下面这段代码：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSError</span> *err = <span class="keyword">nil</span>;</span><br><span class="line"><span class="type">CGFloat</span> <span class="literal">result</span> = [<span class="type">MathTool</span> divide:<span class="number">2</span>.<span class="number">5</span> by:<span class="number">3</span>.<span class="number">0</span> error:&amp;err];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">"%@"</span>, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    [<span class="type">MathTool</span> doSomethingWithResult:<span class="literal">result</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="方案二">方案二</h3><p>而另一种方案，则是将错误的结果继续往后传，在最后统一处理：<br><img src="http://segmentfault.com/img/bVlsLe" alt=""></p>
<p>这种方案有两个问题：</p>
<ul>
<li>在发生异常的时候，如何把异常继续传给下面的函数？</li>
<li>当整个流程结束的时候，一个函数如何输出多个结果？</li>
</ul>
<h3 id="车轨">车轨</h3><p>我们把方案二抽象出来，就像是一段车轨：</p>
<p><img src="http://segmentfault.com/img/bVlsNx" alt=""></p>
<p>对于同一个输入，会有 Success 和 Failure 两种输出结果，对于 Success 的情况，我们希望它能继续走到后面的流程里，而对于 Failure 的情况，它怎么处理并不重要，我们希望它能避开后面的流程：</p>
<p><img src="http://segmentfault.com/img/bVlsNC" alt=""></p>
<p>于是乎，两段车轨拼接的时候，便成了这样：</p>
<p><img src="http://segmentfault.com/img/bVlsNH" alt=""></p>
<p>那么三段什么的自然也不在话下了。我们把下面那根 Failure 的线路扩展一下，便会看到两条平行的线路，这便是“双轨模型” (Two Track Model) ，这是用“面向轨道编程”思想解决异常处理的理论基础。</p>
<p><img src="http://segmentfault.com/img/bVlsNK" alt=""></p>
<p>这就是 “面向轨道编程” 。一开始我觉得这概念应该只是来搞笑的，仔细想想似乎倒也是很贴切。将事件流当做两条平行的轨道，如果顺利则在上行轨道，继续传递给下个业务逻辑去处理，如果出现异常也不慌，直接扔到下行轨道，一直在下行轨道传递到终点，在最后统一处理。</p>
<p>这样处理使得整个流程变成了一条双进双出的流水线，有点像是 shell 里的 pipeline ，上一次的输出作为下一次的输入，十分顺畅。而且拼接起来也很方便，我们可以把三段拼接成一段暴露给其他对象使用：</p>
<p><img src="http://segmentfault.com/img/bVlsOy" alt=""></p>
<h3 id="实现">实现</h3><p>接下来看看在 Swift 中如何应用这种思路处理异常。</p>
<p>首先我们需要两种类型的输出结果：</p>
<ul>
<li>成功，返回某种类型的值</li>
<li>失败，返回一个 Error 对象或者失败的具体信息</li>
</ul>
<p>照着这个想法，我们可以定义一个 Result 枚举用做输出：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Result&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">case</span> Success(T)</span><br><span class="line">    <span class="keyword">case</span> Failure(<span class="built_in">String</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>利用 Swift 的枚举特性，我们可以在成功的枚举值里关联一些返回值，然后在失败的情况下则带上失败的消息内容。不过 enum 目前还不支持泛型，我们可以在外面封装一个 Box 类来解决这个问题：<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> Box&lt;T&gt; &#123;</span><br><span class="line">    let <span class="keyword">value</span>: T</span><br><span class="line">    init(<span class="keyword">value</span>: T) &#123;</span><br><span class="line">        self.<span class="keyword">value</span> = <span class="keyword">value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Result&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">case</span> Success(Box&lt;T&gt;)</span><br><span class="line">    <span class="keyword">case</span> Failure(String)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再看下一开始我们举的那个例子，用这个枚举类重新写下就是这样的：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">result</span> = divide(<span class="number">2</span>.<span class="number">5</span>, by:<span class="number">3</span>)</span><br><span class="line">switch <span class="literal">result</span> &#123;</span><br><span class="line"><span class="keyword">case</span> .<span class="type">Success</span>(<span class="keyword">let</span> value):</span><br><span class="line">    doSomethingWithResult(value)</span><br><span class="line"><span class="keyword">case</span> .<span class="type">Failure</span>(<span class="keyword">let</span> errString):</span><br><span class="line">    println(errString)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>“看起来好像也没什么嘛，你不还是用了个大括号处理两种情况嘛！”（嫌弃脸</p>
<p>确实正如这位热情的朋友所说，写完这个例子我也没觉得有什么优点，难道我就是来搞笑的？</p>
<p>“并不。”（严肃脸</p>
<h3 id="栗子">栗子</h3><p>接下来我们举个栗子玩一玩。为了更好的观赏效果，请允许我使用浮夸的写法和粗暴的命名举这个栗子。</p>
<p>比如对于即将输入的数字 x ，我们希望输出 <code>4 / (2 / x - 1)</code> 的计算结果。这里会有两处出错的可能，一个是 <code>(2 / x)</code> 时 x 为 0 ，另一个就是 <code>(2 / x - 1)</code> 为 0 的情况。</p>
<p>先看下传统写法：<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> errorStr = <span class="string">"输入错误，我很抱歉"</span></span><br><span class="line">func cal(<span class="keyword">value</span>: Float) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">value</span> == <span class="number">0</span> &#123;</span><br><span class="line">        println(errorStr)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">value</span><span class="number">1</span> = <span class="number">2</span> / <span class="keyword">value</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">value</span><span class="number">2</span> = <span class="keyword">value</span><span class="number">1</span> - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">value</span><span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">            println(errorStr)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">value</span><span class="number">3</span> = <span class="number">4</span> / <span class="keyword">value</span><span class="number">2</span></span><br><span class="line">            println(<span class="keyword">value</span><span class="number">3</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cal(<span class="number">2</span>)    <span class="comment">// 输入错误，我很抱歉</span></span><br><span class="line">cal(<span class="number">1</span>)    <span class="comment">// 4.0</span></span><br><span class="line">cal(<span class="number">0</span>)    <span class="comment">// 输入错误，我很抱歉</span></span><br></pre></td></tr></table></figure></p>
<p>那么用面向轨道的思想怎么去解决这个问题呢？</p>
<p>大概是这个样子的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">final <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value: <span class="type">T</span></span><br><span class="line">    <span class="keyword">init</span>(value: <span class="type">T</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Success</span>(<span class="type">Box</span>&lt;<span class="type">T</span>&gt;)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Failure</span>(<span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> errorStr = <span class="string">"输入错误，我很抱歉"</span></span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">cal</span><span class="params">(value: Float)</span></span> &#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">cal1</span><span class="params">(value: Float)</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">Float</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> value == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> .<span class="type">Failure</span>(errorStr)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> .<span class="type">Success</span>(<span class="type">Box</span>(value: <span class="number">2</span> / value))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">cal2</span><span class="params">(value: Result&lt;Float&gt;)</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">Float</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">switch</span> value &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Success</span>(<span class="keyword">let</span> v):</span><br><span class="line">            <span class="keyword">return</span> .<span class="type">Success</span>(<span class="type">Box</span>(value: v.value - <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Failure</span>(<span class="keyword">let</span> str):</span><br><span class="line">            <span class="keyword">return</span> .<span class="type">Failure</span>(str)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">cal3</span><span class="params">(value: Result&lt;Float&gt;)</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">Float</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">switch</span> value &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Success</span>(<span class="keyword">let</span> v):</span><br><span class="line">            <span class="keyword">if</span> v.value == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> .<span class="type">Failure</span>(errorStr)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> .<span class="type">Success</span>(<span class="type">Box</span>(value: <span class="number">4</span> / v.value))</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Failure</span>(<span class="keyword">let</span> str):</span><br><span class="line">            <span class="keyword">return</span> .<span class="type">Failure</span>(str)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> r = cal3(cal2(cal1(value)))</span><br><span class="line">    <span class="keyword">switch</span> r &#123;</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Success</span>(<span class="keyword">let</span> v):</span><br><span class="line">        <span class="built_in">println</span>(v.value)</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Failure</span>(<span class="keyword">let</span> s):</span><br><span class="line">        <span class="built_in">println</span>(s)</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line">cal(<span class="number">2</span>)    <span class="comment">// 输入错误，我很抱歉</span></span><br><span class="line">cal(<span class="number">1</span>)    <span class="comment">// 4.0</span></span><br><span class="line">cal(<span class="number">0</span>)    <span class="comment">// 输入错误，我很抱歉</span></span><br></pre></td></tr></table></figure>
<p>同学，放下手里的键盘，冷静下来，有话好好说。</p>
<h3 id="反思">反思</h3><p>面向轨道之后，代码量翻了两倍多，而且似乎变得更难读了。浪费了大家这么多时间结果就带来这么个玩意儿，实在是对不起观众们热情的掌声。</p>
<p>仔细看下上面的代码， switch 的操作重复而多余，都在重复着把 Success 和 Failure 分开的逻辑，实际上每个函数只需要处理 Success 的情况。我们在 Result 中加入 funnel 提前处理掉 Failure 的情况：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Success</span>(<span class="type">Box</span>&lt;<span class="type">T</span>&gt;)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Failure</span>(<span class="type">String</span>)</span><br><span class="line"></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">funnel</span><span class="generics">&lt;U&gt;</span><span class="params">(f:T -&gt; Result&lt;U&gt;)</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Success</span>(<span class="keyword">let</span> value):</span><br><span class="line">            <span class="keyword">return</span> f(value.value)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Failure</span>(<span class="keyword">let</span> errString):</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Result</span>&lt;<span class="type">U</span>&gt;.<span class="type">Failure</span>(errString)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>funnel</code> 帮我们把上次的结果进行分流，只将 <code>Success</code> 的轨道对接到了下个业务上，而将 <code>Failure</code> 引到了下一个 <code>Failure</code> 轨道上。</p>
<p>接下来再回到栗子里，此时我们已经不再需要传入 <code>Result</code> 值了，只需要传入 <code>value</code> 即可：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">cal</span><span class="params">(value: Float)</span></span> &#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">cal1</span><span class="params">(v: Float)</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">Float</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> .<span class="type">Failure</span>(errorStr)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> .<span class="type">Success</span>(<span class="type">Box</span>(<span class="number">2</span> / v))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">cal2</span><span class="params">(v: Float)</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">Float</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> .<span class="type">Success</span>(<span class="type">Box</span>(v - <span class="number">1</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">cal3</span><span class="params">(v: Float)</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">Float</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> .<span class="type">Failure</span>(errorStr)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> .<span class="type">Success</span>(<span class="type">Box</span>(<span class="number">4</span> / v))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> r = cal1(value).funnel(cal2).funnel(cal3)</span><br><span class="line">    <span class="keyword">switch</span> r &#123;</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Success</span>(<span class="keyword">let</span> v):</span><br><span class="line">        <span class="built_in">println</span>(v.value)</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Failure</span>(<span class="keyword">let</span> s):</span><br><span class="line">        <span class="built_in">println</span>(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看起来简洁了一些。我们可以通过 <code>cal1(value).funnel(cal2).funnel(cal3)</code> 这样的链式调用来获取计算结果。</p>
<p>“面向轨道”编程确实给我们提供了一个很有趣的思路。本文只是一个简单地讨论，进一步学习可以仔细阅读后面的参考文献。比如 ValueTransformation.swift 这个真实的完整案例，以及 antitypical/Result 这个封装完整的 Result 库。文中的实现方案只是一个比较简单的方法，和前两种实现略有差异。</p>
<p>面向铁轨，春暖花开。愿每段代码都走在 Happy Path 上，愿每个人都有个 Happy Ending 。<br>md</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://blog.callmewhy.com/2015/04/20/error-handling-in-swift/">转自</a></p>
<h2 id="Swift_中的异常处理">Swift 中的异常处理</h2><h3 id="问题">问题</h3><p>在开发过程中，异常处理算是比较常见的问题了。</p>
<p>举一个比较常见的例子：用户修改注册的邮箱，大概分为以下几个步骤：</p>
<ul>
<li>接收到一个用户的请求：我要修改邮箱地址</li>
<li>验证一下请求是否合法，将请求进行格式转化</li>
<li>更新以前的邮箱地址记录</li>
<li>给新的邮箱地址发送验证邮件</li>
<li>将结果返回给用户</li>
</ul>
<p>上面的步骤如果一切顺利，那代码肯定干净利落，但是人生不如意十有八九，上面的步骤很容易出现问题：</p>
<ul>
<li>用户把邮箱地址填成了家庭地址</li>
<li>用户是个黑客，没登录就发送了更新请求</li>
<li>发送验证邮件的时候服务器爆炸了，发送邮件失败</li>
</ul>
<p>各种异常都会导致这次操作的失败。</p>
<h3 id="方案一">方案一</h3><p>在传统的处理方案里，一般是遇到异常就往上抛：<br><img src="http://segmentfault.com/img/bVlsK9" alt=""></p>
<p>这种方案想必大家都不陌生，比如下面这段代码：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSError</span> *err = <span class="keyword">nil</span>;</span><br><span class="line"><span class="type">CGFloat</span> <span class="literal">result</span> = [<span class="type">MathTool</span> divide:<span class="number">2</span>.<span class="number">5</span> by:<span class="number">3</span>.<span class="number">0</span> error:&amp;err];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">"%@"</span>, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    [<span class="type">MathTool</span> doSomethingWithResult:<span class="literal">result</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Exception" scheme="http://ytlvy.com/tags/Exception/"/>
    
      <category term="Swift" scheme="http://ytlvy.com/tags/Swift/"/>
    
      <category term="Swift" scheme="http://ytlvy.com/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS ARC Practices]]></title>
    <link href="http://ytlvy.com/2015/07/28/iOS-ARC-Practices/"/>
    <id>http://ytlvy.com/2015/07/28/iOS-ARC-Practices/</id>
    <published>2015-07-28T13:39:38.000Z</published>
    <updated>2015-07-28T13:40:09.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://amattn.com/p/arc_best_practices.html" target="_blank" rel="external">转自</a></p>
<h2 id="ARC_最佳实践">ARC 最佳实践</h2><h3 id="General">General</h3><p>1) 数值变量应该使用 assign：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">int</span> scalarInt;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> scalarFloat;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGPoint</span> scalarStruct;</span><br></pre></td></tr></table></figure></p>
<p>2) 在层次结构上属于下一级的对象应该使用 strong ：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> childObject;</span><br></pre></td></tr></table></figure></p>
<p>3) 在层次结构上属于上一级的对象应该使用 weak ，另外，当出现循环引用的时候也应该使用 weak ：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> parentObject;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSObject</span> &lt;SomeDelegate&gt; *delegate;</span><br></pre></td></tr></table></figure></p>
<p>4) 闭包应该使用 copy ：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) SomeBlockType someBlock;</span><br></pre></td></tr></table></figure>
<p>5) 在 dealloc 里：</p>
<ul>
<li>从观察者中移除 (remove observers)</li>
<li>取消订阅通知 (unregister for notifications)</li>
<li>设置非 weak 的委托为 nil (set any non-weak delegates to nil)</li>
<li>关闭所有的计时器 (invalidate any timers)</li>
</ul>
<p>6) 所有的 IBOutlet 都应该是 weak 的。除非顶层的 IBOutlet 应该是 strong 的，比如 UIViewController 的 View 是需要直接拥有的，所以应该设置成 strong </p>
<a id="more"></a>
<h3 id="Bridging">Bridging</h3><p>从文档来看是这样的：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> my_id;</span><br><span class="line"><span class="built_in">CFStringRef</span> my_cfref;</span><br><span class="line"><span class="built_in">NSString</span>   *a = (__bridge <span class="built_in">NSString</span>*)my_cfref;     <span class="comment">// Noop cast.</span></span><br><span class="line"><span class="built_in">CFStringRef</span> b = (__bridge <span class="built_in">CFStringRef</span>)my_id;      <span class="comment">// Noop cast.</span></span><br><span class="line"><span class="built_in">NSString</span>   *c = (__bridge_transfer <span class="built_in">NSString</span>*)my_cfref; <span class="comment">// -1 on the CFRef</span></span><br><span class="line"><span class="built_in">CFStringRef</span> d = (__bridge_retained <span class="built_in">CFStringRef</span>)my_id;  <span class="comment">// returned CFRef +1</span></span><br></pre></td></tr></table></figure></p>
<p>简单的翻译成大白话：</p>
<ul>
<li>__bridge 只做类型转换，但是不修改对象内存的管理权。</li>
<li>__bridge_transfer 将 Core Foundation 的对象转换为 Objective-C 的对象，同时将对象内存的管理权交给 ARC 。 ARC 会自动将引用计数减1 。</li>
<li>__bridge_retained 将 Objective-C 的对象转换为 Core Foundation 的对象，同时将对象内存的管理权交给我们，引用计数会自动加1。后续需要使用 CFRelease 或者相关方法来释放对象。</li>
</ul>
<h3 id="NSError">NSError</h3><p>无所不在的 <code>NSError</code> 有点特殊，在标准的 Cocoa 使用中， <code>NSError</code> 是通过外部参数 <code>(out-parameter)</code> 实现的，又称为 <code>indirect pointer</code> 。</p>
<p>在 ARC 里， <code>out-parameter</code> 默认是 <code>__autoreleasing</code> 的，并且实现方法应该是这样的：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)performWithError:(__autoreleasing <span class="built_in">NSError</span> **)error &#123;</span><br><span class="line">    <span class="comment">// 如果发生了一些错误</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="comment">// 写入到外部参数， ARC 会自动释放</span></span><br><span class="line">        *error = [[<span class="built_in">NSError</span> alloc] initWithDomain:<span class="string">@""</span> </span><br><span class="line">                                            code:-<span class="number">1</span> </span><br><span class="line">                                        userInfo:<span class="literal">nil</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当我们使用这个方法的时候， *error 前面应该加上 __autoreleasing 的标记：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSError __autoreleasing *<span class="keyword">error</span> = <span class="keyword">error</span>;</span><br><span class="line">BOOL OK = [myObject performOperationWithError:&amp;<span class="keyword">error</span>];</span><br><span class="line"><span class="keyword">if</span> (!OK)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// handle the error.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你标记了 <code>__autoreleasing</code> ，编译器会简单的插入一个临时的中介对象。这是为了能够向下兼容的妥协方案，因为有些编译器的设置并没有自动把它们设置为 <code>__autoreleasing</code> ，所以为了安全起见，还是加上 <code>__autoreleasing</code> 的比较保险。</p>
<h3 id="@autoreleasepool">@autoreleasepool</h3><p>可以在如下场景使用自动释放池：</p>
<ul>
<li>遍历很多很多遍的时候</li>
<li>创建大量的临时变量</li>
</ul>
<p>比如下面这个例子：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 someArray 里的元素非常多</span></span><br><span class="line"><span class="tag">for</span> (id obj in someArray) &#123;</span><br><span class="line">    <span class="variable">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// 或者在每次遍历里都创建了大量的临时变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以通过 <code>@autoreleasepool</code> 标记创建和销毁一个自动释放池。</p>
<h3 id="Blocks">Blocks</h3><p>总的来说，闭包用起来还行，但是还是有那么点小问题。</p>
<p>当我们把闭包添加到集合中的时候 (比如 NSArray) ，一定要先 copy 一下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">someBlockType someBlock = ^&#123;<span class="built_in">NSLog</span>(<span class="string">@"hi"</span>);&#125;;</span><br><span class="line">[someArray addObject:[someBlock <span class="keyword">copy</span>]];</span><br></pre></td></tr></table></figure>
<p>循环引用是十分危险的，你可能看到过这些 warning ：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">warning</span>: capturing <span class="string">'self'</span> strongly <span class="keyword">in</span> <span class="keyword">this</span> </span><br><span class="line">block <span class="keyword">is</span> likely <span class="keyword">to</span> lead <span class="keyword">to</span> a retain cycle </span><br><span class="line">[-Warc-retain-cycles,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">SomeBlockType someBlock = ^&#123;</span><br><span class="line">    [self someMethod];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>警告的原因是 <code>someBlock</code> 是 <code>self</code> 的强引用，而 <code>someBlock</code> 又捕捉并且 <code>retain</code> 了 <code>self。</code></p>
<p>再举一个表现不明显的循环引用：任何变量的父对象都是会被捕捉的：<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面这个闭包会持有 "self"</span></span><br><span class="line"><span class="constant">SomeBlockType someBlock</span> = ^&#123;</span><br><span class="line"><span class="constant">    BOOL isDone</span> = _isDone;  <span class="comment">// _isDone 是 self 的一个变量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>更安全但是也更啰嗦的方法是使用 weakSelf ：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> SomeObjectClass *weakSelf = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line">SomeBlockType someBlock = ^&#123;</span><br><span class="line">    SomeObjectClass *strongSelf = weakSelf;</span><br><span class="line">    <span class="keyword">if</span> (strongSelf == <span class="literal">nil</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// The original self doesn't exist anymore.</span></span><br><span class="line">        <span class="comment">// Ignore, notify or otherwise handle this case.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        [strongSelf someMethod];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>有时候你也需要注意避免对象的循环引用：如果 someObject 将会被 block 强引用，可以用 weakSomeObject 打破循环引用：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SomeObjectClass *<span class="variable">someObject =</span> ...</span><br><span class="line">__weak SomeObjectClass *<span class="variable">weakSomeObject =</span> someObject;</span><br><span class="line"></span><br><span class="line">someObject.<span class="variable">completionHandler =</span> ^&#123;</span><br><span class="line">    SomeObjectClass *<span class="variable">strongSomeObject =</span> weakSomeObject;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">strongSomeObject =</span>= nil)</span><br><span class="line">    &#123;</span><br><span class="line">        // The original someObject doesn't exist anymore.</span><br><span class="line">        // Ignore, notify <span class="constant">or</span> otherwise handle this case.</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        // okay, NOW we can do something <span class="keyword">with</span> someObject</span><br><span class="line">        [strongSomeObject someMethod];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="Accessing_CGThings_from_NSThings_or_UIThings">Accessing CGThings from NSThings or UIThings</h3><p>先看一段代码：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIColor</span> *redColor = [<span class="built_in">UIColor</span> redColor]; </span><br><span class="line"><span class="built_in">CGColorRef</span> redRef = redColor<span class="variable">.CGColor</span>;</span><br><span class="line"><span class="comment">// 用 redRef 做一些事情</span></span><br></pre></td></tr></table></figure></p>
<p>上面这段代码有一些很隐蔽的问题。当你创建 <code>redRef</code> 的时候，如果 <code>redColor</code> 不再被使用，那么 <code>redColor</code> 会在备注那一行立即被销毁。</p>
<p>问题是 <code>redColor</code> 持有了 <code>redRef</code> ，当访问 <code>redRef</code> 的时候，它有可能是也有可能不再是一个 <code>colorRef</code> 。更糟糕的是，这种问题很少在虚拟机上出现，这更有可能在那种低内存的设备上出现，比如第一代的 <code>iPad</code> 老爷机。</p>
<p>解决的方案也有很多。最关键的一点是：在使用 <code>redRef</code> 的时候，我们需要保证 <code>redColor</code> 是有效的。</p>
<p>一种最简单的方式就是使用 <code>__autoreleasingpool</code> ：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIColor</span> * __autoreleasing redColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line"><span class="built_in">CGColorRef</span> redRef = redColor<span class="variable">.CGColor</span>;</span><br></pre></td></tr></table></figure></p>
<p>注意这时候 <code>redColor</code> 在方法返回之前都不会被释放掉，所以我们可以放心的在当前的方法里使用 <code>redRef</code> 。</p>
<p>另一种方法是 <code>retain</code> 一下 <code>redRef</code> ：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIColor</span> *redColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line"><span class="built_in">CGColorRef</span> redRef = <span class="built_in">CFRetain</span>(redColor<span class="variable">.CGColor</span>);</span><br><span class="line"><span class="comment">// 尽情的使用 redRef ，注意，在结束的时候要 release</span></span><br><span class="line"><span class="built_in">CFRelease</span>(redRef)</span><br></pre></td></tr></table></figure></p>
<p>注意：我们需要在 <code>redColor.CGColor</code> 处使用 <code>CFRetain()</code>，因为在最近一次使用之后 <code>redColor</code> 就被释放了。比如下面这段代码就是没啥用的：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIColor</span> *redColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line"><span class="built_in">CGColorRef</span> redRef = redColor<span class="variable">.CGColor</span>; <span class="comment">// redColor 在这行代码之后就被 release 了</span></span><br><span class="line"><span class="built_in">CFRetain</span>(redRef);  <span class="comment">// 这里可能会崩溃</span></span><br></pre></td></tr></table></figure></p>
<p>有趣的是标记了 这里可能会崩溃 的那一行。在我的印象里，在虚拟机里很少崩溃，而在真机上就很常见。</p>
<h3 id="单例模式">单例模式</h3><p>标准的单例模式的实现应该是这个样子的：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (MyClass *)singleton</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> MyClass *sharedMyClass = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> once = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;once, ^&#123;sharedMyClass = [[<span class="keyword">self</span> alloc] init];&#125;);</span><br><span class="line">    <span class="keyword">return</span> sharedMyClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有时候我们还需要销毁单例，不过如果不是用在单元测试里，那么很有可能你不该使用单例模式。</p>
<p>可以销毁并重建的单例模式是这样的：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 singleton 外声明一个静态变量</span></span><br><span class="line"><span class="keyword">static</span> MyClass *__sharedMyClass = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">+ (MyClass *)singleton</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> once = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;once, ^&#123;__sharedMyClass = [[<span class="keyword">self</span> alloc] init];&#125;);</span><br><span class="line">    <span class="keyword">return</span> __sharedMyClass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅可用于测试！</span></span><br><span class="line">- (<span class="keyword">void</span>)destroyAndRecreateSingleton</span><br><span class="line">&#123;</span><br><span class="line">    __sharedMyClass = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://amattn.com/p/arc_best_practices.html">转自</a></p>
<h2 id="ARC_最佳实践">ARC 最佳实践</h2><h3 id="General">General</h3><p>1) 数值变量应该使用 assign：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">int</span> scalarInt;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> scalarFloat;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGPoint</span> scalarStruct;</span><br></pre></td></tr></table></figure></p>
<p>2) 在层次结构上属于下一级的对象应该使用 strong ：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> childObject;</span><br></pre></td></tr></table></figure></p>
<p>3) 在层次结构上属于上一级的对象应该使用 weak ，另外，当出现循环引用的时候也应该使用 weak ：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> parentObject;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSObject</span> &lt;SomeDelegate&gt; *delegate;</span><br></pre></td></tr></table></figure></p>
<p>4) 闭包应该使用 copy ：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) SomeBlockType someBlock;</span><br></pre></td></tr></table></figure>
<p>5) 在 dealloc 里：</p>
<ul>
<li>从观察者中移除 (remove observers)</li>
<li>取消订阅通知 (unregister for notifications)</li>
<li>设置非 weak 的委托为 nil (set any non-weak delegates to nil)</li>
<li>关闭所有的计时器 (invalidate any timers)</li>
</ul>
<p>6) 所有的 IBOutlet 都应该是 weak 的。除非顶层的 IBOutlet 应该是 strong 的，比如 UIViewController 的 View 是需要直接拥有的，所以应该设置成 strong </p>]]>
    
    </summary>
    
      <category term="ARC" scheme="http://ytlvy.com/tags/ARC/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS9 NSAppTransportSecurity Bypass]]></title>
    <link href="http://ytlvy.com/2015/07/28/iOS9-NSAppTransportSecurity-Bypass/"/>
    <id>http://ytlvy.com/2015/07/28/iOS9-NSAppTransportSecurity-Bypass/</id>
    <published>2015-07-28T13:38:09.000Z</published>
    <updated>2015-07-28T13:39:09.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Configuring_App_Transport_Security_Exceptions_in_iOS_9_and_OSX_10-11">Configuring App Transport Security Exceptions in iOS 9 and OSX 10.11</h2><h3 id="What_is_App_Transport_Security_(ATS)?">What is App Transport Security (ATS)?</h3><p>At WWDC 2015, Apple announced “App Transport Security” for iOS 9 and OSX 10.11 El Capitan. The <a href="https://developer.apple.com/library/prerelease/ios/releasenotes/General/WhatsNewIniOS/Articles/iOS9.html#//apple_ref/doc/uid/TP40016198-SW1" target="_blank" rel="external">“What’s New in iOS”</a> guide for iOS 9 explains:</p>
<blockquote>
<p>App Transport Security (ATS) lets an app add a declaration to its Info.plist file that specifies the domains with which it needs secure communication. ATS prevents accidental disclosure, provides secure default behavior, and is easy to adopt. You should adopt ATS as soon as possible, regardless of whether you’re creating a new app or updating an existing one.<br>If you’re developing a new app, you should use HTTPS exclusively. If you have an existing app, you should use HTTPS as much as you can right now, and create a plan for migrating the rest of your app as soon as possible.</p>
</blockquote>
<p>In simple terms, this means that if your application attempts to connect to any HTTP server (in this example, yourserver.com) that doesn’t support the latest SSL technology (TLSv1.2), your connections will fail with an error like this:<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFNetwork SSLHandshake failed (-<span class="number">9801</span>)</span><br><span class="line">Error <span class="variable">Domain=</span>NSURLErrorDomain <span class="variable">Code=</span>-<span class="number">1200</span> <span class="string">"An SSL error has occurred and a secure connection to the server cannot be made."</span> <span class="variable">UserInfo=</span><span class="number">0</span>x7fb080442170 &#123;<span class="variable">NSURLErrorFailingURLPeerTrustErrorKey=</span>&lt;SecTrustRef: <span class="number">0</span>x7fb08043b380&gt;, <span class="variable">NSLocalizedRecoverySuggestion=</span>Would you like to connect to the server anyway?, <span class="variable">_kCFStreamErrorCodeKey=</span>-<span class="number">9802</span>, <span class="variable">NSUnderlyingError=</span><span class="number">0</span>x7fb08055bc00 <span class="string">"The operation couldn’t be completed. (kCFErrorDomainCFNetwork error -1200.)"</span>, <span class="variable">NSLocalizedDescription=</span>An SSL error has occurred <span class="constant">and</span> a secure connection to the server cannot be made., <span class="variable">NSErrorFailingURLKey=</span>https://yourserver.com, <span class="variable">NSErrorFailingURLStringKey=</span>https://yourserver.com, <span class="variable">_kCFStreamErrorDomainKey=</span><span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>Curiously, you’ll notice that the connection attempts to change the http protocol to https to protect against mistakes in your code where you may have accidentally misconfigured the URL. In some cases, this might actually work, but it’s also confusing.</p>
<h3 id="WARNING:_ATS_is_good_for_you_and_your_users_and_you_shouldn’t_disable_it!"><strong>WARNING: ATS is good for you and your users and you shouldn’t disable it!</strong></h3><p>The reason why Apple is pushing so aggressively to force secure connections is because it’s the right thing to do. Protecting personal data from being compromised over insecure wireless connections, among other things, is great for users. Just because these exceptions exist doesn’t mean you should actually use them.</p>
<p>If your application is connecting to third party APIs that you can’t control (such as in my case, where my application Routesy connects to public transit APIs that don’t yet support SSL) or serving as a means to load syndicated content (a browser or a news reader, for instance), these techniques might be useful to you.</p>
<p>The bottom line is, if you run your own API server, FIX YOUR SSL. Thanks to Dave DeLong for reminding me that I should clarify that disabling ATS is a bad idea.</p>
<p>That being said…<br><a id="more"></a></p>
<h3 id="How_to_Bypass_App_Transport_Security">How to Bypass App Transport Security</h3><p>Unfortunately, the pre-release documentation doesn’t currently include any references to this key, so many developers who are testing their preexisting apps with the new betas have been receiving this error and aren’t sure what to do about it. Thanks to some digging through the strings in the CFNetwork executable bundled with Xcode 7, I was able to find the keys necessary to configure your Info.plist.</p>
<p>Per-Domain Exceptions</p>
<p>To configure a per-domain exception so that your app can connect to a non-secure (or non TLSv1.2-enabled secure host), add these keys to your Info.plist (and note that Xcode doesn’t currently auto-complete these keys as of the first Xcode 7 beta seed):</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">key</span>&gt;</span>NSAppTransportSecurity<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">dict</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">key</span>&gt;</span>NSExceptionDomains<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">key</span>&gt;</span>yourserver.com<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">dict</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--Include to allow subdomains--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">key</span>&gt;</span>NSIncludesSubdomains<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">true</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--Include to allow insecure HTTP requests--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">key</span>&gt;</span>NSTemporaryExceptionAllowsInsecureHTTPLoads<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">true</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--Include to specify minimum TLS version--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">key</span>&gt;</span>NSTemporaryExceptionMinimumTLSVersion<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">string</span>&gt;</span>TLSv1.1<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">dict</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dict</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>There are other keys that you can use to configure App Transport Security as well, such as:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSRequiresCertificateTransparency</span></span><br><span class="line"><span class="built_in">NSTemporaryExceptionRequiresForwardSecrecy</span></span><br><span class="line"><span class="built_in">NSTemporaryThirdPartyExceptionAllowsInsecureHTTPLoads</span></span><br><span class="line"><span class="built_in">NSTemporaryThirdPartyExceptionMinimumTLSVersion</span></span><br><span class="line"><span class="built_in">NSTemporaryThirdPartyExceptionRequiresForwardSecrecy</span></span><br></pre></td></tr></table></figure></p>
<p>When the Apple documentation is updated, you should familiarize yourself with these other keys and how they’re used. Also, note that some of these keys were listen incorrectly in the “Privacy and Your App” session at WWDC 2015 (NSExceptionAllowsInsecureHTTPLoads instead of NSTemporaryExceptionAllowsInsecureHTTPLoads, for instance). The keys listed above are the correct ones.</p>
<h3 id="But_What_If_I_Don’t_Know_All_the_Insecure_Domains_I_Need_to_Use?">But What If I Don’t Know All the Insecure Domains I Need to Use?</h3><p>If your app (a third-party web browser, for instance) needs to load arbitrary content, Apple provides a way to disable ATS altogether, but I suspect it’s wise for you to use this capability sparingly:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">key</span>&gt;</span>NSAppTransportSecurity<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">dict</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Connect to anything (this is probably BAD)--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">key</span>&gt;</span>NSAllowsArbitraryLoads<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">true</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dict</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Configuring_App_Transport_Security_Exceptions_in_iOS_9_and_OSX_10-11">Configuring App Transport Security Exceptions in iOS 9 and OSX 10.11</h2><h3 id="What_is_App_Transport_Security_(ATS)?">What is App Transport Security (ATS)?</h3><p>At WWDC 2015, Apple announced “App Transport Security” for iOS 9 and OSX 10.11 El Capitan. The <a href="https://developer.apple.com/library/prerelease/ios/releasenotes/General/WhatsNewIniOS/Articles/iOS9.html#//apple_ref/doc/uid/TP40016198-SW1">“What’s New in iOS”</a> guide for iOS 9 explains:</p>
<blockquote>
<p>App Transport Security (ATS) lets an app add a declaration to its Info.plist file that specifies the domains with which it needs secure communication. ATS prevents accidental disclosure, provides secure default behavior, and is easy to adopt. You should adopt ATS as soon as possible, regardless of whether you’re creating a new app or updating an existing one.<br>If you’re developing a new app, you should use HTTPS exclusively. If you have an existing app, you should use HTTPS as much as you can right now, and create a plan for migrating the rest of your app as soon as possible.</p>
</blockquote>
<p>In simple terms, this means that if your application attempts to connect to any HTTP server (in this example, yourserver.com) that doesn’t support the latest SSL technology (TLSv1.2), your connections will fail with an error like this:<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFNetwork SSLHandshake failed (-<span class="number">9801</span>)</span><br><span class="line">Error <span class="variable">Domain=</span>NSURLErrorDomain <span class="variable">Code=</span>-<span class="number">1200</span> <span class="string">"An SSL error has occurred and a secure connection to the server cannot be made."</span> <span class="variable">UserInfo=</span><span class="number">0</span>x7fb080442170 &#123;<span class="variable">NSURLErrorFailingURLPeerTrustErrorKey=</span>&lt;SecTrustRef: <span class="number">0</span>x7fb08043b380&gt;, <span class="variable">NSLocalizedRecoverySuggestion=</span>Would you like to connect to the server anyway?, <span class="variable">_kCFStreamErrorCodeKey=</span>-<span class="number">9802</span>, <span class="variable">NSUnderlyingError=</span><span class="number">0</span>x7fb08055bc00 <span class="string">"The operation couldn’t be completed. (kCFErrorDomainCFNetwork error -1200.)"</span>, <span class="variable">NSLocalizedDescription=</span>An SSL error has occurred <span class="constant">and</span> a secure connection to the server cannot be made., <span class="variable">NSErrorFailingURLKey=</span>https://yourserver.com, <span class="variable">NSErrorFailingURLStringKey=</span>https://yourserver.com, <span class="variable">_kCFStreamErrorDomainKey=</span><span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>Curiously, you’ll notice that the connection attempts to change the http protocol to https to protect against mistakes in your code where you may have accidentally misconfigured the URL. In some cases, this might actually work, but it’s also confusing.</p>
<h3 id="WARNING:_ATS_is_good_for_you_and_your_users_and_you_shouldn’t_disable_it!"><strong>WARNING: ATS is good for you and your users and you shouldn’t disable it!</strong></h3><p>The reason why Apple is pushing so aggressively to force secure connections is because it’s the right thing to do. Protecting personal data from being compromised over insecure wireless connections, among other things, is great for users. Just because these exceptions exist doesn’t mean you should actually use them.</p>
<p>If your application is connecting to third party APIs that you can’t control (such as in my case, where my application Routesy connects to public transit APIs that don’t yet support SSL) or serving as a means to load syndicated content (a browser or a news reader, for instance), these techniques might be useful to you.</p>
<p>The bottom line is, if you run your own API server, FIX YOUR SSL. Thanks to Dave DeLong for reminding me that I should clarify that disabling ATS is a bad idea.</p>
<p>That being said…<br>]]>
    
    </summary>
    
      <category term="ATS" scheme="http://ytlvy.com/tags/ATS/"/>
    
      <category term="IOS9" scheme="http://ytlvy.com/tags/IOS9/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
</feed>