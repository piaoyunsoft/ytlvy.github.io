<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Yt's Blog]]></title>
  <subtitle><![CDATA[Valar Morghulis]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://ytlvy.com//"/>
  <updated>2015-07-19T09:20:13.000Z</updated>
  <id>http://ytlvy.com//</id>
  
  <author>
    <name><![CDATA[Yt]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[iOS CoreText Advance]]></title>
    <link href="http://ytlvy.com/2015/07/19/iOS-CoreText-Advance/"/>
    <id>http://ytlvy.com/2015/07/19/iOS-CoreText-Advance/</id>
    <published>2015-07-19T09:19:58.000Z</published>
    <updated>2015-07-19T09:20:13.000Z</updated>
    <content type="html"><![CDATA[<h2 id="版权说明">版权说明</h2><p>原创文章，转载请保留以下信息：</p>
<p>本文节选自我的图书：《iOS 开发进阶 》。<br>本文涉及的 Demo 工程在这里：<a href="https://github.com/tangqiaoboy/iOS-Pro。" target="_blank" rel="external">https://github.com/tangqiaoboy/iOS-Pro。</a><br>扫码关注我的「iOS 开发」微信公众帐号：<br><img src="http://blog.devtang.com/images/weixin-qr.jpg" alt=""></p>
<hr>
<h2 id="基于_CoreText_的排版引擎：进阶">基于 CoreText 的排版引擎：进阶</h2><h3 id="本章前言">本章前言</h3><p>在上一篇《基于 CoreText 的排版引擎：基础》中，我们学会了排版的基础知识，现在我们来增加复杂性，让我们的排版引擎支持图片和链接的点击。</p>
<h3 id="支持图文混排的排版引擎">支持图文混排的排版引擎</h3><h4 id="改造模版文件">改造模版文件</h4><p>下面我们来进一步改造，让排版引擎支持对于图片的排版。在上一小节中，我们在设置模版文件的时候，就专门在模板文件里面留了一个名为<code>type</code>的字段，用于表示内容的类型。之前的<code>type</code>的值都是txt，这次，我们增加一个值为<code>img</code>的值，用于表示图片。</p>
<p>我们将上一节的<code>content.json</code>文件修改为如下内容，增加了 2 个<code>type</code>值为<code>img</code>的配置项。由于是图片的配置项，所以我们不需要设置颜色，字号这些图片不具有的属性，但是，我们另外增加了 3 个图片的配置属性：</p>
<ol>
<li>一个名为width的属性，用于设置图片显示的宽度。</li>
<li>一个名为height的属性，用于设置图片显示的高度。</li>
<li>一个名为name的属性，用于设置图片的资源名。</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[ &#123;</span><br><span class="line">    "<span class="attribute">type</span>" : <span class="value"><span class="string">"img"</span></span>,</span><br><span class="line">    "<span class="attribute">width</span>" : <span class="value"><span class="number">200</span></span>,</span><br><span class="line">    "<span class="attribute">height</span>" : <span class="value"><span class="number">108</span></span>,</span><br><span class="line">    "<span class="attribute">name</span>" : <span class="value"><span class="string">"coretext-image-1.jpg"</span></span><br><span class="line">  </span>&#125;,</span><br><span class="line">  &#123; "<span class="attribute">color</span>" : <span class="value"><span class="string">"blue"</span></span>,</span><br><span class="line">    "<span class="attribute">content</span>" : <span class="value"><span class="string">" 更进一步地，实际工作中，我们更希望通过一个排版文件，来设置需要排版的文字的 "</span></span>,</span><br><span class="line">    "<span class="attribute">size</span>" : <span class="value"><span class="number">16</span></span>,</span><br><span class="line">    "<span class="attribute">type</span>" : <span class="value"><span class="string">"txt"</span></span><br><span class="line">  </span>&#125;,</span><br><span class="line">  &#123; "<span class="attribute">color</span>" : <span class="value"><span class="string">"red"</span></span>,</span><br><span class="line">    "<span class="attribute">content</span>" : <span class="value"><span class="string">" 内容、颜色、字体 "</span></span>,</span><br><span class="line">    "<span class="attribute">size</span>" : <span class="value"><span class="number">22</span></span>,</span><br><span class="line">    "<span class="attribute">type</span>" : <span class="value"><span class="string">"txt"</span></span><br><span class="line">  </span>&#125;,</span><br><span class="line">  &#123; "<span class="attribute">color</span>" : <span class="value"><span class="string">"black"</span></span>,</span><br><span class="line">    "<span class="attribute">content</span>" : <span class="value"><span class="string">" 大小等信息。\n"</span></span>,</span><br><span class="line">    "<span class="attribute">size</span>" : <span class="value"><span class="number">16</span></span>,</span><br><span class="line">    "<span class="attribute">type</span>" : <span class="value"><span class="string">"txt"</span></span><br><span class="line">  </span>&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    "<span class="attribute">type</span>" : <span class="value"><span class="string">"img"</span></span>,</span><br><span class="line">    "<span class="attribute">width</span>" : <span class="value"><span class="number">200</span></span>,</span><br><span class="line">    "<span class="attribute">height</span>" : <span class="value"><span class="number">130</span></span>,</span><br><span class="line">    "<span class="attribute">name</span>" : <span class="value"><span class="string">"coretext-image-2.jpg"</span></span><br><span class="line">  </span>&#125;,</span><br><span class="line">  &#123; "<span class="attribute">color</span>" : <span class="value"><span class="string">"default"</span></span>,</span><br><span class="line">    "<span class="attribute">content</span>" : <span class="value"><span class="string">" 我在开发猿题库应用时，自己定义了一个基于 UBB 的排版模版，但是实现该排版文件的解析器要花费大量的篇幅，考虑到这并不是本章的重点，所以我们以一个较简单的排版文件来讲解其思想。"</span></span>,</span><br><span class="line">    "<span class="attribute">type</span>" : <span class="value"><span class="string">"txt"</span></span><br><span class="line">  </span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>按理说，图片本身的内容信息中，是包含宽度和高度信息的，为什么我们要在这里指定图片的宽高呢？这主要是因为，在真实的开发中，应用的模版和图片通常是通过服务器获取的，模版是纯文本的内容，获取速度比图片快很多，而图片不但获取速度慢，而且为了省流量，通常的做法是直到需要显示图片的时候，再加载图片内容。</p>
<p>如果我们不将图片的宽度和高度信息设置在模板里面，那么 CoreText 在排版的时候就无法知道绘制所需要的高度，我们就无法设置<code>CoreTextData</code>类中的<code>height</code>信息，没有高度信息，就会对 <code>UITableView</code> 一类的控件排版造成影响。所以，除非你的应用图片能够保证在绘制前都能全部在本地，否则就应该另外提前提供图片宽度和高度信息。</p>
<p>在完成模板文件修改后，我们选取两张测试用的图片，分别将其命名为<code>coretext-image-1.jpg</code>和<code>coretext-image-2.jpg</code>（和模板中的值一致），将其拖动增加到工程中。向 Xcode 工程增加图片资源是基础知识，在此就不详细介绍过程了。</p>
<h4 id="CTLine_与_CTRun">CTLine 与 CTRun</h4><p>接下来我们需要改造的是<code>CTFrameParser</code>类，让解析模板文件的方法支持type为img的配置。</p>
<p>在改造前，我们先来了解一下<code>CTFrame</code>内部的组成。通过之前的例子，我们可以看到，我们首先通过<code>NSAttributeString</code>和配置信息创建 <code>CTFrameSetter</code>， 然后，再通过<code>CTFrameSetter</code>来创建<code>CTFrame</code>。</p>
<p>在<code>CTFrame</code>内部，是由多个<code>CTLine</code>来组成的，每个<code>CTLine</code>代表一行，每个<code>CTLine</code>又是由多个<code>CTRun</code>来组成，每个<code>CTRun</code>代表一组显示风格一致的文本。我们不用手工管理<code>CTLine</code>和<code>CTRun</code>的创建过程。</p>
<p>下图是一个<code>CTLine</code>和<code>CTRun</code>的示意图，可以看到，第三行的<code>CTLine</code>是由 2 个<code>CTRun</code>构成的，第一个<code>CTRun</code>为红色大字号的左边部分，第二个<code>CTRun</code>为右边字体较小的部分。</p>
<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-ctline.jpg" alt=""></p>
<p>虽然我们不用管理<code>CTRun</code>的创建过程，但是我们可以设置某一个具体的<code>CTRun</code>的<code>CTRunDelegate</code>来指定该文本在绘制时的高度、宽度、排列对齐方式等信息。</p>
<p>对于图片的排版，其实 <code>CoreText</code>本质上不是直接支持的，但是，我们可以在要显示文本的地方，用一个特殊的空白字符代替，同时设置该字体的<code>CTRunDelegate</code>信息为要显示的图片的宽度和高度信息，这样最后生成的<code>CTFrame</code>实例，就会在绘制时将图片的位置预留出来。</p>
<p>因为我们的<code>CTDisplayView</code>的绘制代码是在<code>drawRect</code>里面的，所以我们可以方便地把需要绘制的图片，用<code>CGContextDrawImage</code>方法直接绘制出来就可以了。</p>
<h4 id="改造模版解析类">改造模版解析类</h4><p>在了解了以上原理后，我们就可以开始进行改造了。</p>
<p>我们需要做的工作包括：</p>
<ol>
<li>改造CTFrameParser的parseTemplateFile:(NSString <em>)path config:(CTFrameParserConfig</em>)config;方法，使其支持对type为img的节点解析。并且对type为img的节点，设置其CTRunDelegate信息，使其在绘制时，为图片预留相应的空白位置。</li>
<li>改造CoreTextData类，增加图片相关的信息，并且增加计算图片绘制区域的逻辑。</li>
<li>改造CTDisplayView类，增加绘制图片相关的逻辑。</li>
</ol>
<p>首先介绍对于<code>CTFrameParser</code>的改造：</p>
<p>我们修改了<code>parseTemplateFile</code>方法，增加了一个名为<code>imageArray</code>的参数来保存解析时的图片信息。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (CoreTextData *)<span class="string">parseTemplateFile:</span>(NSString *)path <span class="string">config:</span>(CTFrameParserConfig*)config &#123;</span><br><span class="line">    NSMutableArray *imageArray = [NSMutableArray array];</span><br><span class="line">    NSAttributedString *content = [self <span class="string">loadTemplateFile:</span>path <span class="string">config:</span>config <span class="string">imageArray:</span>imageArray];</span><br><span class="line">    CoreTextData *data = [self <span class="string">parseAttributedContent:</span>content <span class="string">config:</span>config];</span><br><span class="line">    data.imageArray = imageArray;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着我们修改<code>loadTemplateFile</code>方法，增加了对于type是img的节点处理逻辑，该逻辑主要做 2 件事情：</p>
<ol>
<li>保存当前图片节点信息到imageArray变量中</li>
<li>新建一个空白的占位符。</li>
</ol>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> (<span class="type">NSAttributedString</span> *)loadTemplateFile:(<span class="type">NSString</span> *)path</span><br><span class="line">                                  config:(<span class="type">CTFrameParserConfig</span>*)config</span><br><span class="line">                              imageArray:(<span class="type">NSMutableArray</span> *)imageArray &#123;</span><br><span class="line">    <span class="type">NSData</span> *data = [<span class="type">NSData</span> dataWithContentsOfFile:path];</span><br><span class="line">    <span class="type">NSMutableAttributedString</span> *<span class="literal">result</span> = [[<span class="type">NSMutableAttributedString</span> alloc] init];</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        <span class="type">NSArray</span> *<span class="type">array</span> = [<span class="type">NSJSONSerialization</span> <span class="type">JSONObjectWithData</span>:data</span><br><span class="line">                             options:<span class="type">NSJSONReadingAllowFragments</span></span><br><span class="line">                               error:<span class="keyword">nil</span>];</span><br><span class="line">        <span class="keyword">if</span> ([<span class="type">array</span> isKindOfClass:[<span class="type">NSArray</span> class]]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">NSDictionary</span> *dict <span class="keyword">in</span> <span class="type">array</span>) &#123;</span><br><span class="line">                <span class="type">NSString</span> *<span class="keyword">type</span> = dict[@<span class="string">"type"</span>];</span><br><span class="line">                <span class="keyword">if</span> ([<span class="keyword">type</span> isEqualToString:@<span class="string">"txt"</span>]) &#123;</span><br><span class="line">                    <span class="type">NSAttributedString</span> *<span class="keyword">as</span> =</span><br><span class="line">                        [self parseAttributedContentFromNSDictionary:dict</span><br><span class="line">                                                              config:config];</span><br><span class="line">                    [<span class="literal">result</span> appendAttributedString:<span class="keyword">as</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">type</span> isEqualToString:@<span class="string">"img"</span>]) &#123;</span><br><span class="line">                    // 创建 <span class="type">CoreTextImageData</span></span><br><span class="line">                    <span class="type">CoreTextImageData</span> *imageData = [[<span class="type">CoreTextImageData</span> alloc] init];</span><br><span class="line">                    imageData.name = dict[@<span class="string">"name"</span>];</span><br><span class="line">                    imageData.position = [<span class="literal">result</span> length];</span><br><span class="line">                    [imageArray addObject:imageData];</span><br><span class="line">                    // 创建空白占位符，并且设置它的 <span class="type">CTRunDelegate</span> 信息</span><br><span class="line">                    <span class="type">NSAttributedString</span> *<span class="keyword">as</span> = [self parseImageDataFromNSDictionary:dict config:config];</span><br><span class="line">                    [<span class="literal">result</span> appendAttributedString:<span class="keyword">as</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们新建一个最关键的方法：<code>parseImageDataFromNSDictionary</code>，生成图片空白的占位符，并且设置其<code>CTRunDelegate</code>信息。其代码如下：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">CGFloat</span> ascentCallback(<span class="type">void</span> *<span class="keyword">ref</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> [(<span class="type">NSNumber</span>*)[(__bridge <span class="type">NSDictionary</span>*)<span class="keyword">ref</span> objectForKey:@<span class="string">"height"</span>] floatValue];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">CGFloat</span> descentCallback(<span class="type">void</span> *<span class="keyword">ref</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">CGFloat</span> widthCallback(<span class="type">void</span>* <span class="keyword">ref</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> [(<span class="type">NSNumber</span>*)[(__bridge <span class="type">NSDictionary</span>*)<span class="keyword">ref</span> objectForKey:@<span class="string">"width"</span>] floatValue];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">NSAttributedString</span> *)parseImageDataFromNSDictionary:(<span class="type">NSDictionary</span> *)dict</span><br><span class="line">                                                config:(<span class="type">CTFrameParserConfig</span>*)config &#123;</span><br><span class="line">    <span class="type">CTRunDelegateCallbacks</span> callbacks;</span><br><span class="line">    memset(&amp;callbacks, <span class="number">0</span>, sizeof(<span class="type">CTRunDelegateCallbacks</span>));</span><br><span class="line">    callbacks.version = kCTRunDelegateVersion1;</span><br><span class="line">    callbacks.getAscent = ascentCallback;</span><br><span class="line">    callbacks.getDescent = descentCallback;</span><br><span class="line">    callbacks.getWidth = widthCallback;</span><br><span class="line">    <span class="type">CTRunDelegateRef</span> delegate = <span class="type">CTRunDelegateCreate</span>(&amp;callbacks, (__bridge <span class="type">void</span> *)(dict));</span><br><span class="line"></span><br><span class="line">    // 使用 <span class="number">0xFFFC</span> 作为空白的占位符</span><br><span class="line">    unichar objectReplacementChar = <span class="number">0xFFFC</span>;</span><br><span class="line">    <span class="type">NSString</span> * content = [<span class="type">NSString</span> stringWithCharacters:&amp;objectReplacementChar length:<span class="number">1</span>];</span><br><span class="line">    <span class="type">NSDictionary</span> * attributes = [self attributesWithConfig:config];</span><br><span class="line">    <span class="type">NSMutableAttributedString</span> * space =</span><br><span class="line">       [[<span class="type">NSMutableAttributedString</span> alloc] initWithString:content</span><br><span class="line">                                              attributes:attributes];</span><br><span class="line">    <span class="type">CFAttributedStringSetAttribute</span>((<span class="type">CFMutableAttributedStringRef</span>)space,</span><br><span class="line">              <span class="type">CFRangeMake</span>(<span class="number">0</span>, <span class="number">1</span>), kCTRunDelegateAttributeName, delegate);</span><br><span class="line">    <span class="type">CFRelease</span>(delegate);</span><br><span class="line">    <span class="keyword">return</span> space;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着我们对<code>CoreTextData</code>进行改造，增加了<code>imageArray</code>成员变量，用于保存图片绘制时所需的信息。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"CoreTextImageData.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CoreTextData</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) CTFrameRef ctFrame;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> height;</span><br><span class="line"><span class="comment">// 新增加的成员</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSArray</span> * imageArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>在设置<code>imageArray</code>成员时，我们还会调一个新创建的fillImagePosition方法，用于找到每张图片在绘制时的位置。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setImageArray:(<span class="built_in">NSArray</span> *)imageArray &#123;</span><br><span class="line">    _imageArray = imageArray;</span><br><span class="line">    [<span class="keyword">self</span> fillImagePosition];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)fillImagePosition &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.imageArray</span><span class="variable">.count</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSArray</span> *lines = (<span class="built_in">NSArray</span> *)CTFrameGetLines(<span class="keyword">self</span><span class="variable">.ctFrame</span>);</span><br><span class="line">    <span class="keyword">int</span> lineCount = [lines count];</span><br><span class="line">    <span class="built_in">CGPoint</span> lineOrigins[lineCount];</span><br><span class="line">    CTFrameGetLineOrigins(<span class="keyword">self</span><span class="variable">.ctFrame</span>, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="number">0</span>), lineOrigins);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> imgIndex = <span class="number">0</span>;</span><br><span class="line">    CoreTextImageData * imageData = <span class="keyword">self</span><span class="variable">.imageArray</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lineCount; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (imageData == <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        CTLineRef line = (__bridge CTLineRef)lines[i];</span><br><span class="line">        <span class="built_in">NSArray</span> * runObjArray = (<span class="built_in">NSArray</span> *)CTLineGetGlyphRuns(line);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> runObj <span class="keyword">in</span> runObjArray) &#123;</span><br><span class="line">            CTRunRef run = (__bridge CTRunRef)runObj;</span><br><span class="line">            <span class="built_in">NSDictionary</span> *runAttributes = (<span class="built_in">NSDictionary</span> *)CTRunGetAttributes(run);</span><br><span class="line">            CTRunDelegateRef delegate = (__bridge CTRunDelegateRef)[runAttributes valueForKey:(<span class="keyword">id</span>)kCTRunDelegateAttributeName];</span><br><span class="line">            <span class="keyword">if</span> (delegate == <span class="literal">nil</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSDictionary</span> * metaDic = CTRunDelegateGetRefCon(delegate);</span><br><span class="line">            <span class="keyword">if</span> (![metaDic isKindOfClass:[<span class="built_in">NSDictionary</span> class]]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">CGRect</span> runBounds;</span><br><span class="line">            <span class="built_in">CGFloat</span> ascent;</span><br><span class="line">            <span class="built_in">CGFloat</span> descent;</span><br><span class="line">            runBounds<span class="variable">.size</span><span class="variable">.width</span> = CTRunGetTypographicBounds(run, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="number">0</span>), &amp;ascent, &amp;descent, <span class="literal">NULL</span>);</span><br><span class="line">            runBounds<span class="variable">.size</span><span class="variable">.height</span> = ascent + descent;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">CGFloat</span> xOffset = CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run)<span class="variable">.location</span>, <span class="literal">NULL</span>);</span><br><span class="line">            runBounds<span class="variable">.origin</span><span class="variable">.x</span> = lineOrigins[i]<span class="variable">.x</span> + xOffset;</span><br><span class="line">            runBounds<span class="variable">.origin</span><span class="variable">.y</span> = lineOrigins[i]<span class="variable">.y</span>;</span><br><span class="line">            runBounds<span class="variable">.origin</span><span class="variable">.y</span> -= descent;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">CGPathRef</span> pathRef = CTFrameGetPath(<span class="keyword">self</span><span class="variable">.ctFrame</span>);</span><br><span class="line">            <span class="built_in">CGRect</span> colRect = <span class="built_in">CGPathGetBoundingBox</span>(pathRef);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">CGRect</span> delegateBounds = <span class="built_in">CGRectOffset</span>(runBounds, colRect<span class="variable">.origin</span><span class="variable">.x</span>, colRect<span class="variable">.origin</span><span class="variable">.y</span>);</span><br><span class="line"></span><br><span class="line">            imageData<span class="variable">.imagePosition</span> = delegateBounds;</span><br><span class="line">            imgIndex++;</span><br><span class="line">            <span class="keyword">if</span> (imgIndex == <span class="keyword">self</span><span class="variable">.imageArray</span><span class="variable">.count</span>) &#123;</span><br><span class="line">                imageData = <span class="literal">nil</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                imageData = <span class="keyword">self</span><span class="variable">.imageArray</span>[imgIndex];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加对图片的点击支持">添加对图片的点击支持</h3><h4 id="实现方式">实现方式</h4><p>为了实现对图片的点击支持，我们需要给<code>CTDisplayView</code>类增加用户点击操作的检测函数，在检测函数中，判断当前用户点击的区域是否在图片上，如果在图片上，则触发点击图片的逻辑。苹果提供的<code>UITapGestureRecognizer</code>可以很好的满足我们的要求，所以我们这里用它来检测用户的点击操作。</p>
<p>我们这里实现的是点击图片后，先用NSLog打印出一行日志。实际应用中，读者可以根据业务需求自行调整点击后的效果。</p>
<p>我们先为CTDisplayView类增加<code>UITapGestureRecognizer</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithCoder:aDecoder];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> setupEvents];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setupEvents &#123;</span><br><span class="line">    <span class="built_in">UIGestureRecognizer</span> * tapRecognizer =</span><br><span class="line">          [[<span class="built_in">UITapGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span></span><br><span class="line">                    action:<span class="keyword">@selector</span>(userTapGestureDetected:)];</span><br><span class="line">    tapRecognizer<span class="variable">.delegate</span> = <span class="keyword">self</span>;</span><br><span class="line">    [<span class="keyword">self</span> addGestureRecognizer:tapRecognizer];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.userInteractionEnabled</span> = <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后增加<code>UITapGestureRecognizer</code>的回调函数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)userTapGestureDetected:(<span class="built_in">UIGestureRecognizer</span> *)recognizer &#123;</span><br><span class="line">    <span class="built_in">CGPoint</span> point = [recognizer locationInView:<span class="keyword">self</span>];</span><br><span class="line">    <span class="keyword">for</span> (CoreTextImageData * imageData <span class="keyword">in</span> <span class="keyword">self</span><span class="variable">.data</span><span class="variable">.imageArray</span>) &#123;</span><br><span class="line">        <span class="comment">// 翻转坐标系，因为 imageData 中的坐标是 CoreText 的坐标系</span></span><br><span class="line">        <span class="built_in">CGRect</span> imageRect = imageData<span class="variable">.imagePosition</span>;</span><br><span class="line">        <span class="built_in">CGPoint</span> imagePosition = imageRect<span class="variable">.origin</span>;</span><br><span class="line">        imagePosition<span class="variable">.y</span> = <span class="keyword">self</span><span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.height</span> - imageRect<span class="variable">.origin</span><span class="variable">.y</span></span><br><span class="line">                          - imageRect<span class="variable">.size</span><span class="variable">.height</span>;</span><br><span class="line">        <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(imagePosition<span class="variable">.x</span>, imagePosition<span class="variable">.y</span>, imageRect<span class="variable">.size</span><span class="variable">.width</span>, imageRect<span class="variable">.size</span><span class="variable">.height</span>);</span><br><span class="line">        <span class="comment">// 检测点击位置 Point 是否在 rect 之内</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">CGRectContainsPoint</span>(rect, point)) &#123;</span><br><span class="line">            <span class="comment">// 在这里处理点击后的逻辑</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"bingo"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="事件处理">事件处理</h4><p>在界面上，<code>CTDisplayView</code>通常在UIView的树形层级结构中，一个 UIView 可能是最外层 View Controller 的 View 的孩子的孩子的孩子（如下图所示）。在这种多级层次结构中，很难通过delegate模式将图片点击的事件一层一层往外层传递，所以最好使用NSNotification，来处理图片点击事件。</p>
<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-uiview-tree.png" alt=""></p>
<p>在 Demo 中，我们在最外层的 <code>View Controller</code>中监听图片点击的通知，当收到通知后，进入到一个新的界面来显示图片点击内容。</p>
<p>注：读者可以将 demo 工程切换到image_click分支，查看示例代码。</p>
<h4 id="添加对链接的点击支持">添加对链接的点击支持</h4><h5 id="修改模板文件">修改模板文件</h5><p>我们修改模版文件，增加一个名为 link 的类型，用于表示链接内容。如下所示：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; "<span class="attribute">color</span>" : <span class="value"><span class="string">"default"</span></span>,</span><br><span class="line">    "<span class="attribute">content</span>" : <span class="value"><span class="string">" 这在这里尝试放一个参考链接："</span></span>,</span><br><span class="line">    "<span class="attribute">type</span>" : <span class="value"><span class="string">"txt"</span></span><br><span class="line">  </span>&#125;,</span><br><span class="line">  &#123; "<span class="attribute">color</span>" : <span class="value"><span class="string">"blue"</span></span>,</span><br><span class="line">    "<span class="attribute">content</span>" : <span class="value"><span class="string">" 链接文字 "</span></span>,</span><br><span class="line">    "<span class="attribute">url</span>" : <span class="value"><span class="string">"http://blog.devtang.com"</span></span>,</span><br><span class="line">    "<span class="attribute">type</span>" : <span class="value"><span class="string">"link"</span></span><br><span class="line">  </span>&#125;,</span><br><span class="line">  &#123; "<span class="attribute">color</span>" : <span class="value"><span class="string">"default"</span></span>,</span><br><span class="line">    "<span class="attribute">content</span>" : <span class="value"><span class="string">" 大家可以尝试点击一下 "</span></span>,</span><br><span class="line">    "<span class="attribute">type</span>" : <span class="value"><span class="string">"txt"</span></span><br><span class="line">  </span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h5 id="解析模版中的链接信息">解析模版中的链接信息</h5><p>我们首先增加一个CoreTextLinkData类，用于记录解析 JSON 文件时的链接信息：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">CoreTextLinkData </span>: NSObject</span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span> (strong, nonatomic) NSString * title;</span><br><span class="line"><span class="variable">@property</span> (strong, nonatomic) NSString * url;</span><br><span class="line"><span class="variable">@property</span> (assign, nonatomic) NSRange range;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></p>
<p>然后我们修改 CTFrameParser 类，增加解析链接的逻辑：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">NSAttributedString</span> *)loadTemplateFile:(<span class="type">NSString</span> *)path</span><br><span class="line">                                  config:(<span class="type">CTFrameParserConfig</span>*)config</span><br><span class="line">                              imageArray:(<span class="type">NSMutableArray</span> *)imageArray</span><br><span class="line">                               linkArray:(<span class="type">NSMutableArray</span> *)linkArray &#123;</span><br><span class="line">    <span class="type">NSData</span> *data = [<span class="type">NSData</span> dataWithContentsOfFile:path];</span><br><span class="line">    <span class="type">NSMutableAttributedString</span> *<span class="literal">result</span> = [[<span class="type">NSMutableAttributedString</span> alloc] init];</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        <span class="type">NSArray</span> *<span class="type">array</span> = [<span class="type">NSJSONSerialization</span> <span class="type">JSONObjectWithData</span>:data</span><br><span class="line">                                        options:<span class="type">NSJSONReadingAllowFragments</span></span><br><span class="line">                                          error:<span class="keyword">nil</span>];</span><br><span class="line">        <span class="keyword">if</span> ([<span class="type">array</span> isKindOfClass:[<span class="type">NSArray</span> class]]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">NSDictionary</span> *dict <span class="keyword">in</span> <span class="type">array</span>) &#123;</span><br><span class="line">                <span class="type">NSString</span> *<span class="keyword">type</span> = dict[@<span class="string">"type"</span>];</span><br><span class="line">                <span class="keyword">if</span> ([<span class="keyword">type</span> isEqualToString:@<span class="string">"txt"</span>]) &#123;</span><br><span class="line">                    // 省略</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">type</span> isEqualToString:@<span class="string">"img"</span>]) &#123;</span><br><span class="line">                    // 省略</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">type</span> isEqualToString:@<span class="string">"link"</span>]) &#123;</span><br><span class="line">                    <span class="type">NSUInteger</span> startPos = <span class="literal">result</span>.length;</span><br><span class="line">                    <span class="type">NSAttributedString</span> *<span class="keyword">as</span> =</span><br><span class="line">                       [self parseAttributedContentFromNSDictionary:dict</span><br><span class="line">                                                             config:config];</span><br><span class="line">                    [<span class="literal">result</span> appendAttributedString:<span class="keyword">as</span>];</span><br><span class="line">                    // 创建 <span class="type">CoreTextLinkData</span></span><br><span class="line">                    <span class="type">NSUInteger</span> length = <span class="literal">result</span>.length - startPos;</span><br><span class="line">                    <span class="type">NSRange</span> linkRange = <span class="type">NSMakeRange</span>(startPos, length);</span><br><span class="line">                    <span class="type">CoreTextLinkData</span> *linkData = [[<span class="type">CoreTextLinkData</span> alloc] init];</span><br><span class="line">                    linkData.title = dict[@<span class="string">"content"</span>];</span><br><span class="line">                    linkData.url = dict[@<span class="string">"url"</span>];</span><br><span class="line">                    linkData.<span class="type">range</span> = linkRange;</span><br><span class="line">                    [linkArray addObject:linkData];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们增加一个 Utils 类来专门处理检测用户点击是否在链接上。主要的方法是使用 CTLineGetStringIndexForPosition 函数来获得用户点击的位置与 NSAttributedString 字符串上的位置的对应关系。这样就知道是点击的哪个字符了。然后判断该字符串是否在链接上即可。该 Util 在实现逻辑如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检测点击位置是否在链接上</span></span><br><span class="line">+ (CoreTextLinkData *)touchLinkInView:(<span class="built_in">UIView</span> *)view atPoint:(<span class="built_in">CGPoint</span>)point data:(CoreTextData *)data &#123;</span><br><span class="line">    CTFrameRef textFrame = data<span class="variable">.ctFrame</span>;</span><br><span class="line">    <span class="built_in">CFArrayRef</span> lines = CTFrameGetLines(textFrame);</span><br><span class="line">    <span class="keyword">if</span> (!lines) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">CFIndex</span> count = <span class="built_in">CFArrayGetCount</span>(lines);</span><br><span class="line">    CoreTextLinkData *foundLink = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得每一行的 origin 坐标</span></span><br><span class="line">    <span class="built_in">CGPoint</span> origins[count];</span><br><span class="line">    CTFrameGetLineOrigins(textFrame, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>,<span class="number">0</span>), origins);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 翻转坐标系</span></span><br><span class="line">    <span class="built_in">CGAffineTransform</span> transform =  <span class="built_in">CGAffineTransformMakeTranslation</span>(<span class="number">0</span>, view<span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.height</span>);</span><br><span class="line">    transform = <span class="built_in">CGAffineTransformScale</span>(transform, <span class="number">1.</span>f, -<span class="number">1.</span>f);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="built_in">CGPoint</span> linePoint = origins[i];</span><br><span class="line">        CTLineRef line = <span class="built_in">CFArrayGetValueAtIndex</span>(lines, i);</span><br><span class="line">        <span class="comment">// 获得每一行的 CGRect 信息</span></span><br><span class="line">        <span class="built_in">CGRect</span> flippedRect = [<span class="keyword">self</span> getLineBounds:line point:linePoint];</span><br><span class="line">        <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectApplyAffineTransform</span>(flippedRect, transform);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">CGRectContainsPoint</span>(rect, point)) &#123;</span><br><span class="line">            <span class="comment">// 将点击的坐标转换成相对于当前行的坐标</span></span><br><span class="line">            <span class="built_in">CGPoint</span> relativePoint = <span class="built_in">CGPointMake</span>(point<span class="variable">.x</span>-<span class="built_in">CGRectGetMinX</span>(rect),</span><br><span class="line">                                                point<span class="variable">.y</span>-<span class="built_in">CGRectGetMinY</span>(rect));</span><br><span class="line">            <span class="comment">// 获得当前点击坐标对应的字符串偏移</span></span><br><span class="line">            <span class="built_in">CFIndex</span> idx = CTLineGetStringIndexForPosition(line, relativePoint);</span><br><span class="line">            <span class="comment">// 判断这个偏移是否在我们的链接列表中</span></span><br><span class="line">            foundLink = [<span class="keyword">self</span> linkAtIndex:idx linkArray:data<span class="variable">.linkArray</span>];</span><br><span class="line">            <span class="keyword">return</span> foundLink;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">CGRect</span>)getLineBounds:(CTLineRef)line point:(<span class="built_in">CGPoint</span>)point &#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> ascent = <span class="number">0.0</span>f;</span><br><span class="line">    <span class="built_in">CGFloat</span> descent = <span class="number">0.0</span>f;</span><br><span class="line">    <span class="built_in">CGFloat</span> leading = <span class="number">0.0</span>f;</span><br><span class="line">    <span class="built_in">CGFloat</span> width = (<span class="built_in">CGFloat</span>)CTLineGetTypographicBounds(line, &amp;ascent, &amp;descent, &amp;leading);</span><br><span class="line">    <span class="built_in">CGFloat</span> height = ascent + descent;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGRectMake</span>(point<span class="variable">.x</span>, point<span class="variable">.y</span> - descent, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (CoreTextLinkData *)linkAtIndex:(<span class="built_in">CFIndex</span>)i linkArray:(<span class="built_in">NSArray</span> *)linkArray &#123;</span><br><span class="line">    CoreTextLinkData *link = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">for</span> (CoreTextLinkData *data <span class="keyword">in</span> linkArray) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">NSLocationInRange</span>(i, data<span class="variable">.range</span>)) &#123;</span><br><span class="line">            link = data;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> link;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后改造一下CTDisplayView，使其在检测到用户点击后，调用上面的 Util 方法即可。我们这里实现的是点击链接后，先用NSLog打印出一行日志。实际应用中，读者可以根据业务需求自行调整点击后的效果。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)userTapGestureDetected:(<span class="built_in">UIGestureRecognizer</span> *)recognizer &#123;</span><br><span class="line">    <span class="built_in">CGPoint</span> point = [recognizer locationInView:<span class="keyword">self</span>];</span><br><span class="line">    <span class="comment">// 此处省略上一节中介绍的，对图片点击检测的逻辑</span></span><br><span class="line"></span><br><span class="line">    CoreTextLinkData *linkData = [CoreTextUtils touchLinkInView:<span class="keyword">self</span> atPoint:point data:<span class="keyword">self</span><span class="variable">.data</span>];</span><br><span class="line">    <span class="keyword">if</span> (linkData) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"hint link!"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：在 Demo 中工程中，我们实现了点击链接跳转到一个新的界面，然后用 UIWebView 来显示链接内容的逻辑。读者可以将 demo 工程切换到link_click分支，查看示例代码。</p>
<p>Demo 工程的 Gif 效果图如下，读者可以将示例工程用git checkout image_support切换到当前章节状态，查看相关代码逻辑。</p>
<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-demo.gif" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="版权说明">版权说明</h2><p>原创文章，转载请保留以下信息：</p>
<p>本文节选自我的图书：《iOS 开发进阶 》。<br>本文涉及的 Demo 工程在这里：<a href="https://github.com/tangqiaoboy/iOS-Pro。]]>
    </summary>
    
      <category term="CoreText" scheme="http://ytlvy.com/tags/CoreText/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS CoreText Base]]></title>
    <link href="http://ytlvy.com/2015/07/19/iOS-CoreText-Base/"/>
    <id>http://ytlvy.com/2015/07/19/iOS-CoreText-Base/</id>
    <published>2015-07-19T09:19:27.000Z</published>
    <updated>2015-07-19T09:19:44.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://blog.devtang.com/blog/2015/06/27/using-coretext-1/" target="_blank" rel="external">转自</a></p>
<h2 id="转载声明">转载声明</h2><p>原创文章，转载请保留以下信息：</p>
<p>本文节选自我的图书：《iOS 开发进阶 》。<br>本文涉及的 Demo 工程在这里：<a href="https://github.com/tangqiaoboy/iOS-Pro。" target="_blank" rel="external">https://github.com/tangqiaoboy/iOS-Pro。</a><br>扫码关注我的「iOS 开发」微信公众帐号：<br><img src="http://blog.devtang.com/images/weixin-qr.jpg" alt=""></p>
<h2 id="基于_CoreText_的排版引擎：基础">基于 CoreText 的排版引擎：基础</h2><p>使用 CoreText 技术，我们可以对富文本进行复杂的排版。经过一些简单的扩展，我们还可以实现对于图片，链接的点击效果。CoreText 技术相对于 UIWebView，有着更少的内存占用，以及可以在后台渲染的优点，非常适合用于内容的排版工作。</p>
<p>本章我们将从最基本的开始，一步一步完成一个支持图文混排、支持图片和链接点击的排版引擎。</p>
<h3 id="CoreText_简介">CoreText 简介</h3><p>CoreText 是用于处理文字和字体的底层技术。它直接和 Core Graphics（又被称为 Quartz）打交道。Quartz 是一个 2D 图形渲染引擎，能够处理 OSX 和 iOS 中的图形显示。</p>
<p>Quartz 能够直接处理字体（font）和字形（glyphs），将文字渲染到界面上，它是基础库中唯一能够处理字形的模块。因此，CoreText 为了排版，需要将显示的文本内容、位置、字体、字形直接传递给 Quartz。相比其它 UI 组件，由于 CoreText 直接和 Quartz 来交互，所以它具有高速的排版效果。</p>
<p>下图是 CoreText 的架构图，可以看到，CoreText 处于非常底层的位置，上层的 UI 控件（包括 UILabel，UITextField 以及 UITextView）和 UIWebView 都是基于 CoreText 来实现的。</p>
<blockquote>
<p>注意：这个是 iOS7 之后的架构图，在 iOS7 以前，并没有图中的 Text Kit 类，不过 CoreText 仍然是处在最底层直接和 Core Graphics 打交道的模块。</p>
</blockquote>
<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext_arch.png" alt=""></p>
<p>UIWebView 也是处理复杂的文字排版的备选方案。对于排版，基于 CoreText 和基于 UIWebView 相比，前者有以下好处：</p>
<ul>
<li>CoreText 占用的内存更少，渲染速度快，UIWebView 占用的内存更多，渲染速度慢。</li>
<li>CoreText 在渲染界面前就可以精确地获得显示内容的高度（只要有了 CTFrame 即可），而 UIWebView 只有渲染出内容后，才能获得内容的高度（而且还需要用 javascript 代码来获取）</li>
<li>CoreText 的 CTFrame 可以在后台线程渲染，UIWebView 的内容只能在主线程（UI 线程）渲染。</li>
<li>基于 CoreText 可以做更好的原生交互效果，交互效果可以更细腻。而 UIWebView 的交互效果都是用 javascript 来实现的，在交互效果上会有一些卡顿存在。例如，在 UIWebView 下，一个简单的按钮按下效果，都无法做到原生按钮的即时和细腻的按下效果。</li>
</ul>
<p>当然，基于 CoreText 的排版方案也有一些劣势：</p>
<ul>
<li>CoreText 渲染出来的内容不能像 UIWebView 那样方便地支持内容的复制。</li>
<li>基于 CoreText 来排版需要自己处理很多复杂逻辑，例如需要自己处理图片与文字混排相关的逻辑，也需要自己实现链接点击操作的支持。</li>
</ul>
<p>在业界，很多应用都采用了基于 CoreText 技术的排版方案，例如：新浪微博客户端，多看阅读客户端。我所在的创业公司的猿题库，也使用了自己基于 CoreText 技术实现的排版引擎，下图是我们产品的一个图文混排的界面（其中所有公式都是用图片的方式呈现的），可以看到，图片和文字排版效果很好。</p>
<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-1.png" alt=""></p>
<h3 id="基于_CoreText_的基础排版引擎">基于 CoreText 的基础排版引擎</h3><h4 id="不带图片的排版引擎">不带图片的排版引擎</h4><p>下面我们来尝试完成一个基于 CoreText 的排版引擎。我们将从最简单的排版功能开始，然后逐步支持图文混排，链接点击等功能。</p>
<p>首先我们来尝试完成一个不支持图片内容的纯文字排版引擎。</p>
<p>注意 1：由于整个排版引擎的代码太多，为方便读者阅读，文章中只会列出最关键的核心代码，完整的代码请参考本书对应的 github 项目，项目地址是：<a href="https://github.com/tangqiaoboy/iOS-Pro" target="_blank" rel="external">https://github.com/tangqiaoboy/iOS-Pro</a></p>
<h4 id="能输出_Hello_World_的_CoreText_工程">能输出 Hello World 的 CoreText 工程</h4><h5 id="操作步骤">操作步骤</h5><ol>
<li>建立 <code>CoreTextDemo</code> 工程</li>
<li>新建 <code>UIView</code> 子类CTDisplayView</li>
<li>编码如下:</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"CTDisplayView.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"CoreText/CoreText.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CTDisplayView</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> drawRect:rect];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 1</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 2</span></span><br><span class="line">    <span class="built_in">CGContextSetTextMatrix</span>(context, <span class="built_in">CGAffineTransformIdentity</span>);</span><br><span class="line">    <span class="built_in">CGContextTranslateCTM</span>(context, <span class="number">0</span>, <span class="keyword">self</span><span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.height</span>);</span><br><span class="line">    <span class="built_in">CGContextScaleCTM</span>(context, <span class="number">1.0</span>, -<span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 3</span></span><br><span class="line">    <span class="built_in">CGMutablePathRef</span> path = <span class="built_in">CGPathCreateMutable</span>();</span><br><span class="line">    <span class="built_in">CGPathAddRect</span>(path, <span class="literal">NULL</span>, <span class="keyword">self</span><span class="variable">.bounds</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 4</span></span><br><span class="line">    <span class="built_in">NSAttributedString</span> *attString = [[<span class="built_in">NSAttributedString</span> alloc] initWithString:<span class="string">@"Hello World!"</span>];</span><br><span class="line">    CTFramesetterRef framesetter =</span><br><span class="line">    CTFramesetterCreateWithAttributedString((<span class="built_in">CFAttributedStringRef</span>)attString);</span><br><span class="line">    CTFrameRef frame =</span><br><span class="line">    CTFramesetterCreateFrame(framesetter,</span><br><span class="line">                             <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, [attString length]), path, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 5</span></span><br><span class="line">    CTFrameDraw(frame, context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 6</span></span><br><span class="line">    <span class="built_in">CFRelease</span>(frame);</span><br><span class="line">    <span class="built_in">CFRelease</span>(path);</span><br><span class="line">    <span class="built_in">CFRelease</span>(framesetter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<ol>
<li>打开 Storyboard 文件, 新建<code>UIView</code> 并更改类为<code>CTDisplayView</code></li>
</ol>
<h4 id="代码解释">代码解释</h4><p>下面解释一下drawRect方法主要的步骤：</p>
<ol>
<li>得到当前绘制画布的上下文，用于后续将内容绘制在画布上。</li>
<li>将坐标系上下翻转。对于底层的绘制引擎来说，屏幕的左下角是（0, 0）坐标。而对于上层的 UIKit 来说，左上角是 (0, 0) 坐标。所以我们为了之后的坐标系描述按 UIKit 来做，所以先在这里做一个坐标系的上下翻转操作。翻转之后，底层和上层的 (0, 0) 坐标就是重合的了</li>
<li>创建绘制的区域，CoreText 本身支持各种文字排版的区域，我们这里简单地将 UIView 的整个界面作为排版的区域。</li>
</ol>
<p>为了加深理解，我们将该步骤的代码替换成如下代码，测试设置不同的绘制区域带来的界面变化。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤 3</span></span><br><span class="line"><span class="built_in">CGMutablePathRef</span> path = <span class="built_in">CGPathCreateMutable</span>();</span><br><span class="line"><span class="built_in">CGPathAddEllipseInRect</span>(path, <span class="literal">NULL</span>, <span class="keyword">self</span><span class="variable">.bounds</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤 4</span></span><br><span class="line"><span class="built_in">NSAttributedString</span> *attString = [[<span class="built_in">NSAttributedString</span> alloc] initWithString:<span class="string">@"Hello World! "</span></span><br><span class="line">                                 <span class="string">" 创建绘制的区域，CoreText 本身支持各种文字排版的区域，"</span></span><br><span class="line">                                 <span class="string">" 我们这里简单地将 UIView 的整个界面作为排版的区域。"</span></span><br><span class="line">                                 <span class="string">" 为了加深理解，建议读者将该步骤的代码替换成如下代码，"</span></span><br><span class="line">                                 <span class="string">" 测试设置不同的绘制区域带来的界面变化。"</span>];</span><br></pre></td></tr></table></figure></p>
<p>执行结果如下图所示：<br><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-shape.png" alt=""></p>
<h4 id="代码基本的宏定义和_Category">代码基本的宏定义和 Category</h4><p>为了方便我们的代码编写，我在CoreTextDemo-Prefix.pch文件中增加了以下基本的宏定义，以方便我们使用 NSLog 和 UIColor<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="id">#ifdef</span> DEBUG</span><br><span class="line"><span class="hexcolor">#def</span>ine <span class="function"><span class="title">debugLog</span><span class="params">(...)</span></span> <span class="function"><span class="title">NSLog</span><span class="params">(__VA_ARGS__)</span></span></span><br><span class="line"><span class="hexcolor">#def</span>ine <span class="function"><span class="title">debugMethod</span><span class="params">()</span></span> <span class="function"><span class="title">NSLog</span><span class="params">(@<span class="string">"%s"</span>, __func__)</span></span></span><br><span class="line"><span class="id">#else</span></span><br><span class="line"><span class="hexcolor">#def</span>ine <span class="function"><span class="title">debugLog</span><span class="params">(...)</span></span></span><br><span class="line"><span class="hexcolor">#def</span>ine <span class="function"><span class="title">debugMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="id">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="hexcolor">#def</span>ine <span class="function"><span class="title">RGB</span><span class="params">(A, B, C)</span></span>    [UIColor colorWithRed:A/<span class="number">255.0</span> green:B/<span class="number">255.0</span> blue:C/<span class="number">255.0</span> alpha:<span class="number">1.0</span>]</span><br></pre></td></tr></table></figure></p>
<p>我也为 UIView 的 frame 调整增加了一些扩展，可以方便地调整 UIView 的 x, y, width, height 等值。部分关键代码如下（完整的代码请查看示例工程）</p>
<p>UIView+frameAdjust.h 文件:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIView</span> (<span class="title">frameAdjust</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGFloat</span>)x;</span><br><span class="line">- (<span class="keyword">void</span>)setX:(<span class="built_in">CGFloat</span>)x;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGFloat</span>)y;</span><br><span class="line">- (<span class="keyword">void</span>)setY:(<span class="built_in">CGFloat</span>)y;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGFloat</span>)height;</span><br><span class="line">- (<span class="keyword">void</span>)setHeight:(<span class="built_in">CGFloat</span>)height;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGFloat</span>)width;</span><br><span class="line">- (<span class="keyword">void</span>)setWidth:(<span class="built_in">CGFloat</span>)width;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>UIView+frameAdjust.m 文件：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIView</span> (<span class="title">frameAdjust</span>)</span></span><br><span class="line">- (<span class="built_in">CGFloat</span>)x &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.frame</span><span class="variable">.origin</span><span class="variable">.x</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setX:(<span class="built_in">CGFloat</span>)x &#123;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(x, <span class="keyword">self</span><span class="variable">.y</span>, <span class="keyword">self</span><span class="variable">.width</span>, <span class="keyword">self</span><span class="variable">.height</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGFloat</span>)y &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.frame</span><span class="variable">.origin</span><span class="variable">.y</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setY:(<span class="built_in">CGFloat</span>)y &#123;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(<span class="keyword">self</span><span class="variable">.x</span>, y, <span class="keyword">self</span><span class="variable">.width</span>, <span class="keyword">self</span><span class="variable">.height</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGFloat</span>)height &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.height</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)setHeight:(<span class="built_in">CGFloat</span>)height &#123;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(<span class="keyword">self</span><span class="variable">.x</span>, <span class="keyword">self</span><span class="variable">.y</span>, <span class="keyword">self</span><span class="variable">.width</span>, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGFloat</span>)width &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.width</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)setWidth:(<span class="built_in">CGFloat</span>)width &#123;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(<span class="keyword">self</span><span class="variable">.x</span>, <span class="keyword">self</span><span class="variable">.y</span>, width, <span class="keyword">self</span><span class="variable">.height</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>文章中的其余代码默认都#import 了以上提到的宏定义和 UIView Category。</p>
<h3 id="排版引擎框架">排版引擎框架</h3><p>上面的 Hello World 工程仅仅展示了 Core Text 排版的基本能力。但是要制作一个较完善的排版引擎，我们不能简单的将所有代码都放到 CTDisplayView 的drawRect方法里面。根据设计模式中的 “ 单一功能原则 ”(Single responsibility principle)，我们应该把功能拆分，把不同的功能都放到各自不同的类里面。</p>
<p>对于一个复杂的排版引擎来说，可以将其功能拆成以下几个类来完成：</p>
<ol>
<li>一个显示用的类，仅负责显示内容，不负责排版</li>
<li>一个模型类，用于承载显示所需要的所有数据</li>
<li>一个排版类，用于实现文字内容的排版</li>
<li>一个配置类，用于实现一些排版时的可配置项</li>
</ol>
<blockquote>
<p>注：” 单一功能原则 “(Single responsibility principle) 参考链接：<a href="http://zh.wikipedia.org/wiki/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99" target="_blank" rel="external">http://zh.wikipedia.org/wiki/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99</a></p>
</blockquote>
<p>按照以上原则，我们将CTDisplayView中的部分内容拆开，由 4 个类构成：</p>
<ol>
<li><code>CTFrameParserConfig</code>类，用于配置绘制的参数，例如：文字颜色，大小，行间距等。</li>
<li><code>CTFrameParser</code>类，用于生成最后绘制界面需要的CTFrameRef实例。</li>
<li><code>CoreTextData</code>类，用于保存由CTFrameParser类生成的CTFrameRef实例以及CTFrameRef实际绘制需要的高度。</li>
<li><code>CTDisplayView</code>类，持有CoreTextData类的实例，负责将CTFrameRef绘制到界面上。</li>
</ol>
<p>关于这 4 个类的关键代码如下：</p>
<p>1) CTFrameParserConfig类:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CTFrameParserConfig</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> width;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> fontSize;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> lineSpace;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *textColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="title">"CTFrameParserConfig.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CTFrameParserConfig</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _width = <span class="number">200.0</span>f;</span><br><span class="line">        _fontSize = <span class="number">16.0</span>f;</span><br><span class="line">        _lineSpace = <span class="number">8.0</span>f;</span><br><span class="line">        _textColor = RGB(<span class="number">108</span>, <span class="number">108</span>, <span class="number">108</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>2) CTFrameParser类:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"CoreTextData.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"CTFrameParserConfig.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CTFrameParser</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">+ (CoreTextData *)parseContent:(<span class="built_in">NSString</span> *)content config:(CTFrameParserConfig*)config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="title">"CTFrameParser.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"CTFrameParserConfig.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CTFrameParser</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSDictionary</span> *)attributesWithConfig:(CTFrameParserConfig *)config &#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> fontSize = config<span class="variable">.fontSize</span>;</span><br><span class="line">    CTFontRef fontRef = CTFontCreateWithName((<span class="built_in">CFStringRef</span>)<span class="string">@"ArialMT"</span>, fontSize, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">CGFloat</span> lineSpacing = config<span class="variable">.lineSpace</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">CFIndex</span> kNumberOfSettings = <span class="number">3</span>;</span><br><span class="line">    CTParagraphStyleSetting theSettings[kNumberOfSettings] = &#123;</span><br><span class="line">        &#123; kCTParagraphStyleSpecifierLineSpacingAdjustment, <span class="keyword">sizeof</span>(<span class="built_in">CGFloat</span>), &amp;lineSpacing &#125;,</span><br><span class="line">        &#123; kCTParagraphStyleSpecifierMaximumLineSpacing, <span class="keyword">sizeof</span>(<span class="built_in">CGFloat</span>), &amp;lineSpacing &#125;,</span><br><span class="line">        &#123; kCTParagraphStyleSpecifierMinimumLineSpacing, <span class="keyword">sizeof</span>(<span class="built_in">CGFloat</span>), &amp;lineSpacing &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    CTParagraphStyleRef theParagraphRef = CTParagraphStyleCreate(theSettings, kNumberOfSettings);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIColor</span> * textColor = config<span class="variable">.textColor</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> * dict = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    dict[(<span class="keyword">id</span>)kCTForegroundColorAttributeName] = (<span class="keyword">id</span>)textColor<span class="variable">.CGColor</span>;</span><br><span class="line">    dict[(<span class="keyword">id</span>)kCTFontAttributeName] = (__bridge <span class="keyword">id</span>)fontRef;</span><br><span class="line">    dict[(<span class="keyword">id</span>)kCTParagraphStyleAttributeName] = (__bridge <span class="keyword">id</span>)theParagraphRef;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CFRelease</span>(theParagraphRef);</span><br><span class="line">    <span class="built_in">CFRelease</span>(fontRef);</span><br><span class="line">    <span class="keyword">return</span> dict;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (CoreTextData *)parseContent:(<span class="built_in">NSString</span> *)content config:(CTFrameParserConfig*)config &#123;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *attributes = [<span class="keyword">self</span> attributesWithConfig:config];</span><br><span class="line">    <span class="built_in">NSAttributedString</span> *contentString =</span><br><span class="line">        [[<span class="built_in">NSAttributedString</span> alloc] initWithString:content</span><br><span class="line">                                        attributes:attributes];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 CTFramesetterRef 实例</span></span><br><span class="line">    CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((<span class="built_in">CFAttributedStringRef</span>)contentString);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得要绘制的区域的高度</span></span><br><span class="line">    <span class="built_in">CGSize</span> restrictSize = <span class="built_in">CGSizeMake</span>(config<span class="variable">.width</span>, <span class="built_in">CGFLOAT_MAX</span>);</span><br><span class="line">    <span class="built_in">CGSize</span> coreTextSize = CTFramesetterSuggestFrameSizeWithConstraints(framesetter, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>,<span class="number">0</span>), <span class="literal">nil</span>, restrictSize, <span class="literal">nil</span>);</span><br><span class="line">    <span class="built_in">CGFloat</span> textHeight = coreTextSize<span class="variable">.height</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成 CTFrameRef 实例</span></span><br><span class="line">    CTFrameRef frame = [<span class="keyword">self</span> createFrameWithFramesetter:framesetter config:config height:textHeight];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将生成好的 CTFrameRef 实例和计算好的绘制高度保存到 CoreTextData 实例中，最后返回 CoreTextData 实例</span></span><br><span class="line">    CoreTextData *data = [[CoreTextData alloc] init];</span><br><span class="line">    data<span class="variable">.ctFrame</span> = frame;</span><br><span class="line">    data<span class="variable">.height</span> = textHeight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">CFRelease</span>(frame);</span><br><span class="line">    <span class="built_in">CFRelease</span>(framesetter);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (CTFrameRef)createFrameWithFramesetter:(CTFramesetterRef)framesetter</span><br><span class="line">                                  config:(CTFrameParserConfig *)config</span><br><span class="line">                                  height:(<span class="built_in">CGFloat</span>)height &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGMutablePathRef</span> path = <span class="built_in">CGPathCreateMutable</span>();</span><br><span class="line">    <span class="built_in">CGPathAddRect</span>(path, <span class="literal">NULL</span>, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, config<span class="variable">.width</span>, height));</span><br><span class="line"></span><br><span class="line">    CTFrameRef frame = CTFramesetterCreateFrame(framesetter, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="number">0</span>), path, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">CFRelease</span>(path);</span><br><span class="line">    <span class="keyword">return</span> frame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>CoreTextData类:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CoreTextData</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) CTFrameRef ctFrame;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> height;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="title">"CoreTextData.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CoreTextData</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setCtFrame:(CTFrameRef)ctFrame &#123;</span><br><span class="line">    <span class="keyword">if</span> (_ctFrame != ctFrame) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_ctFrame != <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(_ctFrame);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">CFRetain</span>(ctFrame);</span><br><span class="line">        _ctFrame = ctFrame;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    <span class="keyword">if</span> (_ctFrame != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="built_in">CFRelease</span>(_ctFrame);</span><br><span class="line">        _ctFrame = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>CTDisplayView类：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"CoreTextData.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CTDisplayView</span> : <span class="title">UIView</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) CoreTextData * data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">import <span class="string">"CTDisplayView.h"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CTDisplayView</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> drawRect:rect];</span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    <span class="built_in">CGContextSetTextMatrix</span>(context, <span class="built_in">CGAffineTransformIdentity</span>);</span><br><span class="line">    <span class="built_in">CGContextTranslateCTM</span>(context, <span class="number">0</span>, <span class="keyword">self</span><span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.height</span>);</span><br><span class="line">    <span class="built_in">CGContextScaleCTM</span>(context, <span class="number">1.0</span>, -<span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.data</span>) &#123;</span><br><span class="line">        CTFrameDraw(<span class="keyword">self</span><span class="variable">.data</span><span class="variable">.ctFrame</span>, context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>以上 4 个类中的逻辑与之前 Hello World 那个项目的逻辑基本一致，只是分拆到了 4 个类中完成。另外，<code>CTFrameParser</code> 增加了方法来获得要绘制的区域的高度，并将高度信息保存到CoreTextData类的实例中。之所以要获得绘制区域的高度，是因为在很多实际使用场景中，我们需要先知道所要显示内容的高度，之后才可以进行绘制。</p>
<p>例如，在 UITableView 在渲染时，UITableView 首先会向 delegate 回调如下方法来获得每个将要渲染的 cell 的高度：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (<span class="tag">CGFloat</span>)<span class="rule"><span class="attribute">tableView</span>:<span class="value">(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>之后，UITableView 会计算当前滚动的位置具体需要绘制的 UITableViewCell 是哪些，然后对于那些需要绘制的 Cell，UITableView 才会继续向其 data source 回调如下方法来获得 UITableViewCell 实例：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (<span class="tag">UITableViewCell</span> *)<span class="rule"><span class="attribute">cellForRowAtIndexPath</span>:<span class="value">(NSIndexPath *)indexPath</span></span>;</span><br></pre></td></tr></table></figure>
<p>对于上面的情况，如果我们使用 CoreText 来作为 TableViewCell 的内容，那么就必须在每个 Cell 绘制之前，就知道其需要的绘制高度，否则 UITableView 将无法正常工作。</p>
<p>完成以上 4 个类之后，我们就可以简单地在<code>ViewController.m</code>文件中，加入如下代码来配置CTDisplayView的显示内容，位置，高度，字体，颜色等信息。代码如下所示。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> CTDisplayView *ctView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    CTFrameParserConfig *config = [[CTFrameParserConfig alloc] init];</span><br><span class="line">    config<span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    config<span class="variable">.width</span> = <span class="keyword">self</span><span class="variable">.ctView</span><span class="variable">.width</span>;</span><br><span class="line"></span><br><span class="line">    CoreTextData *data = [CTFrameParser parseContent:<span class="string">@" 按照以上原则，我们将`CTDisplayView`中的部分内容拆开。"</span> config:config];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.ctView</span><span class="variable">.data</span> = data;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.ctView</span><span class="variable">.height</span> = data<span class="variable">.height</span>;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.ctView</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> yellowColor];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>注意：从 Xcode4.0 开始，默认的界面编辑就开启了对于Use Autolayout的使用，但因为我们在代码中直接修改了变量ctView的 frame 信息，所以需要在Main_iPhone.storyboard中将Use Autolayout这一项取消勾选。如下图所示：</p>
<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-un-select-autolayout.png" alt=""></p>
<p>以下是本框架的 UML 示意图，从图中我们可以看出，这 4 个 Core Text 类的关系是这样的：</p>
<ol>
<li><code>CTFrameParser</code>通过<code>CTFrameparserConfig</code>实例来生成CoreTextData实例。</li>
<li><code>CTDisplayView</code>通过持有<code>CoreTextData</code>实例来获得绘制所需要的所有信息。</li>
<li>ViewController类通过配置<code>CTFrameparserConfig</code>实例，进而获得生成的<code>CoreTextData</code>实例，最后将其赋值给他的<code>CTDisplayView</code>成员，达到将指定内容显示在界面上的效果</li>
</ol>
<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-uml.png" alt=""></p>
<p>说明 1：整个工程代码在名为<code>basic_arch</code>的分支下，读者可以在示例的源代码工程中使用<code>git checkout basic_arch</code>来切换到当前讲解的工程示例代码。</p>
<p>说明 2：为了方便操作UIView的frame属性，项目中增加了一个名为UIView+frameAdjust.m文件，它通过Category来给UIView增加了直接设置height属性的方法。</p>
<h4 id="定制排版文件格式">定制排版文件格式</h4><p>对于上面的例子，我们给 <code>CTFrameParser</code> 使增加了一个将 NSString 转换为 <code>CoreTextData</code> 的方法。但这样的实现方式有很多局限性，因为整个内容虽然可以定制字体大小，颜色，行高等信息，但是却不能支持定制内容中的某一部分。例如，如果我们只想让内容的前三个字显示成红色，而其它文字显示成黑色，那么就办不到了。</p>
<p>解决的办法很简单，我们让<code>CTFrameParser</code>支持接受 <code>NSAttributeString</code> 作为参数，然后在ViewController类中设置我们想要的 NSAttributeString 信息。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    CTFrameParserConfig *config = [[CTFrameParserConfig alloc] init];</span><br><span class="line">    config<span class="variable">.width</span> = <span class="keyword">self</span><span class="variable">.ctView</span><span class="variable">.width</span>;</span><br><span class="line">    config<span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> blackColor];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *content =</span><br><span class="line">        <span class="string">@" 对于上面的例子，我们给 CTFrameParser 增加了一个将 NSString 转 "</span></span><br><span class="line">         <span class="string">" 换为 CoreTextData 的方法。"</span></span><br><span class="line">         <span class="string">" 但这样的实现方式有很多局限性，因为整个内容虽然可以定制字体 "</span></span><br><span class="line">         <span class="string">" 大小，颜色，行高等信息，但是却不能支持定制内容中的某一部分。"</span></span><br><span class="line">         <span class="string">" 例如，如果我们只想让内容的前三个字显示成红色，而其它文字显 "</span></span><br><span class="line">         <span class="string">" 示成黑色，那么就办不到了。"</span></span><br><span class="line">         <span class="string">"\n\n"</span></span><br><span class="line">         <span class="string">" 解决的办法很简单，我们让`CTFrameParser`支持接受 "</span></span><br><span class="line">         <span class="string">"NSAttributeString 作为参数，然后在 NSAttributeString 中设置好 "</span></span><br><span class="line">         <span class="string">" 我们想要的信息。"</span>;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *attr = [CTFrameParser attributesWithConfig:config];</span><br><span class="line">    <span class="built_in">NSMutableAttributedString</span> *attributedString =</span><br><span class="line">         [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:content</span><br><span class="line">                                                attributes:attr];</span><br><span class="line">    [attributedString addAttribute:<span class="built_in">NSForegroundColorAttributeName</span></span><br><span class="line">                             value:[<span class="built_in">UIColor</span> redColor]</span><br><span class="line">                             range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">7</span>)];</span><br><span class="line"></span><br><span class="line">    CoreTextData *data = [CTFrameParser parseAttributedContent:attributedString</span><br><span class="line">                                                        config:config];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.ctView</span><span class="variable">.data</span> = data;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.ctView</span><span class="variable">.height</span> = data<span class="variable">.height</span>;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.ctView</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> yellowColor];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>结果如下图所示，我们很方便就把前面 7 个字变成了红色。<br><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-attribute-string-as-argument.png" alt=""></p>
<p>更进一步地，实际工作中，我们更希望通过一个排版文件，来设置需要排版的文字的内容、颜色、字体大小等信息。我在开发猿题库应用时，自己定义了一个基于 UBB 的排版模版，但是实现该排版文件的解析器要花费大量的篇幅，考虑到这并不是本章的重点，所以我们以一个较简单的排版文件来讲解其思想。</p>
<p>我们规定排版的模版文件为 <code>JSON</code> 格式。JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，易于阅读和编写，同时也易于机器解析和生成。iOS 从 5.0 开始，提供了名为NSJSONSerialization的类库来方便开发者对 JSON 的解析。在 iOS5.0 之前，业界也有很多相关的 JSON 解析开源库，例如 JSONKit 可供大家使用。</p>
<p>我们的排版模版示例文件如下所示：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[ &#123; "<span class="attribute">color</span>" : <span class="value"><span class="string">"blue"</span></span>,</span><br><span class="line">    "<span class="attribute">content</span>" : <span class="value"><span class="string">" 更进一步地，实际工作中，我们更希望通过一个排版文件，来设置需要排版的文字的 "</span></span>,</span><br><span class="line">    "<span class="attribute">size</span>" : <span class="value"><span class="number">16</span></span>,</span><br><span class="line">    "<span class="attribute">type</span>" : <span class="value"><span class="string">"txt"</span></span><br><span class="line">  </span>&#125;,</span><br><span class="line">  &#123; "<span class="attribute">color</span>" : <span class="value"><span class="string">"red"</span></span>,</span><br><span class="line">    "<span class="attribute">content</span>" : <span class="value"><span class="string">" 内容、颜色、字体 "</span></span>,</span><br><span class="line">    "<span class="attribute">size</span>" : <span class="value"><span class="number">22</span></span>,</span><br><span class="line">    "<span class="attribute">type</span>" : <span class="value"><span class="string">"txt"</span></span><br><span class="line">  </span>&#125;,</span><br><span class="line">  &#123; "<span class="attribute">color</span>" : <span class="value"><span class="string">"black"</span></span>,</span><br><span class="line">    "<span class="attribute">content</span>" : <span class="value"><span class="string">" 大小等信息。\n"</span></span>,</span><br><span class="line">    "<span class="attribute">size</span>" : <span class="value"><span class="number">16</span></span>,</span><br><span class="line">    "<span class="attribute">type</span>" : <span class="value"><span class="string">"txt"</span></span><br><span class="line">  </span>&#125;,</span><br><span class="line">  &#123; "<span class="attribute">color</span>" : <span class="value"><span class="string">"default"</span></span>,</span><br><span class="line">    "<span class="attribute">content</span>" : <span class="value"><span class="string">" 我在开发猿题库应用时，自己定义了一个基于 UBB 的排版模版，但是实现该排版文件的解析器要花费大量的篇幅，考虑到这并不是本章的重点，所以我们以一个较简单的排版文件来讲解其思想。"</span></span>,</span><br><span class="line">    "<span class="attribute">type</span>" : <span class="value"><span class="string">"txt"</span></span><br><span class="line">  </span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>通过苹果提供的NSJSONSerialization类，我们可以将上面的模版文件转换成 NSArray 数组，每一个数组元素是一个 NSDictionary，代表一段相同设置的文字。为了简单，我们的配置文件只支持配置颜色和字号，但是读者可以依据同样的思想，很方便地增加其它配置信息。</p>
<p>接下来我们要为CTFrameParser增加一个方法，让其可以从如上格式的模版文件中生成CoreTextData。最终我们的实现代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">+ (CoreTextData *)parseTemplateFile:(<span class="built_in">NSString</span> *)path config:(CTFrameParserConfig*)config &#123;</span><br><span class="line">    <span class="built_in">NSAttributedString</span> *content = [<span class="keyword">self</span> loadTemplateFile:path config:config];</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> parseAttributedContent:content config:config];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line">+ (<span class="built_in">NSAttributedString</span> *)loadTemplateFile:(<span class="built_in">NSString</span> *)path config:(CTFrameParserConfig*)config &#123;</span><br><span class="line">    <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:path];</span><br><span class="line">    <span class="built_in">NSMutableAttributedString</span> *result = [[<span class="built_in">NSMutableAttributedString</span> alloc] init];</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *array = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data</span><br><span class="line">                                           options:<span class="built_in">NSJSONReadingAllowFragments</span></span><br><span class="line">                                             error:<span class="literal">nil</span>];</span><br><span class="line">        <span class="keyword">if</span> ([array isKindOfClass:[<span class="built_in">NSArray</span> class]]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *dict <span class="keyword">in</span> array) &#123;</span><br><span class="line">                <span class="built_in">NSString</span> *type = dict[<span class="string">@"type"</span>];</span><br><span class="line">                <span class="keyword">if</span> ([type isEqualToString:<span class="string">@"txt"</span>]) &#123;</span><br><span class="line">                    <span class="built_in">NSAttributedString</span> *as =</span><br><span class="line">                       [<span class="keyword">self</span> parseAttributedContentFrom<span class="built_in">NSDictionary</span>:dict</span><br><span class="line">                                                             config:config];</span><br><span class="line">                    [result appendAttributedString:as];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法三</span></span><br><span class="line">+ (<span class="built_in">NSAttributedString</span> *)parseAttributedContentFrom<span class="built_in">NSDictionary</span>:(<span class="built_in">NSDictionary</span> *)dict</span><br><span class="line">                                                        config:(CTFrameParserConfig*)config &#123;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *attributes = [<span class="keyword">self</span> attributesWithConfig:config];</span><br><span class="line">    <span class="comment">// set color</span></span><br><span class="line">    <span class="built_in">UIColor</span> *color = [<span class="keyword">self</span> colorFromTemplate:dict[<span class="string">@"color"</span>]];</span><br><span class="line">    <span class="keyword">if</span> (color) &#123;</span><br><span class="line">        attributes[(<span class="keyword">id</span>)kCTForegroundColorAttributeName] = (<span class="keyword">id</span>)color<span class="variable">.CGColor</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// set font size</span></span><br><span class="line">    <span class="built_in">CGFloat</span> fontSize = [dict[<span class="string">@"size"</span>] floatValue];</span><br><span class="line">    <span class="keyword">if</span> (fontSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        CTFontRef fontRef = CTFontCreateWithName((<span class="built_in">CFStringRef</span>)<span class="string">@"ArialMT"</span>, fontSize, <span class="literal">NULL</span>);</span><br><span class="line">        attributes[(<span class="keyword">id</span>)kCTFontAttributeName] = (__bridge <span class="keyword">id</span>)fontRef;</span><br><span class="line">        <span class="built_in">CFRelease</span>(fontRef);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSString</span> *content = dict[<span class="string">@"content"</span>];</span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">NSAttributedString</span> alloc] initWithString:content attributes:attributes];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法四</span></span><br><span class="line">+ (<span class="built_in">UIColor</span> *)colorFromTemplate:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    <span class="keyword">if</span> ([name isEqualToString:<span class="string">@"blue"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">UIColor</span> blueColor];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([name isEqualToString:<span class="string">@"red"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([name isEqualToString:<span class="string">@"black"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">UIColor</span> blackColor];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法五</span></span><br><span class="line">+ (CoreTextData *)parseAttributedContent:(<span class="built_in">NSAttributedString</span> *)content config:(CTFrameParserConfig*)config &#123;</span><br><span class="line">    <span class="comment">// 创建 CTFramesetterRef 实例</span></span><br><span class="line">    CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((<span class="built_in">CFAttributedStringRef</span>)content);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得要缓制的区域的高度</span></span><br><span class="line">    <span class="built_in">CGSize</span> restrictSize = <span class="built_in">CGSizeMake</span>(config<span class="variable">.width</span>, <span class="built_in">CGFLOAT_MAX</span>);</span><br><span class="line">    <span class="built_in">CGSize</span> coreTextSize = CTFramesetterSuggestFrameSizeWithConstraints(framesetter, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>,<span class="number">0</span>), <span class="literal">nil</span>, restrictSize, <span class="literal">nil</span>);</span><br><span class="line">    <span class="built_in">CGFloat</span> textHeight = coreTextSize<span class="variable">.height</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成 CTFrameRef 实例</span></span><br><span class="line">    CTFrameRef frame = [<span class="keyword">self</span> createFrameWithFramesetter:framesetter config:config height:textHeight];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将生成好的 CTFrameRef 实例和计算好的缓制高度保存到 CoreTextData 实例中，最后返回 CoreTextData 实例</span></span><br><span class="line">    CoreTextData *data = [[CoreTextData alloc] init];</span><br><span class="line">    data<span class="variable">.ctFrame</span> = frame;</span><br><span class="line">    data<span class="variable">.height</span> = textHeight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">CFRelease</span>(frame);</span><br><span class="line">    <span class="built_in">CFRelease</span>(framesetter);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法六</span></span><br><span class="line">+ (CTFrameRef)createFrameWithFramesetter:(CTFramesetterRef)framesetter</span><br><span class="line">                                  config:(CTFrameParserConfig *)config</span><br><span class="line">                                  height:(<span class="built_in">CGFloat</span>)height &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGMutablePathRef</span> path = <span class="built_in">CGPathCreateMutable</span>();</span><br><span class="line">    <span class="built_in">CGPathAddRect</span>(path, <span class="literal">NULL</span>, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, config<span class="variable">.width</span>, height));</span><br><span class="line"></span><br><span class="line">    CTFrameRef frame = CTFramesetterCreateFrame(framesetter, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="number">0</span>), path, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">CFRelease</span>(path);</span><br><span class="line">    <span class="keyword">return</span> frame;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码主要由 6 个子方法构成：</p>
<ul>
<li>方法一用于提供对外的接口，调用方法二实现从一个 JSON 的模版文件中读取内容，然后调用方法五生成CoreTextData。</li>
<li>方法二读取 JSON 文件内容，并且调用方法三获得从NSDictionary到NSAttributedString的转换结果。</li>
<li>方法三将NSDictionary内容转换为NSAttributedString。</li>
<li>方法四提供将NSString转为UIColor的功能。</li>
<li>方法五接受一个NSAttributedString和一个config参数，将NSAttributedString转换成CoreTextData返回。</li>
<li>方法六是方法五的一个辅助函数，供方法五调用。</li>
</ul>
<p>然后我们将ViewController中的调用代码作一下更改，使其从模版文件中加载内容，如下所示：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    CTFrameParserConfig *config = [[CTFrameParserConfig alloc] init];</span><br><span class="line">    config<span class="variable">.width</span> = <span class="keyword">self</span><span class="variable">.ctView</span><span class="variable">.width</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *path = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"content"</span> ofType:<span class="string">@"json"</span>];</span><br><span class="line">    CoreTextData *data = [CTFrameParser parseTemplateFile:path config:config];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.ctView</span><span class="variable">.data</span> = data;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.ctView</span><span class="variable">.height</span> = data<span class="variable">.height</span>;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.ctView</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>最后运行得到的结果如下所示，可以看到，通过一个简单的模板文件，我们已经可以很方便地定义排版的配置信息了。</p>
<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-load-from-json-template.png" alt=""></p>
<p>说明：读者可以在示例工程中使用git checkout json_template，查看可以运行的示例代码。b</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://blog.devtang.com/blog/2015/06/27/using-coretext-1/" target="_blank" rel="external">转自</a></p>
<h2 id="转载声明">转载声明</h2><p>原]]>
    </summary>
    
      <category term="CoreText" scheme="http://ytlvy.com/tags/CoreText/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS Super init]]></title>
    <link href="http://ytlvy.com/2015/07/17/iOS-Super-init/"/>
    <id>http://ytlvy.com/2015/07/17/iOS-Super-init/</id>
    <published>2015-07-17T08:25:41.000Z</published>
    <updated>2015-07-19T09:18:32.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://www.cocoawithlove.com/2009/04/what-does-it-mean-when-you-assign-super.html" target="_blank" rel="external">转自</a></p>
<h1 id="What_does_it_mean_when_you_assign_[super_init]_to_self?">What does it mean when you assign [super init] to self?</h1><p><code>self = [super init];</code> 是 Objctive-C 语法中很奇怪的一句.</p>
<h2 id="Converting_a_method_invocation">Converting a method invocation</h2><p>首先需要了解<code>self</code>参数, 编译器是如何处理的.当你输入下面代码时</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="name">MyClass</span> *<span class="atom">myObject</span> = [[<span class="name">MyClass</span> <span class="atom">alloc</span>] <span class="atom">initWithString</span>:@<span class="string">"someString"</span>];</span><br></pre></td></tr></table></figure>
<p>编译器会转换为大致如下的代码:</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">class</span> myClass = objc_getClass(<span class="string">"MyClass"</span>);</span><br><span class="line"><span class="title">SEL</span> allocSelector = <span class="variable">@selector</span>(alloc);</span><br><span class="line"><span class="title">MyClass</span> *myObject1 = objc_msgSend(myClass, allocSelector);</span><br><span class="line"></span><br><span class="line"><span class="title">SEL</span> initSelector = <span class="variable">@selector</span>(initWithString:);</span><br><span class="line"><span class="title">MyClass</span> *myObject2 = objc_msgSend(myObject1, initSelector, @<span class="string">"someString"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="So_what_is_“self”?">So what is “self”?</h2><p>每个方法都有两个隐藏参数: <code>self</code> and <code>_cmd</code>.</p>
<p>例如:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (<span class="tag">id</span>)<span class="rule"><span class="attribute">initWithString</span>:<span class="value">(NSString *)aString</span></span>;</span><br></pre></td></tr></table></figure>
<p>会转换为:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> initWithString(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="built_in">NSString</span> *aString);</span><br></pre></td></tr></table></figure>
<p>实际上<code>self</code> 只是在每个方法中都存在的隐藏参数, 像普通参数一样, 它通过函数调用来接收数值.</p>
<p>你可以尝试将下面的方法变更为<code>objc_msgSend</code>方式来调用</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">[myObject someMethodWithParameter:someValue]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>你可以直接调用</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SEL methodSelector = <span class="annotation">@selector</span>(someMethodWithParameter:);</span><br><span class="line">IMP someMethodFunction = <span class="keyword">class</span><span class="number">_</span>getMethodImplementation([myObject <span class="keyword">class</span>], methodSelector);</span><br><span class="line">someMethodFunction(myObject, methodSelector, someValue);</span><br></pre></td></tr></table></figure>
<p><code>self</code>正是由于接收了函数<code>someMethodFunction</code>传入的第一个参数, 才拥有了实际的数值, 如果<br>你此时传入其他的数值, 很可能会造成系统崩溃.</p>
<h2 id="Why_have_a_“self”_parameter_at_all?">Why have a “self” parameter at all?</h2><p>方法需要知道它操作的数据是什么, 而<code>self</code> 正是用来告诉类它要操作的数据是什么的. 因为在运行时, <code>self</code>也即是对象本身存贮了数据, 而方法使在类中存储的. 所以方法操作数据的时候, 需要通过 <code>self</code> 指针来获取数据的具体位置.例如:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> value;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)setValueToZero;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>方法:</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setValueToZero</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">value</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换为:</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> setValueToZero(id <span class="built_in">self</span>, SEL _cmd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">self</span><span class="subst">-&gt;</span>value <span class="subst">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="So_does_self_already_have_a_value_when_init_is_called?">So does self already have a value when init is called?</h2><p>从上面的分析看, <code>initWithString</code> 是 方法调用<code>[[MyClass alloc] initWithString:@&quot;someString&quot;]</code>的一部分.</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass *myObject2 = objc_msgSend<span class="list">(<span class="keyword">myObject1</span>, initSelector, @<span class="string">"someString"</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>所以当我们进入<code>initWithString</code>方法时, <code>self</code> 已经有值<code>myObject1</code>(通过 <code>[MyClass alloc]</code>  返回的), 因为没有<code>super</code>的调用是需要<code>self</code>的,<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">[super init]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>会转换为:</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct objc<span class="number">_</span><span class="keyword">super</span> <span class="keyword">super</span> = &#123;.receiver = self, .<span class="keyword">super</span><span class="number">_</span><span class="keyword">class</span> = <span class="number">0</span>xC<span class="number">0</span>FFEE&#125;;</span><br><span class="line">objc<span class="number">_m</span>sgSendSuper(&amp;<span class="keyword">super</span>, <span class="annotation">@selector</span>(otherMethodWithArgument:), arg);</span><br></pre></td></tr></table></figure>
<h2 id="So_why_assign_the_value_returned_from_[super_init]_to_self?">So why assign the value returned from [super init] to self?</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)initWithString:(<span class="built_in">NSString</span> *)aString</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        instanceString = [aString retain];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么需要将 <code>self</code> 重新赋值为 <code>[super init]</code>, 原因为<code>[super init]</code> 会发生下面3种情况之一:</p>
<ol>
<li>Return its own receiver (the self pointer doesn’t change) with inherited instance values initialized.</li>
<li>Return a different object with inherited instance values initialized.</li>
<li>Return nil, indicating failure.</li>
</ol>
<p>第一种情况, 赋值是没有意义的, 因为 self 没有改变,  <code>instanceString</code> 是作用在原来的对象上的.<br>第三种情况, 初始化失败返回<code>nil</code>, <code>self</code> 也被赋值为<code>nil</code>并返回, 不会发生更进一步的操作.<br>第二种情况, 才是重新赋值的意义所在. 因为返回的对象改变了.</p>
<h2 id="It’s_almost_never_required_to_initialize_self">It’s almost never required to initialize self</h2><p>所以重新赋值的意义在于<code>[super init]</code>可能会返回一个不同的对象.那什么时候 会返回不同对象呢, 情况如下:</p>
<ol>
<li>Singleton object (always returns the singleton instead of any subsequent allocation)</li>
<li>Other unique objects ([NSNumber numberWithInteger:0] always returns the global “zero” object)</li>
<li>Class clusters substitute private subclasses when you initialize an instance of the superclass.</li>
<li>Classes which choose to reallocate the same (or compatible) class based on parameters passed into the initializer.</li>
</ol>
<p>除了最后一种情况外, 如果继续初始化返回的对象, 其实是错误的, 因为这个对象已经被完全初始化完毕了.<br>所以上面说的<code>[super init]</code> 可能发生的情况, 可以扩充了4种:</p>
<ol>
<li>Return its own receiver (the self pointer doesn’t change) with inherited instance values initialized.</li>
<li>Return an object of the same class, requiring further initialization.</li>
<li>Return a different object that is already completely initialized.</li>
<li>Return nil, indicating failure.</li>
</ol>
<p>上面列表中, 第二种和第三种情况是冲突的, 我们原来典型的写法<code>self = [super init]</code> 可以解决1, 2, 4等情况.<br>而可以解决1, 3, 4情况的写法为:<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (id)initWithString:(<span class="type">NSString</span> *)aString</span><br><span class="line">&#123;</span><br><span class="line">    id <span class="literal">result</span> = [super init];</span><br><span class="line">    <span class="keyword">if</span> (self == <span class="literal">result</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        instanceString = [aString retain];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为类簇, 单例和唯一对象等情况都符合第三种情况, 如此以来, 系统中大量的类放入了这种情况, 我仅知道<code>NSManagedObject</code>符合第二种情况.奇怪的是, 适用范围更广的上面的写法反而不是标准写法.</p>
<h2 id="总结">总结</h2><p>大部分情况下, 你不需要将<code>[ super init]</code> 重新赋值给<code>self</code>, 在某些情况下, 这样做更是错误的.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://www.cocoawithlove.com/2009/04/what-does-it-mean-when-you-assign-super.html" target="_blank" rel="external">转自</a></p>
<h1]]>
    </summary>
    
      <category term="init" scheme="http://ytlvy.com/tags/init/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ARC dealloc cxx_destruct]]></title>
    <link href="http://ytlvy.com/2015/07/17/ARC-dealloc-cxx-destruct/"/>
    <id>http://ytlvy.com/2015/07/17/ARC-dealloc-cxx-destruct/</id>
    <published>2015-07-17T08:24:53.000Z</published>
    <updated>2015-07-19T09:18:32.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://blog.sunnyxx.com/2014/04/02/objc_dig_arc_dealloc/" target="_blank" rel="external">转</a></p>
<h1 id="ARC下dealloc过程及-cxx_destruct的探究">ARC下dealloc过程及.cxx_destruct的探究</h1><h2 id="我是前言">我是前言</h2><p>这次探索源自于自己一直以来对ARC的一个疑问，在MRC时代，经常写下面的代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.array</span> = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.string</span> = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// ... //</span></span><br><span class="line">    <span class="comment">// 非Objc对象内存的释放，如CFRelease(...)</span></span><br><span class="line">    <span class="comment">// ... //</span></span><br><span class="line">    [<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象析构时将内部其他对象release掉，申请的非Objc对象的内存当然也一并处理掉，最后调用super，继续将父类对象做析构。而现如今到了ARC时代，只剩下了下面的代码：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (void)<span class="tag">dealloc</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ... //</span></span><br><span class="line">    <span class="comment">// 非Objc对象内存的释放，如CFRelease(...)</span></span><br><span class="line">    <span class="comment">// ... //</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题来了：</p>
<ol>
<li>这个对象实例变量（Ivars）的释放去哪儿了？</li>
<li>没有显示的调用[super dealloc]，上层的析构去哪儿了？</li>
</ol>
<h2 id="ARC文档中对dealloc过程的解释">ARC文档中对dealloc过程的解释</h2><p><a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#dealloc" target="_blank" rel="external">llvm官方的ARC文档</a> 中对ARC下的dealloc过程做了简单说明，从中还是能找出些有用的信息：</p>
<blockquote>
<p>A class may provide a method definition for an instance method named dealloc. This method will be called after the final release of the object but before it is deallocated or any of its instance variables are destroyed. The superclass’s implementation of dealloc will be called automatically when the method returns.</p>
</blockquote>
<p>大概意思是：dealloc方法在最后一次release后被调用，但此时实例变量（Ivars）并未释放，父类的dealloc的方法将在子类dealloc方法返回后自动调用</p>
<blockquote>
<p>The instance variables for an ARC-compiled class will be destroyed at some point after control enters the dealloc method for the root class of the class. The ordering of the destruction of instance variables is unspecified, both within a single class and between subclasses and superclasses.</p>
</blockquote>
<p>理解：ARC下对象的实例变量在根类[NSObject dealloc]中释放（通常root class都是NSObject），变量释放顺序各种不确定（一个类内的不确定，子类和父类间也不确定，也就是说不用care释放顺序）</p>
<p>所以，不用主调[super dealloc]是因为自动调了，后面再说如何实现的；ARC下实例变量在根类NSObject析构时析构，下面就探究下。</p>
<hr>
<h2 id="NSObject的析构过程">NSObject的析构过程</h2><p>通过apple的runtime源码，不难发现NSObject执行<code>dealloc</code>时调用<code>_objc_rootDealloc</code>继而调用<code>object_dispose</code>随后调用<code>objc_destructInstance</code>方法，前几步都是条件判断和简单的跳转，最后的这个函数如下：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void <span class="built_in">*</span>objc_destructInstance<span class="params">(id obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="params">(obj)</span> &#123;</span><br><span class="line">        Class isa_gen = _object_getClass<span class="params">(obj)</span>;</span><br><span class="line">        class_t <span class="built_in">*</span>isa = newcls<span class="params">(isa_gen)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read all of the flags at once for performance.</span></span><br><span class="line">        bool cxx = hasCxxStructors<span class="params">(isa)</span>;</span><br><span class="line">        bool assoc = <span class="built_in">!</span>UseGC &amp;&amp; _class_instancesHaveAssociatedObjects<span class="params">(isa_gen)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This order is important.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="params">(cxx)</span> object_cxxDestruct<span class="params">(obj)</span>;</span><br><span class="line">        <span class="keyword">if</span> <span class="params">(assoc)</span> _object_remove_assocations<span class="params">(obj)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="params">(!UseGC)</span> objc_clear_deallocating<span class="params">(obj)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单明确的干了三件事：</p>
<ol>
<li>执行一个叫<code>object_cxxDestruct</code>的东西干了点什么事</li>
<li>执行<code>_object_remove_assocations</code>去除和这个对象<code>assocate</code>的对象</li>
<li>执行<code>objc_clear_deallocating</code>，清空引用计数表并清除弱引用表，将所有<code>weak</code>引用指nil（这也就是weak变量能安全置空的所在）</li>
</ol>
<p>所以，所探寻的ARC自动释放实例变量的地方就在cxxDestruct这个东西里面没跑了。</p>
<hr>
<h2 id="探寻隐藏的-cxx_destruct">探寻隐藏的.cxx_destruct</h2><p>上面找到的名为<code>object_cxxDestruct</code>的方法最终成为下面的调用：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static void object_cxxDestructFromClass<span class="params">(id obj, Class cls)</span></span><br><span class="line">&#123;</span><br><span class="line">    void <span class="params">(*dtor)</span><span class="params">(id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call cls's dtor first, then superclasses's dtors.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="params">( ; cls != NULL; cls = _class_getSuperclass<span class="params">(cls)</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="params">(!_class_hasCxxStructors<span class="params">(cls)</span>)</span> return; </span><br><span class="line">        dtor = <span class="params">(void<span class="params">(*)</span><span class="params">(id)</span>)</span></span><br><span class="line">            lookupMethodInClassAndLoadCache<span class="params">(cls, SEL_cxx_destruct)</span>;</span><br><span class="line">        <span class="keyword">if</span> <span class="params">(dtor != <span class="params">(void<span class="params">(*)</span><span class="params">(id)</span>)</span>_objc_msgForward_internal)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="params">(PrintCxxCtors)</span> &#123;</span><br><span class="line">                _objc_inform<span class="params">(<span class="string">"CXX: calling C++ destructors for class %s"</span>, </span><br><span class="line">                             _class_getName<span class="params">(cls)</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="params">(*dtor)</span><span class="params">(obj)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码也不难理解，沿着继承链逐层向上搜寻SEL_cxx_destruct这个selector，找到函数实现(void (*)(id)(函数指针)并执行。<br>搜索这个selector的声明，发现是名为.cxx_destruct的方法，以点开头的名字，我想和unix的文件一样，是有隐藏属性的</p>
<p>从<a href="http://my.safaribooksonline.com/book/programming/objective-c/9780132908641/3dot-memory-management/ch03" target="_blank" rel="external">这篇文章</a>中：</p>
<blockquote>
<p>ARC actually creates a -.cxx_destruct method to handle freeing instance variables. This method was originally created for calling C++ destructors automatically when an object was destroyed.</p>
</blockquote>
<p>和《Effective Objective-C 2.0》中提到的：</p>
<blockquote>
<p>When the compiler saw that an object contained C++ objects, it would generate a method called .cxx_destruct. ARC piggybacks on this method and emits the required cleanup code within it.</p>
</blockquote>
<p>可以了解到，<code>.cxx_destruct</code>方法原本是为了C++对象析构的，ARC借用了这个方法插入代码实现了自动内存释放的工作</p>
<h2 id="通过实验找出-cxx_destruct">通过实验找出.cxx_destruct</h2><p>最好的办法还是写个测试代码把这个隐藏的方法找出来，其实在runtime中运行已经没什么隐藏可言了，简单的类结构如下：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">Father </span>: NSObject</span><br><span class="line"><span class="variable">@property</span> (nonatomic, copy) NSString *name;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">Son </span>: Father</span><br><span class="line"><span class="variable">@property</span> (nonatomic, copy) NSArray *toys;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<p>只有两个简单的属性，找个地方写简单的测试代码：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// before new</span></span><br><span class="line">    Son *son = [Son <span class="keyword">new</span>];</span><br><span class="line">    son.name = @<span class="string">"sark"</span>;</span><br><span class="line">    son.toys = @[@<span class="string">"sunny"</span>, @<span class="string">"xx"</span>];</span><br><span class="line">    <span class="comment">// after new</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// gone</span></span><br></pre></td></tr></table></figure>
<p>主要目的是为了让这个对象走<code>dealloc</code>方法，新建的son对象过了大括号作用域就会释放了，所以在<code>after new</code>这行son对象初始化完成，在<code>gone</code>这行son对象被dealloc</p>
<p>个人一直喜欢使用<a href="https://github.com/garnett/DLIntrospection" target="_blank" rel="external">NSObject+DLIntrospection</a>这个扩展作为调试工具，可以轻松打出一个类的方法，变量等等。</p>
<p>将这个扩展引入工程内，在<code>after new</code>处设置一个断点，run，trigger后使用lldb命令用这个扩展输出Son类所有的方法名：</p>
<p><img src="http://ww3.sinaimg.cn/large/51530583gw1ef27srhw7lj208b05ujrq.jpg" alt=""></p>
<p>发现了这个<code>.cxx_destruct</code>方法，经过几次试验，发现：</p>
<ol>
<li>只有在ARC下这个方法才会出现（试验代码的情况下）</li>
<li>只有当前类拥有实例变量时（不论是不是用property）这个方法才会出现，且父类的实例变量不会导致子类拥有这个方法</li>
<li>出现这个方法和变量是否被赋值，赋值成什么没有关系</li>
</ol>
<h2 id="使用watchpoint定位内存释放时刻">使用watchpoint定位内存释放时刻</h2><p>依然在after new断点处，输入lldb命令：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watchpoint <span class="built_in">set</span> <span class="built_in">variable</span> son<span class="subst">-&gt;</span>_name</span><br></pre></td></tr></table></figure></p>
<p>将name的变量加入<code>watchpoint</code>，当这个变量被修改时会触发trigger：</p>
<p><img src="http://ww3.sinaimg.cn/large/51530583gw1ef28rn41lcj20fs03aq3b.jpg" alt=""></p>
<p>从中可以看出，在这个时刻，<code>_name</code>从0x00006b98变成了0x0，也就是nil，赶紧看下调用栈：</p>
<p><img src="http://ww1.sinaimg.cn/large/51530583gw1ef2911o40zj20a605yweu.jpg" alt=""></p>
<p>发现果然跟到了<code>.cxx_destruct</code>方法，而且是在objc_storeStrong的过程中释放</p>
<h1 id="刨根问底-cxx_destruct">刨根问底.cxx_destruct</h1><p>知道了ARC下对象实例变量的释放过程在<code>.cxx_destruct</code>内完成，但这个函数内部发生了什么，是如何调用<code>objc_storeStrong</code>释放变量的呢？<br>从上面的探究中知道，<code>.cxx_destruct</code>是编译器生成的代码，那它很可能在clang前端编译时完成，这让我联想到clang的Code Generation，因为之前曾经使用<code>clang -rewrite-objc xxx.m</code>时查看过官方文档留下了些印象，于是google：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.cxx_destruct</span> site:clang<span class="class">.llvm</span><span class="class">.org</span></span><br></pre></td></tr></table></figure></p>
<p>结果发现clang的doxygen文档中<code>CodeGenModule</code>模块正是这部分的实现代码，cxx相关的代码生成部分源码在<br><a href="http://clang.llvm.org/doxygen/CodeGenModule_8cpp-source.html" target="_blank" rel="external">http://clang.llvm.org/doxygen/CodeGenModule_8cpp-source.html</a><br>位于1827行，删减掉离题部分如下：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// EmitObjCIvarInitializations - Emit information for ivar initialization</span></span><br><span class="line"><span class="comment">/// for an implementation.</span></span><br><span class="line">void CodeGenModule::EmitObjCIvarInitializations<span class="params">(ObjCImplementationDecl *D)</span> </span><br><span class="line">&#123;</span><br><span class="line">    DeclContext<span class="built_in">*</span> DC = const_cast&lt;DeclContext<span class="built_in">*</span>&gt;<span class="params">(dyn_cast&lt;DeclContext&gt;<span class="params">(D)</span>)</span>;</span><br><span class="line">    assert<span class="params">(DC &amp;&amp; <span class="string">"EmitObjCIvarInitializations - null DeclContext"</span>)</span>;</span><br><span class="line">    IdentifierInfo <span class="built_in">*</span>II = &amp;getContext<span class="params">()</span>.Idents.get<span class="params">(<span class="string">".cxx_destruct"</span>)</span>;</span><br><span class="line">    Selector cxxSelector = getContext<span class="params">()</span>.Selectors.getSelector<span class="params">(<span class="number">0</span>, &amp;II)</span>;</span><br><span class="line">    ObjCMethodDecl <span class="built_in">*</span>DTORMethod = ObjCMethodDecl::Create<span class="params">(getContext<span class="params">()</span>, </span><br><span class="line">                                                        D-&gt;getLocation<span class="params">()</span>,</span><br><span class="line">                                                        D-&gt;getLocation<span class="params">()</span>, cxxSelector,</span><br><span class="line">                                                        getContext<span class="params">()</span>.VoidTy, <span class="number">0</span>, </span><br><span class="line">                                                        DC, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>,</span><br><span class="line">                                                        ObjCMethodDecl::Required)</span>;</span><br><span class="line">   D-&gt;addInstanceMethod<span class="params">(DTORMethod)</span>;</span><br><span class="line">   CodeGenFunction<span class="params">(*this)</span>.GenerateObjCCtorDtorMethod<span class="params">(D, DTORMethod, <span class="literal">false</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数大概作用是：获取.<code>cxx_destruct</code>的selector，创建Method，并加入到这个Class的方法列表中，最后一行的调用才是真的创建这个方法的实现。这个方法位于<br><a href="http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html" target="_blank" rel="external">http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html</a></p>
<p>1354行，包含了构造和析构的cxx方法，继续跟随<code>.cxx_destruct</code>，最终调用<code>emitCXXDestructMethod</code>函数，代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> emitCXXDestructMethod(CodeGenFunction &amp;<span class="built_in">CGF</span>, Obj<span class="built_in">CImplementationDecl</span> *impl) </span><br><span class="line">&#123;</span><br><span class="line">   CodeGenFunction::RunCleanupsScope scope(<span class="built_in">CGF</span>);</span><br><span class="line"> </span><br><span class="line">   llvm::Value *<span class="keyword">self</span> = <span class="built_in">CGF</span><span class="variable">.LoadObjCSelf</span>();</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">const</span> Obj<span class="built_in">CInterfaceDecl</span> *iface = impl-&gt;getClassInterface();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">const</span> Obj<span class="built_in">CIvarDecl</span> *ivar = iface-&gt;all_declared_ivar_begin(); ivar; ivar = ivar-&gt;getNextIvar()) </span><br><span class="line">   &#123;</span><br><span class="line">     QualType type = ivar-&gt;getType();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Check whether the ivar is a destructible type.</span></span><br><span class="line">     QualType::DestructionKind dtorKind = type<span class="variable">.isDestructedType</span>();</span><br><span class="line">     <span class="keyword">if</span> (!dtorKind) <span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line">     CodeGenFunction::Destroyer *destroyer = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// Use a call to objc_storeStrong to destroy strong ivars, for the</span></span><br><span class="line">     <span class="comment">// general benefit of the tools.</span></span><br><span class="line">     <span class="keyword">if</span> (dtorKind == QualType::DK_objc_strong_lifetime) &#123;</span><br><span class="line">       destroyer = destroyARCStrongWithStore;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// Otherwise use the default for the destruction kind.</span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       destroyer = <span class="built_in">CGF</span><span class="variable">.getDestroyer</span>(dtorKind);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     CleanupKind cleanupKind = <span class="built_in">CGF</span><span class="variable">.getCleanupKind</span>(dtorKind);</span><br><span class="line">     <span class="built_in">CGF</span><span class="variable">.EHStack</span><span class="variable">.pushCleanup</span>&lt;DestroyIvar&gt;(cleanupKind, <span class="keyword">self</span>, ivar, destroyer,</span><br><span class="line">                                          cleanupKind &amp; EHCleanup);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   assert(scope<span class="variable">.requiresCleanups</span>() &amp;&amp; <span class="string">"nothing to do in .cxx_destruct?"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析这段代码以及其中调用后发现：它遍历当前对象所有的实例变量（Ivars)，调用<code>objc_storeStrong</code>，从clang的ARC文档上可以找到<code>objc_storeStrong</code>的示意代码实现如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">id <span class="title">objc_storeStrong</span>(<span class="params">id *<span class="keyword">object</span>, id <span class="keyword">value</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">value</span> = [<span class="keyword">value</span> retain];</span><br><span class="line">  id oldValue = *<span class="keyword">object</span>;</span><br><span class="line">  *<span class="keyword">object</span> = <span class="keyword">value</span>;</span><br><span class="line">  [oldValue release];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>.cxx_destruct</code>进行形如<code>objc_storeStrong(&amp;ivar, null)</code>的调用后，这个实例变量就被release和设置成nil了<br>注：真实的实现可以参考 <a href="http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html" target="_blank" rel="external">http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html</a> 2078行</p>
<h2 id="自动调用[super_dealloc]的实现">自动调用[super dealloc]的实现</h2><p>按照上面的思路，自动调用<code>[super dealloc]</code>也一定是CodeGen干的工作了<br>位于 <a href="http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html" target="_blank" rel="external">http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html</a> 492行<br><code>StartObjCMethod</code>方法中：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="params">(ident-&gt;isStr<span class="params">(<span class="string">"dealloc"</span>)</span>)</span></span><br><span class="line">   EHStack.pushCleanup&lt;FinishARCDealloc&gt;<span class="params">(getARCCleanupKind<span class="params">()</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码可以得知在调用<code>dealloc</code>方法时被插入了代码，由FinishARCDealloc结构定义：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="type">FinishARCDealloc</span> : <span class="type">EHScopeStack</span>::<span class="type">Cleanup</span> &#123;</span><br><span class="line">   <span class="type">void</span> <span class="type">Emit</span>(<span class="type">CodeGenFunction</span> &amp;<span class="type">CGF</span>, <span class="type">Flags</span> flags) override &#123;</span><br><span class="line">     <span class="keyword">const</span> <span class="type">ObjCMethodDecl</span> *<span class="keyword">method</span> = <span class="keyword">cast</span>&lt;<span class="type">ObjCMethodDecl</span>&gt;(<span class="type">CGF</span>.<span class="type">CurCodeDecl</span>);</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">const</span> <span class="type">ObjCImplDecl</span> *impl = <span class="keyword">cast</span>&lt;<span class="type">ObjCImplDecl</span>&gt;(<span class="keyword">method</span>-&gt;getDeclContext());</span><br><span class="line">     <span class="keyword">const</span> <span class="type">ObjCInterfaceDecl</span> *iface = impl-&gt;getClassInterface();</span><br><span class="line">     <span class="keyword">if</span> (!iface-&gt;getSuperClass()) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">     <span class="type">bool</span> isCategory = isa&lt;<span class="type">ObjCCategoryImplDecl</span>&gt;(impl);</span><br><span class="line"> </span><br><span class="line">     // <span class="type">Call</span> [super dealloc] <span class="keyword">if</span> we have a superclass.</span><br><span class="line">     llvm::<span class="type">Value</span> *self = <span class="type">CGF</span>.<span class="type">LoadObjCSelf</span>();</span><br><span class="line"> </span><br><span class="line">     <span class="type">CallArgList</span> args;</span><br><span class="line">     <span class="type">CGF</span>.<span class="type">CGM</span>.getObjCRuntime().<span class="type">GenerateMessageSendSuper</span>(<span class="type">CGF</span>, <span class="type">ReturnValueSlot</span>(),</span><br><span class="line">                                                       <span class="type">CGF</span>.getContext().<span class="type">VoidTy</span>,</span><br><span class="line">                                                       <span class="keyword">method</span>-&gt;getSelector(),</span><br><span class="line">                                                       iface,</span><br><span class="line">                                                       isCategory,</span><br><span class="line">                                                       self,</span><br><span class="line">                                                       /*<span class="keyword">is</span> class msg*/ <span class="literal">false</span>,</span><br><span class="line">                                                       args,</span><br><span class="line">                                                       <span class="keyword">method</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码基本上就是向父类转发dealloc的调用，实现了自动调用[super dealloc]方法。</p>
<h2 id="总结">总结</h2><ol>
<li>ARC下对象的成员变量于编译器插入的.cxx_desctruct方法自动释放</li>
<li>ARC下[super dealloc]方法也由编译器自动插入</li>
<li>所谓编译器插入代码过程需要进一步了解，还不清楚其运作方式</li>
<li>clang的CodeGen也值得深入研究一下</li>
</ol>
<h2 id="References：">References：</h2><p><a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html" target="_blank" rel="external">http://clang.llvm.org/docs/AutomaticReferenceCounting.html</a><br><a href="http://my.safaribooksonline.com/book/programming/objective-c/9780132908641/3dot-memory-management/ch03" target="_blank" rel="external">http://my.safaribooksonline.com/book/programming/objective-c/9780132908641/3dot-memory-management/ch03</a><br><a href="http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html" target="_blank" rel="external">http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://blog.sunnyxx.com/2014/04/02/objc_dig_arc_dealloc/" target="_blank" rel="external">转</a></p>
<h1 id="ARC下dealloc过程及-cxx_de]]>
    </summary>
    
      <category term="arc" scheme="http://ytlvy.com/tags/arc/"/>
    
      <category term="dealloc" scheme="http://ytlvy.com/tags/dealloc/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ios attribute cleanup]]></title>
    <link href="http://ytlvy.com/2015/07/17/ios-attribute-cleanup/"/>
    <id>http://ytlvy.com/2015/07/17/ios-attribute-cleanup/</id>
    <published>2015-07-17T08:24:01.000Z</published>
    <updated>2015-07-19T09:18:32.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://blog.sunnyxx.com/2014/09/15/objc-attribute-cleanup/" target="_blank" rel="external">转自</a></p>
<h2 id="黑魔法attribute((cleanup))">黑魔法<strong>attribute</strong>((cleanup))</h2><p>编译器属性<strong>attribute</strong>用于向编译器描述特殊的标识、检查或优化，几个常用的用法看<a href="http://nshipster.com/__attribute__/" target="_blank" rel="external">mattt大神的文章</a>就好。今天发现一个名为cleanup的黑魔法属性，简单介绍下。</p>
<h3 id="基本用法">基本用法</h3><p><code>__attribute__((cleanup(...)))</code>，用于修饰一个变量，在它的作用域结束时可以自动执行一个指定的方法，如：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定一个cleanup方法，注意入参是所修饰变量的地址，类型要一样</span></span><br><span class="line"><span class="comment">// 对于指向objc对象的指针(id *)，如果不强制声明__strong默认是__autoreleasing，造成类型不匹配</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> stringCleanUp(__<span class="keyword">strong</span> <span class="built_in">NSString</span> **string) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, *string);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在某个方法中：</span></span><br><span class="line">&#123;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="built_in">NSString</span> *string __attribute__((cleanup(stringCleanUp))) = <span class="string">@"sunnyxx"</span>;</span><br><span class="line">&#125; <span class="comment">// 当运行到这个作用域结束时，自动调用stringCleanUp</span></span><br></pre></td></tr></table></figure>
<p>所谓作用域结束，包括大括号结束、return、goto、break、exception等各种情况。<br>当然，可以修饰的变量不止NSString，自定义Class或基本类型都是可以的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义的Class</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> sarkCleanUp(__<span class="keyword">strong</span> Sark **sark) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, *sark);</span><br><span class="line">&#125;</span><br><span class="line">__<span class="keyword">strong</span> Sark *sark __attribute__((cleanup(sarkCleanUp))) = [Sark new];</span><br><span class="line"><span class="comment">// 基本类型</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> intCleanUp(<span class="built_in">NSInteger</span> *integer) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, *integer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSInteger</span> integer __attribute__((cleanup(intCleanUp))) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>假如一个作用域内有若干个cleanup的变量，他们的调用顺序是先入后出的栈式顺序；<br>而且，cleanup是先于这个对象的dealloc调用的。</p>
<h3 id="进阶用法">进阶用法</h3><p>既然<code>__attribute__((cleanup(...)))</code>可以用来修饰变量，block当然也是其中之一，写一个block的cleanup函数非常有趣：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// <span class="type">void</span>(^<span class="keyword">block</span>)(<span class="type">void</span>)的指针是<span class="type">void</span>(^*<span class="keyword">block</span>)(<span class="type">void</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> blockCleanUp(__strong <span class="type">void</span>(^*<span class="keyword">block</span>)(<span class="type">void</span>)) &#123;</span><br><span class="line">    (*<span class="keyword">block</span>)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是在一个作用域里声明一个block：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 加了个`unused`的attribute用来消除`unused variable`的warning</span></span><br><span class="line">    __strong void<span class="params">(^block)</span><span class="params">(void)</span> __attribute__<span class="params">(<span class="params">(cleanup<span class="params">(blockCleanUp)</span>, unused)</span>)</span> = ^&#123;</span><br><span class="line">        NSLog<span class="params">(@<span class="string">"I'm dying..."</span>)</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="comment">// 这里输出"I'm dying..."</span></span><br></pre></td></tr></table></figure>
<p>这里不得不提万能的<code>Reactive Cocoa</code>中神奇的<code>@onExit</code>方法，其实正是上面的写法，简单定义个宏：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hexcolor">#def</span>ine onExit\</span><br><span class="line">    __strong <span class="function"><span class="title">void</span><span class="params">(^block)</span><span class="params">(void)</span></span> __attribute__((<span class="function"><span class="title">cleanup</span><span class="params">(blockCleanUp)</span></span>, unused)) = ^</span><br></pre></td></tr></table></figure>
<p>用这个宏就能将一段写在前面的代码最后执行：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    onExit &#123;</span><br><span class="line">        <span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"yo"</span>);</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="comment">// Log "yo"</span></span><br></pre></td></tr></table></figure>
<p>这样的写法可以将成对出现的代码写在一起，比如说一个lock：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSRecursiveLock</span> *aLock = [[<span class="built_in">NSRecursiveLock</span> alloc] init];</span><br><span class="line">[aLock lock];</span><br><span class="line"><span class="comment">// 这里</span></span><br><span class="line"><span class="comment">//     有</span></span><br><span class="line"><span class="comment">//        100多万行</span></span><br><span class="line">[aLock unlock]; <span class="comment">// 看到这儿的时候早忘了和哪个lock对应着了</span></span><br></pre></td></tr></table></figure>
<p>用了<code>onExit</code>之后，代码更集中了：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSRecursiveLock</span> *aLock = [[<span class="built_in">NSRecursiveLock</span> alloc] init];</span><br><span class="line">[aLock lock];</span><br><span class="line">onExit &#123;</span><br><span class="line">    [aLock unlock]; <span class="comment">// 妈妈再也不用担心我忘写后半段了</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这里</span></span><br><span class="line"><span class="comment">//    爱多少行</span></span><br><span class="line"><span class="comment">//           就多少行</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://blog.sunnyxx.com/2014/09/15/objc-attribute-cleanup/" target="_blank" rel="external">转自</a></p>
<h2 id="黑魔法attribute((clea]]>
    </summary>
    
      <category term="attribute" scheme="http://ytlvy.com/tags/attribute/"/>
    
      <category term="dig" scheme="http://ytlvy.com/tags/dig/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ios arc dig]]></title>
    <link href="http://ytlvy.com/2015/07/17/ios-arc-dig/"/>
    <id>http://ytlvy.com/2015/07/17/ios-arc-dig/</id>
    <published>2015-07-17T08:23:20.000Z</published>
    <updated>2015-07-19T09:18:32.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://blog.sunnyxx.com/2014/03/15/objc_arc_secret/" target="_blank" rel="external">转自</a></p>
<h2 id="objc_arc的简单探索">objc arc的简单探索</h2><h3 id="ARC_or_not？">ARC or not？</h3><p><code>Automatic Reference Counting</code>是objc发展以来相当重要的一个进步</p>
<blockquote>
<p>对于开发者，任何能降低开发难度，简化代码的功能，我们都应该去了解和使用。<br>我们应该利用一切“偷懒”的机会，将软件开发的复杂度分解并控制在一个个小的范围内，使得对于分解后的每一个小的任务，都能被新手掌握和维护。</p>
</blockquote>
<p>基于简化开发的思想来看，ARC绝对是一个<strong>没理由拒绝</strong>的技术进步。<br>ARC随着iOS5问世，到现在iOS8都快出了，你还在手动写retain，release么？除了固守思想外，对ARC的恐惧大都来自对它的未知。</p>
<p>比如我在公司尝试说服team使用ARC时被质疑的几个问题：</p>
<ol>
<li><p>ARC和Java的GC一样，会导致一部分性能损耗？<br>首先，ARC和GC是两码事，ARC是编译时编译器“帮你”插入了原本需要自己手写的内存管理代码，而非像GC一样运行时的垃圾回收系统</p>
</li>
<li><p>ARC内存不知道什么时候释放，导致不可控的内存涨落？<br>了解ARC的原理后，就知道，ARC下编译器插入的内存管理的代码是经过优化的，对于使用完的内存，多运行一行代码都不会浪费，可以这么说，手写的内存管理必须达到很严谨的水平才可能达到ARC自动生成的一样完整且没有疏漏</p>
</li>
<li><p>ARC下面自己不管理内存，很不爽，很没有安全感<br>这纯粹是习惯的问题了，开发者的目标是用最简化的手段完成一个最可靠的程序，进步需要改变的。好在编译选项中提供了<code>-fobjc-arc</code>和<code>-fno-objc-arc</code>来保证整个的变革的继续下去，就像社会主义中国里的港澳</p>
</li>
</ol>
<h3 id="ARC的约定">ARC的约定</h3><p>使用ARC之后一个费解的地方是，一个方法生成的对象，没有任何附加标示，ARC怎么知道生成的对象是不是<code>autorelease</code>的呢？</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@interface</span> <span class="string">Sark :</span> NSObject</span><br><span class="line">+ (instancetype)<span class="string">sarkWithMark:</span>(NSString *)mark; <span class="comment">// 1</span></span><br><span class="line">- (instancetype)<span class="string">initWithMark:</span>(NSString *)mark; <span class="comment">// 2</span></span><br><span class="line"><span class="annotation">@end</span></span><br></pre></td></tr></table></figure>
<p>这是非ARC时常用的手段，1生成autorelease对象，2生成普通对象，而现在ARC不能调用autorelease，使用时怎么能知道呢？</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">&#123;</span><br><span class="line">    // ...</span><br><span class="line">    Sark *sark1 = <span class="collection">[Sark sarkWithMark:@<span class="string">"萨萨萨"</span>]</span><span class="comment">;</span></span><br><span class="line">    Sark *sark2 = <span class="collection">[<span class="collection">[Sark alloc]</span> initWithMark:@<span class="string">"萨萨萨"</span>]</span><span class="comment">;</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>使用约定，NS定义了下面三个编译属性</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hexcolor">#def</span>ine NS_RETURNS_RETAINED __attribute__((ns_returns_retained))</span><br><span class="line"><span class="hexcolor">#def</span>ine NS_RETURNS_NOT_RETAINED __attribute__((ns_returns_not_retained))</span><br><span class="line"><span class="hexcolor">#def</span>ine NS_RETURNS_INNER_POINTER __attribute__((objc_returns_inner_pointer))</span><br></pre></td></tr></table></figure>
<p>这三个属性是Clang自己使用的标示，除非<strong>特殊情况</strong>不要自己使用，但是这些对理解ARC是很有帮助的。<br>这里还要介绍一个概念，<code>Method family</code></p>
<blockquote>
<p>An Objective-C method may fall into a method family, which is a conventional set of behaviors ascribed to it by the Cocoa conventions.</p>
</blockquote>
<p>指的是命名上表示一类型的方法，比如<code>- init</code>和<code>- initWithMark:</code>都属于init的family<br>于是乎，编译器约定，对于<code>alloc</code>, <code>init</code>, <code>copy</code>, <code>mutableCopy</code>, <code>new</code>这几个家族的方法，后面默认加<code>NS_RETURNS_RETAINED</code>标识；而其他不指名标识的family的方法默认添加<code>NS_RETURNS_NOT_RETAINED</code>标识<br>也就是说刚才的方法，在编译器看来是这样的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Sark</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (instancetype)sarkWithMark:(<span class="built_in">NSString</span> *)mark <span class="built_in">NS_RETURNS_NOT_RETAINED</span>; <span class="comment">// 1</span></span><br><span class="line">- (instancetype)initWithMark:(<span class="built_in">NSString</span> *)mark <span class="built_in">NS_RETURNS_RETAINED</span>; <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>这也就是为什么ARC下面，不能把一个属性定义成名字是这样的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *newString; <span class="comment">// 编译器不允许</span></span><br></pre></td></tr></table></figure>
<p><code>- newString</code>就成了new家族的方法，内存就不对了<br>对于<code>NS_RETURNS_INNER_POINTER</code>这货，主要使用在返回的是一个对象的内部C指针的情况，如NSString的方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (__<span class="keyword">strong</span> <span class="keyword">const</span> <span class="keyword">char</span> *)UTF8String <span class="built_in">NS_RETURNS_INNER_POINTER</span>;</span><br></pre></td></tr></table></figure>
<p>就使用了这个标识，这个就不深入研究了，直接上文档：</p>
<blockquote>
<p>An Objective-C method returning a non-retainable pointer may be annotated with the objc_returns_inner_pointer attribute to indicate that it returns a handle to the internal data of an object, and that this reference will be invalidated if the object is destroyed. When such a message is sent to an object, the object’s lifetime will be extended until at least the earliest of:<br>the last use of the returned pointer, or any pointer derived from it, in the calling function or<br>the autorelease pool is restored to a previous state.</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://blog.sunnyxx.com/2014/03/15/objc_arc_secret/" target="_blank" rel="external">转自</a></p>
<h2 id="objc_arc的简单探索">objc arc的简]]>
    </summary>
    
      <category term="arc" scheme="http://ytlvy.com/tags/arc/"/>
    
      <category term="dig" scheme="http://ytlvy.com/tags/dig/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS kvo dig]]></title>
    <link href="http://ytlvy.com/2015/07/17/iOS-kvo-dig/"/>
    <id>http://ytlvy.com/2015/07/17/iOS-kvo-dig/</id>
    <published>2015-07-17T08:22:49.000Z</published>
    <updated>2015-07-19T09:18:32.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://blog.sunnyxx.com/2014/03/09/objc_kvo_secret/" target="_blank" rel="external">转自</a></p>
<h2 id="objc_kvo简单探索">objc kvo简单探索</h2><p><code>KVO(Key Value Observing)</code>，是观察者模式在Foundation中的实现</p>
<h3 id="KVO的原理">KVO的原理</h3><p>简而言之就是：</p>
<ol>
<li>当一个object有观察者时，动态创建这个object的类的子类</li>
<li>对于每个被观察的property，重写其set方法</li>
<li>在重写的set方法中调用- willChangeValueForKey:和- didChangeValueForKey:通知观察者</li>
<li>当一个property没有观察者时，删除重写的方法</li>
<li>当没有observer观察任何一个property时，删除动态创建的子类</li>
</ol>
<p>空说无凭，简单验证下。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Sark</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Sark</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">Sark *sark = [Sark new];</span><br><span class="line"><span class="comment">// breakpoint 1</span></span><br><span class="line">[sark addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">nil</span>];</span><br><span class="line"><span class="comment">// breakpoint 2</span></span><br><span class="line">sark<span class="variable">.name</span> = <span class="string">@"萨萨萨"</span>;</span><br><span class="line">[sark removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span>];</span><br><span class="line"><span class="comment">// breakpoint 3</span></span><br></pre></td></tr></table></figure>
<p>断住后分别使用- class和object_getClass()打出sark对象的Class和真实的Class</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// breakpoint 1</span></span><br><span class="line">(lldb) po sark<span class="class">.class</span></span><br><span class="line">Sark</span><br><span class="line">(lldb) po <span class="function"><span class="title">object_getClass</span><span class="params">(sark)</span></span></span><br><span class="line">Sark</span><br><span class="line"></span><br><span class="line"><span class="comment">// breakpoint 2</span></span><br><span class="line">(lldb) po sark<span class="class">.class</span></span><br><span class="line">Sark</span><br><span class="line">(lldb) po <span class="function"><span class="title">object_getClass</span><span class="params">(sark)</span></span></span><br><span class="line">NSKVONotifying_Sark</span><br><span class="line"></span><br><span class="line"><span class="comment">// breakpoint 3</span></span><br><span class="line">(lldb) po sark<span class="class">.class</span></span><br><span class="line">Sark</span><br><span class="line">(lldb) po <span class="function"><span class="title">object_getClass</span><span class="params">(sark)</span></span></span><br><span class="line">Sark</span><br></pre></td></tr></table></figure>
<p>上面的结果说明，在sark对象被观察时，framework使用runtime动态创建了一个Sark类的子类<code>NSKVONotifying_Sark</code><br>而且为了隐藏这个行为，<code>NSKVONotifying_Sark</code>重写了<code>- class</code>方法返回之前的类，就好像什么也没发生过一样<br>但是使用<code>object_getClass()</code>时就暴露了，因为这个方法返回的是这个对象的isa指针，这个指针指向的一定是个这个对象的类对象</p>
<hr>
<p>然后来偷窥一下这个动态类实现的方法，这里请出一个NSObject的扩展NSObject+DLIntrospection，它封装了打印一个类的方法、属性、协议等常用调试方法，一目了然。<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">@interface NSObject (DLIntrospection)</span></span><br><span class="line">+ (NSArray <span class="keyword">*</span>)classes;</span><br><span class="line">+ (NSArray <span class="keyword">*</span>)properties;</span><br><span class="line">+ (NSArray <span class="keyword">*</span>)instanceVariables;</span><br><span class="line">+ (NSArray <span class="keyword">*</span>)classMethods;</span><br><span class="line">+ (NSArray <span class="keyword">*</span>)instanceMethods;</span><br><span class="line"></span><br><span class="line">+ (NSArray <span class="keyword">*</span>)protocols;</span><br><span class="line">+ (NSDictionary <span class="keyword">*</span>)descriptionForProtocol:(Protocol <span class="keyword">*</span>)proto;</span><br><span class="line"></span><br><span class="line">+ (NSString <span class="keyword">*</span>)parentClassHierarchy;</span><br><span class="line"><span class="comment">@end</span></span><br></pre></td></tr></table></figure></p>
<p>然后继续在刚才的断点处调试：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// breakpoint 1</span></span><br><span class="line"><span class="params">(lldb)</span> po [object_getClass<span class="params">(sark)</span> instanceMethods]</span><br><span class="line">&lt;__NSArrayI <span class="number">0</span>x8e9aa00&gt;<span class="params">(</span><br><span class="line">- <span class="params">(void)</span>setName:<span class="params">(id)</span>arg0 ,</span><br><span class="line">- <span class="params">(void)</span>.cxx_destruct,</span><br><span class="line">- <span class="params">(id)</span>name</span><br><span class="line">)</span></span><br><span class="line"><span class="comment">// breakpoint 2</span></span><br><span class="line"><span class="params">(lldb)</span> po [object_getClass<span class="params">(sark)</span> instanceMethods]</span><br><span class="line">&lt;__NSArrayI <span class="number">0</span>x8d55870&gt;<span class="params">(</span><br><span class="line">- <span class="params">(void)</span>setName:<span class="params">(id)</span>arg0 ,</span><br><span class="line">- <span class="params">(class)</span>class,</span><br><span class="line">- <span class="params">(void)</span>dealloc,</span><br><span class="line">- <span class="params">(BOOL)</span>_isKVOA</span><br><span class="line">)</span></span><br><span class="line"><span class="comment">// breakpoint 3</span></span><br><span class="line"><span class="params">(lldb)</span> po [object_getClass<span class="params">(sark)</span> instanceMethods]</span><br><span class="line">&lt;__NSArrayI <span class="number">0</span>x8e9cff0&gt;<span class="params">(</span><br><span class="line">- <span class="params">(void)</span>setName:<span class="params">(id)</span>arg0 ,</span><br><span class="line">- <span class="params">(void)</span>.cxx_destruct,</span><br><span class="line">- <span class="params">(id)</span>name</span><br><span class="line">)</span></span><br></pre></td></tr></table></figure>
<p>从上面breakpoint2的打印可以看出，动态类重写了4个方法：</p>
<ol>
<li><code>- setName:</code> 最主要的重写方法，set值时调用通知函数</li>
<li><code>- class</code> 隐藏自己必备啊，返回原来类的class</li>
<li><code>- dealloc</code> 做清理犯罪现场工作</li>
<li><code>- _isKVOA</code> 这就是内部使用的标示了，判断这个类有没被KVO动态生成子类</li>
</ol>
<hr>
<p>接下来验证一下KVO重写set方法后是否调用了<code>- willChangeValueForKey:</code>和<code>- didChangeValueForKey:</code><br>最直接的验证方法就是在Sark类中重写这两个方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Sark</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)willChangeValueForKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromSelector</span>(_cmd));</span><br><span class="line">    [<span class="keyword">super</span> willChangeValueForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromSelector</span>(_cmd));</span><br><span class="line">    [<span class="keyword">super</span> didChangeValueForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://blog.sunnyxx.com/2014/03/09/objc_kvo_secret/" target="_blank" rel="external">转自</a></p>
<h2 id="objc_kvo简单探索">objc kvo简单探]]>
    </summary>
    
      <category term="dig" scheme="http://ytlvy.com/tags/dig/"/>
    
      <category term="kvo" scheme="http://ytlvy.com/tags/kvo/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS category dig]]></title>
    <link href="http://ytlvy.com/2015/07/17/iOS-category-dig/"/>
    <id>http://ytlvy.com/2015/07/17/iOS-category-dig/</id>
    <published>2015-07-17T08:22:13.000Z</published>
    <updated>2015-07-19T09:18:32.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://blog.sunnyxx.com/2014/03/05/objc_category_secret/" target="_blank" rel="external">转自</a></p>
<h2 id="objc_category的秘密">objc category的秘密</h2><h3 id="category的真面目">category的真面目</h3><p>objc所有类和对象都是c结构体，category当然也一样，下面是runtime中category的结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="keyword">_category_t</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">_class_t</span> *cls; <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">struct</span> <span class="keyword">_method_list_t</span> *instance_methods; <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">struct</span> <span class="keyword">_method_list_t</span> *class_methods; <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">struct</span> <span class="keyword">_protocol_list_t</span> *protocols; <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">struct</span> <span class="keyword">_prop_list_t</span> *properties; <span class="comment">// 6</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>name</code> 注意，并不是<code>category</code>小括号里写的名字，而是类的名字</li>
<li><code>cls</code> 要扩展的类对象，编译期间这个值是不会有的，在app被runtime加载时才会根据name对应到类对象</li>
<li><code>instance_methods</code>这个category所有的-方法</li>
<li><code>class_methods</code>这个category所有的+方法</li>
<li><code>protocols</code>这个category实现的protocol，比较不常用在category里面实现协议，但是确实支持的</li>
<li><code>properties</code>这个category所有的property，这也是category里面可以定义属性的原因，不过这个property不会@synthesize实例变量，一般有需求添加实例变量属性时会采用<code>objc_setAssociatedObject</code>和<code>objc_getAssociatedObject</code>方法绑定方法绑定，不过这种方法生成的与一个普通的实例变量完全是两码事。</li>
</ol>
<h3 id="编译器，你对category干了什么？">编译器，你对category干了什么？</h3><p>举个栗子看，定义下面一个类和它的category，实现忽略，保存为sark.h和sark.m</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">Sark </span>: NSObject</span><br><span class="line">- (void)speak;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@interface</span> Sark (GayExtention)</span><br><span class="line">- (void)burst;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<p>请出clang的重写命令：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>clang -rewrite-objc sark.m</span><br></pre></td></tr></table></figure>
<p>同级目录下会生成sark.cpp，这就是objc代码重写成c++(基本就是c)的实现。<br>打开生成的文件，发现茫茫多，排除include进来的header，自己的代码都在文件尾部了，看看上面的category被编译器搞成什么样子了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> <span class="keyword">_category_t</span> _OBJC_$_CATEGORY_Sark_$_GayExtention __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"Sark"</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="comment">// &amp;OBJC_CLASS_$_Sark,</span></span><br><span class="line">    (<span class="keyword">const</span> <span class="keyword">struct</span> <span class="keyword">_method_list_t</span> *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_Sark_$_GayExtention,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>先注意这个category的名字<code>_OBJC_$_CATEGORY_Sark_$_GayExtention</code>，这是一个按规则生成的符号了，中间的<code>Sark</code>是类名，后面的<code>GayExtention</code>是类别的名字，这也就是为什么同一个类的<code>category</code>名不能冲突了<br>对应看上面<code>_category_t</code>的定义，因为category里面只添加了一个<code>- burst</code>方法，所以只有实例方法那一项被填充了值<code>_OBJC_$_CATEGORY_INSTANCE_METHODS_Sark_$_GayExtention</code></p>
<p>其中<code>_I_Sark_GayExtention_burst</code>符号就代表了category里面的<code>- burst</code>方法，同样遵循了一定的命名规范，里面的<code>I</code>表示实例方法</p>
<p>最后，这个类的category们生成了一个数组，存在了<code>__DATA</code>段下的<code>__objc_catlistsection</code>里<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> _category_t *L_OBJC_LABEL_<span class="built_in">CATEGORY_</span>$ [<span class="number">1</span>] __attribute__((used, section (<span class="string">"__DATA, __objc_catlist, regular, no_dead_strip"</span>)))= &#123;</span><br><span class="line">    &amp;_OBJC_$_<span class="built_in">CATEGORY_Sark_</span>$_GayExtention,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>至此编译器的任务完成了。</p>
<h3 id="runtime，我的category哪儿去了？">runtime，我的category哪儿去了？</h3><p>我们知道，category动态扩展了原来类的方法，在调用者看来好像原来类本来就有这些方法似的，有两个事实：</p>
<ol>
<li>不论有没有import category 的.h，都可以成功调用category的方法，都影响不到category的加载流程，import只是帮助了编译检查和链接过程</li>
<li>runtime加载完成后，category的原始信息在类结构里将不会存在</li>
</ol>
<p>这需要探究下runtime对category的加载过程，这里就简单说一下</p>
<ol>
<li>objc runtime的加载入口是一个叫_objc_init的方法，在library加载前由libSystem dyld调用，进行初始化操作</li>
<li>调用map_images方法将文件中的imagemap到内存</li>
<li>调用_read_images方法初始化map后的image，这里面干了很多的事情，像load所有的类、协议和category，著名的+ load方法就是这一步调用的</li>
<li>仔细看category的初始化，循环调用了_getObjc2CategoryList方法，这个方法拿出来看看：</li>
<li>…</li>
</ol>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#define GETSECT(name, type, sectname)                                   \</span></span><br><span class="line">    <span class="typedef"><span class="keyword">type</span> *name<span class="container">(<span class="title">const</span> <span class="title">header_info</span> *<span class="title">hi</span>, <span class="title">size_t</span> *<span class="title">outCount</span>)</span>  \</span></span><br><span class="line">    &#123;                                                                   \</span><br><span class="line">        unsigned long byteCount = <span class="number">0</span>;                                    \</span><br><span class="line">        <span class="typedef"><span class="keyword">type</span> *<span class="keyword">data</span> = <span class="container">(<span class="title">type</span> *)</span>                                           \</span></span><br><span class="line">            getsectiondata(hi-&gt;mhdr, <span class="type">SEG_DATA</span>, sectname, &amp;byteCount);   \</span><br><span class="line">        *outCount = byteCount / sizeof(<span class="typedef"><span class="keyword">type</span>);                           \</span></span><br><span class="line">        return <span class="typedef"><span class="keyword">data</span>;                                                    \</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// ... //</span><br><span class="line"></span><br><span class="line"><span class="type">GETSECT</span>(_getObjc2CategoryList, category_t *, <span class="string">"__objc_catlist"</span>);</span><br></pre></td></tr></table></figure>
<p>眼熟的<code>__objc_catlist</code>，就是上面category存放的数据段了，可以串连起来了</p>
<p>在调用完<code>_getObjc2CategoryList</code>后，runtime终于开始了category的处理，简化的代码如下</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Process this category.</span></span><br><span class="line"><span class="comment">// First, register the category with its target class.</span></span><br><span class="line"><span class="comment">// Then, rebuild the class's method lists (etc) if</span></span><br><span class="line"><span class="comment">// the class is realized.</span></span><br><span class="line">BOOL classExists = NO;</span><br><span class="line"><span class="keyword">if</span> <span class="params">(cat-&gt;instanceMethods ||  cat-&gt;protocols  ||  cat-&gt;instanceProperties)</span></span><br><span class="line">&#123;</span><br><span class="line">    addUnattachedCategoryForClass<span class="params">(cat, cls, hi)</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="params">(isRealized<span class="params">(cls)</span>)</span> &#123;</span><br><span class="line">        remethodizeClass<span class="params">(cls)</span>;</span><br><span class="line">        classExists = YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="params">(cat-&gt;classMethods  ||  cat-&gt;protocols )</span></span><br><span class="line">&#123;</span><br><span class="line">    addUnattachedCategoryForClass<span class="params">(cat, cls-&gt;isa, hi)</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="params">(isRealized<span class="params">(cls-&gt;isa)</span>)</span> &#123;</span><br><span class="line">        remethodizeClass<span class="params">(cls-&gt;isa)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先分成两拨，一拨是实例对象相关的调用a<code>ddUnattachedCategoryForClass</code>，一拨是类对象相关的调用<code>addUnattachedCategoryForClass</code>，然后会调到<code>attachCategoryMethods</code>方法，这个方法把一个类所有的<code>category_list</code>的所有方法取出来组成一个<code>method_list_t **</code>，注意，这里是倒序添加的，也就是说，新生成的category的方法会先于旧的category的方法插入</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line"><span class="title">attachCategoryMethods</span><span class="params">(class_t *cls, category_list *cats,</span><br><span class="line">                      BOOL *inoutVtablesAffected)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cats) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line"></span><br><span class="line">    BOOL isMeta = isMetaClass(cls);</span><br><span class="line">    <span class="keyword">method_list_t</span> **mlists = (<span class="keyword">method_list_t</span> **)</span><br><span class="line">        _malloc_internal(cats-&gt;count * <span class="keyword">sizeof</span>(*mlists));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Count backwards through cats to get newest categories first</span></span><br><span class="line">    <span class="keyword">int</span> mcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = cats-&gt;count;</span><br><span class="line">    BOOL fromBundle = NO;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="keyword">method_list_t</span> *mlist = cat_method_list(cats-&gt;<span class="built_in">list</span>[i].cat, isMeta);</span><br><span class="line">        <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">            fromBundle |= cats-&gt;<span class="built_in">list</span>[i].fromBundle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    attachMethodLists(cls, mlists, mcount, NO, fromBundle, inoutVtablesAffected);</span><br><span class="line"></span><br><span class="line">    _free_internal(mlists);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成了所有method的list之后，调用attachMethodLists将所有方法前序添加进类的方法的数组中，也就是说，如果原来类的方法是a,b,c，类别的方法是1,2,3，那么插入之后的方法将会是1,2,3,a,b,c，也就是说，原来类的方法被category的方法覆盖了，但被覆盖的方法确实还在那里。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://blog.sunnyxx.com/2014/03/05/objc_category_secret/" target="_blank" rel="external">转自</a></p>
<h2 id="objc_category的秘密">ob]]>
    </summary>
    
      <category term="category" scheme="http://ytlvy.com/tags/category/"/>
    
      <category term="dig" scheme="http://ytlvy.com/tags/dig/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ios self in arc]]></title>
    <link href="http://ytlvy.com/2015/07/17/ios-self-in-arc/"/>
    <id>http://ytlvy.com/2015/07/17/ios-self-in-arc/</id>
    <published>2015-07-17T08:21:33.000Z</published>
    <updated>2015-07-19T09:18:32.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://blog.sunnyxx.com/2015/01/17/self-in-arc/" target="_blank" rel="external">转自</a></p>
<h2 id="ARC对self的内存管理">ARC对self的内存管理</h2><p>记录下前两天的一次讨论，源于网络库<code>YTKNetwork</code>中“YTKRequest.m”的 <code>- start</code> 方法其中的几行代码：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)start &#123;</span><br><span class="line">    // ......</span><br><span class="line">    YTKRequest *<span class="keyword">strongSelf </span>= <span class="keyword">self;</span><br><span class="line"></span>    [<span class="keyword">strongSelf.delegate </span>requestFinished:<span class="keyword">strongSelf];</span><br><span class="line"></span>    <span class="preprocessor">if</span> (<span class="keyword">strongSelf.successCompletionBlock) </span>&#123;</span><br><span class="line">        <span class="keyword">strongSelf.successCompletionBlock(strongSelf);</span><br><span class="line"></span>    &#125;</span><br><span class="line">    [<span class="keyword">strongSelf </span>clearCompletionBlock]<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的问题大概是这样：</p>
<ol>
<li>调用方（如view controller）实例化并强引用YTKRequest对象，将自己作为其delegate</li>
<li>调用方调用YTKRequest的 <code>- start</code> 方法发起网络请求</li>
<li>调用方在 <code>- requestFinished:</code> 中执行了<code>self.request = nil</code>;</li>
<li>YTKRequest中，<code>- start</code>方法在回调完-<code>requestFinished:</code> 后 BAD_ACCESS了</li>
</ol>
<p>也就是说，<code>- start</code>方法还未返回时，<code>self</code>就被外部释放了。作者发现了这个潜在的问题，所以在方法局部增设了一个<code>strongSelf</code>的强引用来保证self的生命周期延续到方法结束。问题是解决了，但是更希望知道原因。</p>
<p>简化说明就是：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (void)<span class="tag">foo</span> &#123;</span><br><span class="line">    <span class="comment">// self被delegate持有</span></span><br><span class="line">    <span class="attr_selector">[self.delegate callout]</span>; <span class="comment">// 外部释放了这个对象</span></span><br><span class="line">    <span class="comment">// 这里self野指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在想想还是比较不符合常理，入参的self居然不能保证这个函数执行完成。后来查阅了下文档，发现是ARC的(gao)机(de)制(gui)，clang的《这篇ARC文档》中有明确的解释，总结如下：</p>
<ul>
<li>ARC下，self既不是strong也不是weak，而是unsafe_unretained的，也就是说，入参的self被表示为：（init系列方法的self除外）</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)start &#123;</span><br><span class="line">   <span class="keyword">const</span> __unsafe_unretained YTKRequest *<span class="keyword">self</span>;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在方法调用时，ARC不会对self做retain或release，生命周期全由它的调用方来保证，如果调用方没有保证，就会出现上面的crash</li>
<li>ARC这样做的原因是性能优化，objc中100%的方法（不是函数）调用第一个参数都是self，同时，99%的情况下，调用方都不会在方法执行时把这个对象释放，所以相比于在每个方法中插入对self的引用计数管理：<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)start &#123;</span><br><span class="line">    objc_retain(<span class="keyword">self</span>);</span><br><span class="line">    <span class="regexp">//</span> 其中的代码<span class="keyword">self</span>一定不会被释放</span><br><span class="line">    objc_release(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>优化了的性能还真是比较可观。 而且，ARC也用了挺多方法来避免开发者进行额外的引用计数控制，比如方法的命名约定，通过判断方法是否以如init，alloc，new，copy等关键字开头来决定其内存管理方式。</p>
<hr>
<h4 id="One_more_thing">One more thing</h4><p>在写test时发现，下面两种调用方法会导致不同结果：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (void)<span class="tag">viewDidLoad</span> &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="attr_selector">[_request start]</span>; <span class="comment">// crash</span></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="attr_selector">[self.request start]</span>; <span class="comment">// 正常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为self.request是一次方法调用，返回的结果被objc_retainAutoreleasedReturnValue方法在局部进行了一次强引用</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://blog.sunnyxx.com/2015/01/17/self-in-arc/" target="_blank" rel="external">转自</a></p>
<h2 id="ARC对self的内存管理">ARC对self的内存管理<]]>
    </summary>
    
      <category term="arc" scheme="http://ytlvy.com/tags/arc/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS Class Clusters]]></title>
    <link href="http://ytlvy.com/2015/07/17/iOS-Class-Clusters/"/>
    <id>http://ytlvy.com/2015/07/17/iOS-Class-Clusters/</id>
    <published>2015-07-17T08:20:40.000Z</published>
    <updated>2015-07-19T09:18:32.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://blog.sunnyxx.com/2014/12/18/class-cluster/" target="_blank" rel="external">转自</a></p>
<h2 id="从NSArray看类簇">从NSArray看类簇</h2><h3 id="Class_Clusters">Class Clusters</h3><p>Class Clusters（类簇）是<code>抽象工厂</code>模式在iOS下的一种实现，众多常用类，如NSString，NSArray，NSDictionary，NSNumber都运作在这一模式下，它是接口简单性和扩展性的权衡体现，在我们完全不知情的情况下，偷偷隐藏了很多具体的实现类，只暴露出简单的接口。</p>
<h3 id="NSArray的类簇">NSArray的类簇</h3><p>虽然<a href="https://developer.apple.com/library/ios/documentation/general/conceptual/CocoaEncyclopedia/ClassClusters/ClassClusters.html" target="_blank" rel="external">官方文档</a>中拿<code>NSNumber</code>说事儿，但Foundation并没有像图中描述的那样为每个number都弄一个子类，于是研究下NSArray类簇的实现方式。</p>
<h4 id="__NSPlacehodlerArray">__NSPlacehodlerArray</h4><p>熟悉这个模式的同学很可能看过下面的测试代码，将原有的alloc+init拆开写：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> obj1 = [<span class="built_in">NSArray</span> alloc]; <span class="comment">// __NSPlacehodlerArray *</span></span><br><span class="line"><span class="keyword">id</span> obj2 = [<span class="built_in">NSMutableArray</span> alloc];  <span class="comment">// __NSPlacehodlerArray *</span></span><br><span class="line"><span class="keyword">id</span> obj3 = [obj1 init];  <span class="comment">// __NSArrayI *</span></span><br><span class="line"><span class="keyword">id</span> obj4 = [obj2 init];  <span class="comment">// __NSArrayM *</span></span><br></pre></td></tr></table></figure>
<p>发现<code>+ alloc</code>后并非生成了我们期望的类实例，而是一个<code>__NSPlacehodlerArray</code>的中间对象，后面的<code>- init</code>或<code>- initWithXXXXX</code>消息都是发送给这个中间对象，再由它做工厂，生成真的对象。这里的<code>__NSArrayI</code>和<code>__NSArrayM</code>分别对应Immutable和Mutable（后面的I和M的意思）</p>
<p>于是顺着思路猜实现，<code>__NSPlacehodlerArray</code>必定用某种方式存储了它是由谁alloc出来的这个信息，才能在init的时候知道要创建的是可变数组还是不可变数组</p>
<p>于是乎很开心的去看了下*obj1的内存布局：</p>
<p><img src="http://ww4.sinaimg.cn/large/51530583jw1em3doxs660j20l80j6go3.jpg" alt=""></p>
<p>下面是32位模拟器中的内存布局（64位太长不好看就临时改32位了- -），第一个箭头是<code>*obj1</code>，第二个是<code>*obj2</code></p>
<p><img src="http://ww3.sinaimg.cn/mw690/51530583jw1em3dvmuuanj213006maf2.jpg" alt=""></p>
<p>我们知道，对象的前4字节（32位下）为isa指针，指向类对象地址，上图所示的<code>0x0051E768</code>就是<code>__NSPlacehodlerArray</code>类对象地址，可以从lldb下po这个地址来验证。</p>
<p>那么问题来了，这个中间对象并没有储存任何信息诶（除了isa外就都是0了），那它init的时候咋知道该创建什么呢？<br>经过研究发现，Foundation用了一个很贱的比较静态实例地址方式来实现，伪代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __<span class="built_in">NSPlacehodlerArray</span> *GetPlaceholderFor<span class="built_in">NSArray</span>() &#123;</span><br><span class="line">    <span class="keyword">static</span> __<span class="built_in">NSPlacehodlerArray</span> *instanceFor<span class="built_in">NSArray</span>;</span><br><span class="line">    <span class="keyword">if</span> (!instanceFor<span class="built_in">NSArray</span>) &#123;</span><br><span class="line">        instanceFor<span class="built_in">NSArray</span> = [[__<span class="built_in">NSPlacehodlerArray</span> alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instanceFor<span class="built_in">NSArray</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __<span class="built_in">NSPlacehodlerArray</span> *GetPlaceholderFor<span class="built_in">NSMutableArray</span>() &#123;</span><br><span class="line">    <span class="keyword">static</span> __<span class="built_in">NSPlacehodlerArray</span> *instanceFor<span class="built_in">NSMutableArray</span>;</span><br><span class="line">    <span class="keyword">if</span> (!instanceFor<span class="built_in">NSMutableArray</span>) &#123;</span><br><span class="line">        instanceFor<span class="built_in">NSMutableArray</span> = [[__<span class="built_in">NSPlacehodlerArray</span> alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instanceFor<span class="built_in">NSMutableArray</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// NSArray实现</span></span><br><span class="line">+ (<span class="keyword">id</span>)alloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> == [<span class="built_in">NSArray</span> class]) &#123;</span><br><span class="line">        <span class="keyword">return</span> GetPlaceholderFor<span class="built_in">NSArray</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// NSMutableArray实现</span></span><br><span class="line">+ (<span class="keyword">id</span>)alloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> == [<span class="built_in">NSMutableArray</span> class]) &#123;</span><br><span class="line">        <span class="keyword">return</span> GetPlaceholderFor<span class="built_in">NSMutableArray</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// __NSPlacehodlerArray实现</span></span><br><span class="line">- (<span class="keyword">id</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> == GetPlaceholderFor<span class="built_in">NSArray</span>()) &#123;</span><br><span class="line">        <span class="keyword">self</span> = [[__<span class="built_in">NSArrayI</span> alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span> == GetPlaceholderFor<span class="built_in">NSMutableArray</span>()) &#123;</span><br><span class="line">        <span class="keyword">self</span> = [[__<span class="built_in">NSArrayM</span> alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Foundation不是开源的，所以上面的代码是猜测的，思路大概就是这样，可以这样验证下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> obj1 = [<span class="built_in">NSArray</span> alloc]; </span><br><span class="line"><span class="keyword">id</span> obj2 = [<span class="built_in">NSArray</span> alloc];</span><br><span class="line"><span class="keyword">id</span> obj3 = [<span class="built_in">NSMutableArray</span> alloc];</span><br><span class="line"><span class="keyword">id</span> obj4 = [<span class="built_in">NSMutableArray</span> alloc];</span><br><span class="line"><span class="comment">// 1和2地址相同，3和4地址相同，无论多少次都相同，且地址相差16位</span></span><br></pre></td></tr></table></figure></p>
<h4 id="静态不可变空对象">静态不可变空对象</h4><p>除此之外，Foundation对<code>不可变</code>版本的空数组也做了个小优化：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSArray <span class="keyword">*</span>arr1 = [[NSArray alloc] init];</span><br><span class="line">NSArray <span class="keyword">*</span>arr2 = [[NSArray alloc] init];</span><br><span class="line">NSArray <span class="keyword">*</span>arr3 = <span class="comment">@[];</span></span><br><span class="line">NSArray <span class="keyword">*</span>arr4 = <span class="comment">@[];</span></span><br><span class="line">NSArray <span class="keyword">*</span>arr5 = <span class="comment">@[@1];</span></span><br></pre></td></tr></table></figure>
<p>上边1-4号都指向了同一个对象，而arr5指向了另一个对象。</p>
<p>若干个不可变的空数组间没有任何特异性，返回一个静态对象也理所应当。<br>不仅是NSArray，Foundation中如<code>NSString</code>, <code>NSDictionary</code>, <code>NSSet</code>等区分可变和不可变版本的类，空实例都是静态对象（NSString的空实例对象是常量区的@””）</p>
<p>所以也给用这些方法来测试对象内存管理的同学提个醒，很容易意料之外的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://blog.sunnyxx.com/2014/12/18/class-cluster/" target="_blank" rel="external">转自</a></p>
<h2 id="从NSArray看类簇">从NSArray看类簇</h]]>
    </summary>
    
      <category term="Class Clusters" scheme="http://ytlvy.com/tags/Class-Clusters/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[objc@interface的设计哲学与设计技巧]]></title>
    <link href="http://ytlvy.com/2015/07/17/iOS-interface-dig/"/>
    <id>http://ytlvy.com/2015/07/17/iOS-interface-dig/</id>
    <published>2015-07-17T08:18:19.000Z</published>
    <updated>2015-07-19T09:18:32.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://blog.sunnyxx.com/2014/04/13/objc_dig_interface/" target="_blank" rel="external">转自</a></p>
<h2 id="objc@interface的设计哲学与设计技巧">objc@interface的设计哲学与设计技巧</h2><h3 id="我是前言">我是前言</h3><p>学习objc时，尤其是先学过其他编程语言再来看objc时，总会对objc的类声明的关键字<code>interface</code>感到有点奇怪，在其它面向对象的语言中通常由class关键字来表示，而interface在java中表示的却大约相当于objc的protocol，这个关键字的区别究竟代表了objc语言的设计者怎样的思想呢，在objc类设计中需要注意哪些问题呢？接下来对这个问题进行一些思考和探究.</p>
<h3 id="interface?">interface?</h3><p>先来段Wiki:</p>
<blockquote>
<p>In object-oriented programming, a protocol or interface is a common means for unrelated objects to communicate with each other. These are definitions of methods and values which the objects agree upon in order to cooperate.</p>
</blockquote>
<p>接口约定了对象间交互的属性和方法，使得对象间无需了解对方就可以协作。<br>说的洋气点就是解耦嘛，细心点也能发现Wiki中interface和protocol表示了相近的语义。<br>引用我和项目组架构师讨论有关interface的问题时他的说法:</p>
<blockquote>
<p>interface就是一个object定义的可以被外界影响的方式</p>
</blockquote>
<p>说着他指了下旁边桌子上放着的一把伞，说，这把伞我可以打开它，打开这个动作就是它的一个interface，桌子旁边还放着一个盒子，虽然它和伞都放在这张桌子上，但是它们之间永远不会互相影响，所以：</p>
<blockquote>
<p>interface只存在于能互相影响的两者间</p>
</blockquote>
<h3 id="@interface生成了class？">@interface生成了class？</h3><p>学习<code>objc</code>时最早接触的就是怎么写一个类了，从.h中写<code>@interface</code>声明类，再从.m中写<code>@implementation</code>实现方法，所以，objc中写一个<code>@interface</code>就相当于c++中写一个class。但这是真的么？</p>
<p>写个小test验证一下：<br>有两个类，<code>Sark</code>和<code>Dark</code>，<code>Sark</code>类只有.m文件，其中只写<code>@implementation</code>；<code>Dark</code>类只有.h头文件，其中只写<code>@interface</code>，然后如下测试代码：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Class</span> sarkClass = NSClassFromString(@<span class="string">"Sark"</span>);</span><br><span class="line"><span class="keyword">Class</span> darkClass = NSClassFromString(@<span class="string">"Dark"</span>);</span><br></pre></td></tr></table></figure>
<p><code>NSClassFromString</code>方法调用了runtime方法，根据类名将加载进runtime的这个类找出来，没有这个类就回返回空(Nil)。<br>结果是<code>sarkClass</code>存在，而<code>darkClass</code>为空，说明什么？是否说明其实<code>@implementation</code>才是真正的Class？<br>进一步，不止能取到这个没有<code>@interface</code>的类，还可以正常调用方法（因为万能的runtime）</p>
<p>如下面的测试代码：<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sark *sark = [Sark new]<span class="comment">;</span></span><br><span class="line">[sark speak]<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>要是没有@interface的声明，类名，方法名都会报错说找不到，但是可以像下面一样绕一下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class cls = <span class="built_in">NSClassFromString</span>(<span class="string">@"Sark"</span>);</span><br><span class="line"><span class="keyword">id</span> obj = [cls performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"new"</span>)];</span><br><span class="line">[obj performSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"speak"</span>)];</span><br></pre></td></tr></table></figure></p>
<p>其实，从<code>rewrite</code>后的<code>objc</code>代码可以发现，对于消息的发送，恰恰就是会被处理成类似上面的代码，使用字符串<code>mapping</code>出Class，selctor等再使用<code>objc_msgSend()</code>进行函数调用，如下面所示：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 经过clang -rewrite-objc 命令重写后的代码</span></span><br><span class="line">Sark <span class="built_in">*</span>sark = <span class="params">(<span class="params">(id <span class="params">(*)</span><span class="params">(id, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span>objc_getClass<span class="params">(<span class="string">"Sark"</span>)</span>, sel_registerName<span class="params">(<span class="string">"new"</span>)</span>)</span>;</span><br><span class="line"><span class="params">(<span class="params">(void <span class="params">(*)</span><span class="params">(id, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span>sark, sel_registerName<span class="params">(<span class="string">"speak"</span>)</span>)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="对比@interface和@implementation">对比@interface和@implementation</h3><p><code>@interface</code>我们干过的事：</p>
<ol>
<li>继承</li>
<li>声明协议</li>
<li>定义实例变量（@interface后面加大括号那种）</li>
<li>定义@property</li>
<li>声明方法</li>
</ol>
<p><code>@implementation</code>我们干过的和可以干的事：</p>
<ol>
<li>继承</li>
<li>定义实例变量</li>
<li>合成属性（@synthesize和@dynamic）</li>
<li>实现方法（包括协议方法）</li>
</ol>
<p>在<code>@implementation</code>干一些事情用的相对较少，但是是完全合法的，如这样用：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Sark</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *_name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过对比可以发现，<code>@interface</code>对objc类结构的合成并无决定性作用，加上无决定性是因为如果没有@interface会丢失一些类自省的原始数据，如属性列表和协议列表，但对于纯粹的对象消息发送并无影响。<br>所以说，可以得出这么一个结论，objc中<code>@interface</code>就是为了给调用者看的，是和调用者的一个protocol，没错，就是<strong>protocol</strong>。</p>
<h3 id="对比@interface和@protocol">对比@interface和@protocol</h3><p>与其把<code>@implementation</code>扯进来不如对比下<code>@protocol</code></p>
<p>我理解objc的<code>@interface</code>和<code>@protocal</code>间唯一的区别就是是否和一个类型绑定，这让我想起来鸭子类型(Duck typing), <a href="http://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B" target="_blank" rel="external">wiki链接</a></p>
<blockquote>
<p>“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”</p>
</blockquote>
<p><code>Duck type</code>在objc的体现无疑就是<code>@protocol</code>了，我们常用<code>id&lt;XXXDelegate&gt; delegate</code>的方式声明一个<code>delegate</code>，我们无需care这货到底是什么类型，我们只知道他能干什么就可以work了。同样的功能我也可以使用<code>XXXDelegate *delegate</code>的方式来定义，只不过这样的话这个类又需要耦合一个XXXDelegate类型，而这个delegate类是它原本并不需要关心的。</p>
<p>所以说，<code>@interface</code>是<code>@protocol</code>的强类型升级版。</p>
<p>举个NSObject的例子最合适：<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="class"><span class="keyword">interface</span> <span class="title">NSObject</span> &lt;<span class="title">NSObject</span>&gt; &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">Class</span> <span class="title">isa</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>NSObject</code>之所以成为NSObject，绝大多数都是<code>&lt;NSObject&gt;</code>协议定义的方法，实体类<code>@interface</code>定义的唯一一个变量isa指针，为了继承链和消息传递。<br>除了<code>&lt;NSObject&gt;</code>协议外，NSObject还有很多<code>Category</code>来补充它的功能，其实仔细想想，Category更像protocol，一个补充协议，同样不能添加实例变量，但是和<code>@interface</code>一样需要与Class绑定。</p>
<p>进一步来讲，自从属性能自动合成变量之后，在头文件@interface中写大括号声明实例变量的情况越来越少（可以参见近几个版本iOS SDK中类头文件里这种写法几乎消失），因此，@interface和@protocol的差别进一步缩小。</p>
<hr>
<h2 id="类与接口的设计原则_-_电视和遥控器">类与接口的设计原则 - 电视和遥控器</h2><p>我喜欢将<code>Class</code>和<code>interface</code>的关系比喻成电视+遥控器，那么objc中的消息机制就可以理解成：<br>用户（caller）通过遥控器（interface）上的按钮（methods）发送红外线（message）来操纵电视（object）<br>所以，有没有遥控器，电视都在那儿，也就是说，有没有interface，class都是存在的，只是这种存在并没有意义，就好像这个电视没人会打开，没人会用，没人能看，一堆废铁摆在那儿。</p>
<p><img src="http://ww4.sinaimg.cn/large/51530583tw1efdy7cw48wj20c108qjru.jpg" alt=""></p>
<p>对比简洁的遥控器，一个拥有很多按钮的老式电视遥控器，我们经常会用到的按钮能有几个呢？</p>
<p><img src="http://ww4.sinaimg.cn/large/51530583tw1efe08u9hb7j208c0b4jrp.jpg" alt=""></p>
<p>所以，在设计一个类的interface的时候，如同在设计遥控器应该有怎样功能的按钮，要从调用者的角度出发，区分边界，应该时刻有以下几点考虑：</p>
<ol>
<li>这个方法或属性真的属于这个类的职责么？（电视遥控器能遥控空调？）</li>
<li>这个方法或属性真的必须放在.h中（而不是放在.m的类扩展中）么？</li>
<li>调用者必须看文档才能知道这个类该如何使用么？（同一个业务需要调用者按顺序调用多次（而不是将这些细节隐藏，同时提供一个简洁的接口）才行）</li>
<li>调用者是否可以很容易发现类内部的变量和实现方式？（脑补下电视里面一块电路板漏在外面半截- -）</li>
<li>…</li>
</ol>
<hr>
<h3 id="objc的@interface设计技巧Tips">objc的@interface设计技巧Tips</h3><p>看过不少代码，从@interface设计上多少就能看出作者的水平，分享下我对于这个问题的一些拙见。</p>
<h4 id="只暴露外部需要看到的">只暴露外部需要看到的</h4><p>比如，有如下一个类(这个类无意义，主要关注写法) :<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sark.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SarkViewController</span> : <span class="title">NSObject</span> &lt;<span class="title">NSXMLParserDelegate</span> /*1*/, <span class="title">NSCopying</span>&gt; </span>&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *_name; <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">IBOutlet</span> <span class="built_in">UITextField</span> *_nameTextField; <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSXMLParser</span> *parser; <span class="comment">// 3</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)nameChangedAction:(<span class="keyword">id</span>)sender; <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>这个interface出现的问题：</p>
<ol>
<li>类内部自己使用的协议，如<code>&lt;NSXMLParserDelegate&gt;</code>不应该在头文件@interface中声明，而应该在类扩展中声明；公开由外部调用的协议，如<code>&lt;NSCopying&gt;</code>则写在这儿是正确的。</li>
<li><code>实例变量</code>和<code>IBOutlet</code>不应出现在这儿定义，这将类的内部实现暴露了出去，自从属性可以自动合成后，这里就更应该清净了。</li>
<li>内部使用的属性对象不要暴露在外，应该移动到类扩展中。</li>
<li>调用者对IBAction同样不需要关心，那么就不应该放在这儿。</li>
</ol>
<h4 id="合理分组子功能">合理分组子功能</h4><ul>
<li>将相同功能的一组属性或方法写在一起. 使用这个类或者对其进行修改时，一般都是从功能上找，所以把同一功能模块的一组属性或方法写在一块</li>
<li>纯操作方法的子功能（无需向类添加变量）使用Category分块</li>
<li>在头文件中也可以使用类扩展将interface按功能分区</li>
</ul>
<p><code>Category</code>里不能添加实例变量，但是类扩展可以，一般都在.m中作为私有interface使用，同样在头文件里作为分区使用，如，ReactiveCocoa中的RACStream.h</p>
<h4 id="避免头文件污染">避免头文件污染</h4><p>首先，类实现内部.m文件中使用的其他interface应该在.m文件import，如果也写在header中就会造成对调用者的污染；当interface中出现其他Class或protocol时，可以使用前置声明<code>@class XXX,</code> <code>@protocol XXX</code>；当模块（一组类）内部间需要有一些定义（如常量、类型）而又不需要模块使用者知道时，使用一个内部头文件在模块中使用。</p>
<h4 id="避免接口过度设计">避免接口过度设计</h4><p>考虑调用者的使用方便是很必要的，过火了反而增加了复杂度：<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface Sark : NSObject</span><br><span class="line">- <span class="params">(instancetype)</span>init;</span><br><span class="line">- <span class="params">(instancetype)</span>initWithName:<span class="params">(NSString *)</span>name;</span><br><span class="line">- <span class="params">(instancetype)</span>initWithName:<span class="params">(NSString *)</span>name sex:<span class="params">(NSString *)</span>sex;</span><br><span class="line">- <span class="params">(instancetype)</span>initWithName:<span class="params">(NSString *)</span>name sex:<span class="params">(NSString *)</span>sex age:<span class="params">(NSInteger)</span>age;</span><br><span class="line">- <span class="params">(instancetype)</span>initWithName:<span class="params">(NSString *)</span>name sex:<span class="params">(NSString *)</span>sex age:<span class="params">(NSInteger)</span>age friends:<span class="params">(NSArray *)</span>friends;</span><br><span class="line"><span class="comment">// 无数多个 //</span></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>提供了一组这样的方法，调用者可能只能用到其中的一个，那这样倒不如只留一个接口。</p>
<h4 id="避免单例的滥用">避免单例的滥用</h4><p>单例模式固然好用，但感觉有点过度，将接口设计成单例入口前需要考虑一下：</p>
<ol>
<li>这个类表达的含义真的只能有一个实例么？（如UIApplication）还是只是为了好调用而已？</li>
<li>这个单例持有的内存一直存在</li>
<li>是否能用类方法代替？</li>
<li>这个单例对象是否能成为另一个单例对象的属性？如果是，应该作为属性</li>
</ol>
<h4 id="隐藏继承关系中的私有接口">隐藏继承关系中的私有接口</h4><p>感谢@像条狗在飞在留言中提出的问题，问题大概可以总结为：当子类需要使用父类的一个私有属性（方法）时，需要把这个属性（方法）放到父类的header中，但暴露给子类的同时暴露给了外部调用者，如何解决?</p>
<p>我的方案是：建立一个私有<code>header</code>，使用类扩展定义父类需要暴露给子类的属性（方法），然后在各自的.m文件中引用，如：</p>
<p>有Father类和Son类，继承关系，可以考虑建一个如FatherPrivate.h的私有header：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FatherPrivate.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Father</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *privateThingSonNeed;</span><br><span class="line">- (<span class="keyword">void</span>)privateMethodNeedsSonOverride;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>同时在Father.m和Son.m中同时import这个私有header，这样，Father和Son内部对于定义的属性和方法都是透明的，而对外部是隐藏的（因为两个类的header中都没有import这个私有header）</p>
<h3 id="总结">总结</h3><ol>
<li>@implementation合成了Class，而非@interface，@interface是@protocol的强类型升级版，它们和Category都表示了相近的含义</li>
<li>我们应该善于面向接口编程，划清边界，将类的实现隐藏在调用者所见之外，使主调和被调者之间保持最少知识原则</li>
<li>@interface本身就是最好的文档</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://blog.sunnyxx.com/2014/04/13/objc_dig_interface/" target="_blank" rel="external">转自</a></p>
<h2 id="objc@interface的设计哲学与设计]]>
    </summary>
    
      <category term="dig" scheme="http://ytlvy.com/tags/dig/"/>
    
      <category term="interface" scheme="http://ytlvy.com/tags/interface/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Debug]]></title>
    <link href="http://ytlvy.com/2015/07/16/Debug/"/>
    <id>http://ytlvy.com/2015/07/16/Debug/</id>
    <published>2015-07-16T01:50:30.000Z</published>
    <updated>2015-07-19T09:18:32.000Z</updated>
    <content type="html"><![CDATA[<h3 id="调试">调试</h3><h4 id="DTrace">DTrace</h4><p>You can use <code>DTrace</code> to monitor a running application to see the methods and the classes that are called. You can easily monitor an iOS app running in the Simulator using DTrace on the command line, First you will need to find the PID of the application using ps and then you can run a <code>DTrace</code> probe like the following:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dtrace -<span class="tag">q</span> -n <span class="string">'objc1234:::entry &#123; printf("%s %s\n", probemod, probefunc); &#125;'</span></span><br></pre></td></tr></table></figure></p>
<p>where 1234 is the process ID of the app.</p>
<p>If you are only interested in tracing a single class, UIView for example, you could use:<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dtrace -q -n <span class="string">'objc1234</span>:UIView::entry &#123; printf(<span class="string">"%s %s\n"</span>, probemod, probefunc); &#125;'</span><br></pre></td></tr></table></figure></p>
<p>If you wanted to trace all calls to dealloc on all classes, you would use:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dtrace -<span class="tag">q</span> -n <span class="string">'objc1234::-dealloc:entry &#123; printf("%s %s\n", probemod, probefunc); &#125;'</span></span><br></pre></td></tr></table></figure></p>
<p>Obviously, you could combine these to only see UIView deallocs:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dtrace -<span class="tag">q</span> -n <span class="string">'objc1234:UIView:-dealloc:entry &#123; printf("%s %s\n", probemod, probefunc); &#125;'</span></span><br></pre></td></tr></table></figure></p>
<p>If you want to be able to distinguish a specific object of a class you could also print the memory address of the object (self) using the following:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dtrace -<span class="tag">q</span> -n <span class="string">'objc1234:UIView:-dealloc:entry &#123; printf("%s (0x%p) %s\n", probemod, arg0, probefunc); &#125;'</span></span><br></pre></td></tr></table></figure></p>
<h4 id="message_logging_好像不可以了">message logging 好像不可以了</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Turn on message logging</span></span><br><span class="line">instrumentObjcMessageSends(<span class="literal">YES</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert code here...</span></span><br><span class="line"><span class="built_in">NSString</span> *string = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"This is just %d cool"</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now turn it off again</span></span><br><span class="line">instrumentObjcMessageSends(<span class="literal">NO</span>);</span><br></pre></td></tr></table></figure>
<h4 id="检测是否为主线程">检测是否为主线程</h4><pre><code>[NSThread isMainThread]
</code></pre><h4 id="打印引用计数">打印引用计数</h4><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSLog<span class="list">(@<span class="string">"retain count = %d"</span>, _objc_rootRetainCount<span class="list">(<span class="keyword">obj</span>)</span>)</span><span class="comment">;</span></span><br><span class="line">NSLog<span class="list">(@<span class="string">"Retain count is %ld"</span>, CFGetRetainCount<span class="list">(<span class="list">(<span class="keyword">__bridge</span> CFTypeRef)</span>myObject)</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h4 id="output_observation_information_for_object">output observation information for object</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">po</span><span class="sqbracket"> [self observationInfo]</span></span><br></pre></td></tr></table></figure>
<h4 id="lldb_增强">lldb 增强</h4><pre><code>brew install chisel

vim ~/.lldbinit
command script <span class="keyword">import</span> <span class="regexp">/usr/</span>local<span class="regexp">/Cellar/</span>chisel<span class="regexp">/1.1.0/</span>libexec/fblldb.py
</code></pre><h4 id="lldb_命令">lldb 命令</h4><pre><code><span class="function"><span class="title">print</span><span class="params">(p)</span></span>
po
call function
bt   Printing the Stacktrace
<span class="function"><span class="title">expr</span><span class="params">(e)</span></span> todo<span class="class">.title</span> = @<span class="string">"Changed"</span>
</code></pre><h4 id="lldb_增强命令">lldb 增强命令</h4><pre><code>pviews  
    <span class="type">Print</span> the recursive view description <span class="keyword">for</span> the key window.    <span class="type">Yes</span> <span class="type">Yes</span>
pvc
    <span class="type">Print</span> the recursive view controller description <span class="keyword">for</span> the key window. <span class="type">Yes</span> <span class="type">No</span>
visualize
    <span class="type">Open</span> a <span class="type">UIImage</span>, <span class="type">CGImageRef</span>, <span class="type">UIView</span>, <span class="keyword">or</span> <span class="type">CALayer</span> <span class="keyword">in</span> <span class="type">Preview</span>.app on your <span class="type">Mac</span>.  <span class="type">Yes</span> <span class="type">No</span>
fv  
    <span class="type">Find</span> a view <span class="keyword">in</span> the hierarchy whose class name matches the provided regex.   <span class="type">Yes</span> <span class="type">No</span>
fvc
    <span class="type">Find</span> a view controller <span class="keyword">in</span> the hierarchy whose class name matches the provided regex.    <span class="type">Yes</span> <span class="type">No</span>
show/hide
    <span class="type">Show</span> <span class="keyword">or</span> hide the given view <span class="keyword">or</span> layer. <span class="type">You</span> don't even have to <span class="keyword">continue</span> the process to see the changes!   <span class="type">Yes</span> <span class="type">Yes</span>
mask/unmask
    <span class="type">Overlay</span> a view <span class="keyword">or</span> layer <span class="keyword">with</span> a transparent rectangle to visualize where it <span class="keyword">is</span>.  <span class="type">Yes</span> <span class="type">No</span>
border/unborder
    <span class="type">Add</span> a border to a view <span class="keyword">or</span> layer to visualize where it <span class="keyword">is</span>.   <span class="type">Yes</span> <span class="type">Yes</span>
caflush
    <span class="type">Flush</span> the render server (equivalent to a <span class="string">"repaint"</span> <span class="keyword">if</span> no animations are <span class="keyword">in</span>-flight).)    <span class="type">Yes</span> <span class="type">Yes</span>
bmessage
    <span class="type">Set</span> a symbolic breakpoint on the <span class="keyword">method</span> <span class="keyword">of</span> a class <span class="keyword">or</span> the <span class="keyword">method</span> <span class="keyword">of</span> an instance <span class="keyword">without</span> worrying which class <span class="keyword">in</span> the hierarchy actually implements the <span class="keyword">method</span>.   <span class="type">Yes</span> <span class="type">Yes</span>
wivar
    <span class="type">Set</span> a watchpoint on an instance variable <span class="keyword">of</span> an <span class="keyword">object</span>.  <span class="type">Yes</span> <span class="type">Yes</span>
presponder  
    <span class="type">Print</span> the responder chain starting <span class="keyword">from</span> the given <span class="keyword">object</span>.   <span class="type">Yes</span> <span class="type">Ye</span>
</code></pre><h4 id="show_frame">show frame</h4><pre><code><span class="tag">p</span> (CGRect)[uiTextFieldObj frame]
<span class="tag">p</span> self<span class="class">.view</span><span class="class">.layer</span><span class="class">.frame</span>
</code></pre><h4 id="how_view_hierarchy-">how view hierarchy.</h4><pre><code><span class="id">#ifdef</span> <span class="tag">DEBUG</span>
  <span class="tag">NSLog</span>(@<span class="string">"Cell recursive description:\n\n%@\n\n"</span>, [cell <span class="attribute">performSelector</span>:<span class="variable">@selector</span>(recursiveDescription)]);
<span class="id">#endif</span>
</code></pre><h5 id="显示所有视图">显示所有视图</h5><pre><code>po <span class="comment">[<span class="comment">[UIWindow keyWindow]</span> recursiveDescription]</span>
</code></pre><h5 id="IOS8_显示单个视图">IOS8 显示单个视图</h5><pre><code>po <span class="comment">[<span class="comment">[<span class="comment">[UIWindow keyWindow]</span> rootViewController]</span> _printHierarchy]</span>
</code></pre><h5 id="searchbar_视图">searchbar 视图</h5><pre><code>po <span class="attr_selector">[searchbar recursiveDescription]</span> <span class="comment">//查看索引树</span>
</code></pre><h4 id="LOG">LOG</h4><pre><code><span class="preprocessor">#ifdef DEBUG</span>
<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> ddLogLevel = LOG_LEVEL_VERBOSE;
<span class="preprocessor">#else</span>
<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> ddLogLevel = LOG_LEVEL_OFF;
<span class="preprocessor">#endif</span>

<span class="comment">// 实例化 lumberjack</span>
[DDLog addLogger:[DDTTYLogger sharedInstance]];
<span class="comment">// 允许颜色</span>
[[DDTTYLogger sharedInstance] setColorsEnabled:<span class="literal">YES</span>];

<span class="comment">//lumberjack提供了四种Log方法</span>
DDLogError(<span class="string">@"错误信息"</span>); <span class="comment">// 红色</span>
DDLogWarn(<span class="string">@"警告"</span>); <span class="comment">// 橙色</span>
DDLogInfo(<span class="string">@"提示信息"</span>); <span class="comment">// 默认是黑色</span>
DDLogVerbose(<span class="string">@"详细信息"</span>); <span class="comment">// 默认是黑色</span>

<span class="comment">//如果要修改Log输出的颜色可以使用如下代码</span>
[[DDTTYLogger sharedInstance] setForegroundColor:[<span class="built_in">UIColor</span> blueColor]
                                backgroundColor:<span class="literal">nil</span>
                                        forFlag:LOG_FLAG_INFO];
</code></pre><h4 id="调试的技巧">调试的技巧</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>) buttonPressed :(<span class="built_in">UIButton</span> *)button</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"Stack trace: %@"</span>, [<span class="built_in">NSThread</span> callStackSymbols]);</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"Current selector: %@"</span>, <span class="built_in">NSStringFromSelector</span>(_cmd));  </span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"Object class: %@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> class]));</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"Filename: %@"</span>, [[<span class="built_in">NSString</span> stringWithUTF8String:__FILE__] lastPathComponent]);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="调试">调试</h3><h4 id="DTrace">DTrace</h4><p>You can use <code>DTrace</code> to monitor a running application to see the methods and the]]>
    </summary>
    
      <category term="Debug" scheme="http://ytlvy.com/tags/Debug/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LLDB]]></title>
    <link href="http://ytlvy.com/2015/07/16/LLDB/"/>
    <id>http://ytlvy.com/2015/07/16/LLDB/</id>
    <published>2015-07-16T01:50:00.000Z</published>
    <updated>2015-07-19T09:18:32.000Z</updated>
    <content type="html"><![CDATA[<h3 id="build">build</h3><p>Programs normally have to be compiled with a special option to allow debugging to take place. On UNIX, the option for clang++ is the -g option. For example<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">clang</span><span class="literal">+</span><span class="literal">+</span> <span class="literal">-</span><span class="comment">Wall</span> <span class="literal">-</span><span class="comment">g</span> <span class="literal">-</span><span class="comment">o</span> <span class="comment">prog1</span> <span class="comment">prog1</span><span class="string">.</span><span class="comment">cpp</span></span><br></pre></td></tr></table></figure></p>
<p>We also include the -Wall option, which lists warnings (the ‘all’ is to list all warnings). Note that this option leads to executable files that are larger and slower, so you may not want to use it for final distributions or time-critical programs. But you can always remove the debugging information from an executable without recompiling it with the strip command. For more information on that, see the man page for strip (i.e., run man strip from the command line).</p>
<p>The -g option causes the compiler to include information about the source file (the .cpp file) that is needed for debugging as part of the executable file. This causes the executable to be larger in size, and slightly slower, but allows for debugging. So when you run the debugger, you specify the executable file (not the source file) as the input to the debugger.</p>
<h3 id="Start_Using_lldb">Start Using lldb</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lldb pro<span class="keyword">g1</span></span><br></pre></td></tr></table></figure>
<h3 id="Executing_your_Program">Executing your Program</h3><p>command-line arguments<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">run</span> <span class="bash"><span class="number">100</span> <span class="built_in">test</span>1.dat // prog1 <span class="number">100</span> <span class="built_in">test</span>1.dat</span></span><br></pre></td></tr></table></figure></p>
<h3 id="help">help</h3><p>(lldb) help</p>
<h3 id="excution">excution</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">lldb</span>)</span>r / run</span><br><span class="line"><span class="list">(<span class="keyword">lldb</span>)</span>s / step</span><br><span class="line"><span class="list">(<span class="keyword">lldb</span>)</span>n / next</span><br><span class="line"><span class="list">(<span class="keyword">lldb</span>)</span>c / continue</span><br><span class="line"><span class="list">(<span class="keyword">lldb</span>)</span>si / ni</span><br><span class="line"><span class="list">(<span class="keyword">lldb</span>)</span>finish  <span class="list">(<span class="keyword">finishes</span> executing the current function and then pauses)</span></span><br></pre></td></tr></table></figure>
<h3 id="break_point">break point</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(lldb)<span class="tag">b</span> <span class="function"><span class="title">main</span><span class="params">(set a break at all function named main)</span></span></span><br><span class="line">(lldb)<span class="tag">b</span> test<span class="class">.c</span>:<span class="number">12</span></span><br><span class="line">(lldb)<span class="tag">b</span> -[NSString stringWithFormat:]</span><br><span class="line">(lldb)br s -S count /br set -SvtDataCenterFetchComplete:userData:</span><br><span class="line">(lldb)br list</span><br><span class="line">(lldb)br <span class="tag">del</span> [n]</span><br></pre></td></tr></table></figure>
<h3 id="watch_point">watch point</h3><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) watch <span class="keyword">set</span> <span class="keyword">var</span> -w <span class="keyword">write</span> global_var(<span class="keyword">set</span> <span class="keyword">write</span> watchpoint)</span><br><span class="line">(lldb) watch <span class="keyword">set</span> exp -w <span class="keyword">write</span> -- my_ptr(<span class="keyword">set</span> <span class="keyword">write</span> watchpoint <span class="keyword">in</span> pointer)</span><br><span class="line">(lldb) watch <span class="keyword">set</span> <span class="keyword">var</span> -w <span class="keyword">read</span> global_var(<span class="keyword">set</span> <span class="keyword">read</span> watchpoint)</span><br><span class="line">(lldb) watch modify -c <span class="string">'(global==5)'</span> (<span class="keyword">set</span> condition <span class="keyword">on</span> watch point)</span><br></pre></td></tr></table></figure>
<h3 id="examining_variables">examining variables</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">lldb</span>)</span> frame variable <span class="list">(<span class="keyword">all</span> the arguments and local variables )</span></span><br><span class="line"><span class="list">(<span class="keyword">lldb</span>)</span> frame v -a <span class="list">(<span class="keyword">show</span> local variables for current frame)</span></span><br><span class="line"><span class="list">(<span class="keyword">lldb</span>)</span> frame v isChanged</span><br><span class="line"><span class="list">(<span class="keyword">lldb</span>)</span> target v</span><br><span class="line"><span class="list">(<span class="keyword">lldb</span>)</span> print a_var / po a_var</span><br><span class="line"><span class="list">(<span class="keyword">lldb</span>)</span> display &lt;var&gt; <span class="list">(<span class="keyword">display</span> that variable<span class="quoted">'s</span> value each time the program execution hits a breakpoint)</span></span><br><span class="line"><span class="list">(<span class="keyword">lldb</span>)</span> display <span class="list">(<span class="keyword">show</span> all display variable)</span></span><br><span class="line"><span class="list">(<span class="keyword">lldb</span>)</span> undisplay</span><br></pre></td></tr></table></figure>
<h3 id="Changing_a_Variable’s_Value">Changing a Variable’s Value</h3><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">expr x </span>=<span class="string"> 5</span></span><br></pre></td></tr></table></figure>
<h3 id="examining_thread">examining thread</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">lldb</span>)</span> f<span class="list">(<span class="keyword">see</span> current and surrounding lines)</span></span><br><span class="line"><span class="list">(<span class="keyword">lldb</span>)</span> list <span class="list">(<span class="keyword">shows</span> a listing of the source code where the breakpoint occurred)</span></span><br><span class="line"><span class="list">(<span class="keyword">lldb</span>)</span> thread backtrace</span><br><span class="line"><span class="list">(<span class="keyword">lldb</span>)</span> bt / backtrace</span><br><span class="line"><span class="list">(<span class="keyword">lldb</span>)</span> up<span class="list">(<span class="keyword">select</span> the stack frame that called the current stack frame)</span></span><br><span class="line"><span class="list">(<span class="keyword">lldb</span>)</span> down<span class="list">(<span class="keyword">select</span> the stack frame that is called by the current stack frame)</span></span><br></pre></td></tr></table></figure>
<h3 id="executabe_&amp;&amp;_shared_library">executabe &amp;&amp; shared library</h3><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) image list(list the <span class="keyword">main</span> executable andall dependent <span class="literal">shared</span> libraries)</span><br><span class="line">(lldb) image <span class="literal">dump</span> sections (<span class="literal">dump</span> all sectionsf rom the <span class="keyword">main</span> executable <span class="keyword">and</span> any sharedlibraries))</span><br></pre></td></tr></table></figure>
<h3 id="exaples">exaples</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_subroutine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world"</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = NULL;</span><br><span class="line">    my_subroutine();</span><br><span class="line">    *p = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">", "</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>type run, and let it run to completion (really until it crashes)</li>
<li>try the bt and f commands</li>
<li>set up a break point at line 12, which is the line that is causing the crash</li>
<li>type run, and confirm that you want to restart the program</li>
<li>at the breakpoint, try printing out the value in p (p p); note that it is NULL</li>
<li>set the p pointer, which is currently NULL, to point to a valud value (the int variable - x): expr p = &amp;x</li>
<li>enter c to let it continue running, and it should finish without crashing this time</li>
</ul>
<h3 id="远程调试">远程调试</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process connect <span class="string">connect:</span><span class="comment">//192.168.1.117:1234</span></span><br></pre></td></tr></table></figure>
<h3 id="打印进程模块">打印进程模块</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image <span class="keyword">list</span> -o -<span class="literal">f</span></span><br></pre></td></tr></table></figure>
<h3 id="读取寄存器">读取寄存器</h3><p>register read       读取寄存器<br>x/nfu <addr>        以指定方式读取地址<br>    n 单元格式<br>    f 显示方式, 可取如下值：<br>        x 按十六进制格式显示变量<br>        d 按十进制格式显示变量<br>        u 按十进制格式显示无符号整型<br>        o 按八进制格式显示变量<br>        t 按二进制格式显示变量<br>        a 按十六进制格式显示变量<br>        i 指令地址格式<br>        c 按字符格式显示变量<br>        f 按浮点数格式显示变量<br>    u 地址单元的长度<br>        b 表示单字节<br>        h 表示双字节<br>        w 表示四字节<br>        g 表示八字节</addr></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="build">build</h3><p>Programs normally have to be compiled with a special option to allow debugging to take place. On UNIX, the optio]]>
    </summary>
    
      <category term="Debug" scheme="http://ytlvy.com/tags/Debug/"/>
    
      <category term="LLDB" scheme="http://ytlvy.com/tags/LLDB/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Atom]]></title>
    <link href="http://ytlvy.com/2015/07/16/Atom/"/>
    <id>http://ytlvy.com/2015/07/16/Atom/</id>
    <published>2015-07-16T01:41:32.000Z</published>
    <updated>2015-07-19T09:18:32.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://ninghao.net/blog/2073" target="_blank" rel="external">转自</a></p>
<h2 id="Atom">Atom</h2><p>一款编辑器入门还是很简单的，学会怎么样创建，打开，编辑，保存文件就行。剩下的就是慢慢熟悉，Atom 会不断带给你惊喜，如果你想简化或者加快平时工作中的某些任务或者动作，你就可以去搜索一下，Atom 要么本身就为你提供你需要的功能，没有的话，也可以通过现成的插件（Packages）或者自定义的方式解决。</p>
<h3 id="安装">安装</h3><p>如果你顺着我们的路线走过来，你的电脑上应该已经安装好了系统的包管理工具，Windows 上的 Chocolatey，Mac 上的 Homebrew，Atom 编辑器可以通过包管理工具来安装。</p>
<p>Windows<br>用管理员的身份打开 Powershell，然后用 choco install 去安装 Atom：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">choco <span class="keyword">install</span> atom</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>提示：Atom 编辑器体积挺大，在国内由于网络环境问题，在下载的时候会比较慢，有时也可能出现不能连接到远程服务器的错误，解决的方法就是，准备 “梯子” </p>
</blockquote>
<p>Mac<br>打开系统的 终端，然后用 Homebrew 的 brew install 命令去安装 Atom：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span>install Caskroom/cask/atom</span><br></pre></td></tr></table></figure></p>
<p>在命令行下面安装完 Atom 以后，可以输入 atom ，后面指定一个目录，这样会用 Atom 编辑器打开这个目录。另外 Atom 编辑器还自带了一个包管理工具叫 apm （Atom Package Manager），用这个工具可以在命令行下面为编辑器去安装包 （Package） ，包就是 Atom 的插件。</p>
<h3 id="Packages">Packages</h3><p>Atom 核心的功能是由 Core Packages（核心包） 提供的，另外还有 Community Packages（社区包），就是由社区成员自己开发并且分享出来的 Package。Atom 可以通过安装这些 Package 来扩展编辑器的功能。安装 Package 可以在 Atom 的配置界面上去搜索，然后安装，也可以使用 apm 在命令行下面管理编辑器的 Package 。</p>
<p>Packages 列表：<a href="https://atom.io/packages" target="_blank" rel="external">https://atom.io/packages</a><br><img src="http://work.ninghao.net/wp-content/uploads/2015/01/QQ20150118-1.png" alt=""></p>
<h4 id="安装包：通过配置界面">安装包：通过配置界面</h4><ol>
<li>打开 Atom 编辑器。</li>
<li>打开 Atom 的配置界面（Windows：ctrl + ,    Mac：command + , ）。</li>
<li>点击边栏上的 Install（安装）。</li>
<li>在界面上的 Install Packages 下面，选中 Packages 标签，然后搜索你想要安装的 Package。</li>
<li>在搜索结果找到想要的 Package ，点击 Install 安装。<br><img src="http://work.ninghao.net/wp-content/uploads/2015/01/QQ20150117-11.png" alt=""></li>
</ol>
<h4 id="安装包：通过_apm">安装包：通过 apm</h4><ol>
<li>打开命令行工具，Windows 用 Powershell，Mac 可以使用终端。</li>
<li>搜索包用的是 apm search &lt;关键词&gt; 。</li>
<li>找到想要的包以后，再用 apm install &lt;包的名字&gt;。</li>
</ol>
<p><img src="http://work.ninghao.net/wp-content/uploads/2015/01/QQ20150117-12.png" alt=""></p>
<p><img src="http://work.ninghao.net/wp-content/uploads/2015/01/QQ20150117-13.png" alt=""></p>
<p>下面，你可以搜索一个叫 Localization 的包，然后安装一下，这个包会为 Atom 的菜单栏提供一个中文翻译。下面我们再看一下怎么样去配置与管理包。</p>
<h4 id="手动安装包emmet-atom">手动安装包emmet-atom</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~/.atom/packages</span><br><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/emmetio/emmet-atom</span><br><span class="line"><span class="keyword">cd</span> emmet-atom</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<h4 id="管理包">管理包</h4><p>打开配置界面，在边栏上选中 Packages ，在这个界面上的 Communtity Packages 区域里，你可以找到自己安装的来自社区成员分享的包。Core Packages 下面是 Atom 编辑器核心自带的包。<br><img src="http://work.ninghao.net/wp-content/uploads/2015/01/QQ20150118-3.png" alt=""></p>
<p>这里会显示包的名字，还有介绍，不想用的包，可以点击 Disable 按钮禁用它，或者直接点击 Uninstall 卸载掉包，点击 Settings 按钮可以打开包的配置界面，在这个界面上，你可以找到包的主页，说明的文档，可以查看包的源文件，还有相关的配置与快捷键。</p>
<p>下面打开之前安装的 Localization 这个包的配置界面，然后在 Settings 区域里面，在 Current Language 下面的文本框里输入：Chinese - Simplified ，这样会把菜单栏的语言设置成简体中文，如果设置成 Chinese - Traditional，会把菜单栏设置成繁体中文。输入以后，用鼠标点一下浏览器的其它的地方，这样编辑器会保存你的配置。</p>
<p>完成以后，想让设置生效，可以关掉并且重新打开编辑器，或者可以刷新一下编辑器</p>
<p><img src="http://work.ninghao.net/wp-content/uploads/2015/01/QQ20150118-4.png" alt=""></p>
<p>刷新编辑器的快捷键：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Mac</span>    ：ctrl + alt + command + <span class="keyword">L</span></span><br><span class="line">Windows：ctrl + alt + <span class="literal">R</span></span><br></pre></td></tr></table></figure></p>
<h4 id="打开命令面板">打开命令面板</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac    ：<span class="built_in">command</span> + <span class="built_in">shift</span> + P</span><br><span class="line">Windows：ctrl + <span class="built_in">shift</span> + P</span><br></pre></td></tr></table></figure>
<p>搜索一下 tree view ，列出的就是跟树形视图相关的命令。<br><img src="http://work.ninghao.net/wp-content/uploads/2015/01/QQ20150118-8.png" alt=""></p>
<h3 id="标签面板">标签面板</h3><p>在 Mac 上，你还可以使用 command + 数字 ，打开对应的标签面板。</p>
<h3 id="分离面板">分离面板</h3><p>在编辑器上打开的文件可以分离到不同的面板上显示，你可以把编辑器分隔成上，下，左，右，四个部分。方法是，找到要分离显示的标签面板，鼠标右键点击，然后选择 Split Up，Split Down，Split Left 或者 Split Right。<br><img src="http://work.ninghao.net/wp-content/uploads/2015/01/QQ20150118-13.png" alt=""></p>
<p>这些动作也都有对应的快捷键，可以打开命令面板（Mac：command + shift + P，Windows：ctrl + shift + P），然后搜索 Pane ，这样会显示出面板相关的操作命令。</p>
<p>分离到上面<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac    ：<span class="command"><span class="keyword">command</span> + <span class="title">K</span> ↑</span></span><br><span class="line">Windows：ctrl + K ↑</span><br></pre></td></tr></table></figure></p>
<h3 id="查找文件">查找文件</h3><p>目里的文件多了，想找到对应的文件，用鼠标点出这个文件很费事，可以用搜索找到文件。</p>
<p>在已经打开的文件里找到你想要的文件：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac    ：<span class="command"><span class="keyword">command</span> + <span class="title">B</span></span></span><br><span class="line">Windows：ctrl + B</span><br></pre></td></tr></table></figure></p>
<p><img src="http://work.ninghao.net/wp-content/uploads/2015/01/QQ20150118-9.png" alt=""></p>
<p>在整个项目里找到你需要的文件：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac    ：<span class="command"><span class="keyword">command</span> + <span class="title">P</span></span></span><br><span class="line">Windows：ctrl + P</span><br></pre></td></tr></table></figure></p>
<p><img src="http://work.ninghao.net/wp-content/uploads/2015/01/QQ20150118-10.png" alt=""></p>
<p>查找文件里的内容<br>你可以搜索包含特定内容的文件，比如在当前打开的文件里搜索，或者也可以在整个项目里搜索，找到以后，可以把搜索的内容替换成新的内容。</p>
<p>在当前打开的文件中搜索<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Mac</span>    ：command + <span class="literal">F</span></span><br><span class="line">Windows：ctrl + <span class="literal">F</span></span><br></pre></td></tr></table></figure></p>
<p>比如我当前打开的是 humans.txt ，打开搜索，输入 name ，编辑器会高亮显示匹配搜索的内容。在 Replace in current buffer 里面，可以输入要替换成的东西，点击 Replace 会一个一个的替换，点击 Replace All 按钮，会替换全部的找到的地方。<br><img src="http://work.ninghao.net/wp-content/uploads/2015/01/QQ20150118-11.png" alt=""></p>
<p>查找下一个地方<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac    ：<span class="command"><span class="keyword">command</span> + <span class="title">G</span></span></span><br><span class="line">Windows：F3</span><br></pre></td></tr></table></figure></p>
<p>查找上一个地方<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac    ：<span class="built_in">shift</span> + <span class="built_in">command</span> + G</span><br><span class="line">Windows：<span class="built_in">shift</span> + F3</span><br></pre></td></tr></table></figure></p>
<p>在整个项目中搜索<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac    ：<span class="built_in">shift</span> + <span class="built_in">command</span> + F</span><br><span class="line">Windows：<span class="built_in">shift</span> + ctrl + F</span><br></pre></td></tr></table></figure></p>
<p>下面，是我搜索了项目中的 name ，回车以后，会显示出找到的结果，这个结果显示了包含搜索的内容的文件，还有出现这个内容的位置，点一下，会打开出现这个搜索内容的文件，并且会定位到对应的位置上。<br><img src="http://work.ninghao.net/wp-content/uploads/2015/01/QQ20150118-12.png" alt=""></p>
<h3 id="常用插件">常用插件</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ apm list -i -b</span><br><span class="line">Sublime-Style-Column-Selection<span class="variable">@1</span>.2.3</span><br><span class="line">atom-beautify<span class="variable">@0</span>.24.0</span><br><span class="line">autocomplete-plus<span class="variable">@2</span>.10.0</span><br><span class="line">autocomplete-snippets<span class="variable">@1</span>.3.0</span><br><span class="line"><span class="keyword">color</span>-picker<span class="variable">@1</span>.7.0</span><br><span class="line"><span class="keyword">file</span>-icons<span class="variable">@1</span>.5.5</span><br><span class="line">highlight-selected<span class="variable">@0</span>.9.2</span><br><span class="line">language-cmake<span class="variable">@0</span>.1.3</span><br><span class="line">language-lua<span class="variable">@0</span>.9.2</span><br><span class="line">lines<span class="variable">@0</span>.13.0</span><br><span class="line">linter</span><br><span class="line">linter-coffeelint<span class="variable">@0</span>.2.2</span><br><span class="line">linter-jshint<span class="variable">@0</span>.1.2</span><br><span class="line">linter-lua<span class="variable">@0</span>.1.5</span><br><span class="line">linter-luacheck<span class="variable">@0</span>.4.0</span><br><span class="line">minimap<span class="variable">@4</span>.8.0</span><br><span class="line">pretty-json</span><br></pre></td></tr></table></figure>
<h3 id="常用命令">常用命令</h3><p>刷新编辑器<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + alt + <span class="command"><span class="keyword">command</span> + <span class="title">l</span></span></span><br></pre></td></tr></table></figure></p>
<p>proxy<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ apm config <span class="keyword">set</span> http_proxy <span class="string">"127.0.0.1:8087"</span></span><br><span class="line">$ apm config <span class="keyword">set</span> https_proxy <span class="string">"127.0.0.1:8087"</span></span><br><span class="line">$ apm config <span class="keyword">set</span> https_proxy <span class="string">"http://user:pass@host:port"</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">export</span> <span class="string">"http_proxy=http://..."</span></span><br><span class="line">$ <span class="keyword">export</span> <span class="string">"https_proxy=http://..."</span></span><br><span class="line">$ apm <span class="keyword">install</span> minimap</span><br></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ env | grep proxy</span><br><span class="line"> http_proxy=<span class="string">http:</span><span class="comment">//... OK</span></span><br><span class="line"> https_proxy=<span class="string">http:</span><span class="comment">//... OK</span></span><br><span class="line">$ apm install minimap</span><br><span class="line"> Installing minimap to <span class="regexp">/home/</span>user<span class="regexp">/.atom/</span>packages ✗</span><br><span class="line"> Request <span class="keyword">for</span> <span class="keyword">package</span> information <span class="string">failed:</span> getaddrinfo ENOTFOUND (ENOTFOUND)</span><br></pre></td></tr></table></figure>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ apm config <span class="keyword">ls</span></span><br><span class="line">$ apm <span class="keyword">update</span></span><br><span class="line">$ apm <span class="built_in">search</span> <span class="string">"Markdown"</span> --<span class="keyword">verbose</span></span><br><span class="line">$ apm <span class="keyword">update</span> --<span class="keyword">verbose</span></span><br><span class="line">apm --<span class="keyword">version</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://ninghao.net/blog/2073" target="_blank" rel="external">转自</a></p>
<h2 id="Atom">Atom</h2><p>一款编辑器入门还是很简单的，学会怎么样创建，打开，编辑，保存]]>
    </summary>
    
      <category term="Atom" scheme="http://ytlvy.com/tags/Atom/"/>
    
      <category term="IDE" scheme="http://ytlvy.com/categories/IDE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 绘制1像素的线]]></title>
    <link href="http://ytlvy.com/2015/07/15/iOS-%E7%BB%98%E5%88%B61%E5%83%8F%E7%B4%A0%E7%9A%84%E7%BA%BF/"/>
    <id>http://ytlvy.com/2015/07/15/iOS-绘制1像素的线/</id>
    <published>2015-07-15T13:17:34.000Z</published>
    <updated>2015-07-19T09:18:32.000Z</updated>
    <content type="html"><![CDATA[<h1 id="iOS_绘制1像素的线">iOS 绘制1像素的线</h1><h2 id="Point_Vs_Pixel">Point Vs Pixel</h2><p>iOS中当我们使用Quartz，UIKit，CoreAnimation等框架时，所有的坐标系统采用Point来衡量。系统在实际渲染到设置时会帮助我们处理Point到Pixel的转换。 这样做的好处隔离变化，即我们在布局的事后不需要关注当前设备是否为Retina，直接按照一套坐标系统来布局即可。</p>
<p>实际使用中我们需要牢记下面这一点:</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">One point <span class="keyword">does</span> <span class="keyword">not</span> necessarily correspond <span class="keyword">to</span> one physical pixel.</span><br></pre></td></tr></table></figure>
<p>1 Point的线在非Retina屏幕则是一个像素，在Retina屏幕上则可能是2个或者3个，取决于系统设备的DPI。</p>
<p>iOS系统中，UIScreen，UIView，UIImage，CALayer类都提供相关属性来获取scale factor。 原生的绘制技术天然的帮我们处理了scale factor，例如在drawRect:方法中，UIKit自动的根据当前运行的设备设置了正切的scale factor。所以我们在drawRect: 方法中绘制的任何内容都会被自动缩放到设备的物理屏幕上。</p>
<p>基于以上信息可以看出，我们大部分情况下都不需要去关注pixel，然而存在部分情况需要考虑像素的转化。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如画1个像素的分割线</span><br></pre></td></tr></table></figure>
<p>看到这个问题你的第一想法可能是，直接根据当前屏幕的缩放因子计算出1 像素线对应的Point，然后设置线宽即可。 代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.0f</span> / [UIScreen mainScreen].scale</span><br></pre></td></tr></table></figure>
<p>表面上看着一切正常了，但是通过实际的设备测试你会发现渲染出来的线宽并不是1个像素。</p>
<blockquote>
<p>Why?</p>
</blockquote>
<p>为了获得良好的视觉效果，绘图系统通常都会采用一个叫”antialiasing(反锯齿)”的技术，iOS也不例外。 显示屏幕有很多小的显示单元组成，可以接单的理解为一个单元就代表一个像素。如果要画一条黑线，条线刚好落在了一列或者一行显示显示单元之内，将会渲染出标准的一个像素的黑线。 但如果线落在了两个行或列的中间时，那么会得到一条”失真”的线，其实是两个像素宽的灰线。</p>
<p>如下图所示: <img src="http://images0.cnblogs.com/blog2015/302680/201506/250827276118632.png" alt=""></p>
<blockquote>
<p>Positions defined by whole-numbered points fall at the midpoint between pixels. For example, if you draw a one-pixel-wide vertical line from (1.0, 1.0) to (1.0, 10.0), you get a fuzzy grey line. If you draw a two-pixel-wide line, you get a solid black line because it fully covers two pixels (one on either side of the specified point). As a rule, lines that are an odd number of physical pixels wide appear softer than lines with widths measured in even numbers of physical pixels unless you adjust their position to make them cover pixels fully.</p>
</blockquote>
<p>官方解释如上，简单翻译一下:</p>
<blockquote>
<p>规定：奇数像素宽度的线在渲染的时候将会表现为柔和的宽度扩展到向上的整数宽度的线，除非你手动的调整线的位置，使线刚好落在一行或列的显示单元内。</p>
</blockquote>
<p>如何对齐呢？</p>
<blockquote>
<p>在非高清屏上，一个Point对应一个像素。为了防止”antialiasing”导致的奇数像素的线渲染时出现失真，你需要设置偏移0.5 Point。 在高清屏幕上，要绘制一个像素的线，需要设置线宽为0.5个Point，同事设置偏移为0.25 Point。 如果线宽为偶数Point的话，则不要去设置偏移，否则线条也会失真。</p>
</blockquote>
<p>如下图所示: <img src="http://images0.cnblogs.com/blog2015/302680/201506/250824372995931.png" alt=""></p>
<p>看了上述一通解释，我们了解了1像素宽的线条失真的原因，及解决办法。 至此问题貌似都解决了？再想想为什么在非Retina和Retina屏幕上调整位置时值不一样，前者为0.5Point，后者为0.25Point，那么scale为3的6 Plus设备又该调整多少呢？ 要回答这个问题，我们需要理解调整多少依旧什么原则。</p>
<p><img src="http://images0.cnblogs.com/blog2015/302680/201506/251942350498849.png" alt=""></p>
<p>再回过头来看看这上面的图片，图片中每一格子代表一个像素，而顶部标记的则代码我们布局时的坐标。 可以看到左边的非Retina屏幕，我们要在(3,0)这个位置画一条一个像素宽的竖线时，由于渲染的最小单位是像素，而(3,0)这个坐标恰好位于两个像素中间，此时系统会对坐标3左右两列的像素对填充，为了不至于线显得太宽，为对线的颜色淡化。那么根据上述信息我们可以得出，如果要画出一个像素宽的线，就得把绘制的坐标移动到(2.5, 0)或者(3.5,0)这个位置，这样系统渲染的时候刚好可以填充一列像素，也就是标准的一个像素的线。</p>
<p>基于上面的分析，我们可以得出”Scale为3的6 Plus”设备如果要绘制1个像素宽的线条时，位置调整也应该是0.5像素，对应该的Point计算如下:</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">1.0f</span> / <span class="list">[<span class="keyword">UIScreen</span> mainScreen].scale) / <span class="number">2</span><span class="comment">;</span></span></span></span><br></pre></td></tr></table></figure>
<p>奉上一个画一像素线的一个宏:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hexcolor">#def</span>ine SINGLE_LINE_WIDTH           (<span class="number">1</span> / [UIScreen mainScreen].scale)</span><br><span class="line"><span class="hexcolor">#def</span>ine SINGLE_LINE_ADJUST_OFFSET   ((<span class="number">1</span> / [UIScreen mainScreen].scale) / <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>使用代码如下:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGFloat</span> xPos = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">UIView</span> *view = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGrect</span>(x - SINGLE_LINE_ADJUST_OFFSET, <span class="number">0</span>, SINGLE_LINE_WIDTH, <span class="number">100</span>)];</span><br></pre></td></tr></table></figure>
<h2 id="正确的绘制Grid线条">正确的绘制Grid线条</h2><p>贴上一个写的GridView的代码，代码中对Grid线条的奇数像素做了偏移，防止出现线条模糊的情况。</p>
<p>SvGridView.h</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  SvGridView.h</span></span><br><span class="line"><span class="comment">//  SvSinglePixel</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by xiaoyong.cxy on 6/23/15.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2015 smileEvday. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SvGridView</span> : <span class="title">UIView</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @brief 网格间距，默认30</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span>   gridSpacing;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @brief 网格线宽度，默认为1 pixel (1.0f / [UIScreen mainScreen].scale)</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span>   gridLineWidth;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @brief 网格颜色，默认蓝色</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span>   *gridColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>SvGridView.m</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  SvGridView.m</span></span><br><span class="line"><span class="comment">//  SvSinglePixel</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by xiaoyong.cxy on 6/23/15.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2015 smileEvday. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="title">"SvGridView.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#define SINGLE_LINE_WIDTH           (1 / [UIScreen mainScreen].scale)</span></span><br><span class="line"><span class="preprocessor">#define SINGLE_LINE_ADJUST_OFFSET   ((1 / [UIScreen mainScreen].scale) / 2)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SvGridView</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@synthesize</span> gridColor = _gridColor;</span><br><span class="line"><span class="keyword">@synthesize</span> gridSpacing = _gridSpacing;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithFrame:(<span class="built_in">CGRect</span>)frame</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> clearColor];</span><br><span class="line"></span><br><span class="line">        _gridColor = [<span class="built_in">UIColor</span> blueColor];</span><br><span class="line">        _gridLineWidth = SINGLE_LINE_WIDTH;</span><br><span class="line">        _gridSpacing = <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setGridColor:(<span class="built_in">UIColor</span> *)gridColor</span><br><span class="line">&#123;</span><br><span class="line">    _gridColor = gridColor;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> setNeedsDisplay];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setGridSpacing:(<span class="built_in">CGFloat</span>)gridSpacing</span><br><span class="line">&#123;</span><br><span class="line">    _gridSpacing = gridSpacing;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> setNeedsDisplay];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setGridLineWidth:(<span class="built_in">CGFloat</span>)gridLineWidth</span><br><span class="line">&#123;</span><br><span class="line">    _gridLineWidth = gridLineWidth;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> setNeedsDisplay];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Only override drawRect: if you perform custom drawing.</span></span><br><span class="line"><span class="comment">// An empty implementation adversely affects performance during animation.</span></span><br><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGContextBeginPath</span>(context);</span><br><span class="line">    <span class="built_in">CGFloat</span> lineMargin = <span class="keyword">self</span><span class="variable">.gridSpacing</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *  https://developer.apple.com/library/ios/documentation/2DDrawing/Conceptual/DrawingPrintingiOS/GraphicsDrawingOverview/GraphicsDrawingOverview.html</span><br><span class="line">     * 仅当要绘制的线宽为奇数像素时，绘制位置需要调整</span><br><span class="line">     */</span></span><br><span class="line">    <span class="built_in">CGFloat</span> pixelAdjustOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (((<span class="keyword">int</span>)(<span class="keyword">self</span><span class="variable">.gridLineWidth</span> * [<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.scale</span>) + <span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        pixelAdjustOffset = SINGLE_LINE_ADJUST_OFFSET;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGFloat</span> xPos = lineMargin - pixelAdjustOffset;</span><br><span class="line">    <span class="built_in">CGFloat</span> yPos = lineMargin - pixelAdjustOffset;</span><br><span class="line">    <span class="keyword">while</span> (xPos &lt; <span class="keyword">self</span><span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.width</span>) &#123;</span><br><span class="line">        <span class="built_in">CGContextMoveToPoint</span>(context, xPos, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">CGContextAddLineToPoint</span>(context, xPos, <span class="keyword">self</span><span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.height</span>);</span><br><span class="line">        xPos += lineMargin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (yPos &lt; <span class="keyword">self</span><span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.height</span>) &#123;</span><br><span class="line">        <span class="built_in">CGContextMoveToPoint</span>(context, <span class="number">0</span>, yPos);</span><br><span class="line">        <span class="built_in">CGContextAddLineToPoint</span>(context, <span class="keyword">self</span><span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.width</span>, yPos);</span><br><span class="line">        yPos += lineMargin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGContextSetLineWidth</span>(context, <span class="keyword">self</span><span class="variable">.gridLineWidth</span>);</span><br><span class="line">    <span class="built_in">CGContextSetStrokeColorWithColor</span>(context, <span class="keyword">self</span><span class="variable">.gridColor</span><span class="variable">.CGColor</span>);</span><br><span class="line">    <span class="built_in">CGContextStrokePath</span>(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>使用方法如下：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SvGridView *gridView = [[SvGridView alloc] initWithFrame:self.view.bounds]<span class="comment">;</span></span><br><span class="line">gridView.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight<span class="comment">;</span></span><br><span class="line">gridView.alpha = 0.6<span class="comment">;</span></span><br><span class="line">gridView.gridColor = [UIColor greenColor]<span class="comment">;</span></span><br><span class="line">[self.view addSubview:gridView]<span class="comment">;</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="iOS_绘制1像素的线">iOS 绘制1像素的线</h1><h2 id="Point_Vs_Pixel">Point Vs Pixel</h2><p>iOS中当我们使用Quartz，UIKit，CoreAnimation等框架时，所有的坐标系统采用Point来衡量]]>
    </summary>
    
      <category term="IOS" scheme="http://ytlvy.com/tags/IOS/"/>
    
      <category term="Pixel" scheme="http://ytlvy.com/tags/Pixel/"/>
    
      <category term="Point" scheme="http://ytlvy.com/tags/Point/"/>
    
      <category term="UI" scheme="http://ytlvy.com/tags/UI/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 内存警告]]></title>
    <link href="http://ytlvy.com/2015/07/15/iOS-%E5%86%85%E5%AD%98%E8%AD%A6%E5%91%8A/"/>
    <id>http://ytlvy.com/2015/07/15/iOS-内存警告/</id>
    <published>2015-07-15T13:16:44.000Z</published>
    <updated>2015-07-19T09:18:32.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/smileEvday/archive/2012/03/07/MemoryWarning.html" target="_blank" rel="external">转自</a></p>
<h1 id="内存警告">内存警告</h1><p>系统有四种内存警告</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line"><span class="constant">　   OSMemoryNotificationLevelAny</span>      = -<span class="number">1</span>,</span><br><span class="line"><span class="constant">　   OSMemoryNotificationLevelNormal</span>   =  <span class="number">0</span>,</span><br><span class="line"><span class="constant">　   OSMemoryNotificationLevelWarning</span>  =  <span class="number">1</span>,</span><br><span class="line"><span class="constant">　   OSMemoryNotificationLevelUrgent</span>   =  <span class="number">2</span>,</span><br><span class="line"><span class="constant">　   OSMemoryNotificationLevelCritical</span> =  <span class="number">3</span></span><br><span class="line">&#125; OSMemoryNotificationLevel;</span><br></pre></td></tr></table></figure>
<p>　　通常我们在程序中接收到最多的就是Memory warning level 1，这个时候就证明系统内存紧张了，我们的程序必须做出相应，释放不必要的内存。通常如果我们处理得当的话，内存警告就会到此停止，恢复正常状态。如果我们在接收到<code>memory warning level 1</code>以后坐视不理的话，系统可能还会再尝试通知几次<code>level 1</code>，如果还是不去处理的话，系统将会发出更高一级的内存警告<code>level 2</code>，通常的结果就是我们的App被强制退出，系统收回内存。当然系统在发出level 2的警告时，也会取尝试做一些清理内存的事，例如关闭不必要的后台程序等。很显然我们不该寄希望于系统自己清理，这就好比你的胳膊被划破了，身体肯定会有自修复功能，但是如果伤口比较大的话，肯定还是需要人工处理一下的。</p>
<p>到目前位置我还没有见过level 3的警告，根据stack over flow上面讲的”当发生level 3警告时，系统内核将会接管，很有可能关掉IOS的主界面进程（SpringBorad），甚至会重启”，照这个意思来说我们程序里面接收不到，也实属正常，系统自己的东西都被干掉了，我们肯定早被kill了。 <a id="more"></a> KennyTM写的原文地址： <a href="http://stackoverflow.com/questions/2915247/iphone-os-memory-warnings-what-do-the-different-levels-mean" target="_blank" rel="external">http://stackoverflow.com/questions/2915247/iphone-os-memory-warnings-what-do-the-different-levels-mean</a></p>
<p>如果打开上面的连接，可以看到定义OSMemoryNotificationLevel的源文件，你可能会注意到里面有一个函数OSMemoryNotificationCurrentLevel()，可以用来获取当前内存告警level，不过需要加头文件#import <libkern osmemorynotification.h="">，网上有个查看当前内存数据的开源代码MemWatcher，大家可以看看，说实话我没有看懂。</libkern></p>
<p>说了这么多，希望能帮大家弄清楚内存警告是怎么回事儿，通常我们程序是不会碰到内存警告，平时写代码注意在所有alloc，retain，copy的地方，对应的写上release，或者直接创建autorelease对象（个人不推荐这么做），发布前养成检查内存泄露的好习惯。</p>
<p>顺便提一下如果运行过程中遇到内存警告的话，程序通常情况下都先调用AppDelegate中的applicationDidReceiveMemoryWarning, 然后程序会通知各ViewController，调用其didRecieveMemoryWarning方法，这个时候我们一定要种，释放不必要的资源。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://www.cnblogs.com/smileEvday/archive/2012/03/07/MemoryWarning.html">转自</a></p>
<h1 id="内存警告">内存警告</h1><p>系统有四种内存警告</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line"><span class="constant">　   OSMemoryNotificationLevelAny</span>      = -<span class="number">1</span>,</span><br><span class="line"><span class="constant">　   OSMemoryNotificationLevelNormal</span>   =  <span class="number">0</span>,</span><br><span class="line"><span class="constant">　   OSMemoryNotificationLevelWarning</span>  =  <span class="number">1</span>,</span><br><span class="line"><span class="constant">　   OSMemoryNotificationLevelUrgent</span>   =  <span class="number">2</span>,</span><br><span class="line"><span class="constant">　   OSMemoryNotificationLevelCritical</span> =  <span class="number">3</span></span><br><span class="line">&#125; OSMemoryNotificationLevel;</span><br></pre></td></tr></table></figure>
<p>　　通常我们在程序中接收到最多的就是Memory warning level 1，这个时候就证明系统内存紧张了，我们的程序必须做出相应，释放不必要的内存。通常如果我们处理得当的话，内存警告就会到此停止，恢复正常状态。如果我们在接收到<code>memory warning level 1</code>以后坐视不理的话，系统可能还会再尝试通知几次<code>level 1</code>，如果还是不去处理的话，系统将会发出更高一级的内存警告<code>level 2</code>，通常的结果就是我们的App被强制退出，系统收回内存。当然系统在发出level 2的警告时，也会取尝试做一些清理内存的事，例如关闭不必要的后台程序等。很显然我们不该寄希望于系统自己清理，这就好比你的胳膊被划破了，身体肯定会有自修复功能，但是如果伤口比较大的话，肯定还是需要人工处理一下的。</p>
<p>到目前位置我还没有见过level 3的警告，根据stack over flow上面讲的”当发生level 3警告时，系统内核将会接管，很有可能关掉IOS的主界面进程（SpringBorad），甚至会重启”，照这个意思来说我们程序里面接收不到，也实属正常，系统自己的东西都被干掉了，我们肯定早被kill了。]]>
    
    </summary>
    
      <category term="Debug" scheme="http://ytlvy.com/tags/Debug/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/tags/IOS/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS Crash文件的解析]]></title>
    <link href="http://ytlvy.com/2015/07/15/iOS-Crash%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90/"/>
    <id>http://ytlvy.com/2015/07/15/iOS-Crash文件的解析/</id>
    <published>2015-07-15T13:15:05.000Z</published>
    <updated>2015-07-19T09:18:32.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/smileEvday/p/Crash1.html" target="_blank" rel="external">转自</a></p>
<h1 id="iOS_Crash文件的解析">iOS Crash文件的解析</h1><p>开发程序的过程中不管我们已经如何小心，总是会在不经意间遇到程序闪退。脑补一下当你在一群人面前自信的拿着你的App做功能预演的时候，流畅的操作被无情地Crash打断。联想起老罗在发布Smartisan OS的时候说了，他准备了10个手机，如果一台有问题，就换一台，如果10台后挂了他就不做手机了。好了不闲扯了，今天就跟大家一起聊聊iOSCrash文件的组成以及常用的分析工具。</p>
<p>　　有一个WWDC 2010的视频推荐大家抽空看看，视频名称<a href="https://developer.apple.com/videos/wwdc/2010/?id=317" target="_blank" rel="external">“Understanding Crash Reports on iPhone OS”</a>，该视频详细讲解了Crash文件的结构。当然如果你没时间看的话，不妨阅读以下这篇文章。</p>
<h2 id="Crash文件结构">Crash文件结构</h2><p>当程序运行Crash的时候，系统会把运行的最后时刻的运行信息记录下来，存储到一个文件中，也就是我们所说的Crash文件。iOS的Crash日志通常由以下6各部分组成。 <a id="more"></a></p>
<h3 id="Process_Information(进程信息)">Process Information(进程信息)</h3><p><img src="http://images.cnitblog.com/blog/302680/201412/230718553901251.png" alt=""></p>
<ol>
<li>Incident Idnetifier       ———  崩溃报告的唯一标识符，不同的Crash</li>
<li>CrashReporter Key   ———  设备标识相对应的唯一键值(并非真正的设备的UDID，苹果为了保护用户隐私iOS6以后已经无法获取)。通常同一个设备上同一版本的App发生Crash时，该值都是一样的。</li>
<li>Hardware Model        ———  代表发生Crash的设备类型，上图中的”iPad4,4”代表iPad Air</li>
<li>Process                     ———  代表Crash的进程名称，通常都是我们的App的名字, []里面是当时进程的ID</li>
<li>Path                           ———   可执行程序在手机上的存储位置，注意路径时到XXX.app/XXX，XXX.app其实是作为一个Bundle的，真正的可执行文件其实是Bundle里面的XXX，感兴趣的可以自己查一下相关资料，有机会我后面也会介绍到</li>
<li>Identifier                     ———   你的App的Indentifier，通常为”com.xxx.yyy”，xxx代表你们公司的域名，yyy代表某一个App</li>
<li>Version                      ———   当前App的版本号，由Info.plist中的两个字段组成，CFBundleShortVersionString and CFBundleVersion</li>
<li>Code Type                ———   当前App的CPU架构</li>
<li>Parent Process         ———   当前进程的父进程，由于iOS中App通常都是单进程的，一般父进程都是launchd</li>
</ol>
<h3 id="Basic_Information">Basic Information</h3><p><img src="http://images.cnitblog.com/blog/302680/201501/052025393435295.png" alt=""></p>
<ol>
<li>Date/Time           Crash发生的时间，可读的字符串</li>
<li>OS Version         系统版本，（）内的数字代表的时Bulid号</li>
<li>Report Version    Crash日志的格式，目前基本上都是104，不同的version里面包含的字段可能有不同</li>
</ol>
<h3 id="Exception（非常重要）">Exception（非常重要）</h3><p><img src="http://images.cnitblog.com/blog/302680/201501/052029230317758.png" alt=""></p>
<ol>
<li>Exception Type        异常类型</li>
<li>Exception Subtype:  异常子类型</li>
<li>Crashed Thread       发生异常的线程号</li>
</ol>
<h3 id="Thread_Backtrace">Thread Backtrace</h3><p><img src="http://images.cnitblog.com/blog/302680/201501/052034366876268.png" alt=""></p>
<p>发生Crash的线程的Crash调用栈，从上到下分别代表调用顺序，最上面的一个表示抛出异常的位置，依次往下可以看到API的调用顺序。上图的信息表明本次Crash出现xxxViewController的323行，出错的函数调用为orderCountLoadFailed。</p>
<h3 id="Thread_State">Thread State</h3><p><img src="http://images.cnitblog.com/blog/302680/201501/052036460005028.png" alt=""></p>
<p>Crash时发生时刻，线程的状态，通常我们根据Crash栈即可获取到相关信息，这部分一般不用关心。</p>
<h3 id="Binary_Images">Binary Images</h3><p><img src="http://images.cnitblog.com/blog/302680/201501/052038193591674.png" alt=""></p>
<p>Crash时刻App加载的所有的库，其中第一行是Crash发生时我们App可执行文件的信息，可以看出为armv7，可执行文件的包得uuid位c0f……cd65，解析Crash的时候dsym文件的uuid必须和这个一样才能完成Crash的符号化解析。</p>
<h2 id="常见的Crash类型">常见的Crash类型</h2><h3 id="Watchdog_timeout">Watchdog timeout</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">Exception</span> <span class="preprocessor">Code</span>：<span class="number">0x8badf00d</span>， 不太直观，可以读成“eat <span class="keyword">bad </span>food”，意思是don‘t <span class="keyword">block </span>main thread</span><br></pre></td></tr></table></figure>
<p>紧接着下面会有一段描述：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Application Specific Information：</span><br><span class="line">com<span class="class">.xxx</span><span class="class">.yyy</span>　　 failed to resume <span class="keyword">in</span> time</span><br></pre></td></tr></table></figure>
<p>对于此类Crash，我们应该去审视自己App初始化时做的事情是否正确，是否在主线程请求了网络，或者其他耗时的事情卡住了正常初始化流程。</p>
<p>通常系统允许一个App从启动到可以相应用户事件的时间最多为5S，如果超过了5S，App就会被系统终止掉。在Launch，resume，suspend，quit时都会有相应的时间要求。在Highlight Thread里面我们可以看到被终止时调用到的位置，xxxAppDelegate加上行号。</p>
<p>PS. 在连接Xcode调试时为了便于调试，系统会暂时禁用掉Watchdog，所以此类问题的发现需要使用正常的启动模式。</p>
<h3 id="User_force-quit">User force-quit</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">Exception</span> <span class="rule"><span class="attribute">Codes</span>:<span class="value"> <span class="number">0</span>xdeadfa11, deadfall</span></span></span><br></pre></td></tr></table></figure>
<p>这个强制退出跟我们平时所说的kill掉后台任务操作还不太一样，通常在程序bug造成系统无法响应时可以采用长按电源键，当屏幕出现关机确认画面时按下Home键即可关闭当前程序。</p>
<h3 id="Low_Memory_termination">Low Memory termination</h3><p>跟一般的Crash结构不太一样，通常有Free pages，Wired Pages，Purgeable pages，largest process 组成，同事会列出当前时刻系统运行所有进程的信息。</p>
<p>关于Memory warning可以参看我之前写的一篇文章IOS 内存警告 <a href="http://www.cnblogs.com/smileEvday/archive/2012/03/07/MemoryWarning.html" target="_blank" rel="external">Memory warning level</a>。</p>
<p>App在运行过程中，系统内存紧张时通常会先发警告，同时把后台挂起的程序终止掉，最终如果还是内存不够的话就会终止掉当前前台的进程。</p>
<p>当接受到内存警告的事后，我们应该释放尽可能多的内存，Crash其实也可以看做是对App的一种保护。</p>
<h3 id="Crash_due_to_bugs">Crash due to bugs</h3><p>因为程序bug导致的Crash通常千奇百怪，很难一概而论。大部分情况通过Crash日志就可以定位出问题，当然也不排除部分疑难杂症看半天都不值问题出在哪儿。这个就只能看功底了，一点点找，总是能发现蛛丝马迹。是在看不出来时还可以求助于Google大神，总有人遇到和你一样的Bug</p>
<h2 id="常见的Exception_Type_&amp;_Exception_Code">常见的Exception Type &amp; Exception Code</h2><h3 id="Exception_Type">Exception Type</h3><p>1）EXC_BAD_ACCESS 此类型的Excpetion是我们最长碰到的Crash，通常用于访问了不改访问的内存导致。一般EXC_BAD_ACCESS后面的”()”还会带有补充信息。</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">SIGSEGV:</span> 通常由于重复释放对象导致，这种类型在切换了ARC以后应该已经很少见到了。</span><br><span class="line"><span class="label">SIGABRT:</span>  收到Abort信号退出，通常Foundation库中的容器为了保护状态正常会做一些检测，例如插入nil到数组中等会遇到此类错误。</span><br><span class="line"><span class="label">SEGV:</span>（Segmentation  Violation），代表无效内存地址，比如空指针，未初始化指针，栈溢出等；</span><br><span class="line">SIGBUS：总线错误，与 SIGSEGV 不同的是，SIGSEGV 访问的是无效地址，而 SIGBUS 访问的是有效地址，但总线访问异常(如地址对齐问题)</span><br><span class="line">SIGILL：尝试执行非法的指令，可能不被识别或者没有权限</span><br></pre></td></tr></table></figure>
<p>2）EXC_BAD_INSTRUCTION 此类异常通常由于线程执行非法指令导致</p>
<p>3）EXC_ARITHMETIC 除零错误会抛出此类异常</p>
<h3 id="Exception_Code">Exception Code</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xbaaaaaad</span>  此种类型的log意味着该Crash log并非一个真正的Crash，它仅仅只是包含了整个系统某一时刻的运行状态。通常可以通过同时按Home键和音量键，可能由于用户不小心触发</span><br><span class="line"><span class="number">0xbad22222</span>  当VOIP程序在后台太过频繁的激活时，系统可能会终止此类程序</span><br><span class="line"><span class="number">0x8badf00d</span>   这个前面已经介绍了，程序启动或者恢复时间过长被watch dog终止</span><br><span class="line"><span class="number">0xc00010ff</span>    程序执行大量耗费<span class="built_in">CPU</span>和GPU的运算，导致设备过热，触发系统过热保护被系统终止</span><br><span class="line"><span class="number">0xdead10cc</span>  程序退到后台时还占用系统资源，如通讯录被系统终止</span><br><span class="line"><span class="number">0xdeadfa11</span>   前面也提到过，程序无响应用户强制关闭</span><br></pre></td></tr></table></figure>
<h2 id="获取Crash的途径">获取Crash的途径</h2><h3 id="本机">本机</h3><p>通过xCode连接测试机器，直接在Device中即可读取到该机器上发生的所有Crash log。</p>
<h3 id="itunes_connect">itunes connect</h3><p>通过itunes connect后台获取到用户上报的Crash日志。</p>
<h3 id="第三方的Crash收集系统">第三方的Crash收集系统</h3><p>有很多优秀的第三方Crash收集系统大大的方便了我们收集Crash，甚至还带了符号化Crash日志的功能。比较常用的有Crashlytics，Flurry等。</p>
<h2 id="附录">附录</h2><p>Apple官方文档:</p>
<ol>
<li><a href="https://developer.apple.com/library/ios/technotes/tn2151/_index.html#//apple_ref/doc/uid/DTS40008184-CH1-INTRODUCTION" target="_blank" rel="external">Understanding and Analyzing iOS Application Crash Reports</a></li>
<li><a href="https://developer.apple.com/library/mac/technotes/tn2004/tn2123.html#LISTCRASHLOGEXCEPTION" target="_blank" rel="external">Technical Note TN2123 CrashReporter</a></li>
<li><a href="https://developer.apple.com/library/ios/qa/qa1592/_index.html" target="_blank" rel="external">https://developer.apple.com/library/ios/qa/qa1592/_index.html</a></li>
</ol>
<p>WWDC视频:</p>
<ol>
<li><a href="https://developer.apple.com/videos/wwdc/2010/?id=317" target="_blank" rel="external">Understanding Crash Reports on iPhone OS</a></li>
</ol>
<p>Crash日志记录的时候是将Crash发生时刻，函数的调用栈，以及线程等信息写入文件。一般都是直接写的16进制地址，如果不经过符号化的话，基本上很难获取到有用信息，下一篇我们将聊一聊Crash日志的符号化，通俗点讲就是让Crash日志变成我们可读的格式。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://www.cnblogs.com/smileEvday/p/Crash1.html">转自</a></p>
<h1 id="iOS_Crash文件的解析">iOS Crash文件的解析</h1><p>开发程序的过程中不管我们已经如何小心，总是会在不经意间遇到程序闪退。脑补一下当你在一群人面前自信的拿着你的App做功能预演的时候，流畅的操作被无情地Crash打断。联想起老罗在发布Smartisan OS的时候说了，他准备了10个手机，如果一台有问题，就换一台，如果10台后挂了他就不做手机了。好了不闲扯了，今天就跟大家一起聊聊iOSCrash文件的组成以及常用的分析工具。</p>
<p>　　有一个WWDC 2010的视频推荐大家抽空看看，视频名称<a href="https://developer.apple.com/videos/wwdc/2010/?id=317">“Understanding Crash Reports on iPhone OS”</a>，该视频详细讲解了Crash文件的结构。当然如果你没时间看的话，不妨阅读以下这篇文章。</p>
<h2 id="Crash文件结构">Crash文件结构</h2><p>当程序运行Crash的时候，系统会把运行的最后时刻的运行信息记录下来，存储到一个文件中，也就是我们所说的Crash文件。iOS的Crash日志通常由以下6各部分组成。]]>
    
    </summary>
    
      <category term="Crash" scheme="http://ytlvy.com/tags/Crash/"/>
    
      <category term="Debug" scheme="http://ytlvy.com/tags/Debug/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/tags/IOS/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 应用崩溃日志揭秘]]></title>
    <link href="http://ytlvy.com/2015/07/15/iOS-%E5%BA%94%E7%94%A8%E5%B4%A9%E6%BA%83%E6%97%A5%E5%BF%97%E6%8F%AD%E7%A7%98/"/>
    <id>http://ytlvy.com/2015/07/15/iOS-应用崩溃日志揭秘/</id>
    <published>2015-07-15T02:35:25.000Z</published>
    <updated>2015-07-19T09:18:32.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://www.raywenderlich.com/23704/demystifying-ios-application-crash-logs" target="_blank" rel="external">翻译自</a></p>
<h1 id="iOS应用崩溃日志揭秘1">iOS应用崩溃日志揭秘1</h1><p>作为一名应用开发者，你是否有过如下经历?</p>
<p>为确保你的应用正确无误，在将其提交到应用商店之前，你必定进行了大量的测试工作。它在你的设备上也运行得很好，但是，上了应用商店后，还是有用户抱怨会闪退 !</p>
<p>如果你跟我一样是个完美主义者，你肯定想将应用做到尽善尽美。于是你打开代码准备修复闪退的问题……但是，从何处着手呢？ 这时iOS崩溃日志派上用场了。在大多数情况下，你能从中了解到关于闪退的详尽、有用的信息。</p>
<p>通过本教程，你将学习到一些常见的崩溃日志案例，以及如何从开发设备和iTunes Connect上获取崩溃日志文件。你还将学习到符号化（ symbolication）,从日志追踪到代码 。你还将学习调试一个在待定情况下会闪退的应用。</p>
<p>让我们开始动手吧!</p>
<h2 id="什么是崩溃日志，从哪里能得它?">什么是崩溃日志，从哪里能得它?</h2><p>iOS设备上的应用闪退时，操作系统会生成一个崩溃报告，也叫崩溃日志，保存在设备上。 崩溃日志上有很多有用的信息，包括应用是什么情况下闪退的。通常，上面有每个正在执行线程的完整堆栈跟踪信息，所以你能从中了解到闪退发生时各线程都在做什么，并分辨出闪退发生在哪个线程上。</p>
<p>有几种方法可以从设备上获取崩溃日志。 设备与电脑上的iTunes Store同步后，会将崩溃日志保存在电脑上。根据电脑操作系统的不同，崩溃日志将保存在以下位置:</p>
<p>Mac OS X:</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="regexp">/Library/</span>Logs<span class="regexp">/CrashReporter/M</span>obileDevice<span class="regexp">/</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>当用户抱怨闪退时，你可以要求他让设备与iTunes同步，并根据操作系统的不同，到上述位置把崩溃日志下载下来，然后通过电子邮件发送给你。 你必需尽量获取用户设备生成的所有崩溃日志。因为崩溃日志越多，就越容易诊断问题所在!</p>
<p>另外，如果你装了Xcode，也能很容易通过Xcode从你的设备上获得崩溃日志。将iOS设备连接到电脑上，然后打开Xcode。从菜单栏上选择 Window  菜单, 然后选择 Organizer (快捷方式是 Shift-CMD-2).</p>
<p>在 <code>Organizer</code> 窗口上, 选中 <code>Devices</code> 标签栏. 在左侧的导航面板上，选中 <code>Device Logs</code>, 如下图所示:</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2012/11/Organizer-Devices.png" alt=""></p>
<p>看看上图，左侧有好几个 <code>Device Logs</code> 菜单项. LIBRARY 下面的Device Logs是你所有设备（曾经连接到Xcode的）的日志 。每个设备下面的 Device Logs 是对应设备的日志。 应用提交到App Store后，你也能从<code>iTunes Connect</code> 获取到用户的崩溃日志. 登录到 iTunes Connect 上, 选择 <code>Manage Your Applications</code>, 点击相应的应用, 点击应用图标下面的 View Details 按钮, 然后点击右栏Links部分的  Crash Reports 。</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2012/12/CrashReports-700x234.png" alt=""></p>
<p>如果没有崩溃日志，试试点击Refresh 按钮刷新一下。如果你的应用还卖得不多，或者刚上架不久，iTunes Connect账号上也可能还没有任何崩溃日志。 如果iTunes Connect上有崩溃日志，你将看到如下图:</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2012/11/Firefox.png" alt=""></p>
<p>有时，尽管有用户报告闪退，你仍然看不到崩溃报告。这时，最好让用户直接把崩溃报告发送给你。</p>
<h2 id="什么情况下会产生崩溃日志?">什么情况下会产生崩溃日志?</h2><p>两种主要情况会产生崩溃日志:</p>
<ol>
<li>应用违反操作系统规则。</li>
<li>应用中有Bug。</li>
</ol>
<p>违反iOS规则包括在启动、恢复、挂起、退出时watchdog超时、用户强制退出和低内存终止。让我们详细了解一下吧。</p>
<h2 id="Watchdog_超时机制">Watchdog 超时机制</h2><p>从iOS 4.x开始，退出应用时，应用不会立即终止，而是退到后台。 但是，如果你的应用响应不够快，操作系统有可能会终止你的应用，并产生一个崩溃日志。这些事件与下列UIApplicationDelegate方法相对应:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">application:</span><span class="string">didFinishLaunchingWithOptions:</span></span><br><span class="line"><span class="string">applicationWillResignActive:</span></span><br><span class="line"><span class="string">applicationDidEnterBackground:</span></span><br><span class="line"><span class="string">applicationWillEnterForeground:</span></span><br><span class="line"><span class="string">applicationDidBecomeActive:</span></span><br><span class="line"><span class="string">applicationWillTerminate:</span></span><br></pre></td></tr></table></figure>
<p>上面所有这些方法，应用只有有限的时间去完成处理。如果花费时间太长，操作系统将终止应用。</p>
<blockquote>
<p>注意: 如果你没有把需要花费时间比较长的操作(如网络访问）放在后台线程上就很容易发生这种情况。关于如果避免这种情况的信息，请参考我们的另外两篇教程： Grand Central Dispatch 和 NSOperations。</p>
</blockquote>
<h3 id="用户强制退出">用户强制退出</h3><p>iOS 4.x开始支持多任务。如果应用阻塞界面并停止响应， 用户可以通过在主屏幕上双击Home按钮来终止应用。此时，操作应用将生成一个崩溃日志。</p>
<blockquote>
<p>注意: 双击Home按钮后，你将看到运行过的所有应用。那些应用不一定是正在运行，也不一定是被挂起。 通常，用户点击Home按钮时，应用将在后台保留约10分钟，然后操作系统自动将其终止。 所以双击Home按钮显示的应用列表只是表明那是一系列过去打开过的应用。删除那些应用的图标不会产生任何崩溃日志。</p>
</blockquote>
<h3 id="低内存终止">低内存终止</h3><p>子类化UIViewController时,你或许已经注意到<code>didReceiveMemoryWarning</code>方法。</p>
<p>在前台运行的应用拥有访问和使用内存的最高优化级。然而，这并不意味着该应用能使用设备的所有可用内存 ——每个应用只能使用一部分可用内存。 当内存使用达到一定程度时，操作系统将发出一个<code>UIApplicationDidReceiveMemoryWarningNotification</code> 通知。同时,调用 <code>didReceiveMemoryWarning</code> 方法。</p>
<p>此时，为了让应用继续正常运行，操作系统开始终止在后台的其他应用以释放一些内存。所有后台应用被终止后，如果你的应用还需要更多内存，操作系统会将你的应用也终止掉，并产生一个崩溃日志。而在这种情况下被终止的后台应用，不会产生崩溃日志。</p>
<blockquote>
<p>注意: 根据 <a href="http://developer.apple.com/library/ios/#qa/qa1747/_index.html" target="_blank" rel="external">苹果文档</a> Xcode不会自动添加低内存日志。你必需手动获取日志。 然而，根据我的个人经验，使用 Xcode 4.5.2, 低内存日志也会自动导入，只是”Process”和”Type”属性都被标为Unknown(未知)。 另外，值得一提的是在极短时间内分配一大块内存将给系统内存带来巨大负担。这样，也会产生内存警告的通知。</p>
</blockquote>
<h3 id="应用中有Bug">应用中有Bug</h3><p>如你所想，大多数闪退都是由于应用中有Bug，因此大多数崩溃日志的产生都是因为应用中的Bug。Bug的种类的有很多。</p>
<p><img src="http://www.raywenderlich.com/?attachment_id=27450" alt=""></p>
<p>在本教程的后半部分，你将通过调试一个会产生崩溃日志的含有Bug的应用，学习如何找到问题所在并进行修复!</p>
<h2 id="崩溃日志的实例">崩溃日志的实例</h2><p>让我们看看一个崩溃日志的实例，以使你在处理一些实际问题之前心里有谱。</p>
<p>事不宜迟，见见你的新朋友吧:</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">/// 1: Process Information</span><br><span class="line">Incident Identifier: <span class="number">30E46451-53</span>FD-<span class="number">4965-896</span><span class="keyword">A</span>-457FC11AD05F</span><br><span class="line">CrashReporter Key:   <span class="number">5a56599d83</span><span class="number">6c4f867</span>f6eec76afee451bf9ae5f31</span><br><span class="line">Hardware Model:      iPhone4,1</span><br><span class="line">Process:         Rage Masters [4155]</span><br><span class="line">Path:            /var/mobile/Applications/A5635B22-F5EF-4CEB-94B6-FE<span class="number">158D885014</span>/Rage Masters.app/Rage Masters</span><br><span class="line">Identifier:      Rage Masters</span><br><span class="line">Version:         ??? (???)</span><br><span class="line">Code Type:       ARM (Native)</span><br><span class="line">Parent Process:  launchd [1]</span><br><span class="line"></span><br><span class="line">// 2: Basic Information</span><br><span class="line">Date/Time:       <span class="number">2012-10-17</span> <span class="number">21:39:06.96</span>7 -0400</span><br><span class="line">OS Version:      iOS 6.0 (10A403)</span><br><span class="line">Report Version:  104</span><br><span class="line"></span><br><span class="line">// 3: Exception</span><br><span class="line">Exception Type:  <span class="number">00000020</span></span><br><span class="line">Exception Codes: <span class="number">0x00000000</span>8badf00d</span><br><span class="line">Highlighted Thread:  0</span><br><span class="line"></span><br><span class="line">// 4: Threads backtraces</span><br><span class="line">Thread 0 name:  Dispatch queue: com.apple.main-thread</span><br><span class="line">Thread 0:</span><br><span class="line">0   libsystem_kernel.dylib          <span class="number">0x327f2</span>eb4 mach_msg_trap + 20</span><br><span class="line">1   libsystem_kernel.dylib          <span class="number">0x327f30</span>48 mach_msg + 36</span><br><span class="line">2   CoreFoundation                  0x36bd4040 __CFRunLoopServiceMachPort + 124</span><br><span class="line">3   CoreFoundation                  0x36bd2d9e __CFRunLoopRun + 878</span><br><span class="line">4   CoreFoundation                  0x36b45eb8 CFRunLoopRunSpecific + 352</span><br><span class="line">5   CoreFoundation                  <span class="number">0x36b45d44</span> CFRunLoopRunInMode + 100</span><br><span class="line">6   CFNetwork                       0x32ac343e CFURLConnectionSendSynchronousRequest + 330</span><br><span class="line">7   Foundation                      <span class="number">0x346e69</span>ba +[NSURLConnection sendSynchronousRequest:returningResponse:error:] + 242</span><br><span class="line">8   Rage Masters                    <span class="number">0x000d40</span>46 0xd2000 + 8262</span><br><span class="line"></span><br><span class="line">Thread 1:</span><br><span class="line">0   libsystem_kernel.dylib          <span class="number">0x32803d98</span> __workq_kernreturn + 8</span><br><span class="line">1   libsystem_c.dylib               <span class="number">0x3a987</span>cf6 _pthread_workq_return + 14</span><br><span class="line">2   libsystem_c.dylib               <span class="number">0x3a987</span>a12 _pthread_wqthread + 362</span><br><span class="line">3   libsystem_c.dylib               <span class="number">0x3a9878</span>a0 start_wqthread + 4</span><br><span class="line"></span><br><span class="line">// 5: Thread state</span><br><span class="line">Thread 0 crashed with ARM Thread State (32-bit):</span><br><span class="line">    r0: <span class="number">0x00000000</span>    r1: <span class="number">0x00000000</span>      r2: <span class="number">0x00000001</span>      r3: <span class="number">0x39529</span>fc8</span><br><span class="line">    r4: 0xffffffff    r5: 0x2fd7d301      r6: 0x2fd7d300      r7: 0x2fd7d9d0</span><br><span class="line">    r8: 0x2fd7d330    r9: 0x3adbf8a8     r10: 0x2fd7d308     r11: <span class="number">0x00000032</span></span><br><span class="line">    ip: <span class="number">0x00000025</span>    sp: 0x2fd7d2ec      lr: 0x001bdb25      pc: <span class="number">0x30301838</span></span><br><span class="line">  cpsr: <span class="number">0x00000010</span></span><br><span class="line"></span><br><span class="line">// 6: Binary images</span><br><span class="line">Binary Images:</span><br><span class="line">0xd2000 -    0xd7fff +Rage Masters armv7  &lt;f37ee<span class="number">6d2c7b33</span><span class="number">4868972e0</span>e<span class="number">9c54f7062</span>&gt; /var/mobile/Applications/A5635B22-F5EF-4CEB-94B6-FE<span class="number">158D885014</span>/Rage Masters.app/Rage Masters</span><br><span class="line">0x2fe41000 - 0x2fe61fff  dyld armv7  &lt;<span class="number">75594988728</span><span class="number">831d98e1</span>f<span class="number">7c4c7b7</span>ca29d&gt; /usr/lib/dyld</span><br><span class="line"><span class="number">0x327f200</span>0 - <span class="number">0x32808</span>fff  libsystem_kernel.dylib armv7  &lt;f167dacec<span class="number">44b3a86a8</span>eee73400ff7a83&gt; /usr/lib/system/libsystem_kernel.dylib</span><br><span class="line"><span class="number">0x328a80</span>00 - 0x328bdfff  libresolv.9.dylib armv7  &lt;e<span class="number">79b59a3406</span>f<span class="number">34d9b37f80</span><span class="number">85955115</span>ce&gt; /usr/lib/libresolv.9.dylib</span><br><span class="line"><span class="number">0x32a70000</span> - 0x32b35fff  CFNetwork armv7  &lt;<span class="number">3e973794</span>a<span class="number">4d13428</span>bb974edcb<span class="number">2027139</span>&gt; /System/Library/Frameworks/CFNetwork.framework/CFNetwork</span><br><span class="line"><span class="number">0x32b7a00</span>0 - 0x32cc3fff  libicucore.<span class="keyword">A</span>.dylib armv7  &lt;<span class="number">0253932c1</span>b<span class="number">9038a0849</span>ef<span class="number">73c38e076</span>ca&gt; /usr/lib/libicucore.<span class="keyword">A</span>.dylib</span><br><span class="line">0x32cc4000 - 0x32cc5fff  CoreSurface armv7  &lt;b<span class="number">3f9d4e8</span>dd<span class="number">803a48b88</span>c<span class="number">58a0663d92</span>a3&gt; /System/Library/PrivateFrameworks/CoreSurface.framework/CoreSurface</span><br><span class="line"><span class="number">0x32f65000</span> - 0x32f8afff  OpenCL armv7  &lt;f<span class="number">770650101243</span>0fc94ed<span class="number">99006419</span>fba9&gt; /System/Library/PrivateFrameworks/OpenCL.framework/OpenCL</span><br></pre></td></tr></table></figure>
<p>这报告看起来像天书。:) 我们分几部分来解读吧:</p>
<h3 id="进程信息">进程信息</h3><p>第一部分是闪退进程的相关信息。</p>
<ul>
<li><code>Incident Identifier</code>是崩溃报告的唯一标识符。</li>
<li><code>CrashReporter Key</code> 是与设备标识相对应的唯一键值。虽然它不是真正的设备标识符，但也是一个非常有用的情报:如果你看到100个崩溃日志的<code>CrashReporter Key</code>值都是相同的，或者只有少数几个不同的CrashReport值，说明这不是一个普遍的问题，只发生在一个或少数几个设备上。</li>
<li><code>Hardware Model</code>标识设备类型。 如果很多崩溃日志都是来自相同的设备类型，说明应用只在某特定类型的设备上有问题。上面的日志里，崩溃日志产生的设备是<code>iPhone 4s</code>。</li>
<li>Process 是应用名称。中括号里面的数字是闪退时应用的进程ID。</li>
<li>接下来几行不言自明，无需赘述。</li>
</ul>
<h3 id="基本信息">基本信息</h3><p>这部分给出了一些基本信息，包括闪退发生的日期和时间，设备的iOS版本。如果有很多崩溃日志都来自iOS 6.0，说明问题只发生在iOS 6.0上。</p>
<h3 id="异常">异常</h3><p>在这部分，你可以看到闪退发生时抛出的异常类型。还能看到异常编码和抛出异常的线程。根据崩溃报告类型的不同，在这部分你还能看到一些另外的信息。</p>
<h3 id="线程回溯">线程回溯</h3><p>这部分提供应用中所有线程的回溯日志。 回溯是闪退发生时所有活动帧清单。它包含闪退发生时调用函数的清单。看下面这行日志:</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2    XYZLib    <span class="number">0x34648e88</span>    <span class="number">0x83000</span> + 8740</span><br></pre></td></tr></table></figure>
<p>它包括四列:</p>
<ol>
<li>帧编号—— 此处是2。</li>
<li>二进制库的名称 ——此处是 <code>XYZLib</code>.</li>
<li>调用方法的地址 ——此处是 <code>0x34648e88</code>.</li>
<li>第四列分为两个子列，一个基本地址和一个偏移量。此处是<code>0×83000 + 8740</code>, 第一个数字指向文件，第二个数字指向文件中的代码行。</li>
</ol>
<h3 id="线程状态">线程状态</h3><p>这部分是闪退时寄存器中的值。一般不需要这部分的信息，因为回溯部分的信息已经足够让你找出问题所在。</p>
<h3 id="二进制映像">二进制映像</h3><p>这部分列出了闪退时已经加载的二进制文件</p>
<h2 id="符号化Symbolication">符号化Symbolication</h2><p>第一次看到崩溃日志上的回溯时，你或许会觉得它没什么意义。我们习惯使用方法名和行数，而非像这样的神秘位置:</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6    Rage Masters    <span class="number">0x0001625</span>c    <span class="number">0x2a000</span> + 3003</span><br></pre></td></tr></table></figure>
<p>将这些十六进制地址转化成方法名称和行数的过程称之为符号化。 从Xcode的Organizer窗口获取崩溃日志后过几秒钟，崩溃日志将被自动符号化。上面那行被符号化后的版本如下 :</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span>    Rage Masters    <span class="number">0x0001625c</span>    -[RMAppDelegate <span class="string">application:</span><span class="string">didFinishLaunchingWithOptions:</span>] (RMAppDelegate.<span class="string">m:</span><span class="number">35</span>)</span><br></pre></td></tr></table></figure>
<p>Xcode符号化崩溃日志时，需要访问与App Store上对应的应用二进制文件以及生成二进制文件时产生的 .dSYM 文件。必需完全匹配才行。否则，日志将无法被完全符号化。</p>
<p>所以，保留每个分发给用户的编译版本非常重要。提交应用前进行归档时，Xcode将保存应用的二进制文件。可以在Xcode Organizer的Archives标签栏下找到所有已归档的应用文件。</p>
<p>在发现崩溃日志时，如果有相匹配的.dSYM文件和应用二进制文件，Xcode会自动对崩溃日志进行符号化。如果你换到别的电脑或创建新的账户，务必将所有二进制文件移动到正确的位置，使Xcode能找到它们。</p>
<blockquote>
<p>注意: 你必需同时保留应用二进制文件和.dSYM文件才能将崩溃日志完整符号化。每次提交到iTunes Connect的构建都必需归档。 .dSYM文件和二进制文件是特定绑定于每一次构建和后续构建的，即使来自相同的源代码文件，每一次构建也与其他构建不同，不能相互替换。 如果你使用Build 和 Archive 命令,这些文件会自动放在适当位置。 如果不是使用Build 和 Archive命令，放在Spotlight能够搜索到的位置（比如Home目录）即可。</p>
</blockquote>
<h2 id="低内存闪退">低内存闪退</h2><p>因为低内存崩溃日志与普通崩溃日志略有不同，所以本教程特别分开说明一下。:]</p>
<p>iOS设备检测到低内存时，虚拟内存系统发出通知请求应用释放内存。这些通知发送到所有正在运行的应用和进程，试图收回一些内存。</p>
<p>如果内存使用依然居高不下，系统将会终止后台线程以缓解内存压力。如果可用内存足够，应用将能够继续运行而不会产生崩溃报告。否则，应用将被iOS终止，并产生低内存崩溃报告。</p>
<p>低内存崩溃日志上没有应用线程的堆栈回溯。相反，上面显示的是以内存页数为单位的各进程内存使用量。(在撰写本文的时候，一个内存页的大小是4KB。)</p>
<p>被iOS因释放内存页终止的进程名称后面你会看到<code>jettisoned</code> 字样。如果看到它出现在你的应用名称后面，说明你的应用因使用太多内存而被终止了。</p>
<p>低内存崩溃日志看起来像这样：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Incident Identifier: <span class="number">30E46451-53</span>FD-<span class="number">4965-896</span><span class="keyword">A</span>-457FC11AD05F</span><br><span class="line">CrashReporter Key:   <span class="number">5a56599d83</span><span class="number">6c4f867</span>f6eec76afee451bf9ae5f31</span><br><span class="line">OS Version:          iPhone OS 3.1.3 (7E18)</span><br><span class="line">Date/Time:           <span class="number">2012-10-17</span> <span class="number">21:39:06.96</span>7 -0400</span><br><span class="line"></span><br><span class="line">Free pages:        96</span><br><span class="line">Wired pages:       10558</span><br><span class="line">Purgeable pages:   0</span><br><span class="line">Largest process:   Rage Masters</span><br><span class="line"></span><br><span class="line">Processes</span><br><span class="line">         Name                 UUID                    Count resident pages</span><br><span class="line">    Rage Masters &lt;cc527ca<span class="number">9b51937c5</span>adbe035fe27a7b12&gt;    9320 (jettisoned) (active)</span><br><span class="line">    mediaserverd &lt;<span class="number">3d3800d6</span>acfff<span class="number">050e4d0</span>ed91cbe2467e&gt;     255</span><br><span class="line">     dataaccessd &lt;<span class="number">13d80b2e70</span>7acc91f9aa3ec<span class="number">4c715b9</span>cc&gt;     505</span><br><span class="line">         syslogd &lt;8eddddc<span class="number">00294d5615</span>afded36ee3f1b62&gt;      71</span><br><span class="line">            apsd &lt;<span class="number">32070d91b216</span>d<span class="number">806973c8</span>f<span class="number">1b1d8077</span>a4&gt;     171</span><br><span class="line">       securityd &lt;b<span class="number">9e51062610</span>d<span class="number">27f727c51</span>19b8f80dcdf&gt;     243</span><br><span class="line">         notifyd &lt;591dd4dd<span class="number">804b4b87</span><span class="number">41f52335</span>ea1fa4ab&gt;    2027</span><br><span class="line">      CommCenter &lt;b<span class="number">4b87526</span>ae086bb<span class="number">62c982f107</span>8f43f81&gt;     189</span><br><span class="line">     SpringBoard &lt;<span class="number">324939a43</span>7d1cca1fa4af<span class="number">72d9f5d0</span>eba&gt;    2158 (active)</span><br><span class="line">      accessoryd &lt;<span class="number">8f21c8b37</span>6d16e2ccb95ed<span class="number">6d21d8317</span>a&gt;      91</span><br><span class="line">         configd &lt;85efd41aceac34ccc0019df<span class="number">76623c7a9</span>&gt;     371</span><br><span class="line">       fairplayd &lt;a2eaf<span class="number">736b3e07</span>c<span class="number">7c9a2c82</span>e9eb893555&gt;      93</span><br><span class="line">   mDNSResponder &lt;df1cd275e4ad<span class="number">434e05759</span>90e8e1da4cb&gt;     292</span><br><span class="line">       lockdownd &lt;80d2bd44c0bcca273d48ce<span class="number">52010f7e65</span>&gt;    1204</span><br><span class="line">         launchd &lt;a<span class="number">5988245</span>aade809bf<span class="number">77576f1d9</span>de42c5&gt;      72</span><br></pre></td></tr></table></figure>
<p>当应用发生低内存闪退时，你必需看看应用中内存使用的方式，以及是如何处理低内存警告的。你可以使用<code>Instruments</code>工具中使用<code>Allocations</code> 和 <code>Leaks</code>来发现内存分配问题和内存泄漏问题。如果你不知道如何利用 Instruments 检查内存问题，可以看看<a href="http://www.raywenderlich.com/2696/instruments-tutorial-for-ios-how-to-debug-memory-leaks" target="_blank" rel="external">这个教程</a> 。</p>
<p>还有，别忘记虚拟内存！ Instruments工具的<code>Leaks</code> 和 <code>Allocations</code> 不能跟踪显存使用情况。必需使用 VM Tracker 才能查看显存使用情况。 VM Tracker 默认是关闭的。打开Instrument,手动 选中<code>Automatic Snapshotting</code> 标志或者按下<code>Snapshot Now</code> 按钮。 本教程后面将会学习如何研究低内存崩溃日志。</p>
<h2 id="异常编码">异常编码</h2><p>在研究真实闪退场景之前，还有一点需要重点介绍一下：就是那些有趣的异常编码 。</p>
<p>你可以在报告的异常部分——前面代码的第3部分找到异常编码。有些编码比较常见。</p>
<p>通常，异常编码以一些文字开头，紧接着是一个或多个十六进制值，此数值正是说明闪退根本性质的所在。  从这些编码中，可以区分出闪退是因为程序错误、非法内存访问或者是其他原因。</p>
<p>下面是一些常见的异常编码:</p>
<ul>
<li><p>0x8badf00d: 读做 “ate bad food”! (把数字换成字母，是不是很像 :p)该编码表示应用是因为发生watchdog超时而被iOS终止的。  通常是应用花费太多时间而无法启动、终止或响应用系统事件。</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2013/01/badfood.jpg" alt=""></p>
</li>
<li><p><code>0xbad22222</code>: 该编码表示 VoIP 应用因为过于频繁重启而被终止。</p>
</li>
<li><code>0xdead10cc</code>: 读做 “dead lock”!该代码表明应用因为在后台运行时占用系统资源，如通讯录数据库不释放而被终止</li>
<li><code>0xdeadfa11</code>: 读做 “dead fall”! 该代码表示应用是被用户强制退出的。根据苹果文档, 强制退出发生在用户长按开关按钮直到出现 “滑动来关机”, 然后长按 Home按钮。强制退出将产生 包含0xdeadfa11 异常编码的崩溃日志, 因为大多数是强制退出是因为应用阻塞了界面。</li>
</ul>
<blockquote>
<p>注意: 在后台任务列表中关闭已挂起的应用不会产生崩溃日志。 一旦应用被挂起，它何时被终止都是合理的。所以不会产生崩溃日志。</p>
</blockquote>
<h2 id="大展身手的时候到了!">大展身手的时候到了!</h2><p>好了! 你已经学习了所有分析崩溃日志和修复错误的基础知识!</p>
<p>假设你刚进入Rage-O-Rage有限公司工作。该公司有一个在App Store上热销的应用，叫 Rage Masters。</p>
<p>你的老板安迪要你帮忙解决几个用户经常抱怨闪退问题。你的任务就是研究这些闪退，符号化用户提供的崩溃日志，查找问题所在，并修复之。</p>
<p>你可以从 <a href="http://cdn1.raywenderlich.com/downloads/RageMasters-Buggy.zip" target="_blank" rel="external">这里</a>下载应用的源代码。</p>
<blockquote>
<p>注意: 如果你想自己重新生成崩溃报告，请遵照以下指引：</p>
<ol>
<li>下载源码然后在Xcode中打开工程文件。</li>
<li>使用正确的provisioning profile连接到iOS设备。</li>
<li>从Xcode工具栏上选择iOS设备——不是模拟器作为target，然后构建应用。</li>
<li>当你在设备上到默认页面（应用的全屏图片）时，立即在Xcode上点击停止按钮。</li>
<li>关闭 Xcode。</li>
<li>在设备上直接打开应用。</li>
<li>测试场景，完成后连接设备到电脑上，通过Xcode获取崩溃日志。</li>
</ol>
</blockquote>
<h3 id="场景_1:_糟糕的代码">场景 1: 糟糕的代码</h3><p>一封来自用户的邮件: “大哥，你的应用就是一坨屎! 我将其下载到我自己的iPod Touch和iPhone上，还下载到我儿子的iPod Touch上。在所有的设备上，都是还没打开就闪退了……”</p>
<p>别一封来自用户的邮件说, “我下载了你们的应用，一打开就闪退。真悲催…”</p>
<p>另一封邮件说得更明确：”你们的应用不能运行。我把它下载到我和妻子的设备上。所有设备都是 一打开就闪退了…”</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2012/12/YourAppSucks.png" alt=""></p>
<p>好吧，别灰心! 这些意见藏着什么玄机呢？让我们看看崩溃日志吧:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Incident <span class="string">Identifier:</span> <span class="number">85833</span>DBA-<span class="number">3</span>DF7-<span class="number">43</span>EE-AF80-<span class="number">4E5</span>C51091F42</span><br><span class="line">CrashReporter <span class="string">Key:</span>   <span class="number">5</span>a56599d836c4f867f6eec76afee451bf9ae5f31</span><br><span class="line">Hardware <span class="string">Model:</span>      iPhone4,<span class="number">1</span></span><br><span class="line"><span class="string">Process:</span>         Rage Masters [<span class="number">20067</span>]</span><br><span class="line"><span class="string">Path:</span>            <span class="regexp">/var/</span>mobile<span class="regexp">/Applications/</span>B2121A89-<span class="number">3</span>D1F-<span class="number">4E61</span>-BB18-<span class="number">5511E1</span>DC150F<span class="regexp">/Rage Masters.app/</span>Rage Masters</span><br><span class="line"><span class="string">Identifier:</span>      Rage Masters</span><br><span class="line"><span class="string">Version:</span>         ??? (???)</span><br><span class="line">Code Type:       ARM (Native)</span><br><span class="line">Parent <span class="string">Process:</span>  launchd [<span class="number">1</span>]</span><br><span class="line">Date/<span class="string">Time:</span>       <span class="number">2012</span>-<span class="number">11</span>-<span class="number">03</span> <span class="number">13</span>:<span class="number">37</span>:<span class="number">31.148</span> -<span class="number">0400</span></span><br><span class="line">OS <span class="string">Version:</span>      iOS <span class="number">6.0</span> (<span class="number">10</span>A403)</span><br><span class="line">Report <span class="string">Version:</span>  <span class="number">104</span></span><br><span class="line">Exception <span class="string">Type:</span>  <span class="number">00000020</span></span><br><span class="line">Exception <span class="string">Codes:</span> <span class="number">0x000000008badf00d</span></span><br><span class="line">Highlighted <span class="string">Thread:</span>  <span class="number">0</span></span><br><span class="line">Application Specific <span class="string">Information:</span></span><br><span class="line">Soheil-Azarpour.Rage-Masters failed to launch <span class="keyword">in</span> time</span><br><span class="line">Elapsed total CPU time (seconds): <span class="number">8.030</span> (user <span class="number">8.030</span>, system <span class="number">0.000</span>), <span class="number">20</span>% CPU</span><br><span class="line">Elapsed application CPU time (seconds): <span class="number">3.840</span>, <span class="number">10</span>% CPU</span><br><span class="line">Thread <span class="number">0</span> <span class="string">name:</span>  Dispatch <span class="string">queue:</span> com.apple.main-thread</span><br><span class="line">Thread <span class="number">0</span>:</span><br><span class="line"><span class="number">0</span>   libsystem_kernel.dylib          <span class="number">0x327f2eb4</span> mach_msg_trap + <span class="number">20</span></span><br><span class="line"><span class="number">1</span>   libsystem_kernel.dylib          <span class="number">0x327f3048</span> mach_msg + <span class="number">36</span></span><br><span class="line"><span class="number">2</span>   CoreFoundation                  <span class="number">0x36bd4040</span> __CFRunLoopServiceMachPort + <span class="number">124</span></span><br><span class="line"><span class="number">3</span>   CoreFoundation                  <span class="number">0x36bd2d9e</span> __CFRunLoopRun + <span class="number">878</span></span><br><span class="line"><span class="number">4</span>   CoreFoundation                  <span class="number">0x36b45eb8</span> CFRunLoopRunSpecific + <span class="number">352</span></span><br><span class="line"><span class="number">5</span>   CoreFoundation                  <span class="number">0x36b45d44</span> CFRunLoopRunInMode + <span class="number">100</span></span><br><span class="line"><span class="number">6</span>   CFNetwork                       <span class="number">0x32ac343e</span> CFURLConnectionSendSynchronousRequest + <span class="number">330</span></span><br><span class="line"><span class="number">7</span>   Foundation                      <span class="number">0x346e69ba</span> +[NSURLConnection <span class="string">sendSynchronousRequest:</span><span class="string">returningResponse:</span><span class="string">error:</span>] + <span class="number">242</span></span><br><span class="line"><span class="number">8</span>   Rage Masters                    <span class="number">0x000ea1c4</span> -[RMAppDelegate <span class="string">application:</span><span class="string">didFinishLaunchingWithOptions:</span>] (RMAppDelegate.<span class="string">m:</span><span class="number">36</span>)</span><br><span class="line"><span class="number">9</span>   UIKit                           <span class="number">0x37f30ad4</span> -[UIApplication <span class="string">_handleDelegateCallbacksWithOptions:</span><span class="string">isSuspended:</span><span class="string">restoreState:</span>] + <span class="number">248</span></span><br><span class="line"><span class="number">10</span>  UIKit                           <span class="number">0x37f3065e</span> -[UIApplication <span class="string">_callInitializationDelegatesForURL:</span><span class="string">payload:</span><span class="string">suspended:</span>] + <span class="number">1186</span></span><br><span class="line"><span class="number">11</span>  UIKit                           <span class="number">0x37f28846</span> -[UIApplication <span class="string">_runWithURL:</span><span class="string">payload:</span><span class="string">launchOrientation:</span><span class="string">statusBarStyle:</span><span class="string">statusBarHidden:</span>] + <span class="number">694</span></span><br><span class="line"><span class="number">12</span>  UIKit                           <span class="number">0x37ed0c3c</span> -[UIApplication <span class="string">handleEvent:</span><span class="string">withNewEvent:</span>] + <span class="number">1000</span></span><br><span class="line"><span class="number">13</span>  UIKit                           <span class="number">0x37ed06d0</span> -[UIApplication <span class="string">sendEvent:</span>] + <span class="number">68</span></span><br><span class="line"><span class="number">14</span>  UIKit                           <span class="number">0x37ed011e</span> _UIApplicationHandleEvent + <span class="number">6150</span></span><br><span class="line"><span class="number">15</span>  GraphicsServices                <span class="number">0x370835a0</span> _PurpleEventCallback + <span class="number">588</span></span><br><span class="line"><span class="number">16</span>  GraphicsServices                <span class="number">0x370831ce</span> PurpleEventCallback + <span class="number">30</span></span><br><span class="line"><span class="number">17</span>  CoreFoundation                  <span class="number">0x36bd4170</span> __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__ + <span class="number">32</span></span><br><span class="line"><span class="number">18</span>  CoreFoundation                  <span class="number">0x36bd4112</span> __CFRunLoopDoSource1 + <span class="number">134</span></span><br><span class="line"><span class="number">19</span>  CoreFoundation                  <span class="number">0x36bd2f94</span> __CFRunLoopRun + <span class="number">1380</span></span><br><span class="line"><span class="number">20</span>  CoreFoundation                  <span class="number">0x36b45eb8</span> CFRunLoopRunSpecific + <span class="number">352</span></span><br><span class="line"><span class="number">21</span>  CoreFoundation                  <span class="number">0x36b45d44</span> CFRunLoopRunInMode + <span class="number">100</span></span><br><span class="line"><span class="number">22</span>  UIKit                           <span class="number">0x37f27480</span> -[UIApplication _run] + <span class="number">664</span></span><br><span class="line"><span class="number">23</span>  UIKit                           <span class="number">0x37f242fc</span> UIApplicationMain + <span class="number">1116</span></span><br><span class="line"><span class="number">24</span>  Rage Masters                    <span class="number">0x000ea004</span> main (main.<span class="string">m:</span><span class="number">16</span>)</span><br><span class="line"><span class="number">25</span>  libdyld.dylib                   <span class="number">0x3b630b1c</span> start + <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>发现问题了吗? 异常编码是<code>0x000000008badf00d</code>,还有后面的报告:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Application Specific Information:</span><br><span class="line">Soheil-Azarpour<span class="class">.Rage-Masters</span> failed to launch <span class="keyword">in</span> <span class="tag">time</span></span><br><span class="line">Elapsed total CPU <span class="tag">time</span> (seconds): <span class="number">8.030</span> (user <span class="number">8.030</span>, system <span class="number">0.000</span>), <span class="number">20%</span> CPU</span><br><span class="line">Elapsed application CPU <span class="tag">time</span> (seconds): <span class="number">3.840</span>, <span class="number">10%</span> CPU</span><br></pre></td></tr></table></figure>
<p>这说明应用在启动时就闪退了，iOS的<code>watchdog</code>机制终止了应用。帅! 找到问题了，但是为什会发生这样的事呢？</p>
<p>接着往下看日志。 从下向上读回溯日志。最底下的帧 (frame 25: <code>libdyld.dylib</code>)是最先调用的，然后是帧24,<code>Rage Masters</code>, main (main.m:16) ，依此类推。</p>
<p>跟应用源代码相关的帧是最重要的。忽略掉系统库和框架。下一个与代码相关的帧是:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span>    Rage Masters    <span class="number">0x0009f244</span> -[RMAppDelegate <span class="string">application:</span><span class="string">didFinishLaunchingWithOptions:</span>] (RMAppDelegate.<span class="string">m:</span><span class="number">35</span>)</span><br></pre></td></tr></table></figure>
<p>应用在执行<code>RMAppDelegate</code> (RMAppDelegate.m:35) 类<code>application:didFinishLaunchingWithOptions:</code>方法第35 行代码时闪退。打开Xcode看看那行代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSData</span> *directoryData = [<span class="built_in">NSURLConnection</span> sendSynchronousRequest:request returningResponse:<span class="literal">nil</span> error:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<p>就是它了! 同步调用web服务?! 在主线程上?! 在 <code>application:didFinishLaunchingWithOptions:</code> 方法上?!! 谁写的代码呀?!</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2012/12/iStock_000020175708XSmall.jpg" alt="Network calls on the main thread makes kittens sad."></p>
<p>不管如何，问题得你来修复了。这个调用必需异步进行，甚至更理想的情况是，在<code>application:didFinishLaunchingWithOptions:</code>返回YES之后的其他部分再执行Web服务。</p>
<p>在其他地方调用可能需要比较多的修改。当下，我们只要使应用不闪退就行。可以在日后再实现更好的设计。 将上面那行讨厌的代码（及其下面的三行代码）换成下面这个异步的版本吧:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSURLConnection</span> sendAsynchronousRequest:request</span><br><span class="line">                                           queue:[<span class="built_in">NSOperationQueue</span> mainQueue]</span><br><span class="line">                               completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="built_in">NSURL</span> *cacheDirectory = [[[<span class="built_in">NSFileManager</span> defaultManager] URLsForDirectory:<span class="built_in">NSUserDirectory</span> inDomains:<span class="built_in">NSCachesDirectory</span>] lastObject];</span><br><span class="line">             <span class="built_in">NSURL</span> *filePath = [<span class="built_in">NSURL</span> URLWithString:kDirectoryFile relativeToURL:cacheDirectory];</span><br><span class="line">             [data writeToFile:[filePath absoluteString] atomically:<span class="literal">YES</span>];</span><br><span class="line">         &#125;];</span><br></pre></td></tr></table></figure>
<h3 id="场景_2:_无法响应事件的按钮">场景 2: 无法响应事件的按钮</h3><p>一名用户说: “我不能将某个rage master添加到书签里面。我想添加的时候应用就闪退…”</p>
<p>用一名用户说 ：”书签不能用 … 在详细页面上，点击书签按钮,应用就闪退了!”</p>
<p>上面的抱怨说得不是很清楚，引起问题的原因肯定有多样。看看崩溃日志:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Incident <span class="string">Identifier:</span> <span class="number">3</span>AAA63CC-<span class="number">3088</span>-<span class="number">41</span>CC-<span class="number">84</span>D9-<span class="number">82</span>FE03F9F354</span><br><span class="line">CrashReporter <span class="string">Key:</span>   <span class="number">5</span>a56599d836c4f867f6eec76afee451bf9ae5f31</span><br><span class="line">Hardware <span class="string">Model:</span>      iPhone4,<span class="number">1</span></span><br><span class="line"><span class="string">Process:</span>         Rage Masters [<span class="number">20090</span>]</span><br><span class="line"><span class="string">Path:</span>            <span class="regexp">/var/</span>mobile<span class="regexp">/Applications/</span>B2121A89-<span class="number">3</span>D1F-<span class="number">4E61</span>-BB18-<span class="number">5511E1</span>DC150F<span class="regexp">/Rage Masters.app/</span>Rage Masters</span><br><span class="line"><span class="string">Identifier:</span>      Rage Masters</span><br><span class="line"><span class="string">Version:</span>         ??? (???)</span><br><span class="line">Code Type:       ARM (Native)</span><br><span class="line">Parent <span class="string">Process:</span>  launchd [<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">Date/<span class="string">Time:</span>       <span class="number">2012</span>-<span class="number">11</span>-<span class="number">03</span> <span class="number">13</span>:<span class="number">39</span>:<span class="number">00.081</span> -<span class="number">0400</span></span><br><span class="line">OS <span class="string">Version:</span>      iOS <span class="number">6.0</span> (<span class="number">10</span>A403)</span><br><span class="line">Report <span class="string">Version:</span>  <span class="number">104</span></span><br><span class="line"></span><br><span class="line">Exception <span class="string">Type:</span>  EXC_CRASH (SIGABRT)</span><br><span class="line">Exception <span class="string">Codes:</span> <span class="number">0x0000000000000000</span>, <span class="number">0x0000000000000000</span></span><br><span class="line">Crashed <span class="string">Thread:</span>  <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Last Exception <span class="string">Backtrace:</span></span><br><span class="line"><span class="number">0</span>   CoreFoundation                  <span class="number">0x36bff29e</span> __exceptionPreprocess + <span class="number">158</span></span><br><span class="line"><span class="number">1</span>   libobjc.A.dylib                 <span class="number">0x34f0f97a</span> objc_exception_throw + <span class="number">26</span></span><br><span class="line"><span class="number">2</span>   CoreFoundation                  <span class="number">0x36c02e02</span> -[NSObject(NSObject) <span class="string">doesNotRecognizeSelector:</span>] + <span class="number">166</span></span><br><span class="line"><span class="number">3</span>   CoreFoundation                  <span class="number">0x36c0152c</span> ___forwarding___ + <span class="number">388</span></span><br><span class="line"><span class="number">4</span>   CoreFoundation                  <span class="number">0x36b58f64</span> _CF_forwarding_prep_0 + <span class="number">20</span></span><br><span class="line"><span class="number">5</span>   UIKit                           <span class="number">0x37fbb0a8</span> -[UIApplication <span class="string">sendAction:</span><span class="string">to:</span><span class="string">from:</span><span class="string">forEvent:</span>] + <span class="number">68</span></span><br><span class="line"><span class="number">6</span>   UIKit                           <span class="number">0x37fbb05a</span> -[UIApplication <span class="string">sendAction:</span><span class="string">toTarget:</span><span class="string">fromSender:</span><span class="string">forEvent:</span>] + <span class="number">26</span></span><br><span class="line"><span class="number">7</span>   UIKit                           <span class="number">0x37fbb038</span> -[UIControl <span class="string">sendAction:</span><span class="string">to:</span><span class="string">forEvent:</span>] + <span class="number">40</span></span><br><span class="line"><span class="number">8</span>   UIKit                           <span class="number">0x37fba8ee</span> -[UIControl(Internal) <span class="string">_sendActionsForEvents:</span><span class="string">withEvent:</span>] + <span class="number">498</span></span><br><span class="line"><span class="number">9</span>   UIKit                           <span class="number">0x37fbade4</span> -[UIControl <span class="string">touchesEnded:</span><span class="string">withEvent:</span>] + <span class="number">484</span></span><br><span class="line"><span class="number">10</span>  UIKit                           <span class="number">0x37ee35f4</span> -[UIWindow <span class="string">_sendTouchesForEvent:</span>] + <span class="number">520</span></span><br><span class="line"><span class="number">11</span>  UIKit                           <span class="number">0x37ed0804</span> -[UIApplication <span class="string">sendEvent:</span>] + <span class="number">376</span></span><br><span class="line"><span class="number">12</span>  UIKit                           <span class="number">0x37ed011e</span> _UIApplicationHandleEvent + <span class="number">6150</span></span><br><span class="line"><span class="number">13</span>  GraphicsServices                <span class="number">0x3708359e</span> _PurpleEventCallback + <span class="number">586</span></span><br><span class="line"><span class="number">14</span>  GraphicsServices                <span class="number">0x370831ce</span> PurpleEventCallback + <span class="number">30</span></span><br><span class="line"><span class="number">15</span>  CoreFoundation                  <span class="number">0x36bd416e</span> __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__ + <span class="number">30</span></span><br><span class="line"><span class="number">16</span>  CoreFoundation                  <span class="number">0x36bd4112</span> __CFRunLoopDoSource1 + <span class="number">134</span></span><br><span class="line"><span class="number">17</span>  CoreFoundation                  <span class="number">0x36bd2f94</span> __CFRunLoopRun + <span class="number">1380</span></span><br><span class="line"><span class="number">18</span>  CoreFoundation                  <span class="number">0x36b45eb8</span> CFRunLoopRunSpecific + <span class="number">352</span></span><br><span class="line"><span class="number">19</span>  CoreFoundation                  <span class="number">0x36b45d44</span> CFRunLoopRunInMode + <span class="number">100</span></span><br><span class="line"><span class="number">20</span>  GraphicsServices                <span class="number">0x370822e6</span> GSEventRunModal + <span class="number">70</span></span><br><span class="line"><span class="number">21</span>  UIKit                           <span class="number">0x37f242fc</span> UIApplicationMain + <span class="number">1116</span></span><br><span class="line"><span class="number">22</span>  Rage Masters                    <span class="number">0x000ca004</span> main (main.<span class="string">m:</span><span class="number">16</span>)</span><br><span class="line"><span class="number">23</span>  libdyld.dylib                   <span class="number">0x3b630b1c</span> start + <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>异常代码是<code>SIGABRT</code>。通常,  <code>SIGABRT</code> 异常是由于<strong><em>某个对象接收到未实现的消息</em></strong>引起的。 或者，用简单的话说，在某个对象上<strong><em>调用了不存在的方法</em></strong>。</p>
<p>这种情况一般不会发生，因为A对象调用了B方法，如果B方法不存在，编译器会报错。但是，如果你是使用selector间接调用方法的，编译器则无法检测对象是否存在该方法了。</p>
<p>回到崩溃日志。它指出闪退发生在编号为0的线程上。 这意味着很可能是在主线程上调用了某个对象没有实现的方法。</p>
<p>如果你接着阅读回溯日志，会发现跟你的代码相关的只有帧22, main.m:16. 这没有多大帮助。 :[</p>
<p>继续向上查看框架调用，出现这个:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>    CoreFoundation    <span class="number">0</span>x36c02e02 -[<span class="function"><span class="title">NSObject</span><span class="params">(NSObject)</span></span> doesNotRecognizeSelector:] + <span class="number">166</span></span><br></pre></td></tr></table></figure>
<p>这不是你自己写的代码。但至少它确认了是对象调用了一个没有实现的方法。</p>
<p>回到<code>RMDetailViewController.m</code>文件, 因为那是书签按钮实现动作的地方。 找到书签功能代码:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">IBAction</span>)bookmarkButtonPressed &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.master</span><span class="variable">.isBookmarked</span> = !<span class="keyword">self</span><span class="variable">.master</span><span class="variable">.isBookmarked</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update shared bookmarks</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.master</span><span class="variable">.isBookmarked</span>)</span><br><span class="line">        [[RMBookmarks sharedBookmarks] bookmarkMaster:<span class="keyword">self</span><span class="variable">.master</span>];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        [[RMBookmarks sharedBookmarks] unbookmarkMaster:<span class="keyword">self</span><span class="variable">.master</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update UI</span></span><br><span class="line">    [<span class="keyword">self</span> updateBookmarkImage];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看起来没什么问题，再检查一下storyboard (XIB文件) ，确认按钮连接的正确性。</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2012/10/Scenario_2-700x290.png" alt=""></p>
<p>就是它了! 在 <code>MainStoryboard.storyboard</code>,按钮连接的是 <code>bookmarkButtonPressed:</code> 而不是<code>bookmarkButtonPressed</code> (注意后面的分号说明方法有一个参数）。 只要将上面的方法签名修改成这样就能修复问题了:</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span>(IBAction)<span class="tag">bookmarkButtonPressed</span>:(id)<span class="tag">sender</span> &#123;</span><br><span class="line">    <span class="comment">// Remain unchanged..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，你也可以简单地在XIB文件上删除错误的连接，然后重新连接方法，使XIB文件连接到正确的方法上。两者方法都行。 又处理了一个闪退问题，好样的。:]</p>
<h3 id="场景_3:_表格上的Bug">场景 3: 表格上的Bug</h3><p>另一用户抱怨道, “在书签视图上无法删除书签…” 还有另一用户抱怨同样的问题, “当我试图删除书签时，应用闪退…” 这些邮件没什么作用，还是看看崩溃日志!</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Incident <span class="string">Identifier:</span> <span class="number">5</span>B62D681-D8FE-<span class="number">41</span>FE-<span class="number">8</span>D52-AB7E6D6B2AC7</span><br><span class="line">CrashReporter <span class="string">Key:</span>   <span class="number">5</span>a56599d836c4f867f6eec76afee451bf9ae5f31</span><br><span class="line">Hardware <span class="string">Model:</span>      iPhone4,<span class="number">1</span></span><br><span class="line"><span class="string">Process:</span>         Rage Masters [<span class="number">20088</span>]</span><br><span class="line"><span class="string">Path:</span>            <span class="regexp">/var/</span>mobile<span class="regexp">/Applications/</span>B2121A89-<span class="number">3</span>D1F-<span class="number">4E61</span>-BB18-<span class="number">5511E1</span>DC150F<span class="regexp">/Rage Masters.app/</span>Rage Masters</span><br><span class="line"><span class="string">Identifier:</span>      Rage Masters</span><br><span class="line"><span class="string">Version:</span>         ??? (???)</span><br><span class="line">Code Type:       ARM (Native)</span><br><span class="line">Parent <span class="string">Process:</span>  launchd [<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">Date/<span class="string">Time:</span>       <span class="number">2012</span>-<span class="number">11</span>-<span class="number">03</span> <span class="number">13</span>:<span class="number">38</span>:<span class="number">45.762</span> -<span class="number">0400</span></span><br><span class="line">OS <span class="string">Version:</span>      iOS <span class="number">6.0</span> (<span class="number">10</span>A403)</span><br><span class="line">Report <span class="string">Version:</span>  <span class="number">104</span></span><br><span class="line"></span><br><span class="line">Exception <span class="string">Type:</span>  EXC_CRASH (SIGABRT)</span><br><span class="line">Exception <span class="string">Codes:</span> <span class="number">0x0000000000000000</span>, <span class="number">0x0000000000000000</span></span><br><span class="line">Crashed <span class="string">Thread:</span>  <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Last Exception <span class="string">Backtrace:</span></span><br><span class="line"><span class="number">0</span>   CoreFoundation                  <span class="number">0x36bff29e</span> __exceptionPreprocess + <span class="number">158</span></span><br><span class="line"><span class="number">1</span>   libobjc.A.dylib                 <span class="number">0x34f0f97a</span> objc_exception_throw + <span class="number">26</span></span><br><span class="line"><span class="number">2</span>   CoreFoundation                  <span class="number">0x36bff158</span> +[NSException <span class="string">raise:</span><span class="string">format:</span><span class="string">arguments:</span>] + <span class="number">96</span></span><br><span class="line"><span class="number">3</span>   Foundation                      <span class="number">0x346812aa</span> -[NSAssertionHandler <span class="string">handleFailureInMethod:</span><span class="string">object:</span><span class="string">file:</span><span class="string">lineNumber:</span><span class="string">description:</span>] + <span class="number">86</span></span><br><span class="line"><span class="number">4</span>   UIKit                           <span class="number">0x37f04b7e</span> -[UITableView(_UITableViewPrivate) <span class="string">_endCellAnimationsWithContext:</span>] + <span class="number">7690</span></span><br><span class="line"><span class="number">5</span>   UIKit                           <span class="number">0x3803a4a2</span> -[UITableView <span class="string">deleteRowsAtIndexPaths:</span><span class="string">withRowAnimation:</span>] + <span class="number">22</span></span><br><span class="line"><span class="number">6</span>   Rage Masters                    <span class="number">0x000fd9ca</span> -[RMBookmarksViewController <span class="string">tableView:</span><span class="string">commitEditingStyle:</span><span class="string">forRowAtIndexPath:</span>] (RMBookmarksViewController.<span class="string">m:</span><span class="number">68</span>)</span><br><span class="line"><span class="number">7</span>   UIKit                           <span class="number">0x3809a5d4</span> -[UITableView(UITableViewInternal) <span class="string">animateDeletionOfRowWithCell:</span>] + <span class="number">80</span></span><br><span class="line"><span class="number">8</span>   UIKit                           <span class="number">0x37fbb0a8</span> -[UIApplication <span class="string">sendAction:</span><span class="string">to:</span><span class="string">from:</span><span class="string">forEvent:</span>] + <span class="number">68</span></span><br><span class="line"><span class="number">9</span>   UIKit                           <span class="number">0x37fbb05a</span> -[UIApplication <span class="string">sendAction:</span><span class="string">toTarget:</span><span class="string">fromSender:</span><span class="string">forEvent:</span>] + <span class="number">26</span></span><br><span class="line"><span class="number">10</span>  UIKit                           <span class="number">0x37fbb038</span> -[UIControl <span class="string">sendAction:</span><span class="string">to:</span><span class="string">forEvent:</span>] + <span class="number">40</span></span><br><span class="line"><span class="number">11</span>  UIKit                           <span class="number">0x37fba8ee</span> -[UIControl(Internal) <span class="string">_sendActionsForEvents:</span><span class="string">withEvent:</span>] + <span class="number">498</span></span><br><span class="line"><span class="number">12</span>  UIKit                           <span class="number">0x37fbb0a8</span> -[UIApplication <span class="string">sendAction:</span><span class="string">to:</span><span class="string">from:</span><span class="string">forEvent:</span>] + <span class="number">68</span></span><br><span class="line"><span class="number">13</span>  UIKit                           <span class="number">0x37fbb05a</span> -[UIApplication <span class="string">sendAction:</span><span class="string">toTarget:</span><span class="string">fromSender:</span><span class="string">forEvent:</span>] + <span class="number">26</span></span><br><span class="line"><span class="number">14</span>  UIKit                           <span class="number">0x37fbb038</span> -[UIControl <span class="string">sendAction:</span><span class="string">to:</span><span class="string">forEvent:</span>] + <span class="number">40</span></span><br><span class="line"><span class="number">15</span>  UIKit                           <span class="number">0x37fba8ee</span> -[UIControl(Internal) <span class="string">_sendActionsForEvents:</span><span class="string">withEvent:</span>] + <span class="number">498</span></span><br><span class="line"><span class="number">16</span>  UIKit                           <span class="number">0x37fbade4</span> -[UIControl <span class="string">touchesEnded:</span><span class="string">withEvent:</span>] + <span class="number">484</span></span><br><span class="line"><span class="number">17</span>  UIKit                           <span class="number">0x37ee35f4</span> -[UIWindow <span class="string">_sendTouchesForEvent:</span>] + <span class="number">520</span></span><br><span class="line"><span class="number">18</span>  UIKit                           <span class="number">0x37ed0804</span> -[UIApplication <span class="string">sendEvent:</span>] + <span class="number">376</span></span><br><span class="line"><span class="number">19</span>  UIKit                           <span class="number">0x37ed011e</span> _UIApplicationHandleEvent + <span class="number">6150</span></span><br><span class="line"><span class="number">20</span>  GraphicsServices                <span class="number">0x3708359e</span> _PurpleEventCallback + <span class="number">586</span></span><br><span class="line"><span class="number">21</span>  GraphicsServices                <span class="number">0x370831ce</span> PurpleEventCallback + <span class="number">30</span></span><br><span class="line"><span class="number">22</span>  CoreFoundation                  <span class="number">0x36bd416e</span> __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__ + <span class="number">30</span></span><br><span class="line"><span class="number">23</span>  CoreFoundation                  <span class="number">0x36bd4112</span> __CFRunLoopDoSource1 + <span class="number">134</span></span><br><span class="line"><span class="number">24</span>  CoreFoundation                  <span class="number">0x36bd2f94</span> __CFRunLoopRun + <span class="number">1380</span></span><br><span class="line"><span class="number">25</span>  CoreFoundation                  <span class="number">0x36b45eb8</span> CFRunLoopRunSpecific + <span class="number">352</span></span><br><span class="line"><span class="number">26</span>  CoreFoundation                  <span class="number">0x36b45d44</span> CFRunLoopRunInMode + <span class="number">100</span></span><br><span class="line"><span class="number">27</span>  GraphicsServices                <span class="number">0x370822e6</span> GSEventRunModal + <span class="number">70</span></span><br><span class="line"><span class="number">28</span>  UIKit                           <span class="number">0x37f242fc</span> UIApplicationMain + <span class="number">1116</span></span><br><span class="line"><span class="number">29</span>  Rage Masters                    <span class="number">0x000fb004</span> main (main.<span class="string">m:</span><span class="number">16</span>)</span><br><span class="line"><span class="number">30</span>  libdyld.dylib                   <span class="number">0x3b630b1c</span> start + <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这看起来跟前面那个崩溃日志很像。是另一个<code>SIGABRT</code> 异常。 你可能想知道是否是相同的问题：发送信息到一个没有实现相应方法的对象?</p>
<p>让我们从回溯日志看看哪些方法被调用了。从底部开始，你的源代码最后被调用的是帧 6:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span>    Rage Masters    <span class="number">0x00088c66</span> -[RMBookmarksViewController <span class="string">tableView:</span><span class="string">commitEditingStyle:</span><span class="string">forRowAtIndexPath:</span>] (RMBookmarksViewController.<span class="string">m:</span><span class="number">68</span>)</span><br></pre></td></tr></table></figure>
<p>这是UITableViewDataSource 的一个方法. 呵呵?! 毫无疑问苹果已经实现了该方法 —— 你可以重载它, 但不像是还没有实现。而且,这是个可选的委派方法。 所以问题不是调用了一个没有实现的方法。 再看看上面的几个帧:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>    Foundation    <span class="number">0x346812aa</span> -[NSAssertionHandler <span class="string">handleFailureInMethod:</span><span class="string">object:</span><span class="string">file:</span><span class="string">lineNumber:</span><span class="string">description:</span>] + <span class="number">86</span></span><br><span class="line"><span class="number">4</span>    UIKit         <span class="number">0x37f04b7e</span> -[UITableView(_UITableViewPrivate) <span class="string">_endCellAnimationsWithContext:</span>] + <span class="number">7690</span></span><br><span class="line"><span class="number">5</span>    UIKit         <span class="number">0x3803a4a2</span> -[UITableView <span class="string">deleteRowsAtIndexPaths:</span><span class="string">withRowAnimation:</span>] + <span class="number">22</span></span><br></pre></td></tr></table></figure>
<p>帧 5, <code>UITableView</code>调用了它自己的另一个方法 <code>deleteRowsAtIndexPaths:withRowAnimation:</code>然后是看起来像苹果内部方法的<code>_endCellAnimationsWithContext:</code>被调用。然后<code>Foundation framework</code>发生异常<code>handleFailureInMethod:object:file:lineNumber:description:</code>.</p>
<p>这些分析结合用户的抱怨，看起来是你在处理UITableView删除行过程中有Bug。回到Xcode。你知道看哪里吗 ? 能从崩溃日志中判断出来? 就是RMBookmarksViewController.m文件的第68行:</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (void)<span class="tag">tableView</span>:(UITableView *)<span class="tag">tableView</span> <span class="tag">commitEditingStyle</span>:(UITableViewCellEditingStyle)<span class="tag">editingStyle</span> <span class="tag">forRowAtIndexPath</span>:(NSIndexPath *)<span class="tag">indexPath</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr_selector">[self.tableView deleteRowsAtIndexPaths:[NSArray arrayWithObject:indexPath]</span> <span class="tag">withRowAnimation</span><span class="pseudo">:UITableViewRowAnimationAutomatic</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现问题了吗? 给你点时间，仔细看一下。 找到了吧! 数据源呢? 代码在表格视图上删除了一行，但并没有修改背后的数据源。把上面的代码替换成下面的就能修复问题了:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span>(<span class="tag">void</span>)<span class="rule"><span class="attribute">tableView</span>:<span class="value">(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line"></span><br><span class="line">    RMMaster *masterToDelete = [bookmarks objectAtIndex:indexPath.row]</span></span>;</span><br><span class="line">    <span class="attr_selector">[bookmarks removeObject:masterToDelete]</span>;</span><br><span class="line">    <span class="attr_selector">[[RMBookmarks sharedBookmarks]</span> <span class="rule"><span class="attribute">unbookmarkMaster</span>:<span class="value">masterToDelete]</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="attr_selector">[self.tableView deleteRowsAtIndexPaths:[NSArray arrayWithObject:indexPath]</span> <span class="rule"><span class="attribute">withRowAnimation</span>:<span class="value">UITableViewRowAnimationAutomatic]</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>搞定了!走起，讨厌的 bug!!</p>
<h3 id="场景_4:_吃棒棒糖时闪退!">场景 4: 吃棒棒糖时闪退!</h3><p>用户邮件说, “当rage master吃棒棒糖时应用就闪退…” 另一用户说, “我让rage master 吃棒棒糖，没几次应用就闪退了!” 崩溃日志如下:</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">Incident Identifier: <span class="number">081E58F5</span>-<span class="number">95A8-404</span>D-947B-<span class="number">5E104B6</span>BC1B1</span><br><span class="line">CrashReporter Key:   <span class="number">5a56599d83</span><span class="number">6c4f867</span>f6eec76afee451bf9ae5f31</span><br><span class="line">Hardware Model:      iPhone4,1</span><br><span class="line">OS Version:          iPhone OS 6.0 (10A403)</span><br><span class="line">Kernel Version:      Darwin Kernel Version 13.0.0: Sun Aug <span class="number">19 00:28:05</span> PDT 2012<span class="comment">; root:xnu-2107.2.33~4/RELEASE_ARM_S5L8940X</span></span><br><span class="line">Date:                <span class="number">2012-11-03</span> 13:39:59 -0400</span><br><span class="line">Time since snapshot: 4353 ms</span><br><span class="line"></span><br><span class="line">Free pages:        968</span><br><span class="line">Active pages:      7778</span><br><span class="line">Inactive pages:    4005</span><br><span class="line">Throttled pages:   92319</span><br><span class="line">Purgeable pages:   0</span><br><span class="line">Wired pages:       23347</span><br><span class="line">Largest process:   Rage Masters</span><br><span class="line"></span><br><span class="line">Processes</span><br><span class="line">     Name                    &lt;UUID&gt;                       rpages       recent_max       [reason]          (state)</span><br><span class="line"></span><br><span class="line">             lsd &lt;<span class="number">6a9f5b5</span>f36b23fc<span class="number">78f87b6d8</span>f1f49a9d&gt;          331              331         [vm]         (daemon) (idle)</span><br><span class="line">            afcd &lt;b0aff<span class="number">2e7952e34</span>a9882fec81a8dcdbb2&gt;          141              141         [vm]         (daemon) (idle)</span><br><span class="line">    itunesstored &lt;4e0cd9f873de<span class="number">3435b4119</span>c<span class="number">48b2d6d13</span>d&gt;         1761             1761         [vm]         (daemon) (idle)</span><br><span class="line">softwareupdatese &lt;2bc4b5ae<span class="number">016431c98</span>d<span class="number">3b34f81027</span>d0ae&gt;          311              311         [vm]         (daemon) (idle)</span><br><span class="line">          Amazon &lt;<span class="number">4600481f07</span>ec<span class="number">3e59a92531</span>9b7f67ba14&gt;         2951             2951         [vm]         (suspended)</span><br><span class="line">       accountsd &lt;ac0fce<span class="number">15c1a2350</span>d951efc<span class="number">498d521</span>ac7&gt;          519              519         [vm]         (daemon) (idle)</span><br><span class="line">coresymbolicatio &lt;edba<span class="number">67001f76313</span>b<span class="number">992056c71</span>2153b4b&gt;          126              126         [vm]         (daemon) (idle)</span><br><span class="line">           Skype &lt;504cf2fe60cb3cdea8273e74df09836b&gt;         3187             3187         [vm]         (background)</span><br><span class="line">      MobileMail &lt;bff817c61ce33c85a43ea<span class="number">9a6c98c29</span>f5&gt;        14927            14927         [vm]         (continuous)</span><br><span class="line">       MobileSMS &lt;46778de<span class="number">076363d67</span>aeea207464cfc581&gt;         2134             2134         [vm]         (background)</span><br><span class="line">     MobilePhone &lt;3fca<span class="number">241f2a193d0</span>fb<span class="number">8264218d29</span>6ea41&gt;         2689             2689         [vm]         (continuous)</span><br><span class="line">      librariand &lt;c9a9be81aa<span class="number">9632f0a91</span>3ce<span class="number">79b911f27</span>e&gt;          317              317         [vm]         (daemon)</span><br><span class="line">             kbd &lt;3e7136ddcefc<span class="number">3d77a01499</span>db593466cd&gt;          616              616         [vm]         (daemon)</span><br><span class="line">            tccd &lt;eb5ddcf<span class="number">533663f8</span>d987d67cae6a4c4ea&gt;          224              224         [vm]         (daemon)</span><br><span class="line">    Rage Masters &lt;<span class="number">90b45d6281</span>e<span class="number">934209c5b06</span>cf7dc4d492&gt;        28591            28591         [vm]         (frontmost) (resume)</span><br><span class="line">            ptpd &lt;04a56fce<span class="number">67053c57a79</span>79aeea8e5a7ea&gt;          879              879                      (daemon)</span><br><span class="line">   iaptransportd &lt;f784f30dc<span class="number">09d32078d87</span>b<span class="number">450e8113</span>ef6&gt;          230              230                      (daemon)</span><br><span class="line">       locationd &lt;892cd1c9ffa43c99a82dba197be5f09e&gt;         1641             1641                      (daemon)</span><br><span class="line">         syslogd &lt;cbef142fa<span class="number">0a839f08</span>85afb693fb169c3&gt;          237              237                      (daemon)</span><br><span class="line">    mediaserverd &lt;<span class="number">80657170</span>daca<span class="number">32c9b8f3</span>a6b1faac43a2&gt;         4869             4869                      (daemon)</span><br><span class="line">     dataaccessd &lt;<span class="number">2a3f6a51</span><span class="number">8f3f3646</span>bf35eddd<span class="number">36f25005</span>&gt;         1786             1786                      (daemon)</span><br><span class="line">      aosnotifyd &lt;d<span class="number">4d14f2914</span>c<span class="number">3343796e44</span>7cfef3e6542&gt;          549              549                      (daemon)</span><br><span class="line">           wifid &lt;<span class="number">9472b09074</span><span class="number">6237998</span>cdbb<span class="number">9b34f090</span>d0c&gt;          455              455                      (daemon)</span><br><span class="line">     SpringBoard &lt;27372aae101f3bbc87804edc10314af3&gt;        18749            18749</span><br><span class="line">      backboardd &lt;<span class="number">5037235f29</span>5b33eda98eb<span class="number">5c72c09885</span>8&gt;         5801             5801                      (daemon)</span><br><span class="line">  UserEventAgent &lt;6edfd8d8dba<span class="number">23187b05772</span>dcdfc94f90&gt;          601              601                      (daemon)</span><br><span class="line">    mediaremoted &lt;4ff<span class="number">39c50c68430</span><span class="number">2492e396</span>ace813cb25&gt;          293              293                      (daemon)</span><br><span class="line">     pasteboardd &lt;<span class="number">8a4279b78</span>e<span class="number">4a321f84</span>a<span class="number">076a711</span>dc1c51&gt;          176              176                      (daemon)</span><br><span class="line">springboardservi &lt;ff<span class="number">6f64b3a21</span>a<span class="number">39c9a179332</span>1eefa5304&gt;            0                0                      (daemon)</span><br><span class="line">    syslog_relay &lt;<span class="number">45e9844605</span>d<span class="number">737a08368</span>b5215bb54426&gt;            0                0                      (daemon)</span><br><span class="line">      DTMobileIS &lt;23303ca402aa<span class="number">3705870b01</span>a<span class="number">9047854</span>ea&gt;            0                0                      (daemon)</span><br><span class="line">notification_pro &lt;845b7beebc8538ca9ceef<span class="number">731031983</span>b7&gt;          169              169                      (daemon)</span><br><span class="line">    syslog_relay &lt;<span class="number">45e9844605</span>d<span class="number">737a08368</span>b5215bb54426&gt;            0                0                      (daemon)</span><br><span class="line">             ubd &lt;74dc<span class="number">476d178530</span>0e9fcda555fcb8d774&gt;          976              976                      (daemon)</span><br><span class="line">        twitterd &lt;<span class="number">4b4946378</span>a<span class="number">9c397d82</span><span class="number">50965d17055</span>b8e&gt;          730              730                      (daemon)</span><br><span class="line">         configd &lt;<span class="number">4245d73a9</span>e<span class="number">96360399452</span>cf<span class="number">6b8671844</span>&gt;          809              809                      (daemon)</span><br><span class="line">   absinthed.N94 &lt;<span class="number">7f4164c84</span>4fa340caa<span class="number">940b863</span>c901aa9&gt;           99               99                      (daemon)</span><br><span class="line">filecoordination &lt;fbab<span class="number">576f37a63</span>b<span class="number">56a1039153</span>fc1aa7d8&gt;          226              226                      (daemon)</span><br><span class="line">       distnoted &lt;a89af76ec8633ac2bbe99bc2b7964bb0&gt;          137              137                      (daemon)</span><br><span class="line">            apsd &lt;94d8051dd<span class="number">5f5362f82</span>d775bc279ae608&gt;          373              373                      (daemon)</span><br><span class="line">        networkd &lt;<span class="number">0032f46009</span>f<span class="number">53a6c80973</span>fe<span class="number">153d1a588</span>&gt;          219              219                      (daemon)</span><br><span class="line">      aggregated &lt;<span class="number">8c3c991</span>dc4153bc38aee<span class="number">1e841864</span>d088&gt;          112              112                      (daemon)</span><br><span class="line">        BTServer &lt;c92fbd7488e63be99ec9dbd<span class="number">05824f5e5</span>&gt;          522              522                      (daemon)</span><br><span class="line">   fairplayd.N94 &lt;7bd896bd<span class="number">00783a48906</span>090d05cf1c86a&gt;          210              210                      (daemon)</span><br><span class="line">       fseventsd &lt;996cc4ca<span class="number">03793184</span>aea<span class="number">8d781b55</span>bce08&gt;          384              384                      (daemon)</span><br><span class="line">         imagent &lt;<span class="number">1e68080947</span>be352590ce<span class="number">96b7a1d07</span>b2f&gt;          586              586                      (daemon)</span><br><span class="line">   mDNSResponder &lt;<span class="number">3e557693</span>f<span class="number">3073697a58</span>da<span class="number">6d27a827</span>d97&gt;          295              295                      (daemon)</span><br><span class="line">       lockdownd &lt;ba<span class="number">1358c7a80</span>03f1b91af7d5f58dd5bbe&gt;          389              389                      (daemon)</span><br><span class="line">          powerd &lt;2d2ffed<span class="number">5e69638</span>aeba1b92ef124ed861&gt;          174              174                      (daemon)</span><br><span class="line">      CommCenter &lt;<span class="number">1f425e1</span>e<span class="number">897d32e88</span>64fdd8eeaa803a8&gt;         2212             2212                      (daemon)</span><br><span class="line">         notifyd &lt;51c0e03da8a93ac<span class="number">8a595442</span>fcaac531f&gt;          211              211                      (daemon)</span><br><span class="line">     ReportCrash &lt;<span class="number">8c32f231b2</span>ed360bb<span class="number">151b2563</span>bcaa363&gt;          337              337                      (daemon)</span><br></pre></td></tr></table></figure>
<p>这日志跟我们前面见到的相差很多。</p>
<p>这个一个来自iOS 6的低内存崩溃日志。正如我们前面所说的，低内存崩溃日志与其他类型的崩溃日志很不一样，它们不指向特定的文件和代码行。相反，它们画出了闪退时设备上的内存使用情况的图表。</p>
<p>至少，头部还是跟其他崩溃日志很像的:  提供了 <code>Incident Identifier</code>,<code>CrashReporter Key</code>, <code>Hardware Model</code>, <code>OS Version</code>等信息。 接下来部分是低内存崩溃日志特有的:</p>
<ul>
<li>Free pages 指可用内存页数。每页大小约是4KB, 上面的日志中，可用内存约为3,872 KB (或者说 3.9 MB)。</li>
<li>Purgeable pages 是那部分可被清除或重用的内存。在上面的日志中，是0KB。</li>
<li>Largest process是闪退时使用大部分内存的应用名称，在上面的日志中，正是你的应用!</li>
<li>Processes显示了闪退时各进程列表，还包含内存使用量。包含进程名 (第一列), 进程唯一标识符(第二名), 进程使用的内存页数(第三列)。最后一列是每个应用的状态。通常，发生闪退的应用的状态是 frontmost。 这里是 Rage Masters, 使用28591 页 (or 114.364 MB) 内存——这内存太多了!</li>
</ul>
<p>通过，最大进程和frontmost状态的应用是相同的， 而且也是引起低内存闪退的应用进程。但是也可能看到最大进程和 frontmost状态应用不同的例子。比如，如果最大进程是SpringBoard, 忽略它 , 因为 SpringBoard 进程是显示主屏幕的应用，出现在你双击home按钮等情况，而且它是一直活动的。</p>
<p>低内存发生时，iOS向活动的应用发出低内存警告并终止后台应用。如果前台应用仍然继续增长内存，iOS将终止它。 为了查找低内存问题的原因，你必需使用Instruments剖析应用。如果你不知道怎么做，可以看一下我们 一篇关于这个方面的教程.。 :] 另外, 你也可以走捷径，响应低内存警告通知，以解决部分闪退问题。</p>
<p>回到Xcode查看RMLollipopLicker.m文件。 这是实现吃棒棒糖的视图控制器。看看源代码:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"RMLollipopLicker.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#define COUNT 20</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RMLollipopLicker</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIProgressView</span> *progressView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UILabel</span> *label;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UILabel</span> *lickedTimeLabel;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RMLollipopLicker</span> </span>&#123;</span><br><span class="line">    <span class="built_in">NSOperationQueue</span> *queue;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *lollipops;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - Life cycle</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.progressView</span><span class="variable">.progress</span> = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.label</span><span class="variable">.text</span> = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Tap on run and I'll lick a lollipop %d times!"</span>, COUNT];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.lickedTimeLabel</span><span class="variable">.text</span> = <span class="string">@""</span>;</span><br><span class="line"></span><br><span class="line">    lollipops = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">    queue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)lickLollipop &#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *fileURL = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@"Lollipop"</span> withExtension:<span class="string">@"plist"</span>];</span><br><span class="line">    <span class="built_in">NSDictionary</span> *dictionary = [<span class="built_in">NSDictionary</span> dictionaryWithContentsOfURL:fileURL];</span><br><span class="line">    <span class="built_in">NSString</span> *lollipop = [dictionary objectForKey:<span class="string">@"Lollipop"</span>];</span><br><span class="line">    [lollipops addObject:lollipop];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - IBActions</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)doneButtonPressed:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)runButtonPressed:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line"></span><br><span class="line">    [sender setEnabled:<span class="literal">NO</span>];</span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span> ; i &lt;= COUNT ; i++) &#123;</span><br><span class="line">            [<span class="keyword">self</span> lickLollipop];</span><br><span class="line"></span><br><span class="line">            [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">self</span><span class="variable">.label</span><span class="variable">.text</span> = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Licked a strawberry lollipop %d time(s)!"</span>, i];</span><br><span class="line">                <span class="keyword">self</span><span class="variable">.lickedTimeLabel</span><span class="variable">.text</span> = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Licked the same lollipop %d time(s)!"</span>, lollipops<span class="variable">.count</span>-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">self</span><span class="variable">.progressView</span><span class="variable">.progress</span> = (<span class="keyword">float</span>)(i/COUNT);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i &gt;= COUNT) &#123;</span><br><span class="line">                    <span class="keyword">self</span><span class="variable">.label</span><span class="variable">.text</span> = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Tap on run and I'll lick a lollipop %d times!"</span>, COUNT];</span><br><span class="line">                    <span class="keyword">self</span><span class="variable">.progressView</span><span class="variable">.progress</span> = <span class="number">0.0</span>;</span><br><span class="line">                    [sender setEnabled:<span class="literal">YES</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>当用户点击运行按钮, 应用开始一个背景线程，调用 <code>lickLollipop</code> 方法若干次，然后更新界面反映吃棒棒糖的数量。<code>lickLollipop</code> 方法从属性列表文件(PLIST）文件读取一个长字符串，然后添加到数组上。这些数据并不重要, 能在不影响用户体验的前提下重新创建。 利用每种能够清除和重建数据而不影响用户体验的情况是好习惯。这样能够方便地释放内存，减少低内存警告。</p>
<p>那么，如何提高代码质量呢? 实现 <code>didReceiveMemoryWarning</code> 方法，像下面这样处理数据:</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span>(void)<span class="tag">didReceiveMemoryWarning</span> &#123;</span><br><span class="line"><span class="attr_selector">[lollipops removeAllObjects]</span>;</span><br><span class="line"><span class="attr_selector">[super didReceiveMemoryWarning]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>搞定!</p>
<h2 id="下一步?">下一步?</h2><p>万岁，你研究了4个闪退案例! 你的应用更完善了，并且学到了一些重要的调试技巧。 你可以到<a href="http://cdn5.raywenderlich.com/downloads/RageMasters-Improved.zip" target="_blank" rel="external">这里</a>下载改进后的项目代码。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://www.raywenderlich.com/23704/demystifying-ios-application-crash-logs">翻译自</a></p>
<h1 id="iOS应用崩溃日志揭秘1">iOS应用崩溃日志揭秘1</h1><p>作为一名应用开发者，你是否有过如下经历?</p>
<p>为确保你的应用正确无误，在将其提交到应用商店之前，你必定进行了大量的测试工作。它在你的设备上也运行得很好，但是，上了应用商店后，还是有用户抱怨会闪退 !</p>
<p>如果你跟我一样是个完美主义者，你肯定想将应用做到尽善尽美。于是你打开代码准备修复闪退的问题……但是，从何处着手呢？ 这时iOS崩溃日志派上用场了。在大多数情况下，你能从中了解到关于闪退的详尽、有用的信息。</p>
<p>通过本教程，你将学习到一些常见的崩溃日志案例，以及如何从开发设备和iTunes Connect上获取崩溃日志文件。你还将学习到符号化（ symbolication）,从日志追踪到代码 。你还将学习调试一个在待定情况下会闪退的应用。</p>
<p>让我们开始动手吧!</p>
<h2 id="什么是崩溃日志，从哪里能得它?">什么是崩溃日志，从哪里能得它?</h2><p>iOS设备上的应用闪退时，操作系统会生成一个崩溃报告，也叫崩溃日志，保存在设备上。 崩溃日志上有很多有用的信息，包括应用是什么情况下闪退的。通常，上面有每个正在执行线程的完整堆栈跟踪信息，所以你能从中了解到闪退发生时各线程都在做什么，并分辨出闪退发生在哪个线程上。</p>
<p>有几种方法可以从设备上获取崩溃日志。 设备与电脑上的iTunes Store同步后，会将崩溃日志保存在电脑上。根据电脑操作系统的不同，崩溃日志将保存在以下位置:</p>
<p>Mac OS X:</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="regexp">/Library/</span>Logs<span class="regexp">/CrashReporter/M</span>obileDevice<span class="regexp">/</span></span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="IOS" scheme="http://ytlvy.com/tags/IOS/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS property attribute]]></title>
    <link href="http://ytlvy.com/2015/07/13/iOS-property-attribute/"/>
    <id>http://ytlvy.com/2015/07/13/iOS-property-attribute/</id>
    <published>2015-07-13T13:36:06.000Z</published>
    <updated>2015-07-19T09:18:32.000Z</updated>
    <content type="html"><![CDATA[<h2 id="iOS_property_&amp;&amp;_ivar_&amp;&amp;_local_variable">iOS property &amp;&amp; ivar &amp;&amp; local variable</h2><h3 id="default_attributes">default attributes</h3><ol>
<li>property: atomic assign readwrite</li>
<li>ivar &amp;&amp; local varibal: strong readwrite non-atomic</li>
</ol>
<blockquote>
<p>atomic 在实现中通过加入 lock 的方式来保证多线程安全, 但是这只是很简单的一种线程安全, 只局限于此属性的读写.实际应用场景中, 业务的原子性, 是需要自己来实现的.</p>
</blockquote>
<h3 id="when_to_use_copy">when to use copy</h3><ol>
<li>NSStrings: 为了防止其他地方修改</li>
<li>block: 防止自动释放</li>
<li>可变数据类型, 当你想阻止其他拥有者变更数据时.</li>
</ol>
<h3 id="尽量使用_copy_关键字">尽量使用 copy 关键字</h3><p>任何实现了<code>NSCopying</code>协议的类型, 都应该尽量采用<code>copy</code>. 因为我们定义的属性,在使用时可能是用一个可变的子属性来赋值的, 例如<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Book</span> : <span class="title">NSObject</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *title;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)stringExample &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">NSMutableString</span> *bookTitle = [<span class="built_in">NSMutableString</span> stringWithString:<span class="string">@"Best book ever"</span>];</span><br><span class="line"> </span><br><span class="line">    Book *book = [[Book alloc] init];</span><br><span class="line">    book<span class="variable">.title</span> = bookTitle;</span><br><span class="line"> </span><br><span class="line">    [bookTitle setString:<span class="string">@"Worst book ever"</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"book title %@"</span>, book<span class="variable">.title</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="@dynamic">@dynamic</h3><p>@synthesize 会自动生成 getter setter方法, @dynamic 只是告诉编译器 getter setter方法 已经定义, 但是不在当前类中(比如在父类中, 或者由 runtime 动态生成).</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">property</span> (nonatomic, retain) NSButton *someButton</span>;</span><br><span class="line">...</span><br><span class="line"><span class="at_rule">@<span class="keyword">synthesize</span> someButton</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, retain) <span class="keyword">IBOutlet</span> <span class="built_in">NSButton</span> *someButton;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">@dynamic</span> someButton;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="iOS_property_&amp;&amp;_ivar_&amp;&amp;_local_variable">iOS property &amp;&amp; ivar &amp;&amp; local variable</h2><h3 id="default_attributes">default attributes</h3><ol>
<li>property: atomic assign readwrite</li>
<li>ivar &amp;&amp; local varibal: strong readwrite non-atomic</li>
</ol>
<blockquote>
<p>atomic 在实现中通过加入 lock 的方式来保证多线程安全, 但是这只是很简单的一种线程安全, 只局限于此属性的读写.实际应用场景中, 业务的原子性, 是需要自己来实现的.</p>
</blockquote>
<h3 id="when_to_use_copy">when to use copy</h3><ol>
<li>NSStrings: 为了防止其他地方修改</li>
<li>block: 防止自动释放</li>
<li>可变数据类型, 当你想阻止其他拥有者变更数据时.</li>
</ol>
<h3 id="尽量使用_copy_关键字">尽量使用 copy 关键字</h3><p>任何实现了<code>NSCopying</code>协议的类型, 都应该尽量采用<code>copy</code>. 因为我们定义的属性,在使用时可能是用一个可变的子属性来赋值的, 例如<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Book</span> : <span class="title">NSObject</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *title;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)stringExample &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">NSMutableString</span> *bookTitle = [<span class="built_in">NSMutableString</span> stringWithString:<span class="string">@"Best book ever"</span>];</span><br><span class="line"> </span><br><span class="line">    Book *book = [[Book alloc] init];</span><br><span class="line">    book<span class="variable">.title</span> = bookTitle;</span><br><span class="line"> </span><br><span class="line">    [bookTitle setString:<span class="string">@"Worst book ever"</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"book title %@"</span>, book<span class="variable">.title</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="iOS" scheme="http://ytlvy.com/tags/iOS/"/>
    
      <category term="property" scheme="http://ytlvy.com/tags/property/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[NSRunLoop深入理解]]></title>
    <link href="http://ytlvy.com/2015/07/13/NSRunLoop%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    <id>http://ytlvy.com/2015/07/13/NSRunLoop深入理解/</id>
    <published>2015-07-13T13:34:28.000Z</published>
    <updated>2015-07-19T09:18:32.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://www.cocoachina.com/ios/20150601/11970.html" target="_blank" rel="external">转自</a></p>
<h2 id="RunLoop">RunLoop</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;RunLoop 是 iOS 和 OS X 开发中非常基础的一个概念，这篇文章将从 CFRunLoop 的源码入手，介绍 RunLoop 的概念以及底层实现原理。之后会介绍一下在 iOS 中，苹果是如何利用 RunLoop 实现自动释放池、延迟回调、触摸事件、屏幕刷新等功能的。</p>
<h3 id="RunLoop_的概念">RunLoop 的概念</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span><span class="params">()</span> &#123;</span></span><br><span class="line">    initialize<span class="params">()</span>;</span><br><span class="line">    do &#123;</span><br><span class="line">        var message = get_next_message<span class="params">()</span>;</span><br><span class="line">        process_message<span class="params">(message)</span>;</span><br><span class="line">    &#125; while <span class="params">(message != quit)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这种模型通常被称作 Event Loop。 Event Loop 在很多系统和框架里都有实现，比如 Node.js 的事件处理，比如 Windows 程序的消息循环，再比如 OSX/iOS 里的 RunLoop。实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。<br><a id="more"></a><br>&nbsp;&nbsp;&nbsp;&nbsp;OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;CFRunLoopRef 的代码是开源的，你可以在这里 <a href="http://opensource.apple.com/tarballs/CF/CF-855.17.tar.gz" target="_blank" rel="external">http://opensource.apple.com/tarballs/CF/CF-855.17.tar.gz</a> 下载到整个 CoreFoundation 的源码。为了方便跟踪和查看，你可以新建一个 Xcode 工程，把这堆源码拖进去看。</p>
<h3 id="RunLoop_与线程的关系">RunLoop 与线程的关系</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;首先，iOS 开发中能遇到两个线程对象: <code>pthread_t</code> 和 <code>NSThread</code>。过去苹果有份文档标明了<code>NSThread</code> 只是 <code>pthread_t</code> 的封装，但那份文档已经失效了，现在它们也有可能都是直接包装自最底层的 <code>mach thread</code>。苹果并没有提供这两个对象相互转换的接口，但不管怎么样，可以肯定的是 <code>pthread_t</code> 和 <code>NSThread</code> 是一一对应的。比如，你可以通过 <code>pthread_main_np()</code> 或 <code>[NSThread mainThread]</code> 来获取主线程；也可以通过 <code>pthread_self()</code> 或 <code>[NSThread currentThread]</code> 来获取当前线程。<code>CFRunLoop</code> 是基于 <code>pthread</code> 来管理的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：<code>CFRunLoopGetMain()</code> 和 <code>CFRunLoopGetCurrent()</code>。 这两个函数内部的逻辑大概是下面这样:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CFMutableDictionaryRef</span> loopsDic;</span><br><span class="line"><span class="comment">/// 访问 loopsDic 时的锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CFSpinLock_t</span> loopsLock;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/// 获取一个 pthread 对应的 RunLoop。</span></span><br><span class="line"><span class="built_in">CFRunLoopRef</span> _<span class="built_in">CFRunLoopGet</span>(pthread_t thread) &#123;</span><br><span class="line">    OSSpinLockLock(&amp;loopsLock);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (!loopsDic) &#123;</span><br><span class="line">        <span class="comment">// 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。</span></span><br><span class="line">        loopsDic = <span class="built_in">CFDictionaryCreateMutable</span>();</span><br><span class="line">        <span class="built_in">CFRunLoopRef</span> mainLoop = _<span class="built_in">CFRunLoopCreate</span>();</span><br><span class="line">        <span class="built_in">CFDictionarySetValue</span>(loopsDic, pthread_main_thread_np(), mainLoop);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/// 直接从 Dictionary 里获取。</span></span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> loop = <span class="built_in">CFDictionaryGetValue</span>(loopsDic, thread));</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line">        <span class="comment">/// 取不到时，创建一个</span></span><br><span class="line">        loop = _<span class="built_in">CFRunLoopCreate</span>();</span><br><span class="line">        <span class="built_in">CFDictionarySetValue</span>(loopsDic, thread, loop);</span><br><span class="line">        <span class="comment">/// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。</span></span><br><span class="line">        _<span class="built_in">CFSetTSD</span>(..., thread, loop, __<span class="built_in">CFFinalizeRunLoop</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    OSSpinLockUnLock(&amp;loopsLock);</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetMain</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> _<span class="built_in">CFRunLoopGet</span>(pthread_main_thread_np());</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetCurrent</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> _<span class="built_in">CFRunLoopGet</span>(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;从上面的代码可以看出，线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）</p>
<h3 id="RunLoop_对外的接口">RunLoop 对外的接口</h3><p>在 CoreFoundation 里面关于 RunLoop 有5个类:</p>
<ul>
<li>CFRunLoopRef</li>
<li>CFRunLoopModeRef</li>
<li>CFRunLoopSourceRef</li>
<li>CFRunLoopTimerRef</li>
<li>CFRunLoopObserverRef</li>
</ul>
<p>其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:<br><img src="http://cc.cocimg.com/api/uploads/20150528/1432798883604537.png" alt=""><br>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p>
<p><code>CFRunLoopSourceRef</code> 是事件产生的地方。Source有两个版本：Source0 和 Source1。</p>
<ul>
<li>Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</li>
<li>Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。</li>
</ul>
<p><code>CFRunLoopTimerRef</code> 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</p>
<p><code>CFRunLoopObserverRef</code> 是观察者，每个 Observer 都包含了一个回调（函数指针），当 <code>RunLoop</code>的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_OPTIONS</span>(<span class="built_in">CFOptionFlags</span>, <span class="built_in">CFRunLoopActivity</span>) &#123;</span><br><span class="line">    k<span class="built_in">CFRunLoopEntry</span>         = (<span class="number">1</span>UL &lt;&lt; <span class="number">0</span>), <span class="comment">// 即将进入Loop</span></span><br><span class="line">    k<span class="built_in">CFRunLoopBeforeTimers</span>  = (<span class="number">1</span>UL &lt;&lt; <span class="number">1</span>), <span class="comment">// 即将处理 Timer</span></span><br><span class="line">    k<span class="built_in">CFRunLoopBeforeSources</span> = (<span class="number">1</span>UL &lt;&lt; <span class="number">2</span>), <span class="comment">// 即将处理 Source</span></span><br><span class="line">    k<span class="built_in">CFRunLoopBeforeWaiting</span> = (<span class="number">1</span>UL &lt;&lt; <span class="number">5</span>), <span class="comment">// 即将进入休眠</span></span><br><span class="line">    k<span class="built_in">CFRunLoopAfterWaiting</span>  = (<span class="number">1</span>UL &lt;&lt; <span class="number">6</span>), <span class="comment">// 刚从休眠中唤醒</span></span><br><span class="line">    k<span class="built_in">CFRunLoopExit</span>          = (<span class="number">1</span>UL &lt;&lt; <span class="number">7</span>), <span class="comment">// 即将退出Loop</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面的 Source/Timer/Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。</p>
<h3 id="RunLoop_的_Mode">RunLoop 的 Mode</h3><p>CFRunLoopMode 和 CFRunLoop 的结构大致如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __<span class="built_in">CFRunLoopMode</span> &#123;</span><br><span class="line">    <span class="built_in">CFStringRef</span> _name;            <span class="comment">// Mode Name, 例如 @"kCFRunLoopDefaultMode"</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources0;    <span class="comment">// Set</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources1;    <span class="comment">// Set</span></span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _observers; <span class="comment">// Array</span></span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _timers;    <span class="comment">// Array</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">struct</span> __<span class="built_in">CFRunLoop</span> &#123;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModes;     <span class="comment">// Set</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModeItems; <span class="comment">// Set</span></span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> _currentMode;    <span class="comment">// Current Runloop Mode</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _modes;           <span class="comment">// Set</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里有个概念叫 “CommonModes”：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。</p>
<p>应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。</p>
<p>有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。</p>
<p>CFRunLoop对外暴露的管理 Mode 接口只有下面2个:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopAddCommonMode</span>(<span class="built_in">CFRunLoopRef</span> runloop, <span class="built_in">CFStringRef</span> modeName);</span><br><span class="line"><span class="built_in">CFRunLoopRunInMode</span>(<span class="built_in">CFStringRef</span> modeName, ...);</span><br></pre></td></tr></table></figure></p>
<p>Mode 暴露的管理 mode item 的接口有下面几个：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopAddSource</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopSourceRef</span> source, <span class="built_in">CFStringRef</span> modeName);</span><br><span class="line"><span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFStringRef</span> modeName);</span><br><span class="line"><span class="built_in">CFRunLoopAddTimer</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopTimerRef</span> timer, <span class="built_in">CFStringRef</span> mode);</span><br><span class="line"><span class="built_in">CFRunLoopRemoveSource</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopSourceRef</span> source, <span class="built_in">CFStringRef</span> modeName);</span><br><span class="line"><span class="built_in">CFRunLoopRemoveObserver</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFStringRef</span> modeName);</span><br><span class="line"><span class="built_in">CFRunLoopRemoveTimer</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopTimerRef</span> timer, <span class="built_in">CFStringRef</span> mode);</span><br></pre></td></tr></table></figure></p>
<p>你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。</p>
<p>苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。</p>
<p>同时苹果还提供了一个操作 Common 标记的字符串：kCFRunLoopCommonModes (NSRunLoopCommonModes)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 mode name。</p>
<h3 id="RunLoop_的内部逻辑">RunLoop 的内部逻辑</h3><p>根据苹果在文档里的说明，RunLoop 内部的逻辑大致如下:<br><img src="http://cc.cocimg.com/api/uploads/20150528/1432798974517485.png" alt=""><br>其内部代码整理如下 （太长了不想看可以直接跳过去，后面会有说明）：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 用DefaultMode启动</span></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">CFRunLoopRun</span>(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), k<span class="built_in">CFRunLoopDefaultMode</span>, <span class="number">1.0e10</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/// 用指定的Mode启动，允许设置RunLoop超时时间</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">CFRunLoopRunInMode</span>(<span class="built_in">CFStringRef</span> modeName, <span class="built_in">CFTimeInterval</span> seconds, Boolean stopAfterHandle) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/// RunLoop的实现</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">CFRunLoopRunSpecific</span>(runloop, modeName, seconds, stopAfterHandle) &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/// 首先根据modeName找到对应mode</span></span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> currentMode = __<span class="built_in">CFRunLoopFindMode</span>(runloop, modeName, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">/// 如果mode里没有source/timer/observer, 直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (__<span class="built_in">CFRunLoopModeIsEmpty</span>(currentMode)) <span class="keyword">return</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/// 1. 通知 Observers: RunLoop 即将进入 loop。</span></span><br><span class="line">    __<span class="built_in">CFRunLoopDoObservers</span>(runloop, currentMode, k<span class="built_in">CFRunLoopEntry</span>);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/// 内部函数，进入loop</span></span><br><span class="line">    __<span class="built_in">CFRunLoopRun</span>(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</span><br><span class="line">         </span><br><span class="line">        Boolean sourceHandledThisLoop = <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">int</span> retVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">  </span><br><span class="line">            <span class="comment">/// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span></span><br><span class="line">            __<span class="built_in">CFRunLoopDoObservers</span>(runloop, currentMode, k<span class="built_in">CFRunLoopBeforeTimers</span>);</span><br><span class="line">            <span class="comment">/// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span></span><br><span class="line">            __<span class="built_in">CFRunLoopDoObservers</span>(runloop, currentMode, k<span class="built_in">CFRunLoopBeforeSources</span>);</span><br><span class="line">            <span class="comment">/// 执行被加入的block</span></span><br><span class="line">            __<span class="built_in">CFRunLoopDoBlocks</span>(runloop, currentMode);</span><br><span class="line">             </span><br><span class="line">            <span class="comment">/// 4. RunLoop 触发 Source0 (非port) 回调。</span></span><br><span class="line">            sourceHandledThisLoop = __<span class="built_in">CFRunLoopDoSources0</span>(runloop, currentMode, stopAfterHandle);</span><br><span class="line">            <span class="comment">/// 执行被加入的block</span></span><br><span class="line">            __<span class="built_in">CFRunLoopDoBlocks</span>(runloop, currentMode);</span><br><span class="line">  </span><br><span class="line">            <span class="comment">/// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span></span><br><span class="line">            <span class="keyword">if</span> (__Source0DidDispatchPortLastTime) &#123;</span><br><span class="line">                Boolean hasMsg = __<span class="built_in">CFRunLoopServiceMachPort</span>(dispatchPort, &amp;msg)</span><br><span class="line">                <span class="keyword">if</span> (hasMsg) <span class="keyword">goto</span> handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">/// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span></span><br><span class="line">            <span class="keyword">if</span> (!sourceHandledThisLoop) &#123;</span><br><span class="line">                __<span class="built_in">CFRunLoopDoObservers</span>(runloop, currentMode, k<span class="built_in">CFRunLoopBeforeWaiting</span>);</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">/// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span></span><br><span class="line">            <span class="comment">/// ? 一个基于 port 的Source 的事件。</span></span><br><span class="line">            <span class="comment">/// ? 一个 Timer 到时间了</span></span><br><span class="line">            <span class="comment">/// ? RunLoop 自身的超时时间到了</span></span><br><span class="line">            <span class="comment">/// ? 被其他什么调用者手动唤醒</span></span><br><span class="line">            __<span class="built_in">CFRunLoopServiceMachPort</span>(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort) &#123;</span><br><span class="line">                mach_msg(msg, MACH_RCV_MSG, port); <span class="comment">// thread wait for receive msg</span></span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">            <span class="comment">/// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span></span><br><span class="line">            __<span class="built_in">CFRunLoopDoObservers</span>(runloop, currentMode, k<span class="built_in">CFRunLoopAfterWaiting</span>);</span><br><span class="line">             </span><br><span class="line">            <span class="comment">/// 收到消息，处理消息。</span></span><br><span class="line">            handle_msg:</span><br><span class="line">  </span><br><span class="line">            <span class="comment">/// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span></span><br><span class="line">            <span class="keyword">if</span> (msg_is_timer) &#123;</span><br><span class="line">                __<span class="built_in">CFRunLoopDoTimers</span>(runloop, currentMode, mach_absolute_time())</span><br><span class="line">            &#125; </span><br><span class="line">  </span><br><span class="line">            <span class="comment">/// 9.2 如果有dispatch到main_queue的block，执行block。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (msg_is_dispatch) &#123;</span><br><span class="line">                __<span class="built_in">CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</span>(msg);</span><br><span class="line">            &#125; </span><br><span class="line">  </span><br><span class="line">            <span class="comment">/// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">CFRunLoopSourceRef</span> source1 = __<span class="built_in">CFRunLoopModeFindSourceForMachPort</span>(runloop, currentMode, livePort);</span><br><span class="line">                sourceHandledThisLoop = __<span class="built_in">CFRunLoopDoSource1</span>(runloop, currentMode, source1, msg);</span><br><span class="line">                <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">                    mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">/// 执行加入到Loop的block</span></span><br><span class="line">            __<span class="built_in">CFRunLoopDoBlocks</span>(runloop, currentMode);</span><br><span class="line">             </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">                <span class="comment">/// 进入loop时参数说处理完事件就返回。</span></span><br><span class="line">                retVal = k<span class="built_in">CFRunLoopRunHandledSource</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">                <span class="comment">/// 超出传入参数标记的超时时间了</span></span><br><span class="line">                retVal = k<span class="built_in">CFRunLoopRunTimedOut</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__<span class="built_in">CFRunLoopIsStopped</span>(runloop)) &#123;</span><br><span class="line">                <span class="comment">/// 被外部调用者强制停止了</span></span><br><span class="line">                retVal = k<span class="built_in">CFRunLoopRunStopped</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__<span class="built_in">CFRunLoopModeIsEmpty</span>(runloop, currentMode)) &#123;</span><br><span class="line">                <span class="comment">/// source/timer/observer一个都没有了</span></span><br><span class="line">                retVal = k<span class="built_in">CFRunLoopRunFinished</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">/// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (retVal == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/// 10. 通知 Observers: RunLoop 即将退出。</span></span><br><span class="line">    __<span class="built_in">CFRunLoopDoObservers</span>(rl, currentMode, k<span class="built_in">CFRunLoopExit</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。</p>
<h3 id="RunLoop_的底层实现">RunLoop 的底层实现</h3><p>从上面代码可以看到，RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach_msg()。为了解释这个逻辑，下面稍微介绍一下 OSX/iOS 的系统架构。<br><img src="http://cc.cocimg.com/api/uploads/20150528/1432799001829463.png" alt=""></p>
<p>苹果官方将整个系统大致划分为上述4个层次：</p>
<ol>
<li>应用层包括用户能接触到的图形应用，例如 Spotlight、Aqua、SpringBoard 等。</li>
<li>应用框架层即开发人员接触到的 Cocoa 等框架。</li>
<li>核心框架层包括各种核心框架、OpenGL 等内容。</li>
<li>Darwin 即操作系统的核心，包括系统内核、驱动、Shell 等内容，这一层是开源的，其所有源码都可以在 opensource.apple.com 里找到。</li>
</ol>
<p>我们在深入看一下 Darwin 这个核心的架构：<br><img src="http://cc.cocimg.com/api/uploads/20150528/1432799031419231.png" alt=""></p>
<p>其中，在硬件层上面的三个组成部分：Mach、BSD、IOKit (还包括一些上面没标注的内容)，共同组成了 XNU 内核。</p>
<p>XNU 内核的内环被称作 Mach，其作为一个微内核，仅提供了诸如处理器调度、IPC (进程间通信)等非常少量的基础服务。</p>
<p>BSD 层可以看作围绕 Mach 层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。</p>
<p>IOKit 层是为设备驱动提供了一个面向对象(C++)的一个框架。</p>
<p>Mach 本身提供的 API 非常有限，而且苹果也不鼓励使用 Mach 的 API，但是这些API非常基础，如果没有这些API的话，其他任何工作都无法实施。在 Mach 中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为”对象”。和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。”消息”是 Mach 中最基础的概念，消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。</p>
<p>Mach 的消息定义是在头文件的，很简单：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="keyword">mach_msg_header_t</span> header;</span><br><span class="line">  <span class="keyword">mach_msg_body_t</span> body;</span><br><span class="line">&#125; <span class="keyword">mach_msg_base_t</span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="keyword">mach_msg_bits_t</span> msgh_bits;</span><br><span class="line">  <span class="keyword">mach_msg_size_t</span> msgh_size;</span><br><span class="line">  <span class="keyword">mach_port_t</span> msgh_remote_port;</span><br><span class="line">  <span class="keyword">mach_port_t</span> msgh_local_port;</span><br><span class="line">  <span class="keyword">mach_port_name_t</span> msgh_voucher_port;</span><br><span class="line">  <span class="keyword">mach_msg_id_t</span> msgh_id;</span><br><span class="line">&#125; <span class="keyword">mach_msg_header_t</span>;</span><br></pre></td></tr></table></figure></p>
<p>一条 Mach 消息实际上就是一个二进制数据包 (BLOB)，其头部定义了当前端口 local_port 和目标端口 remote_port，</p>
<p>发送和接受消息是通过同一个 API 进行的，其 option 标记了消息传递的方向：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mach_msg_return_t</span> mach_msg(</span><br><span class="line"><span class="keyword">mach_msg_header_t</span> *msg,</span><br><span class="line"><span class="keyword">mach_msg_option_t</span> option,</span><br><span class="line"><span class="keyword">mach_msg_size_t</span> send_size,</span><br><span class="line"><span class="keyword">mach_msg_size_t</span> rcv_size,</span><br><span class="line"><span class="keyword">mach_port_name_t</span> rcv_name,</span><br><span class="line"><span class="keyword">mach_msg_timeout_t</span> timeout,</span><br><span class="line"><span class="keyword">mach_port_name_t</span> notify);</span><br></pre></td></tr></table></figure></p>
<p>为了实现消息的发送和接收，mach_msg() 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数mach_msg_trap()，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作，如下图：<br><img src="http://cc.cocimg.com/api/uploads/20150528/1432799057446598.png" alt=""></p>
<p>这些概念可以参考维基百科: System<em>call、Trap</em>(computing)。</p>
<p>RunLoop 的核心就是一个 mach_msg() (见上面代码的第7步)，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 mach_msg_trap() 这个地方。</p>
<p>关于具体的如何利用 mach port 发送信息，可以看看 <a href="http://nshipster.com/inter-process-communication/" target="_blank" rel="external">NSHipster 这一篇文章</a>，或者这里的中文翻译 。</p>
<p>关于Mach的历史可以看看这篇很有趣的文章：<a href="http://www.programmer.com.cn/8121/" target="_blank" rel="external">Mac OS X 背后的故事（三）Mach 之父 Avie Tevanian</a>。</p>
<h3 id="苹果用_RunLoop_实现的功能">苹果用 RunLoop 实现的功能</h3><p>首先我们可以看一下 App 启动后 RunLoop 的状态：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoop &#123;</span><br><span class="line">    current <span class="variable">mode =</span> kCFRunLoopDefaultMode</span><br><span class="line">    common <span class="variable">modes =</span> &#123;</span><br><span class="line">        UITrackingRunLoopMode</span><br><span class="line">        kCFRunLoopDefaultMode</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    common mode <span class="variable">items =</span> &#123;</span><br><span class="line">  </span><br><span class="line">        // source0 (manual)</span><br><span class="line">        CFRunLoopSource &#123;<span class="variable">order =</span>-<span class="number">1</span>, &#123;</span><br><span class="line">            <span class="variable">callout =</span> _UIApplicationHandleEventQueue&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;<span class="variable">order =</span>-<span class="number">1</span>, &#123;</span><br><span class="line">            <span class="variable">callout =</span> PurpleEventSignalCallback &#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;<span class="variable">order =</span> <span class="number">0</span>, &#123;</span><br><span class="line">            <span class="variable">callout =</span> FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line">  </span><br><span class="line">        // source1 (mach port)</span><br><span class="line">        CFRunLoopSource &#123;<span class="variable">order =</span> <span class="number">0</span>,  &#123;<span class="variable">port =</span> <span class="number">17923</span>&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;<span class="variable">order =</span> <span class="number">0</span>,  &#123;<span class="variable">port =</span> <span class="number">12039</span>&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;<span class="variable">order =</span> <span class="number">0</span>,  &#123;<span class="variable">port =</span> <span class="number">16647</span>&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;<span class="variable">order =</span>-<span class="number">1</span>, &#123;</span><br><span class="line">            <span class="variable">callout =</span> PurpleEventCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;<span class="variable">order =</span> <span class="number">0</span>, &#123;<span class="variable">port =</span> <span class="number">2407</span>,</span><br><span class="line">            <span class="variable">callout =</span> _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;<span class="variable">order =</span> <span class="number">0</span>, &#123;<span class="variable">port =</span> <span class="number">1</span>c03,</span><br><span class="line">            <span class="variable">callout =</span> __IOHIDEventSystemClientAvailabilityCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;<span class="variable">order =</span> <span class="number">0</span>, &#123;<span class="variable">port =</span> <span class="number">1</span>b03,</span><br><span class="line">            <span class="variable">callout =</span> __IOHIDEventSystemClientQueueCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;<span class="variable">order =</span> <span class="number">1</span>, &#123;<span class="variable">port =</span> <span class="number">1903</span>,</span><br><span class="line">            <span class="variable">callout =</span> __IOMIGMachPortPortCallback&#125;&#125;</span><br><span class="line">  </span><br><span class="line">        // Ovserver</span><br><span class="line">        CFRunLoopObserver &#123;<span class="variable">order =</span> -<span class="number">2147483647</span>, <span class="variable">activities =</span> <span class="number">0</span>x1, // Entry</span><br><span class="line">            <span class="variable">callout =</span> _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line">        CFRunLoopObserver &#123;<span class="variable">order =</span> <span class="number">0</span>, <span class="variable">activities =</span> <span class="number">0</span>x20,          // BeforeWaiting</span><br><span class="line">            <span class="variable">callout =</span> _UIGestureRecognizerUpdateObserver&#125;</span><br><span class="line">        CFRunLoopObserver &#123;<span class="variable">order =</span> <span class="number">1999000</span>, <span class="variable">activities =</span> <span class="number">0</span>xa0,    // BeforeWaiting | Exit</span><br><span class="line">            <span class="variable">callout =</span> _afterCACommitHandler&#125;</span><br><span class="line">        CFRunLoopObserver &#123;<span class="variable">order =</span> <span class="number">2000000</span>, <span class="variable">activities =</span> <span class="number">0</span>xa0,    // BeforeWaiting | Exit</span><br><span class="line">            <span class="variable">callout =</span> _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class="line">        CFRunLoopObserver &#123;<span class="variable">order =</span> <span class="number">2147483647</span>, <span class="variable">activities =</span> <span class="number">0</span>xa0, // BeforeWaiting | Exit</span><br><span class="line">            <span class="variable">callout =</span> _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line">  </span><br><span class="line">        // Timer</span><br><span class="line">        CFRunLoopTimer &#123;<span class="variable">firing =</span> No, <span class="variable">interval =</span> <span class="number">3.1536</span>e+<span class="number">09</span>, <span class="variable">tolerance =</span> <span class="number">0</span>,</span><br><span class="line">            next fire <span class="variable">date =</span> <span class="number">453098071</span> (-<span class="number">4421.76019</span> @ <span class="number">96223387169499</span>),</span><br><span class="line">            <span class="variable">callout =</span> _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  </span><br><span class="line">    modes ＝ &#123;</span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            <span class="variable">sources0 =</span>  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">            <span class="variable">sources1 =</span>  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">            <span class="variable">observers =</span> &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">            <span class="variable">timers =</span>    &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">  </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            <span class="variable">sources0 =</span>  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">            <span class="variable">sources1 =</span>  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">            <span class="variable">observers =</span> &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">            <span class="variable">timers =</span>    &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">  </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            <span class="variable">sources0 =</span> &#123;</span><br><span class="line">                CFRunLoopSource &#123;<span class="variable">order =</span> <span class="number">0</span>, &#123;</span><br><span class="line">                    <span class="variable">callout =</span> FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="variable">sources1 =</span> (<span class="constant">null</span>),</span><br><span class="line">            <span class="variable">observers =</span> &#123;</span><br><span class="line">                CFRunLoopObserver &gt;&#123;<span class="variable">activities =</span> <span class="number">0</span>xa0, <span class="variable">order =</span> <span class="number">2000000</span>,</span><br><span class="line">                    <span class="variable">callout =</span> _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class="line">            )&#125;,</span><br><span class="line">            <span class="variable">timers =</span> (<span class="constant">null</span>),</span><br><span class="line">        &#125;,</span><br><span class="line">  </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            <span class="variable">sources0 =</span> &#123;</span><br><span class="line">                CFRunLoopSource &#123;<span class="variable">order =</span> -<span class="number">1</span>, &#123;</span><br><span class="line">                    <span class="variable">callout =</span> PurpleEventSignalCallback&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="variable">sources1 =</span> &#123;</span><br><span class="line">                CFRunLoopSource &#123;<span class="variable">order =</span> -<span class="number">1</span>, &#123;</span><br><span class="line">                    <span class="variable">callout =</span> PurpleEventCallback&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="variable">observers =</span> (<span class="constant">null</span>),</span><br><span class="line">            <span class="variable">timers =</span> (<span class="constant">null</span>),</span><br><span class="line">        &#125;,</span><br><span class="line">         </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            <span class="variable">sources0 =</span> (<span class="constant">null</span>),</span><br><span class="line">            <span class="variable">sources1 =</span> (<span class="constant">null</span>),</span><br><span class="line">            <span class="variable">observers =</span> (<span class="constant">null</span>),</span><br><span class="line">            <span class="variable">timers =</span> (<span class="constant">null</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，系统默认注册了5个Mode:</p>
<ol>
<li><p>kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。</p>
</li>
<li><p>UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</p>
</li>
<li><p>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。</p>
</li>
</ol>
<p>4: GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。</p>
<p>5: kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。</p>
<p>你可以在<a href="http://iphonedevwiki.net/index.php/CFRunLoop" target="_blank" rel="external">这里</a>看到更多的苹果内部的 Mode，但那些 Mode 在开发中就很难遇到了。</p>
<p>当 RunLoop 进行回调时，一般都是通过一个很长的函数调用出去 (call out), 当你在你的代码中下断点调试时，通常能在调用栈上看到这些函数。下面是这几个函数的整理版本，如果你在调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">&#123;</span><br><span class="line">    /// <span class="number">1</span>. 通知Observers，即将进入RunLoop</span><br><span class="line">    /// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush<span class="list">()</span><span class="comment">;</span></span><br><span class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__<span class="list">(<span class="keyword">kCFRunLoopEntry</span>)</span><span class="comment">;</span></span><br><span class="line">    do <span class="collection">&#123;</span><br><span class="line">  </span><br><span class="line">        /// <span class="number">2</span>. 通知 Observers: 即将触发 Timer 回调。</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__<span class="list">(<span class="keyword">kCFRunLoopBeforeTimers</span>)</span><span class="comment">;</span></span><br><span class="line">        /// <span class="number">3</span>. 通知 Observers: 即将触发 Source <span class="list">(非基于port的,Source0)</span> 回调。</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__<span class="list">(<span class="keyword">kCFRunLoopBeforeSources</span>)</span><span class="comment">;</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__<span class="list">(<span class="keyword">block</span>)</span><span class="comment">;</span></span><br><span class="line">  </span><br><span class="line">        /// <span class="number">4</span>. 触发 Source0 <span class="list">(非基于port的)</span> 回调。</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__<span class="list">(<span class="keyword">source0</span>)</span><span class="comment">;</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__<span class="list">(<span class="keyword">block</span>)</span><span class="comment">;</span></span><br><span class="line">  </span><br><span class="line">        /// <span class="number">6</span>. 通知Observers，即将进入休眠</span><br><span class="line">        /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop<span class="list">()</span><span class="comment">; _objc_autoreleasePoolPush();</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__<span class="list">(<span class="keyword">kCFRunLoopBeforeWaiting</span>)</span><span class="comment">;</span></span><br><span class="line">  </span><br><span class="line">        /// <span class="number">7</span>. sleep to wait msg.</span><br><span class="line">        mach_msg<span class="list">()</span> -&gt; mach_msg_trap<span class="list">()</span><span class="comment">;</span></span><br><span class="line">         </span><br><span class="line">  </span><br><span class="line">        /// <span class="number">8</span>. 通知Observers，线程被唤醒</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__<span class="list">(<span class="keyword">kCFRunLoopAfterWaiting</span>)</span><span class="comment">;</span></span><br><span class="line">  </span><br><span class="line">        /// <span class="number">9</span>. 如果是被Timer唤醒的，回调Timer</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__<span class="list">(<span class="keyword">timer</span>)</span><span class="comment">;</span></span><br><span class="line">  </span><br><span class="line">        /// <span class="number">9</span>. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block</span><br><span class="line">        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__<span class="list">(<span class="keyword">dispatched_block</span>)</span><span class="comment">;</span></span><br><span class="line">  </span><br><span class="line">        /// <span class="number">9</span>. 如果如果Runloop是被 Source1 <span class="list">(基于port的)</span> 的事件唤醒了，处理这个事件</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__<span class="list">(<span class="keyword">source1</span>)</span><span class="comment">;</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    &#125;</span> while <span class="list">(<span class="keyword">...</span>)</span><span class="comment">;</span></span><br><span class="line">  </span><br><span class="line">    /// <span class="number">10</span>. 通知Observers，即将退出RunLoop</span><br><span class="line">    /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop<span class="list">()</span><span class="comment">;</span></span><br><span class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__<span class="list">(<span class="keyword">kCFRunLoopExit</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="AutoreleasePool">AutoreleasePool</h4><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p>
<p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p>
<p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p>
<p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p>
<h4 id="事件响应">事件响应</h4><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。</p>
<p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</p>
<p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p>
<h4 id="手势识别">手势识别</h4><p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p>
<p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。</p>
<p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>
<h4 id="界面更新">界面更新</h4><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p>
<p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：</p>
<p>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>
<p>这个函数内部的调用栈大概是这样的：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_<span class="tag">ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv</span>()</span><br><span class="line">    <span class="rule"><span class="attribute">QuartzCore</span>:<span class="value">CA::Transaction::observer_callback:</span><br><span class="line">        CA::Transaction::<span class="function">commit</span>()</span></span>;</span><br><span class="line">            <span class="rule"><span class="attribute">CA</span>:<span class="value">:Context::<span class="function">commit_transaction</span>()</span></span>;</span><br><span class="line">                <span class="rule"><span class="attribute">CA</span>:<span class="value">:Layer::<span class="function">layout_and_display_if_needed</span>()</span></span>;</span><br><span class="line">                    <span class="rule"><span class="attribute">CA</span>:<span class="value">:Layer::<span class="function">layout_if_needed</span>()</span></span>;</span><br><span class="line">                        <span class="attr_selector">[CALayer layoutSublayers]</span>;</span><br><span class="line">                            <span class="attr_selector">[UIView layoutSubviews]</span>;</span><br><span class="line">                    <span class="rule"><span class="attribute">CA</span>:<span class="value">:Layer::<span class="function">display_if_needed</span>()</span></span>;</span><br><span class="line">                        <span class="attr_selector">[CALayer display]</span>;</span><br><span class="line">                            <span class="attr_selector">[UIView drawRect]</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="定时器">定时器</h4><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>
<p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p>
<p>CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。</p>
<h4 id="PerformSelecter">PerformSelecter</h4><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p>
<p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>
<h4 id="关于GCD">关于GCD</h4><p>实际上 RunLoop 底层也会用到 GCD 的东西，比如 RunLoop 是用 dispatch_source_t 实现的 Timer。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。</p>
<p>当调用 dispatch<em>async(dispatch<em>get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</em></em>() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p>
<h4 id="关于网络请求">关于网络请求</h4><p>iOS 中，关于网络请求的接口自下至上有如下几层:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFSocket</span></span><br><span class="line"><span class="built_in">CFNetwork</span>       -&gt;ASIHttpRequest</span><br><span class="line"><span class="built_in">NSURLConnection</span> -&gt;AFNetworking</span><br><span class="line"><span class="built_in">NSURLSession</span>    -&gt;AFNetworking2, Alamofire</span><br></pre></td></tr></table></figure></p>
<ul>
<li>CFSocket 是最底层的接口，只负责 socket 通信。</li>
<li>CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。</li>
<li>NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。</li>
<li>NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如 com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。</li>
</ul>
<p>下面主要介绍下 NSURLConnection 的工作过程。</p>
<p>通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。</p>
<p>当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。<br><img src="http://cc.cocimg.com/api/uploads/20150528/1432799200369980.png" alt=""></p>
<p>NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。</p>
<h3 id="RunLoop_的实际应用举例">RunLoop 的实际应用举例</h3><h4 id="AFNetworking">AFNetworking</h4><p>AFURLConnectionOperation 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)networkRequestThreadEntryPoint:(<span class="keyword">id</span>)__unused object &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [[<span class="built_in">NSThread</span> currentThread] setName:<span class="string">@"AFNetworking"</span>];</span><br><span class="line">        <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">        [runLoop addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">+ (<span class="built_in">NSThread</span> *)networkRequestThread &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSThread</span> *_networkRequestThread = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> oncePredicate;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _networkRequestThread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(networkRequestThreadEntryPoint:) object:<span class="literal">nil</span>];</span><br><span class="line">        [_networkRequestThread start];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _networkRequestThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)start &#123;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.lock</span> lock];</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isCancelled]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(cancelConnection) onThread:[[<span class="keyword">self</span> class] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span><span class="variable">.runLoopModes</span> allObjects]];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span> isReady]) &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.state</span> = AFOperationExecutingState;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(operationDidStart) onThread:[[<span class="keyword">self</span> class] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span><span class="variable">.runLoopModes</span> allObjects]];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.lock</span> unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。</p>
<h4 id="AsyncDisplayKit">AsyncDisplayKit</h4><p>AsyncDisplayKit 是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下：</p>
<p>UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，UI对象操作。</p>
<p>排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。</p>
<p>绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。</p>
<p>UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。</p>
<p>其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如TextView创建时可能需要提前计算出文本的大小）。ASDK 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。</p>
<p>为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了 UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。</p>
<p>ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。</p>
<p>具体的代码可以看这里：<a href="https://github.com/facebook/AsyncDisplayKit/blob/master/AsyncDisplayKit%2FDetails%2FTransactions%2F_ASAsyncTransactionGroup.m" target="_blank" rel="external">_ASAsyncTransactionGroup</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://www.cocoachina.com/ios/20150601/11970.html">转自</a></p>
<h2 id="RunLoop">RunLoop</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;RunLoop 是 iOS 和 OS X 开发中非常基础的一个概念，这篇文章将从 CFRunLoop 的源码入手，介绍 RunLoop 的概念以及底层实现原理。之后会介绍一下在 iOS 中，苹果是如何利用 RunLoop 实现自动释放池、延迟回调、触摸事件、屏幕刷新等功能的。</p>
<h3 id="RunLoop_的概念">RunLoop 的概念</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span><span class="params">()</span> &#123;</span></span><br><span class="line">    initialize<span class="params">()</span>;</span><br><span class="line">    do &#123;</span><br><span class="line">        var message = get_next_message<span class="params">()</span>;</span><br><span class="line">        process_message<span class="params">(message)</span>;</span><br><span class="line">    &#125; while <span class="params">(message != quit)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这种模型通常被称作 Event Loop。 Event Loop 在很多系统和框架里都有实现，比如 Node.js 的事件处理，比如 Windows 程序的消息循环，再比如 OSX/iOS 里的 RunLoop。实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。<br>]]>
    
    </summary>
    
      <category term="IOS" scheme="http://ytlvy.com/tags/IOS/"/>
    
      <category term="NSRunLoop" scheme="http://ytlvy.com/tags/NSRunLoop/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
</feed>