<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Yt's Blog]]></title>
  <subtitle><![CDATA[Valar Morghulis]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://ytlvy.com//"/>
  <updated>2015-08-22T12:47:27.000Z</updated>
  <id>http://ytlvy.com//</id>
  
  <author>
    <name><![CDATA[Yt]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[C programming -- Precompile]]></title>
    <link href="http://ytlvy.com/2015/08/22/C-programming-Precompile/"/>
    <id>http://ytlvy.com/2015/08/22/C-programming-Precompile/</id>
    <published>2015-08-22T12:46:56.000Z</published>
    <updated>2015-08-22T12:47:27.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/kenshincui/p/3854242.html" target="_blank" rel="external">reference</a></p>
<h2 id="C语言之预处理">C语言之预处理</h2><h3 id="概述">概述</h3><p>大家都知道一个C程序的运行包括编译和链接两个阶段，其实在编译之前预处理器首先要进行预处理操作，将处理完产生的一个新的源文件进行编译。由于预处理指令是在编译之前就进行了，因此很多时候它要比在程序运行时进行操作效率高。在C语言中包括三类预处理指令，今天将一一介绍：</p>
<ul>
<li>宏定义</li>
<li>条件编译</li>
<li>文件包含</li>
</ul>
<h3 id="宏定义">宏定义</h3><p>对于程序中经常用到的一些常量或者简短的函数我们通常使用宏定义来处理，这样做的好处是对于程序中所有的配置我们可以统一在宏定义中进行管理，而且由于宏定义是在程序编译之前进行替换相比定义成全局变量或函数效率更高。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  Pretreatment</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-6-28.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PI 3.14 <span class="comment">//宏定义一般大写</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> R 10</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> S 2*PI*R <span class="comment">//在另一个宏里面引用了上面的宏</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> r=<span class="number">10.5</span>;</span><br><span class="line">    <span class="keyword">double</span> area=PI*r*r;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"area=%.2f\n"</span>,area);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> a=S;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%.2f\n"</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"PI=3.14\n"</span>);<span class="comment">//注意输出结果不是3.14=3.14而是PI=3.14，字符串中的PI并不会被替换</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">undef</span> PI <span class="comment">//强制终止宏定义，否则它的范围一直到文件结束</span></span></span><br><span class="line">    <span class="keyword">int</span> PI=<span class="number">3.1415926</span>;</span><br><span class="line">    <span class="keyword">double</span> area2=PI*r*r;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"area2=%.2f\n"</span>,area2);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>宏定义实际的操作就是在预处理时进行对应替换，这个阶段不管语法是否正确，而且对于字符串中出现的宏名不会进行替换。宏定义的功能事实上是非常强大的，除了简单的常量替换还可以传入参数：</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  1.2.c</span></span><br><span class="line"><span class="comment">//  Pretreatment</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-7-17.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> SUM(a,b) a+b</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> SUB(a,b) (a-b)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MUL (a,b) (a*b) <span class="comment">//这么定义是错误的，预处理器会认为宏名为”MUL“,替换内容为”(a,b) (a*b)“</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">2</span>,b=<span class="number">3</span>,c,d;</span><br><span class="line">    c=SUM(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c=%d\n"</span>,c); <span class="comment">//结果：c=5</span></span><br><span class="line">    d=SUM(a, b)*<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"d=%d\n"</span>); <span class="comment">//结果：8,为什么不是10呢？因为替换后：d=a+b*2也就是2+3*2=8</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> e=SUB(b, a)*<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"(b-a)*2=%d\n"</span>,e); <span class="comment">//结果：2,如果SUB定义时不加括号这里应该是-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面我们可以看出带参数的宏功能很强大，有点类似于函数，同函数不同的是它只是简单的替换，不涉及存储空间分配，参数、返回值等问题，但是由于它在预处理阶段展开，所以一般效率较高。使用带参数的宏需要注意的就是结果最好用括号括起来否则很容易出现问题（在上面的SUM例子中我们应该已经看到了）；还有一点就是带参数的宏定义时名称和参数之间不要有空格。</p>
<h3 id="条件编译">条件编译</h3><p>条件编译其实就是在编译之前预处理器根据预处理指令判断对应的条件，如果条件满足就将对应的代码编译进去，否则代码就根本不进入编译环节（相当于根本就没有这段代码）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  Pretreatment</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-06-28.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> COUNT 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//判断是否定义了 COUNT 宏</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> defined(COUNT) <span class="comment">//等价于：#ifdef COUNT,相反如果判断没有定义过则可以通过#if !defined(COUNT)或者#ifndef COUNT</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"COUNT defined\n"</span>);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//判断宏定义COUNT是否等于1</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> COUNT==1</span></span><br><span class="line">    showMessage(<span class="string">"hello,world!\n"</span>);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">    say();</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="文件包含">文件包含</h3><p>文件包含指令#include在前面也多次使用过，这里再次强调一下。首先使用#include”xxx”包含和使用#include <xxx>包含的不同之处就是使用&lt;&gt;包含时，预处理器会搜索C函数库头文件路径下的文件，而使用””包含时首先搜索程序所在目录，其次搜索系统Path定义目录，如果还是找不到才会搜索C函数库头文件所在目录。</xxx></p>
<p>另外在使用#include的时候我们需要注意包含文件的时候是不能递归包含的，例如a.h文件包含b.h，而b.h就不能再包含a.h了；还有就是重复包含虽然是允许的（这里指的是重复包含头文件）但是这会降低编译性能，不妨看一下下面的例子：</p>
<p><img src="http://images.cnitblog.com/blog/62046/201407/182035388189767.png" alt=""></p>
<p>上面有三段代码，在main.c和person.h中都包含了message.h而main.c自身又包含了person.h,这样程序在预处理阶段会对包含内容进行替换，替换后mian.c中包含了两个#include “message.h”虽然没有报错，但这会影响编译的性能，正确的做法应该是这样的：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="id">#ifndef</span> _PERSON_H_</span><br><span class="line"><span class="hexcolor">#def</span>ine _PERSON_H_</span><br><span class="line"></span><br><span class="line"><span class="id">#include</span> <span class="string">"person.h"</span></span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p><img src="http://images.cnitblog.com/blog/62046/201407/182035402567293.png" alt=""></p>
<p>其实就是用宏定义判断一个宏是否定义了，如果没有定义则会定义这个宏，这样以来如果已经包含过则这个宏定义肯定已经定义过了，即使再包含也不会重新定义了，下面的代码也就不会包含进去。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://www.cnblogs.com/kenshincui/p/3854242.html">reference</a></p>
<h2 id="C语言之预处理">C语言之预处理</h2><h3 id="概述">概述</h3><p>大家都知道一个C程序的运行包括编译和链接两个阶段，其实在编译之前预处理器首先要进行预处理操作，将处理完产生的一个新的源文件进行编译。由于预处理指令是在编译之前就进行了，因此很多时候它要比在程序运行时进行操作效率高。在C语言中包括三类预处理指令，今天将一一介绍：</p>
<ul>
<li>宏定义</li>
<li>条件编译</li>
<li>文件包含</li>
</ul>
<h3 id="宏定义">宏定义</h3><p>对于程序中经常用到的一些常量或者简短的函数我们通常使用宏定义来处理，这样做的好处是对于程序中所有的配置我们可以统一在宏定义中进行管理，而且由于宏定义是在程序编译之前进行替换相比定义成全局变量或函数效率更高。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  Pretreatment</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-6-28.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PI 3.14 <span class="comment">//宏定义一般大写</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> R 10</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> S 2*PI*R <span class="comment">//在另一个宏里面引用了上面的宏</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> r=<span class="number">10.5</span>;</span><br><span class="line">    <span class="keyword">double</span> area=PI*r*r;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"area=%.2f\n"</span>,area);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> a=S;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%.2f\n"</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"PI=3.14\n"</span>);<span class="comment">//注意输出结果不是3.14=3.14而是PI=3.14，字符串中的PI并不会被替换</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">undef</span> PI <span class="comment">//强制终止宏定义，否则它的范围一直到文件结束</span></span></span><br><span class="line">    <span class="keyword">int</span> PI=<span class="number">3.1415926</span>;</span><br><span class="line">    <span class="keyword">double</span> area2=PI*r*r;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"area2=%.2f\n"</span>,area2);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>宏定义实际的操作就是在预处理时进行对应替换，这个阶段不管语法是否正确，而且对于字符串中出现的宏名不会进行替换。宏定义的功能事实上是非常强大的，除了简单的常量替换还可以传入参数：</p>]]>
    
    </summary>
    
      <category term="C" scheme="http://ytlvy.com/tags/C/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C programming -- Struct]]></title>
    <link href="http://ytlvy.com/2015/08/22/C-programming-Struct/"/>
    <id>http://ytlvy.com/2015/08/22/C-programming-Struct/</id>
    <published>2015-08-22T12:45:36.000Z</published>
    <updated>2015-08-22T12:46:06.000Z</updated>
    <content type="html"><![CDATA[<p>@charset “UTF-8”;<br>/**</p>
<ul>
<li></li>
<li>@authors Your Name (you@example.org)</li>
<li>@date    2015-08-16 11:06:45</li>
<li>@version $Id$</li>
<li>Copyright (c) 2015年 Guo yanjie. All rights reserved.<br>*/</li>
</ul>
<p><a href="http://www.cnblogs.com/kenshincui/p/3856543.html" target="_blank" rel="external">reference</a></p>
<h2 id="C语言之构造类型">C语言之构造类型</h2><h3 id="概述">概述</h3><p>在第一节中我们就提到C语言的构造类型，分为：数组、结构体、枚举、共用体，当然前面数组的内容已经说了很多了，这一节将会重点说一下其他三种类型。</p>
<ul>
<li>结构体</li>
<li>枚举</li>
<li>共用体</li>
</ul>
<h3 id="结构体">结构体</h3><p>数组中存储的是一系列相同的数据类型，那么如果想让一个变量存储不同的数据类型就要使用结构体，结构体定义类似于C++、C#、Java等高级语言中类的定义，但事实上它们又有着很大的区别。结构体是一种类型，并非一个变量，只是这种类型可以由其他C语言基本类型共同组成。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  main.c</span><br><span class="line">//  ConstructedType</span><br><span class="line">//</span><br><span class="line">//  Created by Kenshin Cui on 14-7-18.</span><br><span class="line">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">//结构体类型Date</span><br><span class="line">struct Date&#123;</span><br><span class="line">    int year;</span><br><span class="line">    int month;</span><br><span class="line">    int day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct <span class="keyword">Person</span>&#123;</span><br><span class="line">    char *name;</span><br><span class="line">    int age;</span><br><span class="line">    struct Date birthday;//一个结构体中使用了另一个结构体类型，结构体类型变量声明前必须加上struct关键字</span><br><span class="line">    float height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv<span class="comment">[]</span>) &#123;</span><br><span class="line">    struct <span class="keyword">Person</span> p=&#123;<span class="string">"Kenshin"</span>,28,&#123;1986,8,8&#125;,1.72&#125;;</span><br><span class="line">    //定义结构体变量并初始化,不允许先定义再直接初始化，例如：struct <span class="keyword">Person</span> p;p=&#123;<span class="string">"Kenshin"</span>,28,&#123;1986,8,8&#125;,1.72&#125;;是错误的，但是可以分别赋值，例如p.name=<span class="string">"Kenshin"</span></span><br><span class="line">    </span><br><span class="line">    printf(<span class="string">"name=%s,age=%d,birthday=%d-%d-%d,height=%.2f\n"</span>,p.name,p.age,p.birthday.year,p.birthday.month,p.birthday.day,p.height); </span><br><span class="line">    //结果：name=Kenshin,age=28,birthday=1986-8-8,height=1.72，结构体的引用是通过<span class="string">"结构体变量.成员名称"</span>(注意和结构体指针访问结构体成员变量区分，结构体指针使用p-&gt;a的形式访问)</span><br><span class="line">    </span><br><span class="line">    printf(<span class="string">"len(Date)=%lu,len(Person)=%lu\n"</span>,sizeof(struct Date),sizeof(struct <span class="keyword">Person</span>)); </span><br><span class="line">    //结果：len(Date)=12,len(<span class="keyword">Person</span>)=32</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>对于上面的例子需要做出如下说明：</p>
<ul>
<li>可以在定义结构体类型的同时声明结构体变量；</li>
<li>如果定义结构体类型的同时声明结构体变量，此时结构体名称可以省略；</li>
<li>定义结构体类型并不会分配内存，在定义结构体变量的时候才进行内存分配（同基本类型时类似的）；</li>
<li>结构体类型的所占用内存大型等于所有成员占用内存大小之和（如果不考虑内存对齐的前提下）；</li>
</ul>
<p>对第4点需要进行说明，例如上面代码是在64位编译器下运行的结果（int长度4，char长度1，float类型4），Date=4+4+4=12。但是对于Person却没有那么简单了，因为按照正常方式计算Person=8+4+12+4=28，但是从上面代码中给出的结果是32，为什么呢？这里不得不引入一个概念“内存对齐”，关于内存对齐的概念在这里不做详细说明，大家需要了解的是：在Mac OS X中对齐参数默认为8（可以通过在代码中添加#pragma pack(8)改变对齐参数），如果结构体中的类型不大于8，那么结构体长度就是其成员类型之和，但是如果成员变量的长度大于这个对齐参数那么得到的结果就不一定是各个成员变量之和了。Person类型的长度之所以是32，其实主要原因是因为Date类型长度12在存储时其偏移量12不是8的倍数，考虑到内存对齐的原因需要添加4个补齐长度，这里使用表格的形式列出了具体原因：</p>
<p><img src="http://images.cnitblog.com/blog/62046/201407/201858560376210.png" alt=""></p>
<p>接下来看一下结构体数组、指向结构体的指针：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  main.c</span><br><span class="line">//  ConstructedType</span><br><span class="line">//</span><br><span class="line">//  Created by Kenshin Cui on 14-7-18.</span><br><span class="line">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">struct Date&#123;</span><br><span class="line">    int year;</span><br><span class="line">    int month;</span><br><span class="line">    int day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct <span class="keyword">Person</span>&#123;</span><br><span class="line">    char *name;</span><br><span class="line">    int age;</span><br><span class="line">    struct Date birthday;</span><br><span class="line">    float height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void changeValue(struct <span class="keyword">Person</span> <span class="keyword">person</span>)&#123;</span><br><span class="line">    <span class="keyword">person</span>.height=1.80;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv<span class="comment">[]</span>) &#123;</span><br><span class="line">    struct <span class="keyword">Person</span> persons<span class="comment">[]</span>=&#123;</span><br><span class="line">        &#123;<span class="string">"Kenshin"</span>,28,&#123;1986,8,8&#125;,1.72&#125;,</span><br><span class="line">        &#123;<span class="string">"Kaoru"</span>,27,&#123;1987,8,8&#125;,1.60&#125;,</span><br><span class="line">        &#123;<span class="string">"Rosa"</span>,29,&#123;1985,8,8&#125;,1.60&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    for (int i=0; i&lt;3; ++i) &#123;</span><br><span class="line">        printf(<span class="string">"name=%s,age=%d,birthday=%d-%d-%d,height=%.2f\n"</span>,</span><br><span class="line">               persons<span class="comment">[i]</span>.name,</span><br><span class="line">               persons<span class="comment">[i]</span>.age,</span><br><span class="line">               persons<span class="comment">[i]</span>.birthday.year,</span><br><span class="line">               persons<span class="comment">[i]</span>.birthday.month,</span><br><span class="line">               persons<span class="comment">[i]</span>.birthday.day,</span><br><span class="line">               persons<span class="comment">[i]</span>.height);</span><br><span class="line">    &#125;</span><br><span class="line">    /*输出结果：</span><br><span class="line">     name=Kenshin,age=28,birthday=1986-8-8,height=1.72</span><br><span class="line">     name=Kaoru,age=27,birthday=1987-8-8,height=1.60</span><br><span class="line">     name=Rosa,age=29,birthday=1985-8-8,height=1.60</span><br><span class="line">     */</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    struct <span class="keyword">Person</span> <span class="keyword">person</span>=persons<span class="comment">[0]</span>;</span><br><span class="line">    changeValue(<span class="keyword">person</span>);</span><br><span class="line">    printf(<span class="string">"name=%s,age=%d,birthday=%d-%d-%d,height=%.2f\n"</span>,</span><br><span class="line">           persons<span class="comment">[0]</span>.name,</span><br><span class="line">           persons<span class="comment">[0]</span>.age,</span><br><span class="line">           persons<span class="comment">[0]</span>.birthday.year,</span><br><span class="line">           persons<span class="comment">[0]</span>.birthday.month,</span><br><span class="line">           persons<span class="comment">[0]</span>.birthday.day,</span><br><span class="line">           persons<span class="comment">[0]</span>.height);</span><br><span class="line">    /*输出结果：</span><br><span class="line">     name=Kenshin,age=28,birthday=1986-8-8,height=1.72</span><br><span class="line">     */</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    struct <span class="keyword">Person</span> *p=&amp;<span class="keyword">person</span>;</span><br><span class="line">    printf(<span class="string">"name=%s,age=%d,birthday=%d-%d-%d,height=%.2f\n"</span>,</span><br><span class="line">           (*p).name,</span><br><span class="line">           (*p).age,</span><br><span class="line">           (*p).birthday.year,</span><br><span class="line">           (*p).birthday.month,</span><br><span class="line">           (*p).birthday.day,</span><br><span class="line">           (*p).height);</span><br><span class="line">    /*输出结果：</span><br><span class="line">     name=Kenshin,age=28,birthday=1986-8-8,height=1.72</span><br><span class="line">     */</span><br><span class="line">    printf(<span class="string">"name=%s,age=%d,birthday=%d-%d-%d,height=%.2f\n"</span>,</span><br><span class="line">           p-&gt;name,</span><br><span class="line">           p-&gt;age,</span><br><span class="line">           p-&gt;birthday.year,</span><br><span class="line">           p-&gt;birthday.month,</span><br><span class="line">           p-&gt;birthday.day,</span><br><span class="line">           p-&gt;height);</span><br><span class="line">    /*输出结果：</span><br><span class="line">     name=Kenshin,age=28,birthday=1986-8-8,height=1.72</span><br><span class="line">     */</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构体作为函数参数传递的是成员的值（值传递而不是引用传递），对于结构体指针而言可以通过”-&gt;”操作符进行访问。</p>
<h3 id="枚举">枚举</h3><p>枚举类型是比较简单的一种数据类型，事实上在C语言中枚举类型是作为整形常量进行处理的，通常称为“枚举常量”。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  ConstructedType</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-7-18.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Season&#123; <span class="comment">//默认情况下spring=0，summer=1,autumn=2,winter=3</span></span><br><span class="line">    spring,</span><br><span class="line">    summer,</span><br><span class="line">    autumn,</span><br><span class="line">    winter</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> Season season=summer; <span class="comment">//枚举赋值,等价于season=1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"summer=%d\n"</span>,season); <span class="comment">//结果：summer=1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(season=spring;season&lt;=winter;++season)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"element value=%d\n"</span>,season);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*结果：</span><br><span class="line">     element value=0</span><br><span class="line">     element value=1</span><br><span class="line">     element value=2</span><br><span class="line">     element value=3</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是枚举成员默认值从0开始，如果给其中一个成员赋值，其它后面的成员将依次赋值，例如上面如果summer手动指定为8，则autumn=9，winter=10，而sprint还是0。</p>
<h3 id="共用体">共用体</h3><p>共用体又叫联合，因为它的关键字是union（貌似数据库操作经常使用这个关键字），它的使用不像枚举和结构体那么频繁，但是作为C语言中的一种数据类型我们也有必要弄清它的用法。从前面的分析我们知道结构体的总长度等于所有成员的和（当然此时还可能遇到对齐问题），但是和结构体不同的是共用体所有成员共用一块内存，顺序从低地址开始存放，一次只能使用其中一个成员，union最终大小由共用体中最大的成员决定，对某一成员赋值可能会覆盖另一个成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  ConstructedType</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-7-20.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> Type&#123;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">union</span> Type t;</span><br><span class="line">    t.a=<span class="string">'a'</span>;</span><br><span class="line">    t.b=<span class="number">10</span>;</span><br><span class="line">    t.c=<span class="number">65796</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"address(Type)=%x,address(t.a)=%x,address(t.b)=%x,address(t.c)=%x\n"</span>,&amp;t,&amp;t.a,&amp;t.b,&amp;t.c);</span><br><span class="line">    <span class="comment">//结果：address(Type)=5fbff7b8,address(t.a)=5fbff7b8,address(t.b)=5fbff7b8,address(t.c)=5fbff7b8</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"len(Type)=%d\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">union</span> Type));</span><br><span class="line">    <span class="comment">//结果：len(Type)=4</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"t.a=%d,t.b=%d,t.c=%d\n"</span>,t.a,t.b,t.c);</span><br><span class="line">    <span class="comment">//结果:t.a=4,t.b=260,t.c=65796</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要重点解释一个问题：为什么t.a、t.b、t.c输出结果分别是4、260、65796，当然t.c等于65796并不奇怪，但是t.a前面赋值为’a’不应该是97吗，而t.b不应该是10吗？其实如果弄清这个问题共用体的概念基本就清楚了。</p>
<p>根据前面提到的，共用体其实每次只能使用其中一个成员，对于上面的代码经过三次赋值最终使用的其实就是t.c,而通过上面的输出结果我们也确实看到c是有效的。共用体有一个特点就是它的成员存储在同一块内存区域，这块区域的大小需要根据它的成员中长度最大的成员长度而定。由于上面的代码是在64位编译器下编译的，具体长度：char=1，short int=2，int=4，所以得出结论，Type的长度为4，又根据上面输出的地址，可以得到下面的存储信息(注意数据的存储方式：高地址存储高位，低地址存储地位)：</p>
<p><img src="http://images.cnitblog.com/blog/62046/201407/201858575218722.png" alt=""></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当读取c的时候，它的二进制是“<span class="number">00000000</span>  <span class="number">00000001</span>  <span class="number">00000001</span>  <span class="number">00000100</span>”，换算成十进制就是65796；而经过三次赋值后，此时b的存储就已经被c成员的低位数据覆盖，b的长度是二，所以从起始地址取两个字节得到的二进制数据此时是“<span class="number">00000001</span>  <span class="number">00000100</span>”（b原来的数据已经被c低2位数据覆盖，其实此时就是c的低2位数据），换算成十进制就是260；类似的a此时的数据就是c的低一位数据”<span class="number">00000100</span>”,换算成十进制就是4。</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>@charset “UTF-8”;<br>/**</p>
<ul>
<li></li>
<li>@authors Your Name (you@example.org)</li>
<li>@date    2015-08-16 11:06:45</li>
<li>@version $Id$</li>
<li>Copyright (c) 2015年 Guo yanjie. All rights reserved.<br>*/</li>
</ul>
<p><a href="http://www.cnblogs.com/kenshincui/p/3856543.html">reference</a></p>
<h2 id="C语言之构造类型">C语言之构造类型</h2><h3 id="概述">概述</h3><p>在第一节中我们就提到C语言的构造类型，分为：数组、结构体、枚举、共用体，当然前面数组的内容已经说了很多了，这一节将会重点说一下其他三种类型。</p>
<ul>
<li>结构体</li>
<li>枚举</li>
<li>共用体</li>
</ul>
<h3 id="结构体">结构体</h3><p>数组中存储的是一系列相同的数据类型，那么如果想让一个变量存储不同的数据类型就要使用结构体，结构体定义类似于C++、C#、Java等高级语言中类的定义，但事实上它们又有着很大的区别。结构体是一种类型，并非一个变量，只是这种类型可以由其他C语言基本类型共同组成。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  main.c</span><br><span class="line">//  ConstructedType</span><br><span class="line">//</span><br><span class="line">//  Created by Kenshin Cui on 14-7-18.</span><br><span class="line">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">//结构体类型Date</span><br><span class="line">struct Date&#123;</span><br><span class="line">    int year;</span><br><span class="line">    int month;</span><br><span class="line">    int day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct <span class="keyword">Person</span>&#123;</span><br><span class="line">    char *name;</span><br><span class="line">    int age;</span><br><span class="line">    struct Date birthday;//一个结构体中使用了另一个结构体类型，结构体类型变量声明前必须加上struct关键字</span><br><span class="line">    float height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv<span class="comment">[]</span>) &#123;</span><br><span class="line">    struct <span class="keyword">Person</span> p=&#123;<span class="string">"Kenshin"</span>,28,&#123;1986,8,8&#125;,1.72&#125;;</span><br><span class="line">    //定义结构体变量并初始化,不允许先定义再直接初始化，例如：struct <span class="keyword">Person</span> p;p=&#123;<span class="string">"Kenshin"</span>,28,&#123;1986,8,8&#125;,1.72&#125;;是错误的，但是可以分别赋值，例如p.name=<span class="string">"Kenshin"</span></span><br><span class="line">    </span><br><span class="line">    printf(<span class="string">"name=%s,age=%d,birthday=%d-%d-%d,height=%.2f\n"</span>,p.name,p.age,p.birthday.year,p.birthday.month,p.birthday.day,p.height); </span><br><span class="line">    //结果：name=Kenshin,age=28,birthday=1986-8-8,height=1.72，结构体的引用是通过<span class="string">"结构体变量.成员名称"</span>(注意和结构体指针访问结构体成员变量区分，结构体指针使用p-&gt;a的形式访问)</span><br><span class="line">    </span><br><span class="line">    printf(<span class="string">"len(Date)=%lu,len(Person)=%lu\n"</span>,sizeof(struct Date),sizeof(struct <span class="keyword">Person</span>)); </span><br><span class="line">    //结果：len(Date)=12,len(<span class="keyword">Person</span>)=32</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="C" scheme="http://ytlvy.com/tags/C/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C programming -- Array & String]]></title>
    <link href="http://ytlvy.com/2015/08/22/C-programming-Array-String/"/>
    <id>http://ytlvy.com/2015/08/22/C-programming-Array-String/</id>
    <published>2015-08-22T12:44:55.000Z</published>
    <updated>2015-08-22T12:46:18.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/kenshincui/p/3843505.html" target="_blank" rel="external">reference</a></p>
<h2 id="C语言之数组和字符串">C语言之数组和字符串</h2><h3 id="概览">概览</h3><p>数组在C语言中有着特殊的地位，它有很多特性，例如它的存储是连续的，数组的名称就是数组的地址等。而在C语言中是没有String类型的，那么如果要表示一个字符串，就必须使用字符数组。今天主要就介绍如下三个方面：</p>
<ul>
<li>一维数组</li>
<li>多维数组</li>
<li>字符串</li>
</ul>
<h3 id="一维数组">一维数组</h3><p>一维数组操作比较简单，但是需要注意，数组长度必须是固定的，长度不能使用变量进行初始化；如果声明的同时进行赋值则数组长度可以省略，编译器会自动计算数组长度；同时数组不能先声明再一次性赋值（当然可以对每个元素一一赋值）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//int a[len] = &#123; 1, 2&#125;;//错误,不能使变量</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">2</span>];<span class="comment">//正确</span></span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//a[2] = 3;//超过数组长度，但是编译器并不会检查，运行报错</span></span><br><span class="line">    <span class="keyword">int</span> b[<span class="string">'a'</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//'a'=97，所以可以作为数组长度，但是后面的元素没有初始化，其值默认为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">97</span>; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"b[%d]=%d\n"</span>,i,b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> c[<span class="number">2</span> * <span class="number">3</span>];<span class="comment">//2*3是固定值可以作为数组长度</span></span><br><span class="line">    <span class="keyword">int</span> d[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;<span class="comment">//如果初始化的同时赋值则数组长度可以省略，当前个数为3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="扩展—数组的存储">扩展—数组的存储</h3><p>数组在内存中存储在一块连续的空间中，如果知道数组类型（int、float等）和初始地址就可以知道其他元素的地址，同时由于数组名等于数组第一个元素的地址，所以当数组作为参数（作为参数时形参可以省略）其实是引用传递。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span> l = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> a[l] = &#123; <span class="number">1</span>, <span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; ++i)&#123;</span><br><span class="line">        <span class="comment">//由于当前在32位编译器下，int型长度为4个字节，可以判断出三个地址两两相差都是4</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a[%d]=%d,address=%x\n"</span>, i, a[i], &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*当前输出结果：</span><br><span class="line">    a[0] = 1, address = c9f95c</span><br><span class="line">    a[1] = 2, address = c9f960</span><br><span class="line">    a[2] = 3, address = c9f964*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看一下上面定义的数组在内存中存储结构</p>
<p><img src="http://images.cnitblog.com/blog/62046/201407/142058350217075.png" alt=""></p>
<p>再来看一下数组作为参数传递的情况，数组作为参数传递的是数组的地址<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeValue</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123; a[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; <span class="keyword">int</span> a[<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    changeValue(a); <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a[%d]=%d\n"</span>,i,a[i]);</span><br><span class="line">    &#125; <span class="comment">/*打印结果</span><br><span class="line">    a[0]=10</span><br><span class="line">    a[1]=2</span><br><span class="line">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="多维数组">多维数组</h3><p>多维数组其实可以看成是一个特殊的一维数组，只是每个元素又是一个一维数组，下面简单看一下多维数组的初始化和赋值</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int a<span class="comment">[2]</span><span class="comment">[3]</span>;//2行3列，二维数组可以看成是一个特殊的一维数组，只是它的每一个元素又是一个一维数组</span><br><span class="line">    a<span class="comment">[0]</span><span class="comment">[0]</span> = 1;</span><br><span class="line">    a<span class="comment">[0]</span><span class="comment">[1]</span> = 2;</span><br><span class="line">    a<span class="comment">[0]</span><span class="comment">[2]</span> = 3;</span><br><span class="line">    a<span class="comment">[1]</span><span class="comment">[0]</span> = 4;</span><br><span class="line">    a<span class="comment">[1]</span><span class="comment">[1]</span> = 5;</span><br><span class="line">    a<span class="comment">[1]</span><span class="comment">[2]</span> = 6;</span><br><span class="line">    for (int i = 0; i &lt; 2; ++i)&#123;</span><br><span class="line">        for (int j = 0; j &lt; 3; ++j)&#123;</span><br><span class="line">            printf(<span class="string">"a<span class="subst">[%d]</span><span class="subst">[%d]</span>=%d,address=%x\n"</span>, i, j, a<span class="comment">[i]</span><span class="comment">[j]</span>, &amp;a<span class="comment">[i]</span><span class="comment">[j]</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /*打印结果</span><br><span class="line">    a<span class="comment">[0]</span><span class="comment">[0]</span>=1,address=f8fb24</span><br><span class="line">    a<span class="comment">[0]</span><span class="comment">[1]</span>=2,address=f8fb28</span><br><span class="line">    a<span class="comment">[0]</span><span class="comment">[2]</span>=3,address=f8fb2c</span><br><span class="line">    a<span class="comment">[1]</span><span class="comment">[0]</span>=4,address=f8fb30</span><br><span class="line">    a<span class="comment">[1]</span><span class="comment">[1]</span>=5,address=f8fb34</span><br><span class="line">    a<span class="comment">[1]</span><span class="comment">[2]</span>=6,address=f8fb38</span><br><span class="line">    */</span><br><span class="line">    //初始化并直接赋值</span><br><span class="line">    int b<span class="comment">[2]</span><span class="comment">[3]</span> = &#123; &#123; 1, 2, 3 &#125;, &#123; 4, 5, 6 &#125; &#125;;</span><br><span class="line">    //由于数组的赋值顺序是先从第一行第一列，再第一行第二列...然后第二行第一列...，所以我们也可以写成如下形式</span><br><span class="line">    int c<span class="comment">[2]</span><span class="comment">[3]</span> = &#123; 1, 2, 3, 4, 5, 6 &#125;;</span><br><span class="line">    //也可以只初始化部分数据，其余元素默认为0</span><br><span class="line">    int d<span class="comment">[2]</span><span class="comment">[3]</span> = &#123; 1, 2, 3, 4 &#125;;</span><br><span class="line">    for (int i = 0; i &lt; 2; ++i)&#123;</span><br><span class="line">        for (int j = 0; j &lt; 3; ++j)&#123;</span><br><span class="line">            printf(<span class="string">"d<span class="subst">[%d]</span><span class="subst">[%d]</span>=%d\n"</span>, i, j, d<span class="comment">[i]</span><span class="comment">[j]</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /*打印结果</span><br><span class="line">    d<span class="comment">[0]</span><span class="comment">[0]</span>=1</span><br><span class="line">    d<span class="comment">[0]</span><span class="comment">[1]</span>=2</span><br><span class="line">    d<span class="comment">[0]</span><span class="comment">[2]</span>=3</span><br><span class="line">    d<span class="comment">[1]</span><span class="comment">[0]</span>=4</span><br><span class="line">    d<span class="comment">[1]</span><span class="comment">[1]</span>=0</span><br><span class="line">    d<span class="comment">[1]</span><span class="comment">[2]</span>=0</span><br><span class="line">    */</span><br><span class="line">    //当然下面赋值也可以</span><br><span class="line">    int e<span class="comment">[2]</span><span class="comment">[3]</span> = &#123; &#123;&#125;, &#123; 4, 5, 6 &#125; &#125;;</span><br><span class="line">    //可以省略行号,但是绝对不可以省略列号，因为按照上面说的赋值顺序，它无法判断有多少行</span><br><span class="line">    int f<span class="comment">[]</span><span class="comment">[3]</span> = &#123; &#123;1,2,3&#125;,&#123;4,5,6&#125; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="扩展—多维数组的存储">扩展—多维数组的存储</h4><p>以上面a数组为例，它在内存中的结构如下图</p>
<p><img src="http://images.cnitblog.com/blog/62046/201407/142058356937703.png" alt=""></p>
<p>根据上图和一维数组的存储，对于二维数组可以得出如下结论:数组名就是整个二维数组的地址，也等于第一行数组名的地址，还等于第一个元素的地址；第二行数组名等于第二行第一个元素的地址。用表达式表示：</p>
<p>a=a[0]=&amp;a[0][0]<br>a[1]=&amp;a[1][0]</p>
<p>同样可以得出a[i][j]=a[i]+j。关于三维数组、四维数组等多维数组，其实可以以此类推，在此不再赘述。</p>
<h3 id="字符串">字符串</h3><p>在C语言中是没有字符串类型的，如果要表示字符串需要使用char类型的数组，因为字符串本身就是多个字符的组合。但是需要注意的是字符串是一个特殊的数组，在它的结束位置必须要加一个”\0”（ASCII中0是空操作符，表示什么也不做）来表示字符串结束，否则编译器是不知道什么时候字符串已经结束的。当直接使用字符串赋值的时候程序会自动加上”\0”作为结束符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  ArrayAndString</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by KenshinCui on 14-7-06.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> a[] = &#123;<span class="string">'K'</span>,<span class="string">'e'</span>,<span class="string">'n'</span>,<span class="string">'s'</span>,<span class="string">'h'</span>,<span class="string">'i'</span>,<span class="string">'n'</span>,<span class="string">'\0'</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,a); <span class="comment">//结果：Kenshin，注意使用%s输出字符串内容，如果换成整形输出格式其实输出的是a的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"address=%x"</span>, a); <span class="comment">//结果：address=5fbff890</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="comment">//后面的\0绝对不能省略,如果没有\0则会出现如下情况</span></span><br><span class="line">    <span class="keyword">char</span> b[] = &#123; <span class="string">'I'</span>, <span class="string">'a'</span>, <span class="string">'m'</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,b); <span class="comment">//没有按照期望输出，多了一些垃圾数据，在当前环境打印结果：IamKenshin</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"address=%x"</span>,b); <span class="comment">//结果：address=5fbff88d</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="comment">//直接赋值为字符串，此时不需要手动添加\0，编译器会自动添加</span></span><br><span class="line">    <span class="keyword">char</span> c[] = <span class="string">"Kenshin"</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c=%s"</span>,c); <span class="comment">//结果：c=Kenshin</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//二维数组存储多个字符串</span></span><br><span class="line">    <span class="keyword">char</span> d[<span class="number">2</span>][<span class="number">3</span>]=&#123;<span class="string">"Kenshin"</span>,<span class="string">"Kaoru"</span>,<span class="string">"Rose"</span>,<span class="string">"Jack"</span>,<span class="string">"Tom"</span>,<span class="string">"Jerry"</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码注释中可以看到打印b的时候不是直接打印出来“Iam”而是打印出了“IamKenshin”，原因就是编译器无法判断字符串是否结束，要解释为什么打印出“IamKenshin”我们需要了解a和b在内存中的存储。</p>
<p><img src="http://images.cnitblog.com/blog/62046/201407/142058363658331.png" alt=""></p>
<p>从图中我们不难发现由于a占用8个字节，而定义完a后直接定义了b，此时分配的空间连续，b占用3个字节，这样当输出b的时候由于输出完“Iam”之后并未遇到”\0”标记，程序继续输出直到遇到数组a中的“\0”才结束，因此输出内容为“IamKenshin”。</p>
<h4 id="扩展—字符串操作常用函数">扩展—字符串操作常用函数</h4><p>下面简单看一下和字符和字符串相关的常用的几个函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  ArrayAndString</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-7-04.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">/*字符操作*/</span></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'a'</span>); <span class="comment">//结果：a，putchar一次只能输出一个字符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">97</span>);<span class="comment">//结果:a</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    a=getchar();<span class="comment">//getchar()一次只能接收一个字符，可以接收空格、tab、回车</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%c"</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*字符串操作*/</span></span><br><span class="line">    <span class="keyword">char</span> b[]=<span class="string">"Kenshin"</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"b=%s"</span>,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(b); <span class="comment">//puts用于输出单个字符串，不能像printf格式化输出，会自动添加换行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,c);<span class="comment">//注意c没必要写成&amp;c，因为c本身就代表了数组的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c=%s\n"</span>,c);<span class="comment">//注意即使你输入的内容大于10，也能正确输出，但是下面的gets()函数却不行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//gets()函数，注意它是不安全的，因为接收的时候不知道它的大小容易造成溢出，建议不要使用</span></span><br><span class="line">    <span class="keyword">char</span> d[<span class="number">10</span>];</span><br><span class="line">    gets(d); <span class="comment">//gets一次只能接收一个字符串，但是scanf可接收多个；scanf不能接收空格、tab，gets则可以</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"d=%s"</span>,d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> e[]=&#123;<span class="string">'K'</span>,<span class="string">'s'</span>,<span class="string">'\0'</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lu"</span>,<span class="built_in">strlen</span>(e)); <span class="comment">//结果是：2，不是3，因为\0不计入长度</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">char</span> f[]=&#123;<span class="string">"Kenshin"</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lu"</span>,<span class="built_in">strlen</span>(f)); <span class="comment">//结果是：7</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> g[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(g,<span class="string">"hello,world!"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,g); <span class="comment">//结果是：hello,即使定义的g长度为5，但是也能完全拷贝进去</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">char</span> h[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">char</span> i[]=&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'\0'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>,<span class="string">'\0'</span>&#125;;</span><br><span class="line">    <span class="built_in">strcpy</span>(h,i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,h); <span class="comment">//结果是：abc,遇到第一个\0则结束</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcat</span>(i,<span class="string">"ghi"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,i); <span class="comment">//结果是：abcghi,注意不是abcdefghi,strcat，从i第一\0开始使用“ghi”覆盖，覆盖完之后加上一个\0,在内存中目前应该是：&#123;'a','b','c','g','h','i','\0','f','\0'&#125;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> j[]=<span class="string">"abc"</span>;</span><br><span class="line">    <span class="keyword">char</span> k[]=<span class="string">"aBc"</span>;</span><br><span class="line">    <span class="keyword">char</span> l[]=<span class="string">"acb"</span>;</span><br><span class="line">    <span class="keyword">char</span> m[]=&#123;<span class="string">'a'</span>,<span class="string">'\0'</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,%d,%d"</span>,<span class="built_in">strcmp</span>(j,k),<span class="built_in">strcmp</span>(k,l),<span class="built_in">strcmp</span>(l,m));<span class="comment">//遇到第一个不相同的字符或\0则返回两者前后之差，结果：32,-33,99</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>1.在Xcode中会提示gets是不安全的，推荐使用fgets()。<br>2.strlen()只用于计算字符串长度，由于在C语言中字符串使用字符数组长度表示，所以它可以计算带有’\0’结尾的字符数组长度，但是它并不能计算其他类型的数组长度。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://www.cnblogs.com/kenshincui/p/3843505.html">reference</a></p>
<h2 id="C语言之数组和字符串">C语言之数组和字符串</h2><h3 id="概览">概览</h3><p>数组在C语言中有着特殊的地位，它有很多特性，例如它的存储是连续的，数组的名称就是数组的地址等。而在C语言中是没有String类型的，那么如果要表示一个字符串，就必须使用字符数组。今天主要就介绍如下三个方面：</p>
<ul>
<li>一维数组</li>
<li>多维数组</li>
<li>字符串</li>
</ul>
<h3 id="一维数组">一维数组</h3><p>一维数组操作比较简单，但是需要注意，数组长度必须是固定的，长度不能使用变量进行初始化；如果声明的同时进行赋值则数组长度可以省略，编译器会自动计算数组长度；同时数组不能先声明再一次性赋值（当然可以对每个元素一一赋值）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//int a[len] = &#123; 1, 2&#125;;//错误,不能使变量</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">2</span>];<span class="comment">//正确</span></span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//a[2] = 3;//超过数组长度，但是编译器并不会检查，运行报错</span></span><br><span class="line">    <span class="keyword">int</span> b[<span class="string">'a'</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//'a'=97，所以可以作为数组长度，但是后面的元素没有初始化，其值默认为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">97</span>; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"b[%d]=%d\n"</span>,i,b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> c[<span class="number">2</span> * <span class="number">3</span>];<span class="comment">//2*3是固定值可以作为数组长度</span></span><br><span class="line">    <span class="keyword">int</span> d[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;<span class="comment">//如果初始化的同时赋值则数组长度可以省略，当前个数为3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="C" scheme="http://ytlvy.com/tags/C/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C programming -- pointer]]></title>
    <link href="http://ytlvy.com/2015/08/22/C-programming-pointer/"/>
    <id>http://ytlvy.com/2015/08/22/C-programming-pointer/</id>
    <published>2015-08-22T12:43:37.000Z</published>
    <updated>2015-08-22T12:44:09.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/kenshincui/p/3848442.html" target="_blank" rel="external">reference</a></p>
<h2 id="C语言之指针">C语言之指针</h2><h3 id="概览">概览</h3><p>指针是C语言的精髓，但是很多初学者往往对于指针的概念并不深刻，以至于学完之后随着时间的推移越来越模糊，感觉指针难以掌握，本文通过简单的例子试图将指针解释清楚，今天的重点有几个方面：</p>
<ul>
<li>什么是指针</li>
<li>数组和指针</li>
<li>函数指针</li>
</ul>
<h3 id="什么是指针">什么是指针</h3><p>存放变量地址的变量我们称之为“指针变量”,简单的说变量p中存储的是变量a的地址,那么p就可以称为是指针变量,或者说p指向a。当我们访问a变量的时候其实是程序先根据a取得a对应的地址，再到这个地址对应的存储空间中拿到a的值，这种方式我们称之为“直接引用”；而当我们通过p取得a的时候首先要先根据p转换成p对应的存储地址，再根据这个地址到其对应的存储空间中拿到存储内容，它的内容其实就是a的地址，然后根据这个地址到对应的存储空间中取得对应的内容，这个内容就是a的值，这种通过p找到a对应地址再取值的方式成为“间接引用”。这里以表格形式列出a和p的存储以帮助大家理解上面说的内容：</p>
<p><img src="http://images.cnitblog.com/blog/62046/201407/161307139741921.png" alt=""></p>
<a id="more"></a>
<p>接下来，看一下指针的赋值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  Point</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-7-05.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    p=&amp;a; <span class="comment">//也可以直接给指针变量赋值：int *p=&amp;a;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"address(a)=%x,address(p)=%x\n"</span>,&amp;a,p); <span class="comment">//结果：address(a)=5fbff81c,address(p)=5fbff81c</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d,p=%d\n"</span>,a,*p); <span class="comment">//结果：a=1,p=1</span></span><br><span class="line">    *p=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d,*p=%d\n"</span>,a,*p); <span class="comment">//结果：a=2,p=2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">8</span>;</span><br><span class="line">    <span class="keyword">char</span> c= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> *q=&amp;c;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"address(b)=%x,address(c)=%x\n"</span>,&amp;b,&amp;c);<span class="comment">//结果：</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c=%d,q=%d\n"</span>, c, *q); <span class="comment">//结果：c=1,q=2049，为什么q的值不是1呢？</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要说明两点：</p>
<p>a. int <em>p;中的</em>只是表示p变量是一个指针变量；而打印<em>p的时候，</em>p中的<em>是操作符，表示p指针指向的变量的存储空间（当前存储就是1），同时我们也看到了</em>p==a；修改了*p也就是修改了p指向的存储空间的内容，也就修改了a，所以第二次打印a=2;</p>
<p>b. 指针所指向的类型必须和定义指针时声明的类型相同；上面指针q定义成了int型而指向了char型，结果输出*q打印出了2049，具体原因见下图（假设在16位编译器下，指针长度为2字节）</p>
<p><img src="http://images.cnitblog.com/blog/62046/201407/161307173968575.png" alt=""></p>
<p>由于局部变量是存储在栈里面的，所以先存储b再存储a、p，当打印<em>p的时候，其实就是以p指向的地址对应的空间开始取两个字节的数据（因为定义p的时候它指向的是int型，在16位编译器下int类型的长度为2），刚好定义的b和c空间连续，所以就取到b的其中一个字节，最后</em>p二进制存储为“0000100000000001”（见上图黄色背景内容），十进制表示就是2049；</p>
<p>c. 指针变量占用的空间和它所指向的变量类型无关，只跟编译器位数有关（准确的说只跟寻址方式有关）；</p>
<h3 id="数组和指针">数组和指针</h3><p>由于数组的存储是连续的，数组名就是数组的地址，这样一来数组和指针就有着很微妙的关系，先看以下例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  Point</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-7-05.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeValue</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line">    a[<span class="number">0</span>]=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeValue2</span><span class="params">(<span class="keyword">int</span> *p)</span></span>&#123;</span><br><span class="line">    p[<span class="number">0</span>]=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *p=&amp;a[<span class="number">0</span>]; <span class="comment">//等价于：*p=a;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"len=%lu\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">//取得int长度为2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//指针加1代表地址向后挪动所指向类型的长度位（这里类型是int，长度为2）</span></span><br><span class="line">    <span class="comment">//也就是说p指向a[0],p+1指向a[1]，以此类推，所以我们通过指针也可以取出数组元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)&#123;</span><br><span class="line">        <span class="comment">//printf("a[%d]=%d\n",i,a[i]);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a[%d]=%d\n"</span>,i,*(p+i));<span class="comment">//由于a就代表数组的地址，其实这里还可以写成*(a+i),但是注意这里*(p+i)可以写成*(p++),但是*(a+i)不能写成*(a++),因为数组名是常量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*输出结果：</span><br><span class="line">     a[0]=1</span><br><span class="line">     a[1]=2</span><br><span class="line">     a[2]=3</span><br><span class="line">     */</span></span><br><span class="line">     </span><br><span class="line">    </span><br><span class="line">    changeValue(p); <span class="comment">//等价于：changeValue(a)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a[%d]=%d\n"</span>,i,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*输出结果：</span><br><span class="line">     a[0]=2</span><br><span class="line">     a[1]=2</span><br><span class="line">     a[2]=3</span><br><span class="line">     */</span></span><br><span class="line">    </span><br><span class="line">    changeValue2(a); <span class="comment">//等价于：changeValue2(p)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a[%d]=%d\n"</span>,i,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*输出结果：</span><br><span class="line">     a[0]=3</span><br><span class="line">     a[1]=2</span><br><span class="line">     a[2]=3</span><br><span class="line">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的例子我们可以得出如下结论：</p>
<ul>
<li>数组名a==&amp;a[0]==*p；</li>
<li>如果p指向一个数组，那么p+1指向数组的下一个元素，同时注意p+1移动的长度并不固定，具体需要根据p指向的数据类型而定；</li>
<li>指针可以写成p++形式，但是数组名不可以，因为数组名是常量</li>
<li>不管函数的形参为数组还是指针，实参都可以使用数组名或指针；</li>
</ul>
<h4 id="扩展—字符串和指针">扩展—字符串和指针</h4><p>由于在C语言中字符串就是字符数组，下面不妨看一下字符串和数组的关系：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  Point</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin on 14-7-05.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[]=<span class="string">"Kenshin"</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%x,%s\n"</span>,a,a);<span class="comment">//结果：5fbff820,Kenshin，同一个变量a是输出字符串还是输出地址，根据格式参数而定</span></span><br><span class="line">    <span class="built_in">printf</span>(a); <span class="comment">//结果：Kenshin</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> b[]=<span class="string">"Kenshin"</span>;</span><br><span class="line">    <span class="keyword">char</span> *p=b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"b=%s,p=%s\n"</span>,b,p);<span class="comment">//结果：b=Kenshin,p=Kenshin</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//指针存储的是地址，而数组名存储的也是地址，既然字符数组可以表示字符串，那么指向字符的指针同样也可以，如下方式可以更简单的定义一个字符串</span></span><br><span class="line">    <span class="keyword">char</span> *c=<span class="string">"Kenshin"</span>; <span class="comment">//等价于char c[]="Kenshin";</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c=%s\n"</span>,c); <span class="comment">//结果：c=Kenshin</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上代码中注释基本已经很清楚了，这里需要指出是为什么printf(a)能够直接输出字符串呢？</p>
<p>我们看一下printf()的定义:int     printf(const char * <strong>restrict, …) </strong>printflike(1, 2);</p>
<p>其实printf的参数要求是指向字符类型的指针，而结合上面的例子和我们之前说的，如果函数形参是指针类型那么可以传入函数名，因此也就能正确输出字符串的内容了。类似的还有上一篇文章中说的strcat()、strcpy()等函数均是如此。</p>
<h3 id="函数指针">函数指针</h3><p>在弄清函数指针的问题之前，我们不妨先来看一下返回指针类型数据的函数，毕竟指针类型也是C语言的数据类型，下面以一个字符串转换为大写字符的程序为例，在这个例子中不仅可以看到返回值为指针类型的函数同时还可以看到前面说到的指针移动操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  Point</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-06-28.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> * toUpper(<span class="keyword">char</span> *a)&#123;</span><br><span class="line">    <span class="keyword">char</span> *b=a; <span class="comment">//保留最初地址，因为后面的循环会改变字符串最初地址</span></span><br><span class="line">    <span class="keyword">int</span> len=<span class="string">'a'</span>-<span class="string">'A'</span>; <span class="comment">//大小写ASCII码差值相等</span></span><br><span class="line">    <span class="keyword">while</span> (*a!=<span class="string">'\0'</span>) &#123; <span class="comment">//字符是否结束</span></span><br><span class="line">        <span class="keyword">if</span>(*a&gt;<span class="string">'a'</span>&amp;&amp;*a&lt;<span class="string">'z'</span>)&#123;<span class="comment">//如果是小写字符</span></span><br><span class="line">            *(a++) -= len; <span class="comment">//*a表示数组对应的字符（-32变为小写），a++代表移动到下一个字符</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">       <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[]=<span class="string">"hello"</span>;</span><br><span class="line">    <span class="keyword">char</span> *p=toUpper(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,p); <span class="comment">//结果：HELLO</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大家都是知道函数只能有一个返回值，如果需要返回多个值，怎么办，其实很简单，只要将指针作为函数参数传递就可以了，在下面的例子中我们再次看到指针作为参数进行传递。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  Point</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-6-28.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operate</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> *c)</span></span>&#123;</span><br><span class="line">    *c=a-b;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>,c,d;</span><br><span class="line">    d=operate(a, b, &amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a+b=%d,a-b=%d\n"</span>,d,c);<span class="comment">//结果：a+b=3,a-b=-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数也是在内存中存储的，当然函数也有一个起始地址（事实上函数名就是函数的起始地址），这里同样需要弄清函数指针的关系。函数指针定义的形式：返回值类型 (*指针变量名)(形参1，形参2)，拿到函数指针其实我们就相当于拿到了这个函数，函数的操作都可以通过指针来完成，而且通过前面的例子可以看到指针作为C语言的数据类型，可以作为参数、作为返回值，那么当然函数指针同样可以作为函数的参数和返回值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  Point</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-6-28.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数指针作为参数进行传递</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operate</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> (*p)</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p(a,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> (*p)(<span class="keyword">int</span> ,<span class="keyword">int</span>)=sum;<span class="comment">//函数名就是函数首地址,等价于：int (*p)(int,int);p=sum;</span></span><br><span class="line">    <span class="keyword">int</span> c=p(a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a+b=%d\n"</span>,c); <span class="comment">//结果：a+b=3</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//函数作为参数传递</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,operate(a, b, sum)); <span class="comment">//结果：3</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,operate(a, b, sub)); <span class="comment">//结果：-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数指针可以作为函数参数进行传递，实在太强大了，是不是想起了C#中的委托？记得C#书籍中经常提到委托类似于函数指针，其实说的就是上面的情况。需要注意的是，普通的指针可以写成p++进行移动，而函数指针写成p++并没有意义。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://www.cnblogs.com/kenshincui/p/3848442.html">reference</a></p>
<h2 id="C语言之指针">C语言之指针</h2><h3 id="概览">概览</h3><p>指针是C语言的精髓，但是很多初学者往往对于指针的概念并不深刻，以至于学完之后随着时间的推移越来越模糊，感觉指针难以掌握，本文通过简单的例子试图将指针解释清楚，今天的重点有几个方面：</p>
<ul>
<li>什么是指针</li>
<li>数组和指针</li>
<li>函数指针</li>
</ul>
<h3 id="什么是指针">什么是指针</h3><p>存放变量地址的变量我们称之为“指针变量”,简单的说变量p中存储的是变量a的地址,那么p就可以称为是指针变量,或者说p指向a。当我们访问a变量的时候其实是程序先根据a取得a对应的地址，再到这个地址对应的存储空间中拿到a的值，这种方式我们称之为“直接引用”；而当我们通过p取得a的时候首先要先根据p转换成p对应的存储地址，再根据这个地址到其对应的存储空间中拿到存储内容，它的内容其实就是a的地址，然后根据这个地址到对应的存储空间中取得对应的内容，这个内容就是a的值，这种通过p找到a对应地址再取值的方式成为“间接引用”。这里以表格形式列出a和p的存储以帮助大家理解上面说的内容：</p>
<p><img src="http://images.cnitblog.com/blog/62046/201407/161307139741921.png" alt=""></p>]]>
    
    </summary>
    
      <category term="C" scheme="http://ytlvy.com/tags/C/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C programming -- memory & scope]]></title>
    <link href="http://ytlvy.com/2015/08/22/C-programming-memory-scope/"/>
    <id>http://ytlvy.com/2015/08/22/C-programming-memory-scope/</id>
    <published>2015-08-22T12:36:41.000Z</published>
    <updated>2015-08-22T12:44:35.000Z</updated>
    <content type="html"><![CDATA[<p>@charset “UTF-8”;<br>/**</p>
<ul>
<li></li>
<li>@authors yanjie Guo (ytlvy2008@gmail.com)</li>
<li>@date    2015-08-15 16:02:00</li>
<li>@version $Id$</li>
<li>Copyright (c) 2015年 Guo yanjie. All rights reserved.</li>
<li>*/</li>
</ul>
<h2 id="概述">概述</h2><p>基本上每种语言都要讨论这个话题，C语言也不例外，因为只有你完全了解每个变量或函数存储方式、作用范围和销毁时间才可能正确的使用这门语言。今天将着重介绍C语言中变量作用范围、存储方式、生命周期、作用域和可访问性。</p>
<ul>
<li>变量作用范围</li>
<li>存储方式</li>
<li>可访问性</li>
</ul>
<h3 id="变量作用范围">变量作用范围</h3><p>在C语言中变量从作用范围包括全局变量和局部变量。全局变量在定义之后所有的函数中均可以使用，只要前面的代码修改了，那么后面的代码中再使用就是修改后的值；局部变量的作用范围一般在一个函数内部（通常在一对大括号{}内），外面的程序无法访问它，它却可以访问外面的变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  ScopeAndLifeCycle</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-7-12.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d\n"</span>,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">1</span>;</span><br><span class="line">    changeValue(); <span class="comment">//结果：a=2</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d,b=%d\n"</span>,a,b); <span class="comment">//结果：a=2,b=1 ，因为changeValue修改了这个全局变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="变量存储方式">变量存储方式</h3><p>C语言的强大之处在于它能直接操作内存（指针），但是要完全熟悉它的操作方式我们必须要弄清它的存储方式。存储变量的位置分为：普通内存(静态存储区)、运行时堆栈（动态存储区）、硬件寄存器（动态存储区），当然这几种存储的效率是从低到高的。而根据存储位置的不同在C语言中又可以将变量依次分为：静态变量、自动变量、寄存器变量。</p>
<h4 id="静态变量">静态变量</h4><p>首先说一下存储在普通内存中的静态变量，全局变量和使用static声明的局部变量都是静态变量，在系统运行过程中只初始化一次（在下面的例子中虽然变量b是局部变量，在外部无法访问，但是他的生命周期一直延续到程序结束，而变量c则在第一次执行完就释放，第二次执行时重新创建）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  2.1.c</span></span><br><span class="line"><span class="comment">//  ScopeAndLifeCycle</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-7-12.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>; <span class="comment">//全局变量存储在静态内存中，只初始化一次</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b=<span class="number">1</span>; <span class="comment">//静态变量存储在静态内存中，第二次调用不会再进行初始化</span></span><br><span class="line">    <span class="keyword">int</span> c=<span class="number">1</span>;</span><br><span class="line">    ++b;</span><br><span class="line">    a+=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d,b=%d,c=%d\n"</span>,a,b,c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    showMessage(); <span class="comment">//结果：a=3,b=2,c=1</span></span><br><span class="line">    showMessage(); <span class="comment">//结果：a=5,b=3,c=1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自动变量">自动变量</h4><p>被关键字auto修饰的局部变量是自动变量，但是auto关键字可以省略，因此可以得出结论：所有没有被static修饰的局部变量都是自动变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  1.3.c</span></span><br><span class="line"><span class="comment">//  ScopeAndLifeCycle</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-7-12.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> <span class="keyword">int</span> b=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d,b=%d\n"</span>,a,b); <span class="comment">//结果：a=1,b=2 ，a和b都是自动变量，auto可以省略</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//需要注意的是，上面的自动变量是存储在栈中，其实还可以存储到堆中</span></span><br><span class="line">    <span class="keyword">char</span> c[] = <span class="string">"hello,world!"</span>;</span><br><span class="line">    <span class="keyword">long</span> len = <span class="built_in">strlen</span>(c) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>) + <span class="number">1</span>;<span class="comment">//之所以加1是因为字符串后面默认有一个\0空操作符不计算在长度内</span></span><br><span class="line">    <span class="keyword">char</span> *p=NULL;<span class="comment">//可以直接写成：char *p;</span></span><br><span class="line">    p=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(len);<span class="comment">//分配指定的字节存放c中字符串，注意由于malloc默认返回“void *”需要转化</span></span><br><span class="line">    <span class="built_in">memset</span>(p,<span class="number">0</span>,len);<span class="comment">//清空指向内存中的存储内容，因为分配的内存是随机的，如果不清空可能会因为垃圾数据产生不必要的麻烦</span></span><br><span class="line">    <span class="built_in">strcpy</span>(p,c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"p=%s\n"</span>,p);<span class="comment">//结果：p=hello,world!</span></span><br><span class="line">    <span class="built_in">free</span>(p);<span class="comment">//释放分配的空间</span></span><br><span class="line">    p=NULL;<span class="comment">//注意让p指向空，否则p将会是一个存储一个无用地址的野指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然存储自动变量的栈和堆其实是两个完全不同的空间（虽然都在运行时有效的空间内）：栈一般是程序自动分配，其存储结果类似于数据结构中的栈，先进后出，程序结束时由编译器自动释放；而堆则是开发人员手动编码分配，如果不进行手动释放就只有等到程序运行完操作系统回收，其存储结构类似于链表。在上面的代码中p变量同样是一个自动变量，同样可以使用auto修饰，只是它所指向的内容放在堆上（p本身存放在栈上）。</p>
<blockquote>
<p>这里说明几点：malloc分配的空间在逻辑上连续，物理上未必连续；p必须手动释放，否则直到程序运行结束它占用的内存将一直被占用；释放p的过程只是把p指向的空间释放掉，p中存放的地址并未释放，需要手动设置为NULL，否则这将是一个无用的野指针</p>
</blockquote>
<h4 id="寄存器变量">寄存器变量</h4><p>默认情况下无论是自动变量还是静态变量它们都在内存中，不同之处就是自动变量放在一块运行时分配的特殊内存中。但是寄存器变量却是在硬件寄存器中，从物理上来说它和内存处在两个完全不同的硬件中。大家都是知道寄存器存储空间很小，但是它的效率很高，那么合理使用寄存器变量就相当重要了。什么是寄存器变量呢？使用register修饰的int或char类型的非静态局部变量是寄存器变量。没错，需要三个条件支撑：register修饰、必须是int或char类型、必须是非静态局部变量。</p>
<p>除了存储位置不同外，寄存器变量完全符合自动变量的条件，因此它的生命周期其实是和自动变量完全一样的，当函数运行结束后它就会被自动释放。由于寄存器空间珍贵，因此我们需要合理使用寄存器变量，只有访问度很高的变量我们才考虑使用寄存器变量，如果过多的定义寄存器变量，当寄存器空间不够用时会自动转化为自动变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  1.3.c</span></span><br><span class="line"><span class="comment">//  ScopeAndLifeCycle</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-7-12.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d\n"</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面我们说到变量的存储类型，其实在C语言中还有两种存储类型：常量存储区和代码存储区，分别用于存储字符串常量、使用const修饰的全局变量以及二进制函数代码。</p>
</blockquote>
<h3 id="可访问性">可访问性</h3><p>在C语言中没有其他高级语言public、private等修饰符，来限定变量和函数的有效范围，但是却有两个类似的关键字能达到类似的效果：extern和static。</p>
<h4 id="extern">extern</h4><h5 id="extern作用于变量">extern作用于变量</h5><p>我们知道在C语言中变量的定义顺序是有严格要求的，要使用变量则必须在使用之前定义，extern用于声明一个已经存在的变量，这样一来即使在后面定义一个变量只要前面声明了，也同样可以使用。具体的细节通过下面的代码相信大家都可以看明白：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  2.1.c</span></span><br><span class="line"><span class="comment">//  ScopeAndLifeCycle</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-7-12.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果在main函数下面定义了一个变量a，如果在main上面不进行声明是无法在main中使用a的；</span></span><br><span class="line"><span class="comment">//同样如果只进行了extern声明不进行定义一样会报错，因为extern并不负责定义变量a而仅仅是声明一个已经定义过的变量；</span></span><br><span class="line"><span class="comment">//当然如果说在main上面定义int a;去掉main下面的定义同样是可以的，相当于在上面定义，但如果两个地方都定义a的话（main上面的extern去掉），则程序认为上面的定义是声明，只是省略了extern关键字；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种情况，在下面定义，不进行声明，报错</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d\n"</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种情况，在上面定义，正确</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d\n"</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种情况，在下面定义在上面声明，正确</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d\n"</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第四种情况，只在上面声明（编译时没有问题，因为上面的声明骗过了编译器，但运行时报错，因为extern只能声明一个已经定义的变量），错误</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d\n"</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第五种情况,上下同时定义（这种方式是正确的，因为上面的定义会被认为是省略了extern的声明），正确</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d\n"</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="comment">//其实下面的情况也是不会出错的</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d\n"</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第六种情况,将全局变量声明为局部变量，但是它的实质还是全局变量，正确</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d\n"</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第七种情况，在函数内部重新定义一个变量a,虽然不会报错，但是两个a不是同一个</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d\n"</span>,a);<span class="comment">//注意这里输出的a其实是内部定义的a，和函数外定义的a没有关系</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a;</span><br></pre></td></tr></table></figure></p>
<p>如果两个文件同时定义一个全局变量，那实质上他们指的是同一个变量。从下面的例子可以看出，在main.c中修改了变量a之后message.c中的变量a值也修改了。</p>
<p><img src="http://images.cnitblog.com/blog/62046/201407/182035555844911.png" alt=""></p>
<p>需要注意，在上面的代码中无论在message.h中将a定义前加上extern，还是在main.h中的a定以前加上extern结果都是一样的，extern同样适用。和在单文件中一样，不能两个定义都添加extern，否则就没有定义了。如果把message.c中a的定义（或声明）去掉呢，那么它能否访问main.c中的全局变量a呢，答案是否定的（这和在一个文件中定义了一个函数在另一个文件不声明就直接用是类似的）。</p>
<h5 id="extern作用于函数">extern作用于函数</h5><p>extern作用于函数就不再是简单的声明函数了，而是将这个函数作为外部函数（当然还有内部函数，下面会说到），在其他文件中也可以访问。但是大家应该已经注意到，在上面的代码中message.c中的showMessage前面并没有添加extern关键字，在main.c中不是照样访问吗？那是因为这个关键字是可以省略的，<strong>默认情况下所有的函数都是外部函数</strong>。</p>
<p><img src="http://images.cnitblog.com/blog/62046/201407/182035567245696.png" alt=""></p>
<p>和作用于变量不同，上面main.c和message.c中的extern都可以省略，在这里extern的作用就是定义或声明一个外部函数。从上面可以看到在不同的文件中可以定义同一个变量，它们被视为同一个变量，但是需要指出的是外部函数在一个程序中是不能重名的，否则会报错。</p>
<h4 id="static">static</h4><h5 id="static作用于变量">static作用于变量</h5><p>其实在前面的例子中我们已经看到static关键字在变量中的使用了，在例子中使用static定了一个局部变量，而且我们强调static局部变量在函数中只被初始化一次。那么如果static作用于全局变量是什么效果呢？如果<strong><em>static作用于全局变量它的作用就是定义一个只能在当前文件访问的全局变量，相等于私有全局变量</em></strong>。</p>
<p><img src="http://images.cnitblog.com/blog/62046/201407/182035581627924.png" alt=""></p>
<p>从上面的输出结果可以看出message.c中的变量a和main.c中的变量a并不是同一个变量，事实上message.c中的变量a只能在message.c中使用，虽然main.c中的变量a是全局变量但是就近原则，message.c会使用自己内部的变量a。当然，上面例子中main.c中的变量a定义成静态全局变量结果也是一样的，只是这样如果还有其他源文件就不能使用a变量了。但是main.c中的a不能声明成extern，因为main.c不能访问message.c中的变量a，这样在main.c中就没变量a的定义了。</p>
<h5 id="static作用于函数">static作用于函数</h5><p>static作用于函数和作用于变量其实是类似的，如果static作用于函数则这个函数就是内部函数，其他文件中的代码不可以访问。下面的代码在运行时会报错，因为mesage.c中的showMessage()函数是私有的，在main.c中尽管进行了声明，可以在编译阶段通过，但是在链接阶段会报错。</p>
<p><img src="http://images.cnitblog.com/blog/62046/201407/182035596461438.png" alt=""></p>
<h3 id="总结">总结</h3><p>最后做一下简单总结一下：</p>
<ol>
<li>extern作用于变量时用于声明一个已经定义的变量，但是并不能定义变量；使用extern你可以在其他文件中使用全局变量（当然此时extern可以省略）；</li>
<li>extern作用于函数时与它作用于全局变量有点类似，声明这个函数是外部函数，其他文件可以访问，但不同的是当它作用于函数时不仅可以声明函数还可以定义函数（用在函数定义前面），不管是定义还是声明都可以省略，C语言默认认为函数定义或声明都是外部函数；</li>
<li>static作用于变量时，该变量只会定义一次，以后在使用时不会重新定义，当static作用于全局变量时说明该变量只能在当前文件可以访问，其他文件中不能访问；</li>
<li>static作用于函数时与作用于全局变量类似，表示声明或定义该函数是内部函数（又叫静态函数），在该函数所在文件外的其他文件中无法访问此函数；</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>@charset “UTF-8”;<br>/**</p>
<ul>
<li></li>
<li>@authors yanjie Guo (ytlvy2008@gmail.com)</li>
<li>@date    2015-08-15 16:02:00</li>
<li>@version $Id$</li>
<li>Copyright (c) 2015年 Guo yanjie. All rights reserved.</li>
<li>*/</li>
</ul>
<h2 id="概述">概述</h2><p>基本上每种语言都要讨论这个话题，C语言也不例外，因为只有你完全了解每个变量或函数存储方式、作用范围和销毁时间才可能正确的使用这门语言。今天将着重介绍C语言中变量作用范围、存储方式、生命周期、作用域和可访问性。</p>
<ul>
<li>变量作用范围</li>
<li>存储方式</li>
<li>可访问性</li>
</ul>
<h3 id="变量作用范围">变量作用范围</h3><p>在C语言中变量从作用范围包括全局变量和局部变量。全局变量在定义之后所有的函数中均可以使用，只要前面的代码修改了，那么后面的代码中再使用就是修改后的值；局部变量的作用范围一般在一个函数内部（通常在一对大括号{}内），外面的程序无法访问它，它却可以访问外面的变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.c</span></span><br><span class="line"><span class="comment">//  ScopeAndLifeCycle</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Kenshin Cui on 14-7-12.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d\n"</span>,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">1</span>;</span><br><span class="line">    changeValue(); <span class="comment">//结果：a=2</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d,b=%d\n"</span>,a,b); <span class="comment">//结果：a=2,b=1 ，因为changeValue修改了这个全局变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="C" scheme="http://ytlvy.com/tags/C/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Big-endian && Little-endian]]></title>
    <link href="http://ytlvy.com/2015/08/22/Big-endian-Little-endian/"/>
    <id>http://ytlvy.com/2015/08/22/Big-endian-Little-endian/</id>
    <published>2015-08-22T12:32:13.000Z</published>
    <updated>2015-08-22T12:33:03.000Z</updated>
    <content type="html"><![CDATA[<h2 id="大端序与小端序">大端序与小端序</h2><h3 id="何为大端序，小端序？">何为大端序，小端序？</h3><p>简单点说，就是字节的存储顺序，如果数据都是单字节的，那怎么存储无所谓了，但是对于多字节数据，比如int，double等，就要考虑存储的顺序了。注意字节序是硬件层面的东西，对于软件来说通常是透明的。再说白一点，字节序通常只和你使用的处理器架构有关，而和编程语言无关，比如常见的Intel x86系列就是小端序。</p>
<h4 id="Big-endian（大端序）">Big-endian（大端序）</h4><p>数据的高位字节存放在地址的低端 低位字节存放在地址高端</p>
<h4 id="Little-endian（小端序）">Little-endian（小端序）</h4><p>数据的高位字节存放在地址的高端 低位字节存放在地址低端</p>
<h4 id="字节的高位与低位">字节的高位与低位</h4><p>举个例子，int a = 0x12345678 ; 那么左边12就是高位字节，右边的78就是低位字节，从左到右，由高到低，（注意，高低乃相对而言，比如56相对于78是高字节，相对于34是低字节）</p>
<p>地址的高端与低端<br>0x00000001<br>0x00000002<br>0x00000003<br>0x00000004<br>从上倒下，由低到高，地址值小的为低端，地址值大的为高端。</p>
<a id="more"></a>
<h3 id="不同字节序如何存储数据？">不同字节序如何存储数据？</h3><p>看看两种方式如何存储数据，假设从地址0x00000001处开始存储十六进制数0x12345678，那么</p>
<p>Bit-endian 如此存放(按原来顺序存储)<br>0x00000001           — 12<br>0x00000002           — 34<br>0x00000003           — 56<br>0x00000004           — 78</p>
<p>Little-endian 如此存放(颠倒顺序储存)<br>0x00000001           — 78<br>0x00000002           — 56<br>0x00000003           — 34<br>0x00000004           — 12</p>
<p>一个很好的记忆方法是，大端序是按照数字的书写顺序进行存储的，而小端序是颠倒书写顺序进行存储的。</p>
<h3 id="编程判断大端序和小端序">编程判断大端序和小端序</h3><p>方法一<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsBigEndian</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a =<span class="number">1</span> ; </span><br><span class="line">    <span class="keyword">if</span>(((<span class="keyword">char</span>*)&amp;a)[<span class="number">3</span>] ==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span> ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>打开VS的内存窗口，看一下a的存储方式，一目了然</p>
<p><img src="http://pic002.cnblogs.com/images/2011/64257/2011042122464910.png" alt=""></p>
<p>由于a是int，所以占四个字节，其值是00000001，存储方式如下。所以a[3]是0，不是大端序。一个更标准的写法是将a[3]替换为a[sizeof(int) - 1]。</p>
<p>0x0012FE88　　01<br>0x0012FE89　　00<br>0x0012FE8A　　00<br>0x0012FE8B　　00</p>
<p>方法二，使用union，原理见后面的面试题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsBigEndian</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">short</span> a ;</span><br><span class="line">        <span class="keyword">char</span> b ;</span><br><span class="line">    &#125; c;</span><br><span class="line"></span><br><span class="line">    c.a =<span class="number">0x0102</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(c.b ==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span> ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="一道面试题">一道面试题</h4><p>来道题巩固一下，下面代码输出什么？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> u &#123;</span><br><span class="line">    <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="keyword">char</span> x[<span class="number">2</span>] ;</span><br><span class="line">&#125; a ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    a.x[<span class="number">0</span>] =<span class="string">'1'</span> ;</span><br><span class="line">    a.x[<span class="number">1</span>] =<span class="string">'2'</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.i &lt;&lt; endl ;</span><br><span class="line"></span><br><span class="line">    getchar() ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个题，要看你使用的是什么系列的CPU，姑且假设是Intel系列的。Union是一个特殊的结构，其中所有成员共享结一个内存地址，任意时间只能存储一个成员，上面的Union大小为4个字节，所以上面的代码存储完字符1和2之后，Union的存储貌似应该是0x31320000，31和32分别是字符’1’和’2’的十六进制ASCII码（注意是字符1和2，而不是整数），但是Intel系列的CPU都是按照小端序存储的，所以，正确的顺序是0x00003231，对应的十进制数是12849，你答对了么？</p>
<p>关于字节序的详细内容，请看Wikipedia的介绍 <a href="http://en.wikipedia.org/wiki/Endianness" target="_blank" rel="external">http://en.wikipedia.org/wiki/Endianness</a></p>
<p>== Happy coding ==</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="大端序与小端序">大端序与小端序</h2><h3 id="何为大端序，小端序？">何为大端序，小端序？</h3><p>简单点说，就是字节的存储顺序，如果数据都是单字节的，那怎么存储无所谓了，但是对于多字节数据，比如int，double等，就要考虑存储的顺序了。注意字节序是硬件层面的东西，对于软件来说通常是透明的。再说白一点，字节序通常只和你使用的处理器架构有关，而和编程语言无关，比如常见的Intel x86系列就是小端序。</p>
<h4 id="Big-endian（大端序）">Big-endian（大端序）</h4><p>数据的高位字节存放在地址的低端 低位字节存放在地址高端</p>
<h4 id="Little-endian（小端序）">Little-endian（小端序）</h4><p>数据的高位字节存放在地址的高端 低位字节存放在地址低端</p>
<h4 id="字节的高位与低位">字节的高位与低位</h4><p>举个例子，int a = 0x12345678 ; 那么左边12就是高位字节，右边的78就是低位字节，从左到右，由高到低，（注意，高低乃相对而言，比如56相对于78是高字节，相对于34是低字节）</p>
<p>地址的高端与低端<br>0x00000001<br>0x00000002<br>0x00000003<br>0x00000004<br>从上倒下，由低到高，地址值小的为低端，地址值大的为高端。</p>]]>
    
    </summary>
    
      <category term="BASE" scheme="http://ytlvy.com/tags/BASE/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS NSNull Detect]]></title>
    <link href="http://ytlvy.com/2015/08/11/iOS-NSNull-Detect/"/>
    <id>http://ytlvy.com/2015/08/11/iOS-NSNull-Detect/</id>
    <published>2015-08-11T14:16:33.000Z</published>
    <updated>2015-08-11T14:16:53.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Object-C中nil,_NULL跟NSNull">Object-C中nil, NULL跟NSNull</h2><p>相信不少开发者，都被NSNull坑过，最常见的是服务器返回的json里面，说好的字典、数组、数字，结果返回的是空值。这个时候，NSJSONSerialization 会自动把他们换成 NSNull。当我们再去用dict[@“hello”]的时候，就会出触发exception，导致程序崩溃。</p>
<h3 id="最简单的做法">最简单的做法</h3><p>相信大家都知道，[NSNull null] 并不是一个工厂方法，而是一个单例模式，那么我们直接去判断赋值的这个指针是不是[NSNull null] 就好了。</p>
<p>那么问题来了，编译器会多了一个warning，很烦人。</p>
<p>在<a href="http://www.takingnotes.co/blog/2012/01/06/comparing-to-nsnull/" target="_blank" rel="external">这篇文章</a>里面介绍了各种做法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)someMethod </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">NSString</span> *aString = <span class="string">@"loremipsum"</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// This will complain: "Comparison of distinct pointer types ('NSString *' and 'NSNull *')" </span></span><br><span class="line">    <span class="keyword">if</span> (aString != [<span class="built_in">NSNull</span> null]) </span><br><span class="line">    &#123; </span><br><span class="line"> </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// This works (at least for strings), but isEqual: does different things  </span></span><br><span class="line">    <span class="comment">// for different classes, so it's not ideal </span></span><br><span class="line">    <span class="keyword">if</span> ([aString isEqual:[<span class="built_in">NSNull</span> null]]) </span><br><span class="line">    &#123; </span><br><span class="line"> </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// If you cast it to the class you're comparing against </span></span><br><span class="line">    <span class="comment">// then you're good to go </span></span><br><span class="line">    <span class="keyword">if</span> (aString != (<span class="built_in">NSString</span> *)[<span class="built_in">NSNull</span> null]) </span><br><span class="line">    &#123; </span><br><span class="line"> </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// But we can also just cast it to id and </span></span><br><span class="line">    <span class="comment">// that works generically </span></span><br><span class="line">    <span class="keyword">if</span> (aString != (<span class="keyword">id</span>)[<span class="built_in">NSNull</span> null]) </span><br><span class="line">    &#123; </span><br><span class="line"> </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// The thing that would be really cool, </span></span><br><span class="line">    <span class="comment">// would be [NSNull null] returning </span></span><br><span class="line">    <span class="comment">// id (like in the sample category below). </span></span><br><span class="line">    <span class="comment">// Wouldn't count on that one though. </span></span><br><span class="line">    <span class="keyword">if</span> (aString != [<span class="built_in">NSNull</span> idNull]) </span><br><span class="line">    &#123; </span><br><span class="line"> </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些都不是非常漂亮的解决方案，这篇文章的作者推荐：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSNull</span> (<span class="title">idNull</span>) </span></span><br><span class="line">+ (<span class="keyword">id</span>)idNull; </span><br><span class="line"><span class="keyword">@end</span> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSNull</span> (<span class="title">idNull</span>) </span></span><br><span class="line">+ (<span class="keyword">id</span>)idNull &#123; <span class="keyword">return</span> [<span class="built_in">NSNull</span> null]; &#125; </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>或者呢<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([[NSNull <span class="literal">null</span>] <span class="string">isEqual:</span>aString]) </span><br><span class="line">&#123; </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="最终解决方案">最终解决方案</h3><p>上面的做法，都需要判断一次，还是很不优雅，为什么呢，我们还是不能像NULL，nil一样，直接拿来用，还是需要判断一下，这里推荐一套最漂亮的作法。</p>
<p>陈航提供了一个<a href="https://gist.github.com/cyndibaby905/9828745" target="_blank" rel="external">gist</a><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#define NSNullObjects @[@<span class="title">""</span>,@0,@&#123;&#125;,@[]] </span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSNull</span> (<span class="title">InternalNullExtention</span>) </span></span><br><span class="line"><span class="keyword">@end</span> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSNull</span> (<span class="title">InternalNullExtention</span>) </span></span><br><span class="line"> </span><br><span class="line">- (<span class="built_in">NSMethodSignature</span>*)methodSignatureForSelector:(SEL)selector </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">NSMethodSignature</span>* signature = [<span class="keyword">super</span> methodSignatureForSelector:selector]; </span><br><span class="line">    <span class="keyword">if</span> (!signature) &#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSObject</span> *object <span class="keyword">in</span> <span class="built_in">NSNullObjects</span>) &#123; </span><br><span class="line">            signature = [object methodSignatureForSelector:selector]; </span><br><span class="line">            <span class="keyword">if</span> (signature) &#123; </span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line"> </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> signature; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation </span><br><span class="line">&#123; </span><br><span class="line">    SEL aSelector = [anInvocation selector]; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSObject</span> *object <span class="keyword">in</span> <span class="built_in">NSNullObjects</span>) &#123; </span><br><span class="line">        <span class="keyword">if</span> ([object respondsToSelector:aSelector]) &#123; </span><br><span class="line">            [anInvocation invokeWithTarget:object]; </span><br><span class="line">            <span class="keyword">return</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    [<span class="keyword">self</span> doesNotRecognizeSelector:aSelector]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>这里还提供一个日本人的封装方案：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"NSNull+OVNatural.h"</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSNull</span> (<span class="title">OVNatural</span>) </span></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:[invocation selector]]) &#123; </span><br><span class="line">        [invocation invokeWithTarget:<span class="keyword">self</span>]; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)selector </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *sig = [[<span class="built_in">NSNull</span> class] instanceMethodSignatureForSelector:selector]; </span><br><span class="line">    <span class="keyword">if</span>(sig == <span class="literal">nil</span>) &#123; </span><br><span class="line">        sig = [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="string">"@^v^c"</span>]; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> sig; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<h3 id="nil_判定">nil 判定</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断对象不空</span></span><br><span class="line"><span class="keyword">if</span>(object) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断对象为空</span></span><br><span class="line"><span class="keyword">if</span>(object == <span class="literal">nil</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组初始化，空值结束</span></span><br><span class="line"><span class="built_in">NSArray</span> *pageNames=[[<span class="built_in">NSArray</span> alloc] initWithObjects:<span class="string">@"DocumentList"</span>,<span class="string">@"AdvancedSearch"</span>,<span class="string">@"Statistics"</span>,<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断数组元素是否为空</span></span><br><span class="line"><span class="built_in">UIViewController</span> *controller=[<span class="built_in">NSArray</span> objectAtIndex:i];</span><br><span class="line"><span class="keyword">if</span>((<span class="built_in">NSNull</span> *)controller == [<span class="built_in">NSNull</span> null])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断字典对象的元素是否为空</span></span><br><span class="line"><span class="built_in">NSString</span> *userId=[<span class="built_in">NSDictionary</span> objectForKey:<span class="string">@"UserId"</span>];</span><br><span class="line"><span class="keyword">if</span>(userId == [<span class="built_in">NSNull</span> null])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Object-C中nil,_NULL跟NSNull">Object-C中nil, NULL跟NSNull</h2><p>相信不少开发者，都被NSNull坑过，最常见的是服务器返回的json里面，说好的字典、数组、数字，结果返回的是空值。这个时候，NSJSONSer]]>
    </summary>
    
      <category term="NSNULL" scheme="http://ytlvy.com/tags/NSNULL/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS APP Icon Longpress shake]]></title>
    <link href="http://ytlvy.com/2015/08/11/iOS-APP-Icon-Longpress-shake/"/>
    <id>http://ytlvy.com/2015/08/11/iOS-APP-Icon-Longpress-shake/</id>
    <published>2015-08-11T14:14:48.000Z</published>
    <updated>2015-08-11T14:15:15.000Z</updated>
    <content type="html"><![CDATA[<h2 id="iOS_APP图标长按抖动效果的实现（CAAnimation）">iOS APP图标长按抖动效果的实现（CAAnimation）</h2><p>实现效果:当长按图标时，图标抖动，点击图标以外区域时停止抖动</p>
<p><img src="http://img.blog.csdn.net/20150808181226925" alt=""></p>
<p>工程下载：<a href="https://github.com/Nongchaozhe/iconShakeDemo" target="_blank" rel="external">github工程下载</a></p>
<p>1) 视图代码</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIImageView</span> *imageView;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    imageView = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>)];</span><br><span class="line">    imageView<span class="variable">.center</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.center</span>;</span><br><span class="line">    imageView<span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"icon1"</span>];</span><br><span class="line">    imageView<span class="variable">.userInteractionEnabled</span> = <span class="literal">YES</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addSubview:imageView];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加长按手势</span></span><br><span class="line">    <span class="built_in">UILongPressGestureRecognizer</span> *recognize = [[<span class="built_in">UILongPressGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(longPress)];</span><br><span class="line">    <span class="comment">//长按响应时间</span></span><br><span class="line">    recognize<span class="variable">.minimumPressDuration</span> = <span class="number">1</span>;</span><br><span class="line">    [imageView addGestureRecognizer:recognize];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>2) 手势响应</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)longPress &#123;</span><br><span class="line">    <span class="built_in">CABasicAnimation</span> *animation = (<span class="built_in">CABasicAnimation</span> *)[imageView<span class="variable">.layer</span> animationForKey:<span class="string">@"rotation"</span>];</span><br><span class="line">    <span class="keyword">if</span> (animation == <span class="literal">nil</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> shakeImage];</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> resume];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果点击图标外区域，停止抖动</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="built_in">UITouch</span> *touch = [touches anyObject];</span><br><span class="line">    <span class="built_in">CGPoint</span> point = [touch locationInView:<span class="keyword">self</span><span class="variable">.view</span>];</span><br><span class="line">    <span class="comment">//转换坐标系，判断touch点是否在imageView内，在的话，仍然抖动，否则停止抖动</span></span><br><span class="line">    <span class="built_in">CGPoint</span> p = [<span class="keyword">self</span><span class="variable">.view</span> convertPoint:point toView:imageView];</span><br><span class="line">    <span class="keyword">if</span> (![imageView pointInside:p withEvent:event]) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"xxxxxxx"</span>);</span><br><span class="line">        [<span class="keyword">self</span> pause];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//layer.speed</span></span><br><span class="line"><span class="comment">/* The rate of the layer. Used to scale parent time to local time, e.g.</span><br><span class="line"> * if rate is 2, local time progresses twice as fast as parent time.</span><br><span class="line"> * Defaults to 1. */</span></span><br><span class="line"><span class="comment">//这个参数的理解比较复杂，我的理解是所在layer的时间与父layer的时间的相对速度，为1时两者速度一样，为2那么父layer过了一秒，而所在layer过了两秒（进行两秒动画）,为0则静止。</span></span><br><span class="line">- (<span class="keyword">void</span>)pause &#123;</span><br><span class="line">    imageView<span class="variable">.layer</span><span class="variable">.speed</span> = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)resume &#123;</span><br><span class="line">    imageView<span class="variable">.layer</span><span class="variable">.speed</span> = <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3) 动画设置<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>shakeImage &#123;</span><br><span class="line">    <span class="comment">//创建动画对象,绕Z轴旋转</span></span><br><span class="line">    CABasicAnimation <span class="built_in">*</span>animation = [CABasicAnimation animationWithKeyPath:@<span class="string">"transform.rotation.z"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置属性，周期时长</span></span><br><span class="line">    [animation setDuration:<span class="number">0.08</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//抖动角度</span></span><br><span class="line">    animation.fromValue = @<span class="params">(-M_1_<span class="literal">PI</span>/<span class="number">2</span>)</span>;</span><br><span class="line">    animation.toValue = @<span class="params">(M_1_<span class="literal">PI</span>/<span class="number">2</span>)</span>;</span><br><span class="line">    <span class="comment">//重复次数，无限大</span></span><br><span class="line">    animation.repeatCount = HUGE_VAL;</span><br><span class="line">    <span class="comment">//恢复原样</span></span><br><span class="line">    animation.autoreverses = YES;</span><br><span class="line">    <span class="comment">//锚点设置为图片中心，绕中心抖动</span></span><br><span class="line">    imageView.layer.anchorPoint = CGPointMake<span class="params">(<span class="number">0.5</span>, <span class="number">0.5</span>)</span>;</span><br><span class="line"></span><br><span class="line">    [imageView.layer addAnimation:animation forKey:@<span class="string">"rotation"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="iOS_APP图标长按抖动效果的实现（CAAnimation）">iOS APP图标长按抖动效果的实现（CAAnimation）</h2><p>实现效果:当长按图标时，图标抖动，点击图标以外区域时停止抖动</p>
<p><img src="http://img.blog.csdn.net/20150808181226925" alt=""></p>
<p>工程下载：<a href="https://github.com/Nongchaozhe/iconShakeDemo">github工程下载</a></p>
<p>1) 视图代码</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIImageView</span> *imageView;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    imageView = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>)];</span><br><span class="line">    imageView<span class="variable">.center</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.center</span>;</span><br><span class="line">    imageView<span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"icon1"</span>];</span><br><span class="line">    imageView<span class="variable">.userInteractionEnabled</span> = <span class="literal">YES</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addSubview:imageView];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加长按手势</span></span><br><span class="line">    <span class="built_in">UILongPressGestureRecognizer</span> *recognize = [[<span class="built_in">UILongPressGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(longPress)];</span><br><span class="line">    <span class="comment">//长按响应时间</span></span><br><span class="line">    recognize<span class="variable">.minimumPressDuration</span> = <span class="number">1</span>;</span><br><span class="line">    [imageView addGestureRecognizer:recognize];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Animation" scheme="http://ytlvy.com/tags/Animation/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS Music Background Play And Lock Screen Image]]></title>
    <link href="http://ytlvy.com/2015/08/11/iOS-Music-Background-Play-And-Lock-Screen-Image/"/>
    <id>http://ytlvy.com/2015/08/11/iOS-Music-Background-Play-And-Lock-Screen-Image/</id>
    <published>2015-08-11T14:13:28.000Z</published>
    <updated>2015-08-11T14:14:04.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/zsk_zane/article/details/47320621" target="_blank" rel="external">reference</a></p>
<h2 id="iOS_音乐后台播放及锁屏信息显示">iOS 音乐后台播放及锁屏信息显示</h2><p>实现音乐的后台播放，以及播放时，可以控制其暂停，下一首等操作，以及锁屏图片歌曲名等的显示<br>此实例需要真机调试，效果图如下： </p>
<p><img src="http://img.blog.csdn.net/20150806175143383" alt=""></p>
<p>工程下载：<a href="https://github.com/Nongchaozhe/MusicRemoteControl" target="_blank" rel="external">github工程下载</a></p>
<h3 id="实现步骤：">实现步骤：</h3><p>1) 首先修改info.plist</p>
<p><img src="http://img.blog.csdn.net/20150806174938474" alt=""></p>
<p>2) 其次引入两个需要的框架</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;AVFoundation/AVFoundation.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;MediaPlayer/MediaPlayer.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>3) 设置播放器及后台播放</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"><span class="comment">//    设置后台播放</span></span><br><span class="line">    [[<span class="built_in">AVAudioSession</span> sharedInstance] setCategory:<span class="built_in">AVAudioSessionCategoryPlayback</span> error:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//    设置播放器</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> fileURLWithPath:[[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"那些花儿"</span> ofType:<span class="string">@"mp3"</span>] ];</span><br><span class="line">    _player = [[<span class="built_in">AVPlayer</span> alloc] initWithURL:url];</span><br><span class="line">    [_player play];</span><br><span class="line">    _isPlayingNow = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后台播放显示信息设置</span></span><br><span class="line">    [<span class="keyword">self</span> setPlayingInfo];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - 接收方法的设置</span></span><br><span class="line">- (<span class="keyword">void</span>)remoteControlReceivedWithEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="keyword">if</span> (event<span class="variable">.type</span> == <span class="built_in">UIEventTypeRemoteControl</span>) &#123;  <span class="comment">//判断是否为远程控制</span></span><br><span class="line">        <span class="keyword">switch</span> (event<span class="variable">.subtype</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span>  <span class="built_in">UIEventSubtypeRemoteControlPlay</span>:</span><br><span class="line">                <span class="keyword">if</span> (!_isPlayingNow) &#123;</span><br><span class="line">                    [_player play];</span><br><span class="line">                &#125;</span><br><span class="line">                _isPlayingNow = !_isPlayingNow;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlPause</span>:</span><br><span class="line">                <span class="keyword">if</span> (_isPlayingNow) &#123;</span><br><span class="line">                    [_player pause];</span><br><span class="line">                &#125;</span><br><span class="line">                _isPlayingNow = !_isPlayingNow;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlNextTrack</span>:</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"下一首"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlPreviousTrack</span>:</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"上一首 "</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>4) 设置后台播放时显示的东西，例如歌曲名字，图片等</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setPlayingInfo &#123;</span><br><span class="line"><span class="comment">//    &lt;MediaPlayer/MediaPlayer.h&gt;</span></span><br><span class="line">    <span class="built_in">MPMediaItemArtwork</span> *artWork = [[<span class="built_in">MPMediaItemArtwork</span> alloc] initWithImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"pushu.jpg"</span>]];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSDictionary</span> *dic = @&#123;<span class="built_in">MPMediaItemPropertyTitle</span>:<span class="string">@"那些花儿"</span>,</span><br><span class="line">                          <span class="built_in">MPMediaItemPropertyArtist</span>:<span class="string">@"朴树"</span>,</span><br><span class="line">                          <span class="built_in">MPMediaItemPropertyArtwork</span>:artWork</span><br><span class="line">                          &#125;;</span><br><span class="line">    [[<span class="built_in">MPNowPlayingInfoCenter</span> defaultCenter] setNowPlayingInfo:dic];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5) 远程控制设置</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (void)<span class="tag">viewDidAppear</span>:(BOOL)<span class="tag">animated</span> &#123;</span><br><span class="line"><span class="comment">//    接受远程控制</span></span><br><span class="line">    <span class="attr_selector">[self becomeFirstResponder]</span>;</span><br><span class="line">    <span class="attr_selector">[[UIApplication sharedApplication]</span> <span class="tag">beginReceivingRemoteControlEvents</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">-</span> (void)<span class="tag">viewDidDisappear</span>:(BOOL)<span class="tag">animated</span> &#123;</span><br><span class="line"><span class="comment">//    取消远程控制</span></span><br><span class="line">    <span class="attr_selector">[self resignFirstResponder]</span>;</span><br><span class="line">    <span class="attr_selector">[[UIApplication sharedApplication]</span> <span class="tag">endReceivingRemoteControlEvents</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://blog.csdn.net/zsk_zane/article/details/47320621">reference</a></p>
<h2 id="iOS_音乐后台播放及锁屏信息显示">iOS 音乐后台播放及锁屏信息显示</h2><p>实现音乐的后台播放，以及播放时，可以控制其暂停，下一首等操作，以及锁屏图片歌曲名等的显示<br>此实例需要真机调试，效果图如下： </p>
<p><img src="http://img.blog.csdn.net/20150806175143383" alt=""></p>
<p>工程下载：<a href="https://github.com/Nongchaozhe/MusicRemoteControl">github工程下载</a></p>
<h3 id="实现步骤：">实现步骤：</h3><p>1) 首先修改info.plist</p>
<p><img src="http://img.blog.csdn.net/20150806174938474" alt=""></p>
<p>2) 其次引入两个需要的框架</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;AVFoundation/AVFoundation.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;MediaPlayer/MediaPlayer.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>3) 设置播放器及后台播放</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"><span class="comment">//    设置后台播放</span></span><br><span class="line">    [[<span class="built_in">AVAudioSession</span> sharedInstance] setCategory:<span class="built_in">AVAudioSessionCategoryPlayback</span> error:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//    设置播放器</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> fileURLWithPath:[[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"那些花儿"</span> ofType:<span class="string">@"mp3"</span>] ];</span><br><span class="line">    _player = [[<span class="built_in">AVPlayer</span> alloc] initWithURL:url];</span><br><span class="line">    [_player play];</span><br><span class="line">    _isPlayingNow = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后台播放显示信息设置</span></span><br><span class="line">    [<span class="keyword">self</span> setPlayingInfo];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark - 接收方法的设置</span></span><br><span class="line">- (<span class="keyword">void</span>)remoteControlReceivedWithEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="keyword">if</span> (event<span class="variable">.type</span> == <span class="built_in">UIEventTypeRemoteControl</span>) &#123;  <span class="comment">//判断是否为远程控制</span></span><br><span class="line">        <span class="keyword">switch</span> (event<span class="variable">.subtype</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span>  <span class="built_in">UIEventSubtypeRemoteControlPlay</span>:</span><br><span class="line">                <span class="keyword">if</span> (!_isPlayingNow) &#123;</span><br><span class="line">                    [_player play];</span><br><span class="line">                &#125;</span><br><span class="line">                _isPlayingNow = !_isPlayingNow;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlPause</span>:</span><br><span class="line">                <span class="keyword">if</span> (_isPlayingNow) &#123;</span><br><span class="line">                    [_player pause];</span><br><span class="line">                &#125;</span><br><span class="line">                _isPlayingNow = !_isPlayingNow;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlNextTrack</span>:</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"下一首"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlPreviousTrack</span>:</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"上一首 "</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Audio" scheme="http://ytlvy.com/tags/Audio/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS Crash Bugs]]></title>
    <link href="http://ytlvy.com/2015/08/11/iOS-Crash-Bugs/"/>
    <id>http://ytlvy.com/2015/08/11/iOS-Crash-Bugs/</id>
    <published>2015-08-11T14:12:12.000Z</published>
    <updated>2015-08-11T14:12:45.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Crash_Bug">Crash Bug</h2><p>1) ios7 下没有 <code>ContainString</code> API</p>
<p>2) NSDictionary &amp; NSArray nil insert </p>
<p>3) 数组越界 NSArray <code>out of bounds</code></p>
<p>4) <code>substringwithrange</code> out of bounds</p>
<p>5) <code>GPUImageView presentBufferForDisplay</code> — 内存泄露 或者 app 进入后台</p>
<p>6) <code>locationOfTouch: inView:</code> </p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">if</span> (gestureRecognizer)<span class="tag">numberOfTouches</span> &gt; <span class="tag">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>7) “[NSPlaceholderMutableString initWithString:]: nil argument” - NSString的<code>initWithString:</code>或者<code>stringWithString:</code> 传入了 nil 参数</p>
<p>8) 调用为 nil 的block<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(block)</span> &#123;</span><br><span class="line">    block<span class="comment">()</span>;    <span class="comment">//确定不为空之后才放心地调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>9) 调用了不存在的方法<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">if</span> ([a <span class="attribute">respondsToSelector</span>:<span class="variable">@selector</span>(aaa)]) &#123;</span><br><span class="line">    <span class="attr_selector">[a aaa]</span>;            <span class="comment">//确定有该方法之后才放心地调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>10) 在cellForRowAtIndexPath中返回了nil</p>
<p>出现这种情况的原因有：</p>
<p><code>numberOfRowsInSection</code>返回的数目不正确，导致行数比<code>cellForRowAtIndexPath</code>预期的多，于是<code>cellForRowAtIndexPath</code>就不能正确返回超出预期的cell了。<br><code>cellForRowAtIndexPath</code>中逻辑有误，漏了一些情况，导致有些cell不能正确返回。</p>
<p>11) NSJSONSerialization 识别失败 为 NSNull </p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Crash_Bug">Crash Bug</h2><p>1) ios7 下没有 <code>ContainString</code> API</p>
<p>2) NSDictionary &amp; NSArray nil insert </p>
<p>3) 数组越界 NSArray <code>out of bounds</code></p>
<p>4) <code>substringwithrange</code> out of bounds</p>
<p>5) <code>GPUImageView presentBufferForDisplay</code> — 内存泄露 或者 app 进入后台</p>
<p>6) <code>locationOfTouch: inView:</code> </p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">if</span> (gestureRecognizer)<span class="tag">numberOfTouches</span> &gt; <span class="tag">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Bug" scheme="http://ytlvy.com/tags/Bug/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Audio Basic Knowleage]]></title>
    <link href="http://ytlvy.com/2015/08/11/Audio-Basic-Knowleage/"/>
    <id>http://ytlvy.com/2015/08/11/Audio-Basic-Knowleage/</id>
    <published>2015-08-11T14:00:00.000Z</published>
    <updated>2015-08-11T14:00:26.000Z</updated>
    <content type="html"><![CDATA[<h2 id="音频编码基础知识">音频编码基础知识</h2><p>自然界中的声音非常复杂，波形极其复杂，通常我们采用的是脉冲代码调制编码，即PCM编码。PCM通过抽样、量化、编码三个步骤将连续变化的模拟信号转换为数字编码。</p>
<h3 id="什么是采样率和采样大小（位/bit）。">什么是采样率和采样大小（位/bit）。</h3><p>声音其实是一种能量波，因此也有频率和振幅的特征，频率对应于时间轴线，振幅对应于电平轴线。波是无限光滑的，弦线可以看成由无数点组成，由于存储空间是相对有限的，数字编码过程中，必须对弦线的点进行采样。采样的过程就是抽取某点的频率值，很显然，在一秒中内抽取的点越多，获取得频率信息更丰富，为了复原波形，一次振动中，必须有2个点的采样，人耳能够感觉到的最高频率为20kHz，因此要满足人耳的听觉要求，则需要至少每秒进行40k次采样，用40kHz表达，这个40kHz就是采样率。我们常见的CD，采样率为44.1kHz。光有频率信息是不够的，我们还必须获得该频率的能量值并量化，用于表示信号强度。量化电平数为2的整数次幂，我们常见的CD位16bit的采样大小，即2的16次方。采样大小相对采样率更难理解，因为要显得抽象点，举个简单例子：假设对一个波进行8次采样，采样点分别对应的能量值分别为A1-A8，但我们只使用2bit的采样大小，结果我们只能保留A1-A8中4个点的值而舍弃另外4个。如果我们进行3bit的采样大小，则刚好记录下8个点的所有信息。采样率和采样大小的值越大，记录的波形更接近原始信号。</p>
<h3 id="有损和无损">有损和无损</h3><p>根据采样率和采样大小可以得知，相对自然界的信号，音频编码最多只能做到无限接近，至少目前的技术只能这样了，相对自然界的信号，任何数字音频编码方案都是有损的，因为无法完全还原。在计算机应用中，能够达到最高保真水平的就是PCM编码，被广泛用于素材保存及音乐欣赏，CD、DVD以及我们常见的WAV文件中均有应用。因此，PCM约定俗成了无损编码，因为PCM代表了数字音频中最佳的保真水准，并不意味着PCM就能够确保信号绝对保真，PCM也只能做到最大程度的无限接近。我们而习惯性的把MP3列入有损音频编码范畴，是相对PCM编码的。强调编码的相对性的有损和无损，是为了告诉大家，要做到真正的无损是困难的，就像用数字去表达圆周率，不管精度多高，也只是无限接近，而不是真正等于圆周率的值。</p>
<h3 id="为什么要使用音频压缩技术">为什么要使用音频压缩技术</h3><p>要算一个PCM音频流的码率是一件很轻松的事情，采样率值×采样大小值×声道数 bps。一个采样率为<code>44.1KHz</code>，采样大小为<code>16bit</code>，双声道的PCM编码的WAV文件，它的数据速率则为 <code>44.1K×16×2 =1411.2 Kbps</code>。我们常说<code>128K</code>的MP3，对应的WAV的参数，就是这个<code>1411.2 Kbps</code>，这个参数也被称为数据带宽，它和ADSL中的带宽是一个概念。将码率除以8,就可以得到这个WAV的数据速率，即<code>176.4KB/s</code>。这表示存储一秒钟采样率为<code>44.1KHz</code>，采样大小为<code>16bit</code>，双声道的PCM编码的音频信号，需要<code>176.4KB</code>的空间，1分钟则约为<code>10.34M</code>，这对大部分用户是不可接受的，尤其是喜欢在电脑上听音乐的朋友，要降低磁盘占用，只有2种方法，降低采样指标或者压缩。降低指标是不可取的，因此专家们研发了各种压缩方案。由于用途和针对的目标市场不一样，各种音频压缩编码所达到的音质和压缩比都不一样，在后面的文章中我们都会一一提到。有一点是可以肯定的，他们都压缩过。</p>
<h3 id="频率与采样率的关系">频率与采样率的关系</h3><p>采样率表示了每秒对原始信号采样的次数，我们常见到的音频文件采样率多为44.1KHz，这意味着什么呢？假设我们有2段正弦波信号，分别为20Hz和20KHz，长度均为一秒钟，以对应我们能听到的最低频和最高频，分别对这两段信号进行40KHz的采样，我们可以得到一个什么样的结果呢？结果是：20Hz的信号每次振动被采样了40K/20=2000次，而20K的信号每次振动只有2次采样。显然，在相同的采样率下，记录低频的信息远比高频的详细。这也是为什么有些音响发烧友指责CD有数码声不够真实的原因，CD的44.1KHz采样也无法保证高频信号被较好记录。要较好的记录高频信号，看来需要更高的采样率，于是有些朋友在捕捉CD音轨的时候使用48KHz的采样率，这是不可取的！这其实对音质没有任何好处，对抓轨软件来说，保持和CD提供的44.1KHz一样的采样率才是最佳音质的保证之一，而不是去提高它。较高的采样率只有相对模拟信号的时候才有用，如果被采样的信号是数字的，请不要去尝试提高采样率。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="音频编码基础知识">音频编码基础知识</h2><p>自然界中的声音非常复杂，波形极其复杂，通常我们采用的是脉冲代码调制编码，即PCM编码。PCM通过抽样、量化、编码三个步骤将连续变化的模拟信号转换为数字编码。</p>
<h3 id="什么是采样率和采样大小（位/b]]>
    </summary>
    
      <category term="Audio" scheme="http://ytlvy.com/tags/Audio/"/>
    
      <category term="Audio" scheme="http://ytlvy.com/categories/Audio/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Convert PCM To AAC]]></title>
    <link href="http://ytlvy.com/2015/08/11/Convert-PCM-To-AAC/"/>
    <id>http://ytlvy.com/2015/08/11/Convert-PCM-To-AAC/</id>
    <published>2015-08-11T13:58:23.000Z</published>
    <updated>2015-08-11T13:58:54.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/poechant/article/details/7435054" target="_blank" rel="external">reference</a></p>
<h2 id="音频编解码·实战篇（1）PCM转至AAC（AAC编码）">音频编解码·实战篇（1）PCM转至AAC（AAC编码）</h2><ul>
<li>作者：柳大·Poechant</li>
<li>博客：blog.csdn.net/poechant</li>
<li>邮箱：zhongchao.ustc@gmail.com</li>
<li>日期：April 7th, 2012</li>
</ul>
<p>这里利用FAAC来实现AAC编码。</p>
<h3 id="下载安装_FAAC">下载安装 FAAC</h3><p>这里的安装过程是在 Mac 和 Linux 上实现的，Windows可以类似参考。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="comment">//downloads.sourceforge.net/faac/faac-1.28.tar.gz</span></span><br><span class="line">tar zxvf faac-<span class="number">1.28</span><span class="class">.tar</span><span class="class">.gz</span></span><br><span class="line">cd faac-<span class="number">1.28</span></span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>如果才用默认的 configure 中的 prefix path，那么安装后的 lib 和 .h 文件分别在/usr/local/lib和/usr/local/include，后面编译的时候会用到。</p>
<p>如果编译过程中发现错误：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpeg4ip.h:126: <span class="keyword">error</span>: <span class="keyword">new</span> declaration ‘<span class="keyword">char</span>* strcasestr(<span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">const</span> <span class="keyword">char</span>*)’</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>解决方法：<br>从123行开始修改此文件mpeg4ip.h，到129行结束。 修改前：<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#ifdef __cplusplus</span></span><br><span class="line">extern <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line"><span class="keyword">char</span> *strcasestr(<span class="keyword">const</span> <span class="keyword">char</span> *haystack, <span class="keyword">const</span> <span class="keyword">char</span> *needle);</span><br><span class="line"><span class="preprocessor">#ifdef __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br></pre></td></tr></table></figure></p>
<p>修改后：<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#ifdef __cplusplus</span></span><br><span class="line">extern <span class="string">"C++"</span> &#123;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *strcasestr(<span class="keyword">const</span> <span class="keyword">char</span> *haystack, <span class="keyword">const</span> <span class="keyword">char</span> *needle);</span><br><span class="line"><span class="preprocessor">#ifdef __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br></pre></td></tr></table></figure></p>
<h3 id="FAAC_API">FAAC API</h3><h4 id="Open_FAAC_engine">Open FAAC engine</h4><p>Prototype:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">faacEncHandle faacEncOpen               <span class="comment">// 返回一个FAAC的handle</span></span><br><span class="line">(                   </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   nSampleRate,        <span class="comment">// 采样率，单位是bps</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   nChannels,          <span class="comment">// 声道，1为单声道，2为双声道</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   &amp;nInputSamples,     <span class="comment">// 传引用，得到每次调用编码时所应接收的原始数据长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   &amp;nMaxOutputBytes    <span class="comment">// 传引用，得到每次调用编码时生成的AAC数据的最大长度</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h4 id="Get/Set_encoding_configuration">Get/Set encoding configuration</h4><p>获取编码器的配置：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">faacEncConfigurationPtr faacEncGetCurrentConfiguration <span class="comment">// 得到指向当前编码器配置的指针</span></span><br><span class="line">(</span><br><span class="line">    faacEncHandle hEncoder  <span class="comment">// FAAC的handle</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>设定编码器的配置：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> FAA<span class="built_in">CAPI</span> faacEncSetConfiguration</span><br><span class="line">(</span><br><span class="line">    faacDecHandle hDecoder,         <span class="comment">// 此前得到的FAAC的handle</span></span><br><span class="line">    faacEncConfigurationPtr config  <span class="comment">// FAAC编码器的配置</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h4 id="Encode">Encode</h4><p>Prototype:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> faacEncEncode</span><br><span class="line">(</span><br><span class="line">    faacEncHandle hEncoder,     <span class="comment">// FAAC的handle</span></span><br><span class="line">    <span class="keyword">short</span> *inputBuffer,         <span class="comment">// PCM原始数据</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> samplesInput,  <span class="comment">// 调用faacEncOpen时得到的nInputSamples值</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *outputBuffer,<span class="comment">// 至少具有调用faacEncOpen时得到的nMaxOutputBytes字节长度的缓冲区</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bufferSize     <span class="comment">// outputBuffer缓冲区的实际大小</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h4 id="Close_FAAC_engine">Close FAAC engine</h4><p>Prototype<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> faacEncClose</span><br><span class="line">(</span><br><span class="line">    faacEncHandle hEncoder  <span class="comment">// 此前得到的FAAC handle</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h3 id="流程">流程</h3><h4 id="做什么准备？">做什么准备？</h4><p>采样率，声道数（双声道还是单声道？），还有你的PCM的单个样本是8位的还是16位的？</p>
<h4 id="开启FAAC编码器，做编码前的准备">开启FAAC编码器，做编码前的准备</h4><ol>
<li>调用faacEncOpen开启FAAC编码器后，得到了单次输入样本数nInputSamples和输出数据最大字节数nMaxOutputBytes；</li>
<li>根据nInputSamples和nMaxOutputBytes，分别为PCM数据和将要得到的AAC数据创建缓冲区；</li>
<li>调用faacEncGetCurrentConfiguration获取当前配置，修改完配置后，调用faacEncSetConfiguration设置新配置。</li>
</ol>
<h4 id="开始编码">开始编码</h4><p>调用<code>faacEncEncode</code>，该准备的刚才都准备好了，很简单。</p>
<h4 id="善后">善后</h4><p>关闭编码器，另外别忘了释放缓冲区，如果使用了文件流，也别忘记了关闭。</p>
<h3 id="测试程序">测试程序</h3><h4 id="完整代码">完整代码</h4><p>将PCM格式音频文件<code>/home/michael/Development/testspace/in.pcm</code>转至AAC格式文件<code>/home/michael/Development/testspace/out.aac</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;faac.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>   ULONG;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>    UINT;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>   BYTE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>            _TCHAR;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, _TCHAR* argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ULONG nSampleRate = <span class="number">11025</span>;  <span class="comment">// 采样率</span></span><br><span class="line">    UINT nChannels = <span class="number">1</span>;         <span class="comment">// 声道数</span></span><br><span class="line">    UINT nPCMBitSize = <span class="number">16</span>;      <span class="comment">// 单样本位数</span></span><br><span class="line">    ULONG nInputSamples = <span class="number">0</span>;</span><br><span class="line">    ULONG nMaxOutputBytes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nRet;</span><br><span class="line">    faacEncHandle hEncoder;</span><br><span class="line">    faacEncConfigurationPtr pConfiguration; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nBytesRead;</span><br><span class="line">    <span class="keyword">int</span> nPCMBufferSize;</span><br><span class="line">    BYTE* pbPCMBuffer;</span><br><span class="line">    BYTE* pbAACBuffer;</span><br><span class="line"></span><br><span class="line">    FILE* fpIn; <span class="comment">// PCM file for input</span></span><br><span class="line">    FILE* fpOut; <span class="comment">// AAC file for output</span></span><br><span class="line"></span><br><span class="line">    fpIn = fopen(<span class="string">"/home/michael/Development/testspace/in.pcm"</span>, <span class="string">"rb"</span>);</span><br><span class="line">    fpOut = fopen(<span class="string">"/home/michael/Development/testspace/out.aac"</span>, <span class="string">"wb"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (1) Open FAAC engine</span></span><br><span class="line">    hEncoder = faacEncOpen(nSampleRate, nChannels, &amp;nInputSamples, &amp;nMaxOutputBytes);</span><br><span class="line">    <span class="keyword">if</span>(hEncoder == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[ERROR] Failed to call faacEncOpen()\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nPCMBufferSize = nInputSamples * nPCMBitSize / <span class="number">8</span>;</span><br><span class="line">    pbPCMBuffer = <span class="keyword">new</span> BYTE [nPCMBufferSize];</span><br><span class="line">    pbAACBuffer = <span class="keyword">new</span> BYTE [nMaxOutputBytes];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (2.1) Get current encoding configuration</span></span><br><span class="line">    pConfiguration = faacEncGetCurrentConfiguration(hEncoder);</span><br><span class="line">    pConfiguration-&gt;inputFormat = FAAC_INPUT_16BIT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (2.2) Set encoding configuration</span></span><br><span class="line">    nRet = faacEncSetConfiguration(hEncoder, pConfiguration);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读入的实际字节数，最大不会超过nPCMBufferSize，一般只有读到文件尾时才不是这个值</span></span><br><span class="line">        nBytesRead = fread(pbPCMBuffer, <span class="number">1</span>, nPCMBufferSize, fpIn);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输入样本数，用实际读入字节数计算，一般只有读到文件尾时才不是nPCMBufferSize/(nPCMBitSize/8);</span></span><br><span class="line">        nInputSamples = nBytesRead / (nPCMBitSize / <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (3) Encode</span></span><br><span class="line">        nRet = faacEncEncode(</span><br><span class="line">        hEncoder, (<span class="keyword">int</span>*) pbPCMBuffer, nInputSamples, pbAACBuffer, nMaxOutputBytes);</span><br><span class="line"></span><br><span class="line">        fwrite(pbAACBuffer, <span class="number">1</span>, nRet, fpOut);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d: faacEncEncode returns %d\n"</span>, i, nRet);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nBytesRead &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        // (3) Flushing</span><br><span class="line">        nRet = faacEncEncode(</span><br><span class="line">        hEncoder, (int*) pbPCMBuffer, 0, pbAACBuffer, nMaxOutputBytes);</span><br><span class="line"></span><br><span class="line">        if(nRet &lt;= 0)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// (4) Close FAAC engine</span></span><br><span class="line">    nRet = faacEncClose(hEncoder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] pbPCMBuffer;</span><br><span class="line">    <span class="keyword">delete</span>[] pbAACBuffer;</span><br><span class="line">    fclose(fpIn);</span><br><span class="line">    fclose(fpOut);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getchar();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="编译运行">编译运行</h4><p>将上述代码保存为“pcm2aac.cpp”文件，然后编译：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">g</span>++ pcm2aac.cpp -o pcm2aac -<span class="keyword">L</span>/usr/<span class="keyword">local</span>/lib -lfaac -I/usr/<span class="keyword">local</span>/<span class="keyword">include</span></span><br></pre></td></tr></table></figure></p>
<p>运行：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./pc<span class="title">m2</span>aac</span><br></pre></td></tr></table></figure></p>
<p>然后就生成了out.aac文件了，听听看吧！~</p>
<h3 id="Reference">Reference</h3><ul>
<li><a href="http://www.audiocoding.com/faac.html" target="_blank" rel="external">AudioCoding.com - FAAC</a></li>
<li><a href="http://blog.tcltk.co.kr/?p=2130" target="_blank" rel="external">Dogfoot – 재밌는 개발</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://blog.csdn.net/poechant/article/details/7435054">reference</a></p>
<h2 id="音频编解码·实战篇（1）PCM转至AAC（AAC编码）">音频编解码·实战篇（1）PCM转至AAC（AAC编码）</h2><ul>
<li>作者：柳大·Poechant</li>
<li>博客：blog.csdn.net/poechant</li>
<li>邮箱：zhongchao.ustc@gmail.com</li>
<li>日期：April 7th, 2012</li>
</ul>
<p>这里利用FAAC来实现AAC编码。</p>
<h3 id="下载安装_FAAC">下载安装 FAAC</h3><p>这里的安装过程是在 Mac 和 Linux 上实现的，Windows可以类似参考。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="comment">//downloads.sourceforge.net/faac/faac-1.28.tar.gz</span></span><br><span class="line">tar zxvf faac-<span class="number">1.28</span><span class="class">.tar</span><span class="class">.gz</span></span><br><span class="line">cd faac-<span class="number">1.28</span></span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>如果才用默认的 configure 中的 prefix path，那么安装后的 lib 和 .h 文件分别在/usr/local/lib和/usr/local/include，后面编译的时候会用到。</p>
<p>如果编译过程中发现错误：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpeg4ip.h:126: <span class="keyword">error</span>: <span class="keyword">new</span> declaration ‘<span class="keyword">char</span>* strcasestr(<span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">const</span> <span class="keyword">char</span>*)’</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Audio" scheme="http://ytlvy.com/tags/Audio/"/>
    
      <category term="Audio" scheme="http://ytlvy.com/categories/Audio/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Wave And PCM Audio Format]]></title>
    <link href="http://ytlvy.com/2015/08/11/Wave-And-PCM-Audio-Format/"/>
    <id>http://ytlvy.com/2015/08/11/Wave-And-PCM-Audio-Format/</id>
    <published>2015-08-11T13:57:06.000Z</published>
    <updated>2015-08-11T13:57:42.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/poechant/article/details/7436710" target="_blank" rel="external">reference</a></p>
<h2 id="音频编解码·格式篇（1）Wave_PCM_audio_format（WAV）">音频编解码·格式篇（1）Wave PCM audio format（WAV）</h2><ul>
<li>作者：柳大·Poechant</li>
<li>博客：Blog.CSDN.net/Poechant</li>
<li>邮箱：zhongchao.ustc@gmail.com</li>
<li>日期：April 6th, 2012</li>
</ul>
<h3 id="音频编解码基础">音频编解码基础</h3><ul>
<li>采样率：声音信号在“模数转换”过程中单位时间内采样的次数。</li>
<li>采样值：每一次采样周期内声音模拟信号的积分值。</li>
<li>单声道：11.025 KHz 采样值，8 Bits 采样值（0x00 - 0xFF）。</li>
<li>双声道：44.1 KHz 采样值，16 Bits 采样值。高八位表示左声道，低八位表示右声道。</li>
</ul>
<h3 id="WAV音频文件格式">WAV音频文件格式</h3><p>见下图：<br><img src="http://img.my.csdn.net/uploads/201204/08/1333820202_8901.png" alt=""></p>
<p>1) 文件头</p>
<ul>
<li>RIFF/WAV 文件标识段</li>
<li>声音数据格式说明段</li>
</ul>
<p>2) 数据体：由 PCM（脉冲编码调制）格式表示的样本组成。</p>
<p>单声道 WAV 文件中，声道0代表左声道，声道1代表右声道；多声道 WAV 文件中，左右声道的样本是交替出现的。</p>
<a id="more"></a>
<h4 id="文件头格式：">文件头格式：</h4><table>
<thead>
<tr>
<th>偏移地址</th>
<th>字节数</th>
<th>数据类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00</td>
<td>4</td>
<td>char</td>
<td>“RIFF”标志</td>
</tr>
<tr>
<td>0x04</td>
<td>4</td>
<td>long int</td>
<td>文件长度</td>
</tr>
<tr>
<td>0x08</td>
<td>4</td>
<td>char</td>
<td>“WAVE”标志</td>
</tr>
<tr>
<td>0x0C</td>
<td>4</td>
<td>char</td>
<td>“fmt ”标志</td>
</tr>
<tr>
<td>0x10</td>
<td>4</td>
<td></td>
<td>过度字节（不定）</td>
</tr>
<tr>
<td>0x14</td>
<td>2</td>
<td>int</td>
<td>格式类别（0x10是PCM形式的声音格式）</td>
</tr>
<tr>
<td>0x16</td>
<td>2</td>
<td>int</td>
<td>通道数（1为单声道，2为双声道）</td>
</tr>
<tr>
<td>0x18</td>
<td>2</td>
<td>int</td>
<td>采样率（每秒的样本数，表示每个通道的播放速度）</td>
</tr>
<tr>
<td>0x1C</td>
<td>4</td>
<td>long int</td>
<td>波形音频数据传输速率，为（通道数x每秒数据位数x样本的数据位数/8，播放器根据此值估算缓冲区大小）</td>
</tr>
<tr>
<td>0x20</td>
<td>2</td>
<td>int</td>
<td>数据块的调整数，为（通道数x没样本的数据位值/8），播放软件一次需要处理多个该值大小的字节数据，以便就爱将其值用于缓冲区的调整</td>
</tr>
<tr>
<td>0x22</td>
<td>2</td>
<td></td>
<td>每样本的数据位数，表示每个声道中各样本的数据位数，如果有多个声道，对每个声道而言，样本大小都一样</td>
</tr>
</tbody>
</table>
<h4 id="数据体格式：">数据体格式：</h4><table>
<thead>
<tr>
<th>偏移地址</th>
<th>字节数</th>
<th>数据类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x24</td>
<td>4</td>
<td>char</td>
<td>数据标记符“data”</td>
</tr>
<tr>
<td>0x28</td>
<td>4</td>
<td>long int</td>
<td>语音数据的长度</td>
</tr>
</tbody>
</table>
<p>然后就是语音数据帧了。下表中的0声道代表左声道，1声道代表右声道：</p>
<table>
<thead>
<tr>
<th>偏移地址</th>
<th>sample1</th>
<th>sample2</th>
</tr>
</thead>
<tbody>
<tr>
<td>8位单声道</td>
<td>0声道</td>
<td>0声道</td>
</tr>
<tr>
<td>8位双声道</td>
<td>0声道，1声道</td>
<td>0声道，1声道</td>
</tr>
<tr>
<td>16位单声道</td>
<td>0声道低字节，0声道高字节</td>
<td>0声道低字节，0声道高字节</td>
</tr>
<tr>
<td>16位双声道</td>
<td>0声道低字节，0声道搞字节</td>
<td>1声道低字节，1声道高字节</td>
</tr>
</tbody>
</table>
<h4 id="WAV文件格式实例分析（转载）">WAV文件格式实例分析（转载）</h4><table>
<thead>
<tr>
<th>地址段</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00000000</td>
<td>52</td>
<td>49</td>
<td>46</td>
<td>46</td>
<td>0A</td>
<td>06</td>
<td>01</td>
<td>00</td>
<td>57</td>
<td>41</td>
<td>56</td>
<td>45</td>
<td>66</td>
<td>6D</td>
<td>74</td>
<td>20</td>
</tr>
<tr>
<td>0x00000010</td>
<td>12</td>
<td>00</td>
<td>00</td>
<td>00</td>
<td>01</td>
<td>00</td>
<td>02</td>
<td>00</td>
<td>44</td>
<td>AC</td>
<td>00</td>
<td>00</td>
<td>10</td>
<td>B1</td>
<td>02</td>
<td>00</td>
</tr>
<tr>
<td>0x00000020</td>
<td>04</td>
<td>00</td>
<td>10</td>
<td>00</td>
<td>00</td>
<td>00</td>
<td>66</td>
<td>61</td>
<td>63</td>
<td>74</td>
<td>04</td>
<td>00</td>
<td>00</td>
<td>00</td>
<td>76</td>
<td>41</td>
</tr>
<tr>
<td>0x00000030</td>
<td>00</td>
<td>00</td>
<td>64</td>
<td>61</td>
<td>74</td>
<td>61</td>
<td>D8</td>
<td>05</td>
<td>01</td>
<td>00</td>
<td>00</td>
<td>00</td>
<td>00</td>
<td>00</td>
<td>FF</td>
<td>FF</td>
</tr>
<tr>
<td>0x00000040</td>
<td>00</td>
<td>00</td>
<td>FE</td>
<td>FF</td>
<td>FE</td>
<td>FF</td>
<td>00</td>
<td>00</td>
<td>00</td>
<td>00</td>
<td>FE</td>
<td>FF</td>
<td>FE</td>
<td>FF</td>
<td>00</td>
<td>00</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>0x00000050</td>
<td>64</td>
<td>61</td>
<td>6B</td>
<td>61</td>
<td>D8</td>
<td>05</td>
<td>01</td>
<td>00</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>地址段</th>
<th>字节数</th>
<th>数据类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00 - 0x03</td>
<td>4</td>
<td>4个char</td>
<td>标志位，”RIFF”</td>
</tr>
<tr>
<td>0x04 - 0x07</td>
<td>4</td>
<td>1个int</td>
<td>文件长度，小尾端，实际是0x0001060A</td>
</tr>
<tr>
<td>0x08 - 0x0B</td>
<td>4</td>
<td>4个char</td>
<td>标志位，“WAVE”</td>
</tr>
<tr>
<td>0x0C - 0x0F</td>
<td>4</td>
<td>4个char</td>
<td>标志位，“fmt ”，fmt表示为，最后一个是空格</td>
</tr>
<tr>
<td>0x10 - 0x13</td>
<td>4</td>
<td>1个int</td>
<td>0x00000012，sizeof(PCMWAVEFORMAT)</td>
</tr>
<tr>
<td>0x14 - 0x15</td>
<td>2</td>
<td>1个short</td>
<td>格式类别，1（WAVE_FORMAT_PCM）表示PCM形式的声音数据</td>
</tr>
<tr>
<td>0x16 - 0x17</td>
<td>2</td>
<td>1个short</td>
<td>通道数，1为单声道，2为双声道</td>
</tr>
<tr>
<td>0x18 - 0x1B</td>
<td>4</td>
<td>1个int</td>
<td>采样率</td>
</tr>
<tr>
<td>0x1C - 0x1F</td>
<td>4</td>
<td>1个int</td>
<td>0x10B10000，每秒数据量</td>
</tr>
<tr>
<td>0x20 - 0x21</td>
<td>2</td>
<td>1个short</td>
<td>数据块的调整值（按字节算）</td>
</tr>
<tr>
<td>0x22 - 0x4F</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>0x50 - 0x53</td>
<td>4</td>
<td>4个char</td>
<td>标志位，“data”</td>
</tr>
<tr>
<td>0x54 - 0x57</td>
<td>4</td>
<td>1个int</td>
<td>语音数据大小，0x000105D8</td>
</tr>
</tbody>
</table>
<h3 id="Reference">Reference</h3><ul>
<li><a href="http://wenku.baidu.com/view/c8357e6baf1ffc4ffe47ac08.html" target="_blank" rel="external">WAV(PCM)文件格式分析</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://blog.csdn.net/poechant/article/details/7436710">reference</a></p>
<h2 id="音频编解码·格式篇（1）Wave_PCM_audio_format（WAV）">音频编解码·格式篇（1）Wave PCM audio format（WAV）</h2><ul>
<li>作者：柳大·Poechant</li>
<li>博客：Blog.CSDN.net/Poechant</li>
<li>邮箱：zhongchao.ustc@gmail.com</li>
<li>日期：April 6th, 2012</li>
</ul>
<h3 id="音频编解码基础">音频编解码基础</h3><ul>
<li>采样率：声音信号在“模数转换”过程中单位时间内采样的次数。</li>
<li>采样值：每一次采样周期内声音模拟信号的积分值。</li>
<li>单声道：11.025 KHz 采样值，8 Bits 采样值（0x00 - 0xFF）。</li>
<li>双声道：44.1 KHz 采样值，16 Bits 采样值。高八位表示左声道，低八位表示右声道。</li>
</ul>
<h3 id="WAV音频文件格式">WAV音频文件格式</h3><p>见下图：<br><img src="http://img.my.csdn.net/uploads/201204/08/1333820202_8901.png" alt=""></p>
<p>1) 文件头</p>
<ul>
<li>RIFF/WAV 文件标识段</li>
<li>声音数据格式说明段</li>
</ul>
<p>2) 数据体：由 PCM（脉冲编码调制）格式表示的样本组成。</p>
<p>单声道 WAV 文件中，声道0代表左声道，声道1代表右声道；多声道 WAV 文件中，左右声道的样本是交替出现的。</p>]]>
    
    </summary>
    
      <category term="Audio" scheme="http://ytlvy.com/tags/Audio/"/>
    
      <category term="Audio" scheme="http://ytlvy.com/categories/Audio/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[git flow]]></title>
    <link href="http://ytlvy.com/2015/08/09/git-flow/"/>
    <id>http://ytlvy.com/2015/08/09/git-flow/</id>
    <published>2015-08-09T13:33:20.000Z</published>
    <updated>2015-08-09T13:33:53.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="external">reference</a></p>
<h2 id="A_successful_Git_branching_model">A successful Git branching model</h2><p><code>git flow</code> 工作流, 流转示意图:</p>
<p><img src="http://nvie.com/img/git-model@2x.png" alt="git flow"></p>
<h3 id="去中心化_和_中心化">去中心化 和 中心化</h3><p>此工作流中, 存在唯一的<code>中心仓库</code> — <code>origin</code>. 每个程序员向中心仓库, 拉取更新和提交更新. 然而, 程序员也可以被划分为小组, 来进入更进一步的划分, 先从这些<code>分中心仓库</code> 来拉取更新和提交更新, 先完成小组的同步, 再和中心仓库同步.</p>
<p><img src="http://nvie.com/img/centr-decentr@2x.png" alt=""></p>
<h3 id="主要分支">主要分支</h3><p>这个工作流的核心为两个主分支:</p>
<ol>
<li>Master</li>
<li>Develop</li>
</ol>
<p><img src="http://nvie.com/img/main-branches@2x.png" alt=""></p>
<a id="more"></a>
<p>在<code>origin</code> 上的主分支, 对 Git 用户来说是很熟悉了, 另外一个则是 <code>develop</code> 分支. 我们认为 <code>origin/master</code> 分支的 <code>HEAD</code> 总是<strong>发布版</strong>的源代码. 而 <code>origin/develop</code> 分支的 <code>HEAD</code> 则是为下一个开发版准备的最新开发状态. 此分支也被称为<strong>整合分支</strong>. 这也是所有 <code>nightly</code> 版本编译的来源.</p>
<p>当在开发分支上达到一定的稳定状态时, 会被合并到 <code>master</code> 分支, 从而生成一个全新的发布版本. 我们倾向于严格的处理主分支的合并, 此外, 我们可以采用一个 <code>Git hook</code> 脚本来监控主分支的 <code>commit</code> 事件, 然后自动打包, 并将程序分发到产品服务器.</p>
<h3 id="支持分支">支持分支</h3><p>除了主要分支外, 工作流还使用了很多支持分支, 来方便并发开发. 比如: 新功能开发, 版本发布准备和版本 bug 修复工作同步处理. 不像主要分支, 这些分支都有一定的生命周期, 他们将最终被删除.</p>
<p>支持分支类型:</p>
<ol>
<li>Feature branches</li>
<li>Release branches</li>
<li>Hotfix branches</li>
</ol>
<p>这些分支都有自己独特的使命, 并存在严格的处理规则, 例如从哪里派生, 合并到哪里.这些分支在技术角度是没有区别的, 只是我们人为的划分为不同的功能.</p>
<h3 id="Feature_branches">Feature branches</h3><p>可以派生自:<br><code>Develop</code> 分支</p>
<p>必须合并到:<br><code>Develop</code> 分支</p>
<p>命名规则:<br>除 <code>master, develop, release-*, or hotfix-*</code> 以外</p>
<p><img src="http://nvie.com/img/fb@2x.png" alt=""></p>
<p><code>Feature branches</code> 主要用来开发新功能. 当进入 <code>Feature</code> 开发时, 最终会发布到那个版本, 可能还没有确定. <code>Feature</code>分支最终会合并入 <code>Develop</code>分支, 或者废弃. <code>Feature</code>分支只存在于开发库中, 不应该同步到 <code>origin</code> 中心仓库.</p>
<h4 id="Creating_a_feature_branch">Creating a feature branch</h4><p>从<code>develop</code> 派生新的功能分支</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -<span class="tag">b</span> myfeature develop</span><br><span class="line">Switched to <span class="tag">a</span> new branch <span class="string">"myfeature"</span></span><br></pre></td></tr></table></figure>
<h4 id="Incorporating_a_finished_feature_on_develop">Incorporating a finished feature on develop</h4><p>当功能分支结束开发, 合并回开发分支.</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout develop</span><br><span class="line"><span class="keyword">Switched </span>to <span class="keyword">branch </span><span class="string">'develop'</span></span><br><span class="line"></span><br><span class="line">$ git merge --no-ff myfeature</span><br><span class="line"><span class="label">Updating</span> ea1b82a..<span class="number">05</span>e9557</span><br><span class="line">(Summary of changes)</span><br><span class="line"></span><br><span class="line">$ git <span class="keyword">branch </span>-d myfeature</span><br><span class="line"><span class="label">Deleted</span> <span class="keyword">branch </span>myfeature (was <span class="number">05</span>e9557).</span><br><span class="line"></span><br><span class="line">$ git <span class="keyword">push </span>origin develop</span><br></pre></td></tr></table></figure>
<p><code>--no-ff</code> 符号会使得合并总是生成一个新的提交点, 即使是 <code>fast-forward</code> 合并. 这可以避免丢失分支的历史存在信息.</p>
<p><img src="http://nvie.com/img/merge-without-ff@2x.png" alt=""></p>
<p>在上图中, 后面不添加 <code>--no-ff</code> 的做法, 就使得我们很难看出, 曾经合并了一个功能分支, 除非通过阅读所有的日志信息.</p>
<h3 id="Release_branches">Release branches</h3><p>可以派生自:<br><code>Develop</code> 分支</p>
<p>必须合并到:<br><code>develop</code> 分支 和 <code>master</code> 分支</p>
<p>命名规则:<br><code>release-*</code></p>
<p>发布分支为下一个版本的发布做准备. 它允许少量的 bug 修复, 以及发布准备(例如: 版本号, 编译日期, 等). 通过在发布分支做这些事情, 可以使得 开发分支 清晰的去合并新的功能分支, 从而为下一个版本做准备.</p>
<p>发布分支是在开发分支达到一定的发布状态时, 才在开发分支派生的, 例如至少要在所有当前版本功能, 都合并入开发分支后. 此时所有的未来版本功能不应合并入开发分支, 直到发布分支派生后为止.</p>
<h4 id="Creating_a_release_branch">Creating a release branch</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -<span class="tag">b</span> release-<span class="number">1.2</span> develop</span><br><span class="line">Switched to <span class="tag">a</span> new branch <span class="string">"release-1.2"</span></span><br><span class="line"></span><br><span class="line">$ ./bump-version<span class="class">.sh</span> <span class="number">1.2</span></span><br><span class="line">Files modified successfully, version bumped to <span class="number">1.2</span>.</span><br><span class="line"></span><br><span class="line">$ git commit -<span class="tag">a</span> -m <span class="string">"Bumped version number to 1.2"</span></span><br><span class="line">[release-<span class="number">1.2</span> <span class="number">74</span>d9424] Bumped version number to <span class="number">1.2</span></span><br><span class="line"><span class="number">1</span> files changed, <span class="number">1</span> <span class="function"><span class="title">insertions</span><span class="params">(+)</span></span>, <span class="number">1</span> <span class="function"><span class="title">deletions</span><span class="params">(-)</span></span></span><br></pre></td></tr></table></figure>
<p><code>bump-version.sh</code> 脚本为一个变更文件版本号的脚本, 此步骤可以通过手工更改代替.</p>
<p>这个新分支会存在一段时间, 直到可以确定发布为止. 在此阶段, 此分支的主要功能为 bug 修改. 此时严禁合并大的功能模块. 此分支会最终合并回开发分支, 在开发分支为下一个发布做准备.</p>
<h4 id="Finishing_a_release_branch">Finishing a release branch</h4><p>当发布分支准备完毕后, 会被首先合并到 <code>master</code> 分支, 因为所有的发布状态都会放到此分支. 然后在主分支打标签, 以便未来浏览. 最后在发布分支上的修改会合并回 <code>develop</code>.</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched <span class="built_in">to</span> branch <span class="string">'master'</span></span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">merge</span> <span class="comment">--no-ff release-1.2</span></span><br><span class="line">Merge made <span class="keyword">by</span> recursive.</span><br><span class="line">(Summary <span class="operator">of</span> changes)</span><br><span class="line"></span><br><span class="line">$ git tag -<span class="operator">a</span> <span class="number">1.2</span></span><br></pre></td></tr></table></figure>
<p>发布完成, 也打完了标签</p>
<blockquote>
<p>你可能希望使用 <code>-s or -u &lt;key&gt;</code> 来打标签</p>
</blockquote>
<p>合并回 <code>develop</code> </p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout develop</span><br><span class="line">Switched <span class="built_in">to</span> branch <span class="string">'develop'</span></span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">merge</span> <span class="comment">--no-ff release-1.2</span></span><br><span class="line">Merge made <span class="keyword">by</span> recursive.</span><br><span class="line">(Summary <span class="operator">of</span> changes)</span><br></pre></td></tr></table></figure>
<p>这一步可能引起冲突, 如果发生, 先解决冲突再提交.</p>
<p>删除此分支<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>-d release-<span class="number">1</span>.<span class="number">2</span></span><br><span class="line"><span class="label">Deleted</span> <span class="keyword">branch </span>release-<span class="number">1</span>.<span class="number">2</span> (was ff452fe).</span><br></pre></td></tr></table></figure></p>
<h3 id="Hotfix_branches">Hotfix branches</h3><p>可以派生自:<br><code>master</code> 分支</p>
<p>必须合并到:<br><code>develop</code> 分支 和 <code>master</code> 分支</p>
<p>命名规则:<br><code>hotfix-*</code></p>
<p><code>Hotfix</code> 分支和 <code>release</code> 分支很像, 都是为新的版本发布做准备. 他们为解决某个线上产品版本的严重 bug 而生. 它的存在是为了不打断现阶段的开发进程.</p>
<p><img src="http://nvie.com/img/hotfix-branches@2x.png" alt=""></p>
<h4 id="Creating_the_hotfix_branch">Creating the hotfix branch</h4><p><code>Hotfix</code> 分支派生自 <code>master</code>分支. 例如: 当前版本为1.2, 出现了严重问题. 然而在 <code>develop</code> 分支修改是很不稳定的, 因为此分支目前可能有新的不完善的功能, 所以我们需要派生一个 <code>Hotfix</code> 分支.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -<span class="tag">b</span> hotfix-<span class="number">1.2</span>.<span class="number">1</span> master</span><br><span class="line">Switched to <span class="tag">a</span> new branch <span class="string">"hotfix-1.2.1"</span></span><br><span class="line"></span><br><span class="line">$ ./bump-version<span class="class">.sh</span> <span class="number">1.2</span>.<span class="number">1</span></span><br><span class="line">Files modified successfully, version bumped to <span class="number">1.2</span>.<span class="number">1</span>.</span><br><span class="line"></span><br><span class="line">$ git commit -<span class="tag">a</span> -m <span class="string">"Bumped version number to 1.2.1"</span></span><br><span class="line">[hotfix-<span class="number">1.2</span>.<span class="number">1</span> <span class="number">41</span>e61bb] Bumped version number to <span class="number">1.2</span>.<span class="number">1</span></span><br><span class="line"><span class="number">1</span> files changed, <span class="number">1</span> <span class="function"><span class="title">insertions</span><span class="params">(+)</span></span>, <span class="number">1</span> <span class="function"><span class="title">deletions</span><span class="params">(-)</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>不要忘记修改版本信息</p>
</blockquote>
<p>然后 bug 修复完了, 我们需要提交修改</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"Fixed severe production problem"</span></span><br><span class="line">[hotfix-<span class="number">1.2</span>.<span class="number">1</span> abbe5d6] Fixed severe production problem</span><br><span class="line"><span class="number">5</span> files changed, <span class="number">32</span> <span class="function"><span class="title">insertions</span><span class="params">(+)</span></span>, <span class="number">17</span> <span class="function"><span class="title">deletions</span><span class="params">(-)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="Finishing_a_hotfix_branch">Finishing a hotfix branch</h4><p>结束后, <code>bugfix</code> 需要合并回 <code>master</code>, 同时也需要合并到 <code>develop</code>. </p>
<p>合并到主分支<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched <span class="built_in">to</span> branch <span class="string">'master'</span></span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">merge</span> <span class="comment">--no-ff hotfix-1.2.1</span></span><br><span class="line">Merge made <span class="keyword">by</span> recursive.</span><br><span class="line">(Summary <span class="operator">of</span> changes)</span><br><span class="line"></span><br><span class="line">$ git tag -<span class="operator">a</span> <span class="number">1.2</span>.1</span><br></pre></td></tr></table></figure></p>
<p>合并到开发分支<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout develop</span><br><span class="line">Switched <span class="built_in">to</span> branch <span class="string">'develop'</span></span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">merge</span> <span class="comment">--no-ff hotfix-1.2.1</span></span><br><span class="line">Merge made <span class="keyword">by</span> recursive.</span><br><span class="line">(Summary <span class="operator">of</span> changes)</span><br></pre></td></tr></table></figure></p>
<p>例外情况为, 如果此时 <code>release</code>分支存在, 则直接合并入此 <code>release</code>分支, 不再直接合并入 <code>develop</code>. 因为<code>release</code>分支最终回合并回 <code>develop</code>.</p>
<p>删除此分支<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>-d hotfix-<span class="number">1</span>.<span class="number">2</span>.<span class="number">1</span></span><br><span class="line"><span class="label">Deleted</span> <span class="keyword">branch </span>hotfix-<span class="number">1</span>.<span class="number">2</span>.<span class="number">1</span> (was abbe5d6).</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://nvie.com/posts/a-successful-git-branching-model/">reference</a></p>
<h2 id="A_successful_Git_branching_model">A successful Git branching model</h2><p><code>git flow</code> 工作流, 流转示意图:</p>
<p><img src="http://nvie.com/img/git-model@2x.png" alt="git flow"></p>
<h3 id="去中心化_和_中心化">去中心化 和 中心化</h3><p>此工作流中, 存在唯一的<code>中心仓库</code> — <code>origin</code>. 每个程序员向中心仓库, 拉取更新和提交更新. 然而, 程序员也可以被划分为小组, 来进入更进一步的划分, 先从这些<code>分中心仓库</code> 来拉取更新和提交更新, 先完成小组的同步, 再和中心仓库同步.</p>
<p><img src="http://nvie.com/img/centr-decentr@2x.png" alt=""></p>
<h3 id="主要分支">主要分支</h3><p>这个工作流的核心为两个主分支:</p>
<ol>
<li>Master</li>
<li>Develop</li>
</ol>
<p><img src="http://nvie.com/img/main-branches@2x.png" alt=""></p>]]>
    
    </summary>
    
      <category term="Git" scheme="http://ytlvy.com/tags/Git/"/>
    
      <category term="Git" scheme="http://ytlvy.com/categories/Git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Notes: The interesting things from WWDC, iOS 9, Swift 2]]></title>
    <link href="http://ytlvy.com/2015/08/08/Notes-The-interesting-things-from-WWDC-iOS-9-Swift-2/"/>
    <id>http://ytlvy.com/2015/08/08/Notes-The-interesting-things-from-WWDC-iOS-9-Swift-2/</id>
    <published>2015-08-08T13:25:39.000Z</published>
    <updated>2015-08-08T13:26:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="WWDC中那些令人感兴趣的事物:iOS_9,_Swift_2">WWDC中那些令人感兴趣的事物:iOS 9, Swift 2</h2><blockquote>
<ul>
<li>原文链接 : <a href="http://iosdevtips.co/post/121053658888/wwdc-ios-9-swift-2-notes" target="_blank" rel="external">Notes: The interesting things from WWDC, iOS 9, Swift 2</a></li>
<li>原文作者: <a href="http://iosdevtips.co" target="_blank" rel="external">Rounak Jain</a></li>
<li>译文出自: <a href="http://www.devtf.cn/" target="_blank" rel="external">开发技术前线http://www.devtf.cn/</a></li>
<li>译者 : <a href="https://github.com/Lollypo" target="_blank" rel="external">Lollypo</a> </li>
<li>校对者:<a href="https://github.com/bboyfeiyu" target="_blank" rel="external">Mr.Simple</a></li>
<li>状态 :  完成</li>
</ul>
</blockquote>
<p>今天WWDC上的Keynote非常棒,即便到目前为止还未结束.在开发者方面,已经有大量的新事物出现,其中包括有Swift 2, iOS 9, CloudKit等等.</p>
<p>这里是我在浏览发布日志,API差异,新特性等内容时记录的笔记</p>
<ul>
<li><p>你不需要加入$99的开发者计划就可以在真机上调试应用程序.此外,Mac与iOS开发者计划合并,可以节省一半支出:<br><img src="http://40.media.tumblr.com/ab8cf0d95f459e63bb10ded612e2fa34/tumblr_inline_npnb64YpK31qh9cw7_500.png" alt=""></p>
</li>
<li><p>Interface Builder支持实时预览模糊与透明效果<br><img src="http://40.media.tumblr.com/ed19a7cbd80fe5ccb49f5a9102744eec/tumblr_inline_npnb8aLtBC1qh9cw7_500.png" alt=""></p>
</li>
<li><p>Objective-C支持泛型,这意味着集合对象,如数组,字典可以像Swift一样指定类型<br><img src="http://40.media.tumblr.com/4ed77823bca27d89db84f654080d7d28/tumblr_inline_npnbbdudd01qh9cw7_500.png" alt=""></p>
</li>
<li><p>新的名为 <a href="https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIStackView_Class_Reference/index.html#//apple_ref/doc/uid/TP40015256" target="_blank" rel="external">UIStackView</a>UI类,是Mac中NSStackView的一种实现.</p>
</li>
<li><p><a href="https://developer.apple.com/library/prerelease/ios/documentation/DataManagement/Conceptual/CloutKitWebServicesReference/Introduction/Introduction.html#//apple_ref/doc/uid/TP40015240" target="_blank" rel="external">CloudKit现在也可以在Web中使用</a></p>
</li>
<li><p>开放 CASpringAnimation!<br><img src="http://40.media.tumblr.com/65c41c82d295034c23ef986214404c6d/tumblr_inline_npnbg2mCrc1qh9cw7_500.png" alt=""></p>
</li>
<li><p>应用程序现在可以作为拓展插入到Safari中,听起来有点像广告拦截器.此外,应用程序可以在Safari的共享链接填充内容</p>
</li>
<li><p>开发者现在可以使用 <code>SFSafariViewController</code>, 这可以共享Safari中中cookies, 自动填充以及其他Safari中的特性.</p>
</li>
<li><p><code>UIPickerView</code> 可转换为任意尺寸,而不必再使用那些丑陋的转换技巧.</p>
</li>
<li><p>iOS应用程序可在发出提醒展示一段文本域,此前仅限于Messages使用.</p>
</li>
<li><p>通讯录可通过面向对象的API来访问,而不是之前的C</p>
</li>
<li><p>电话API在低版本设备上不支持,这也许会导致编译时错误.现在有新的判断条件来决定是否执行代码,这可以有效避免使用新的API导致的应用程序崩溃:<br><img src="http://41.media.tumblr.com/c1875f851f168467e8e3bd435fa31f8d/tumblr_inline_npnbnvrUp31qh9cw7_500.png" alt=""></p>
</li>
<li><p><code>UICollectionView</code> 新添加了许多方法来支持交互式移动</p>
</li>
<li><p>新的名为 <code>UIFieldBehavior</code> 的 UIKit Dynamics类</p>
</li>
<li><p>Xcode Assets Catalog: 设备不会一次性下载所有尺寸的图片,而根据其自身的需要下载 1x, 2x 或 3x 的图片,大大减少了应用程序的大小.</p>
</li>
</ul>
<h2 id="其他一些你可能感兴趣的链接:">其他一些你可能感兴趣的链接:</h2><ul>
<li><a href="https://t.co/cOdmXdQ0EQ" target="_blank" rel="external">API差异</a></li>
<li><a href="https://itunes.apple.com/us/book/swift-programming-language/id1002622538?mt=11" target="_blank" rel="external">Swift 2提前发布版电子书</a></li>
<li><a href="http://t.co/5pU8P4iNEH" target="_blank" rel="external">Xcode 7 发布日志</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="WWDC中那些令人感兴趣的事物:iOS_9,_Swift_2">WWDC中那些令人感兴趣的事物:iOS 9, Swift 2</h2><blockquote>
<ul>
<li>原文链接 : <a href="http://iosdevtips.co/post/1]]>
    </summary>
    
      <category term="WWDC" scheme="http://ytlvy.com/tags/WWDC/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift UIKit Dynamics Tutorial: Getting Started]]></title>
    <link href="http://ytlvy.com/2015/08/08/Swift-UIKit-Dynamics-Tutorial-Getting-Started/"/>
    <id>http://ytlvy.com/2015/08/08/Swift-UIKit-Dynamics-Tutorial-Getting-Started/</id>
    <published>2015-08-08T13:24:37.000Z</published>
    <updated>2015-08-08T13:25:06.000Z</updated>
    <content type="html"><![CDATA[<h2 id="UIKit_Dynamics_教程:_起步">UIKit Dynamics 教程: 起步</h2><blockquote>
<ul>
<li>原文链接 : <a href="http://www.raywenderlich.com/76147/uikit-dynamics-tutorial-swift" target="_blank" rel="external">UIKit Dynamics Tutorial: Getting Started</a></li>
<li>原文作者: <a href="http://www.raywenderlich.com/u/frosty" target="_blank" rel="external">James Frost</a></li>
<li>译文出自: <a href="http://www.devtf.cn/" target="_blank" rel="external">开发技术前线http://www.devtf.cn/</a></li>
<li>译者 : <a href="https://github.com/Lollypo" target="_blank" rel="external">Lollypo</a> </li>
<li>校对者: <a href="https://github.com/mrchenhao" target="_blank" rel="external">Harries Chen</a></li>
<li>状态 :  完成</li>
</ul>
</blockquote>
<p><strong>更新备注</strong>:本教程是由<a href="http://www.raywenderlich.com/u/ColinEberhardt" target="_blank" rel="external">Colin Eberhardt</a>编写的<a href="http://www.raywenderlich.com/?page_id=48020" target="_blank" rel="external"> iOS 7 by Tutorials</a>其中某章节的精简版本.由James Frost更新到iOS8并用Swift重写,在Xcode 6 beta 7版本上测试通过。</p>
<p>iOS的设计目标鼓励你去创建数字界面模拟触摸，手势，改变方向等，就好像它们真实的物理对象而远非像素的集合。最终给予用户更深层级的交互而不是肤浅的拟真设计。</p>
<p>这听起来感觉挺难的，因为让数字界面看起来是真实的远比让它感觉是真实的简单。不过好在你有一些漂亮的新工具:</p>
<ul>
<li><strong>UIKit Dynamics</strong> 是集成到UIKit中的物理引擎。这允许你创建一个感觉像是真实的界面，通过添加一些行为，例如重力，锚连接 (弹簧)以及力. 你可以定义你希望你的界面需要的物理特征, Dynamics会帮你关心其他的细枝末节。</li>
<li><strong>Motion Effects</strong> 允许你创建类似于iOS 7 主屏幕中酷酷的视差效果. 基本上你可以利用手机加速器提供的数据来创建界面来模拟手机方向发生改变的反应。</li>
</ul>
<p>当一起使用的时候，由 Dynamics 与 Motion形成用户体验的工具，让你的界面给用户生活带来非同一般的体验。当观察到他们的操作是通过一种自然、动态的方式，你的用户将会与你的app进行更深层次的连接。</p>
<blockquote>
<p><strong>注意</strong>: 由于本教程编写的时候iOS 8 还处于测试中，因此<a href="http://www.raywenderlich.com/?p=74138" target="_blank" rel="external">没有提供iOS8的截图</a>. 所有的截图都是iOS7环境下的,不过看起来与iOS 8相差不大.</p>
</blockquote>
<a id="more"></a>
<h3 id="Getting_started_起步">Getting started  起步</h3><p>UIKit Dynamics是非常有趣的；最好的学习方法就是脚踏实地先学一些小例子。</p>
<p>打开Xcode，依次选择<strong>File / New / Project …</strong> 然后选择 <strong>iOS Application / Single View Application</strong> 最后命名你的项目为<strong>DynamicsDemo</strong>。项目创建完成之后，打开 <strong>ViewController.swift</strong> ，然后在<code>viewDidLoad</code>方法中添加如下代码:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> square = <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">100</span>, y: <span class="number">100</span>, width: <span class="number">100</span>, height: <span class="number">100</span>))</span><br><span class="line">square.backgroundColor = <span class="type">UIColor</span>.grayColor()</span><br><span class="line">view.addSubview(square)</span><br></pre></td></tr></table></figure>
<p>以上代码仅仅是在界面上添加一个方形的<code>UIView</code>。</p>
<p>运行你的App,你就可以在模拟器中看到如下的正方形:</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/09/LonelySquare.png" alt=""></p>
<p>如果你在真机中运行此app,可以尝试倾斜、颠倒甚至是摇晃它.你会发现这样做没什么效果.这是因为一切是按照设计来工作的.当你添加一个View到界面上时,你希望它一直固定在设定好的坐标上,除非是你给界面添加一些动态的效果.</p>
<h3 id="Adding_gravity_添加重力">Adding gravity   添加重力</h3><p>还是在 <strong>ViewController.swift</strong>中，在<code>viewDidLoad</code>之上加上下面这些属性:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> animator: <span class="type">UIDynamicAnimator</span>!</span><br><span class="line"><span class="keyword">var</span> gravity: <span class="type">UIGravityBehavior</span>!</span><br></pre></td></tr></table></figure>
<p>这些属性是表示自动拆包可选类型(在类型后由!表示).这些属性必须是可选类型的,因为我们在<code>init</code>方法中不会初始化它们.同时也是因为在你初始化之后它们不可能为空.这样通过!就可以避免每一次都手动拆包.</p>
<p>在<code>viewDidLoad</code>方法的最后加上这段代码:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">animator = <span class="type">UIDynamicAnimator</span>(referenceView: view)</span><br><span class="line">gravity = <span class="type">UIGravityBehavior</span>(items: [square])</span><br><span class="line">animator.addBehavior(gravity)</span><br></pre></td></tr></table></figure>
<p>我会在一会儿之后解释这个.现在,运行你的程序.你会看到你的方块慢慢的开始加速向下运行,直到掉落在屏幕的底部.</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/09/FallingSquare.png" alt=""></p>
<p>刚刚添加的代码中,有两个Dynamics的类在起作用:</p>
<ul>
<li><strong>UIDynamicAnimator</strong> 是UIKit物理引擎.这个类跟踪你添加到Dynamics中的各种行为,例如重力,并且提供了整体的上下文.当你创建一个动画实例时, 你需要传递一个该动画用来定义坐标系统的View.</li>
<li><strong>UIGravityBehavior</strong> 模拟重力行为以及对一个或者多个物体施力,允许你模拟物理行为.当你创建一个行为的实例时, 你需要将此行为关联到一系列的物体上  — 通常来说是View. 这样你就可以选择哪些物体受到该行为的影响,在这个案例中物体受重力影响.</li>
</ul>
<p>大多数的行为有一些配置属性;例如,重力行为允许你改变它的角度和大小.尝试修改这些属性让你的对象降落,侧移,或者是不同加速度的对角线.</p>
<p>注意:稍微说一下,在物理世界中,重力(g)表示米每秒平方,约等于9.8m/s2.使用牛顿第二定律,运用下列公式可以计算出在重力的影响下物体将会下滑多远.</p>
<p><strong>distance = 0.5 × g × time2</strong></p>
<p>在UIKit Dynamics中,该公式是一样的不过单位却是有所不同.你使用的是每千像素平方秒而不是米.使用牛顿第二定律,基于你所提供的重力组件,仍然可以计算出在任意时间点你的View的地点.</p>
<p>但是你真的需要全部了解么?并不是这样;你真正需要知道的是<strong>g</strong>越大就表示物体下降的越快,这在数学的角度来看并不难理解.</p>
<h3 id="Setting_boundaries_设定边界">Setting boundaries  设定边界</h3><p>虽然你看不到它，这个方块甚至会继续下落后即便它已经消失在屏幕的底部.为了让它在屏幕的范围内，你需要定义一个边界.</p>
<p>在<strong>ViewController.swift</strong>中添加另外一个属性:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> collision: <span class="type">UICollisionBehavior</span>!</span><br></pre></td></tr></table></figure>
<p>在<code>viewDidLoad</code>方法的最后加上这几行:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">collision = <span class="type">UICollisionBehavior</span>(items: [square])</span><br><span class="line">collision.translatesReferenceBoundsIntoBoundary = <span class="literal">true</span></span><br><span class="line">animator.addBehavior(collision)</span><br></pre></td></tr></table></figure>
<p>以上代码创建了一个碰撞行为,其中定义了若干边界与该物体交互.</p>
<p>以上代码将<code>translatesReferenceBoundsIntoBoundary</code> 属性设为<code>true</code>,而不是显示的定义边界坐标. 这表示被关联的View的坐标被用于<code>UIDynamicAnimator</code>.</p>
<p>运行程序,你会看到方块碰撞屏幕的底部,然后反弹一下,停了下来,就像这样:</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/09/SquareAtRest.png" alt=""></p>
<p>这是一些令人印象深刻的行为,特别是考虑到你此时只添加了这一点代码.</p>
<h3 id="Handling_collisions_处理碰撞">Handling collisions  处理碰撞</h3><p>接下来,你将添加一个不可移动的障碍物来与下落的方块进行碰撞交互.</p>
<p>将下面的代码添加到<code>viewDidLoad</code>方法中添加方块View的后面:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> barrier = <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">300</span>, width: <span class="number">130</span>, height: <span class="number">20</span>))</span><br><span class="line">barrier.backgroundColor = <span class="type">UIColor</span>.redColor()</span><br><span class="line">view.addSubview(barrier)</span><br></pre></td></tr></table></figure>
<p>运行你的程序;你会看到一个红色的”障碍物”在屏幕的中间穿过.然而事实是障碍物并未对下落的方块产生影响:</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2013/09/BadBarrier.png" alt=""></p>
<p>这并不是你想要的效果,但这却是一个重要的提醒:Dynamics为只对已关联的行为的View产生影响.</p>
<p>可以看一下这张图:</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/09/DynamicClasses.png" alt=""></p>
<p><strong>UIDynamicAnimator</strong>与一个提供了坐标系统的View相关联.然后你在与此关联的物体上添加了若干个行为对它们施力.大多数行为可以与多个物体关联,同样的一个物体也可以与若干个行为关联.上面的图显示当前程序中有关联的行为.</p>
<p>无论是你现在代码中的行为还是障碍物都是不被知道的,所以从引擎系统角度看,障碍物是不存在的.</p>
<h3 id="Making_objects_respond_to_collisions_让物体对碰撞做出反应">Making objects respond to collisions  让物体对碰撞做出反应</h3><p>为了使方块与障碍物相碰撞,找到初始化碰撞行为的那行,然后替换成下面的:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collision = <span class="type">UICollisionBehavior</span>(items: [square, barrier])</span><br></pre></td></tr></table></figure>
<p>碰撞对象需要知道应该与之几乎的每一个View;因此添加障碍物到物体列表中,这样就允许碰撞对象与之发生作用.</p>
<p>运行你的程序;这两个对象产生碰撞行为,如下面的截图所示:</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2013/09/GoodBarrier.png" alt=""></p>
<p>这个碰撞的行为围绕与之关联的每个物体,形成了一个”边界”.将他们从对象改变成更坚固的物体.</p>
<p>更新之前的图示,现在可以看到现在碰撞行为与View相关联了:</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2013/09/DynamicClasses2.png" alt=""></p>
<p>然后,两个物体的相互作用还是有些不太对劲.障碍物应该是不可移动的,但是当两个物体碰撞时,你当前的配置的障碍物向着屏幕的底部移动了.</p>
<p>更奇怪的是,障碍物居然在屏幕底部弹跳,而且不像方块那样停止下来 -这样是因为重力行为没有与障碍物交互.这同样也解释了为什么障碍物直到与方块碰撞才移动.</p>
<p>看起来你需要一个不一样的解决问题的办法.由于障碍物是不可移动的,没有任何必须要让运动引擎直到它的存在,但这样如何检测碰撞呢?</p>
<h3 id="Invisible_boundaries_and_collisions_可见的边界与碰撞">Invisible boundaries and collisions  可见的边界与碰撞</h3><p>恢复碰撞行为的初始化到原来的状态，让它只知道方块：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collision = <span class="type">UICollisionBehavior</span>(items: [square])</span><br></pre></td></tr></table></figure>
<p>此行之后,添加以下内容:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add a boundary that has the same frame as the barrier</span></span><br><span class="line">collision.addBoundaryWithIdentifier(<span class="string">"barrier"</span>, forPath: <span class="type">UIBezierPath</span>(rect: barrier.frame))</span><br></pre></td></tr></table></figure>
<p>上面的代码添加了一个具有同样结构的障碍物View作为可见的边界.这个红色的障碍物保持着对用户可见,但对Dynamics引擎不可见,同时,边界对于Dynamics引擎可见,对于用户却不可见.当方块落下时,看起来似乎是与障碍物交互的,然而实际上却是撞到了不可移动的边界.</p>
<p>运行你的程序看看这个动作,如下图:</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/09/BestBarrier.png" alt=""></p>
<p>现在方块在边界处反弹,旋转了一下,然后继续继续朝屏幕底部落下.</p>
<p>现在的UIKit Dynamics的能力变得相当清楚：你可以用少量代码完成效果.在这之中有很多细节;接下来的部分我将向你展示一些Dynamics在你的应用程序中与对象的交互细节。</p>
<h3 id="Behind_the_scenes_of_collisions_碰撞背后的知识">Behind the scenes of collisions  碰撞背后的知识</h3><p>任何Dynamic行为都有一个action属性,用来提供一个block,在动画的每一步都执行:添加以下代码到<code>viewDidLoad</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">collision.action = &#123;</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">"<span class="subst">\(NSStringFromCGAffineTransform(square.transform)</span>) <span class="subst">\(NSStringFromCGPoint(square.center)</span>)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码的日志记录了下落方块的center与transform属性.运行程序,然后你就会在Xcode的输出窗口看到这些输出.</p>
<p>从开始到400毫秒这段时间,你应该是看到类似下面的日志信息:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], &#123;<span class="number">150</span>, <span class="number">236</span>&#125;</span><br><span class="line">[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], &#123;<span class="number">150</span>, <span class="number">243</span>&#125;</span><br><span class="line">[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], &#123;<span class="number">150</span>, <span class="number">250</span>&#125;</span><br></pre></td></tr></table></figure>
<p>这里你可以看到运动引擎一直在改变方块的center — 也就是动画执行中的每一步的frame值.</p>
<p>只要方块撞到障碍物,就开始旋转,这就会生成类似以下的日志信息:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0.99797821</span>, <span class="number">0.063557133</span>, -<span class="number">0.063557133</span>, <span class="number">0.99797821</span>, <span class="number">0</span>, <span class="number">0</span>] &#123;<span class="number">152</span>, <span class="number">247</span>&#125;</span><br><span class="line">[<span class="number">0.99192101</span>, <span class="number">0.12685727</span>, -<span class="number">0.12685727</span>, <span class="number">0.99192101</span>, <span class="number">0</span>, <span class="number">0</span>] &#123;<span class="number">154</span>, <span class="number">244</span>&#125;</span><br><span class="line">[<span class="number">0.97873402</span>, <span class="number">0.20513339</span>, -<span class="number">0.20513339</span>, <span class="number">0.97873402</span>, <span class="number">0</span>, <span class="number">0</span>] &#123;<span class="number">157</span>, <span class="number">241</span>&#125;</span><br></pre></td></tr></table></figure>
<p>这里你可以看到Dynamics使用的是transform与基于底层物理模型定位视图偏移的组合.</p>
<p>虽然对于Dynamics的这些属性的兴趣可能不大,不过重要的是要知道,他们正在发挥作用.因此,如果你以编程方式更改frame或transform的属性,你可以假设这些值将被覆盖.这意味着当对象被Dynamics控制时,你就不能使用transform缩放对象了.</p>
<p>该方法为Dynamics行为签名,选择物体而不是View.应用动力学行为的唯一需要就是让对象实现 <code>UIDynamicItem</code> 协议,这样:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">UIDynamicItem</span> : <span class="title">NSObjectProtocol</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> center: <span class="type">CGPoint</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">  <span class="keyword">var</span> bounds: <span class="type">CGRect</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  <span class="keyword">var</span> transform: <span class="type">CGAffineTransform</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>UIDynamicItem</code>协议允许Dynamics读写center和transform属性,允许其基于其内部计算来移动物体.它对bounds也有读取的权限,用来确定物体的大小。这允许它来创建碰撞边界的四周的物体以及计算当前物体的质量.</p>
<p>这个协议意味着引擎不与UIView耦合,此外还有一个UIKit类不是视图但仍然遵循这个协议:<code>UICollectionViewLayoutAttributes</code>.这允许引擎在集合视图内执行动画.</p>
<h3 id="Collision_notifications_碰撞提醒">Collision notifications 碰撞提醒</h3><p>到目前为止,你已经添加了一些视图和行为然后让Dynamics控制.在这一节你会看看如何在物体碰撞时接收通知.</p>
<p>还是在<strong>ViewController.swift</strong>文件中,修改类的声明来遵循 <code>UICollisionBehaviorDelegate</code>协议:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="typename">UIViewController</span>, <span class="typename">UICollisionBehaviorDelegate &#123;</span></span></span><br></pre></td></tr></table></figure>
<p>在 <code>viewDidLoad</code>方法中,将视图控制器设置为刚刚初始化的碰撞代理对象,如下:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collision<span class="class">.collisionDelegate</span> = self</span><br></pre></td></tr></table></figure>
<p>接下来,在类中实现碰撞行为代理中的一个方法:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">collisionBehavior</span><span class="params">(behavior: UICollisionBehavior!, beganContactForItem item: UIDynamicItem!, withBoundaryIdentifier identifier: NSCopying!, atPoint p: CGPoint)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">println</span>(<span class="string">"Boundary contact occurred - <span class="subst">\(identifier)</span>"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该代理方法会在发生碰撞时调用.这会在控制台输出日志信息.为了避免太多的日志信息搞乱了控制台的消息,请随意删除上一节添加的<code>collision.action</code>日志.</p>
<p>运行程序,物体发生交互,然后控制台会输出这些:</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Boundary </span>contact occurred - <span class="keyword">barrier</span><br><span class="line"></span><span class="keyword">Boundary </span>contact occurred - <span class="keyword">barrier</span><br><span class="line"></span><span class="keyword">Boundary </span>contact occurred - nil</span><br><span class="line"><span class="keyword">Boundary </span>contact occurred - nil</span><br><span class="line"><span class="keyword">Boundary </span>contact occurred - nil</span><br><span class="line"><span class="keyword">Boundary </span>contact occurred - nil</span><br></pre></td></tr></table></figure>
<p>从上面的日志消息中可以看到,方块与标识的边界发生两次碰撞;这是您前面添加的不可见的边界。(null)标识符是指外部引用视图边界.</p>
<p>这些日志消息可以引人入胜(很严肃的说!),不过需要提供一个视觉指示项来表示反弹.</p>
<p>在第二次输出日志的行后,添加以下代码:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> collidingView = item <span class="keyword">as</span> <span class="type">UIView</span></span><br><span class="line">collidingView.backgroundColor = <span class="type">UIColor</span>.yellowColor()</span><br><span class="line"><span class="type">UIView</span>.animateWithDuration(<span class="number">0.3</span>) &#123;</span><br><span class="line">collidingView.backgroundColor = <span class="type">UIColor</span>.grayColor()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码将碰撞物体的的背景颜色更改为黄色,然后再消褪到灰色.</p>
<p>运行程序然后查看这个效果:</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2013/09/YellowCollision.png" alt=""></p>
<p>方块每次碰撞到边界都会变化成黄色.</p>
<p>到目前为止UIKit Dynamics 通过计算它们的bounds自动为你的物体设置物理属性(如质量和弹性).接下来你将看到如何自己使用<code>UIDynamicItemBehavior</code>类来控制这些物理属性.</p>
<h3 id="Configuring_item_properties_设置属性">Configuring item properties  设置属性</h3><p>在<code>viewDidLoad</code>方法中,在方法的末尾加上以下代码:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let itemBehaviour = <span class="function"><span class="title">UIDynamicItemBehavior</span><span class="params">(items: [square])</span></span></span><br><span class="line">itemBehaviour<span class="class">.elasticity</span> = <span class="number">0.6</span></span><br><span class="line">animator.<span class="function"><span class="title">addBehavior</span><span class="params">(itemBehaviour)</span></span></span><br></pre></td></tr></table></figure>
<p>以上代码创建了一个物体行为,并与方块关联上,接着将其添加到animator中. elasticity属性控制物体的弹力;其值为1.0时表示碰撞完全反弹;也就是说,碰撞不消耗能量或者减缓速度.你为方块设置的elasticity为0.6,这意味着你的方块每次碰撞时都会减缓速度.</p>
<p>运行你的程序,然后你会发现方块现在的行为很有弹性,如下所示:</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2013/09/PrettyBounce.png" alt=""></p>
<blockquote>
<p>注意:如果你想知道我是如何产生上图的方块轨迹图的,这实际上很简单!我只是添加了一个block到每个行为中的action属性中,该block每三秒执行一次,然后使用当前方块的center和transform属性在视图中添加一个新的方块.下面就是我的解决方案.<br>解决方案:<br><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var updateCount = 0</span><br><span class="line"><span class="component">collision.action = &#123;</span><br><span class="line">  if (updateCount % 3 == 0) &#123;</span><br><span class="line">    let outline = UIView(frame: square<span class="string">.bounds)</span></span><br><span class="line">    outline<span class="string">.transform</span> = square<span class="string">.transform</span></span><br><span class="line">    outline<span class="string">.center</span> = square<span class="string">.center</span></span><br><span class="line">    outline<span class="string">.alpha</span> = 0.5</span><br><span class="line">    outline<span class="string">.backgroundColor</span> = UIColor<span class="string">.clearColor()</span></span><br><span class="line">    outline<span class="string">.layer.borderColor</span> = square<span class="string">.layer.presentationLayer().backgroundColor</span></span><br><span class="line">    outline<span class="string">.layer.borderWidth</span> = 1.0</span><br><span class="line">    self<span class="string">.view.addSubview(outline)</span></span><br><span class="line">  &#125;</span></span><br><span class="line">    ++updateCount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>在上面的代码你只改变了物体的弹力;然而,物体的行为类有许多可以控制的属性,如下:</p>
<ul>
<li><code>elasticity</code> – 弹力,决定碰撞时的弹力,例如,当物体发生碰撞行为时的弹力或者韧性.</li>
<li><code>friction</code>   –  摩擦力,决定物体滑动时的抵抗力.</li>
<li><code>density</code>   –  密度,如果加上大小,就能表示物体的质量.质量越大,物体越难加速或减速.</li>
<li><code>resistance</code> – 阻力,任何线性运动的抵抗力.与摩擦力不同的是,摩擦力只对滑动有效.</li>
<li><code>angularResistance</code> – 旋转的阻力.</li>
<li><code>allowsRotation</code> – 这个有点意思,因为这不表示真实物理世界中的属性. 将这个属性设置为NO可以让物体不管任何发生力量的旋转都无效.</li>
</ul>
<h3 id="Adding_behaviors_dynamically_动态添加行为">Adding behaviors dynamically  动态添加行为</h3><p>在当前情况下,你的程序为系统设置全部的行为,然后让Dynamics处理系统中的物理事件直到是全部的物体都静止下来.接下来,你将看到如何动态的添加与删除行为.</p>
<p>打开<strong>ViewController.swift</strong>,然后在<code>viewDidLoad</code>方法中添加以下属性:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> firstContact</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>添加以下代码到碰撞的代理方法<code>collisionBehavior(behavior:beganContactForItem:withBoundaryIdentifier:atPoint:)</code>的最后</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="params">(!firstContact)</span> &#123;</span><br><span class="line">  firstContact = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">let</span> <span class="built_in">square</span> = UIView<span class="params">(frame: CGRect<span class="params">(x: <span class="number">30</span>, y: <span class="number">0</span>, width: <span class="number">100</span>, height: <span class="number">100</span>)</span>)</span></span><br><span class="line">  <span class="built_in">square</span>.backgroundColor = UIColor.grayColor<span class="params">()</span></span><br><span class="line">  view.addSubview<span class="params">(square)</span></span><br><span class="line"></span><br><span class="line">  collision.addItem<span class="params">(square)</span></span><br><span class="line">  gravity.addItem<span class="params">(square)</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">let</span> attach = UIAttachmentBehavior<span class="params">(item: collidingView, attachedToItem:square)</span></span><br><span class="line">  animator.addBehavior<span class="params">(attach)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码检测初次接触时的障碍物和方块,然后创建第二个方块,并为其添加碰撞与重力行为.此外,你创建一个锚链接行为来为一对对象创建虚拟的弹簧效果.</p>
<p>运行你的程序;当最初的方块碰撞到障碍物时,你将会看到一个新的方块出现,就像下面这样:</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2013/09/Attachment.png" alt=""></p>
<p>尽管这样看起来两个方块之间似乎是连接着的,不过你在屏幕上是无法看到线条或者弹簧之类的.</p>
<h3 id="User_Interaction_用户交互">User Interaction  用户交互</h3><p>正如刚刚所看到的那样,你可以动态的添加或是删除你定义的物理系统中正在运动的行为.在最后一节,你将添加另一种类型的Dynamics行为-<code>UISnapBehavior</code>,当用户点击屏幕时,<code>UISnapBehavior</code>会生成一个弹簧动画跳转到指定位置.</p>
<p>删除你在上一节添加的代码:<code>firstContact</code>属性与<code>collisionBehavior()</code>中的if语句.这样当界面中只有一个方块时,就很容易看出来<code>UISnapBehavior</code>的作用.</p>
<p>在<code>viewDidLoad</code>中加上这两个属性:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> square</span>: UIView!</span><br><span class="line"><span class="variable"><span class="keyword">var</span> snap</span>: UISnapBehavior!</span><br></pre></td></tr></table></figure>
<p>这记录了方块视图,这样你就可以在控制器的任何地方访问到它.接下来你就会用到<code>snap</code>对象.</p>
<p>在<code>viewDidLoad</code>方法中,从声明方块的地方移除<code>let</code>关键字,这样就可以使用新的属性来替代局部变量:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">square = UIView(<span class="string">frame:</span> CGRect(<span class="string">x:</span> <span class="number">100</span>, <span class="string">y:</span> <span class="number">100</span>, <span class="string">width:</span> <span class="number">100</span>, <span class="string">height:</span> <span class="number">100</span>))</span><br></pre></td></tr></table></figure>
<p>最后,实现<code>touchesEnded</code>方法,每当用户点击屏幕的时候就创建新的触摸行为:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">touchesEnded</span><span class="params">(touches: NSSet, withEvent event: UIEvent)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (snap != <span class="literal">nil</span>) &#123;</span><br><span class="line">    animator.removeBehavior(snap)</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">let</span> touch = touches.anyObject() <span class="keyword">as</span> <span class="type">UITouch</span> </span><br><span class="line">  snap = <span class="type">UISnapBehavior</span>(item: square, snapToPoint: touch.locationInView(view))</span><br><span class="line">  animator.addBehavior(snap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码相当简单.首先,它会检查当前是否已经存在触摸行为并且移除.然后创建一个新的触摸行为来检测用户是否触摸方块,最后添加到animator中.</p>
<p>运行你的程序.尝试点击一下;无论你点击哪个地方,方块都应该会放大.</p>
<h3 id="Where_To_Go_From_Here?_何去何从">Where To Go From Here? 何去何从</h3><p>此时,你应该对于Dynamics的核心概念有了一定的理解.你可以下载本教程最后<a href="http://cdn5.raywenderlich.com/wp-content/uploads/2014/07/DynamicsDemo-Final-7.zip" target="_blank" rel="external">DynamicsDemo项目</a> 进行进一步的研究。</p>
<p>UIKit Dynamics 给你的应用带来物理引擎的能力.通过精妙的的反弹和弹簧和重力效果,给你的应用程序注入新的血液,让用户如同身临其境.</p>
<p>如果你想要更深入的学习UIKit Dynamics,请查阅我们编写的<a href="http://www.raywenderlich.com/?page_id=48020" target="_blank" rel="external">iOS 7 By Tutorials</a>. 这本书让你的知识更进一步,向你展示如何在真实场景中使用UIKit Dynamics:</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2013/09/SandwichFlowDynamics.png" alt=""></p>
<p>用户可以把菜谱上一瞥,当他们将菜谱放回时,它会掉回菜谱堆中,或者靠近屏幕顶部.最终给予应用程序一个真实的物理效果。</p>
<p>我希望你能喜欢这个UIKit Dynamics的教程,我们觉得这是非常炫酷的,期待你在程序中创造性的使用他们.如果你有任何的问题或意见,请在一下进行讨论!</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="UIKit_Dynamics_教程:_起步">UIKit Dynamics 教程: 起步</h2><blockquote>
<ul>
<li>原文链接 : <a href="http://www.raywenderlich.com/76147/uikit-dynamics-tutorial-swift">UIKit Dynamics Tutorial: Getting Started</a></li>
<li>原文作者: <a href="http://www.raywenderlich.com/u/frosty">James Frost</a></li>
<li>译文出自: <a href="http://www.devtf.cn/">开发技术前线http://www.devtf.cn/</a></li>
<li>译者 : <a href="https://github.com/Lollypo">Lollypo</a> </li>
<li>校对者: <a href="https://github.com/mrchenhao">Harries Chen</a></li>
<li>状态 :  完成</li>
</ul>
</blockquote>
<p><strong>更新备注</strong>:本教程是由<a href="http://www.raywenderlich.com/u/ColinEberhardt">Colin Eberhardt</a>编写的<a href="http://www.raywenderlich.com/?page_id=48020"> iOS 7 by Tutorials</a>其中某章节的精简版本.由James Frost更新到iOS8并用Swift重写,在Xcode 6 beta 7版本上测试通过。</p>
<p>iOS的设计目标鼓励你去创建数字界面模拟触摸，手势，改变方向等，就好像它们真实的物理对象而远非像素的集合。最终给予用户更深层级的交互而不是肤浅的拟真设计。</p>
<p>这听起来感觉挺难的，因为让数字界面看起来是真实的远比让它感觉是真实的简单。不过好在你有一些漂亮的新工具:</p>
<ul>
<li><strong>UIKit Dynamics</strong> 是集成到UIKit中的物理引擎。这允许你创建一个感觉像是真实的界面，通过添加一些行为，例如重力，锚连接 (弹簧)以及力. 你可以定义你希望你的界面需要的物理特征, Dynamics会帮你关心其他的细枝末节。</li>
<li><strong>Motion Effects</strong> 允许你创建类似于iOS 7 主屏幕中酷酷的视差效果. 基本上你可以利用手机加速器提供的数据来创建界面来模拟手机方向发生改变的反应。</li>
</ul>
<p>当一起使用的时候，由 Dynamics 与 Motion形成用户体验的工具，让你的界面给用户生活带来非同一般的体验。当观察到他们的操作是通过一种自然、动态的方式，你的用户将会与你的app进行更深层次的连接。</p>
<blockquote>
<p><strong>注意</strong>: 由于本教程编写的时候iOS 8 还处于测试中，因此<a href="http://www.raywenderlich.com/?p=74138">没有提供iOS8的截图</a>. 所有的截图都是iOS7环境下的,不过看起来与iOS 8相差不大.</p>
</blockquote>]]>
    
    </summary>
    
      <category term="UIKit Dynamics" scheme="http://ytlvy.com/tags/UIKit-Dynamics/"/>
    
      <category term="Swift" scheme="http://ytlvy.com/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift UIKit Dynamics - Tossing Views]]></title>
    <link href="http://ytlvy.com/2015/08/08/Swift-UIKit-Dynamics-Tossing-Views/"/>
    <id>http://ytlvy.com/2015/08/08/Swift-UIKit-Dynamics-Tossing-Views/</id>
    <published>2015-08-08T13:23:36.000Z</published>
    <updated>2015-08-08T13:24:14.000Z</updated>
    <content type="html"><![CDATA[<h2 id="UIKit_Dynamics_和_Swift_教程：抛掷视图_(Tossing_Views)">UIKit Dynamics 和 Swift 教程：抛掷视图 (Tossing Views)</h2><blockquote>
<ul>
<li>原文链接 : <a href="http://www.raywenderlich.com/94719/uikit-dynamics-swift-tutorial-tossing-views" target="_blank" rel="external">UIKit Dynamics and Swift Tutorial:Tossing Views</a></li>
<li>原文作者 : <a href="http://www.raywenderlich.com" target="_blank" rel="external">Ray Wenderlich</a></li>
<li>译文出自 : <a href="http://www.devtf.cn" target="_blank" rel="external">开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/samw00" target="_blank" rel="external">samw00</a> </li>
<li>校对者: <a href="https://github.com/mrchenchao" target="_blank" rel="external">mrchenchao</a></li>
<li>状态 : 完成</li>
</ul>
</blockquote>
<p>在这篇UIKit Dynamics教程中，你将学会如何通过添加手势，用一种很自然的方式将视图抛掷出屏幕的显示区域。如下图所示：</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/07/UIKitDynamics3.gif" alt="效果预览图"></p>
<p>你可能已经在<a href="https://itunes.apple.com/us/app/tweetbot-3-for-twitter-iphone/id722294701" target="_blank" rel="external">Tweetbot</a>这个流行的app里看到这一个技巧被大量的运用。</p>
<p>这篇教程特别适合中级水平的开发人员，因为内容包括如何实现一些特别棒的特效，比如用原生的UIKit框架实现旋转(rotation)和飞离(fly-away)等动画效果。</p>
<p>如果你刚刚接触UIKit dynamics, 也别紧张 － 因为这篇教程会一步一步引导你如何去做。</p>
<p>废话不多说，让我们直切主题吧！</p>
<a id="more"></a>
<h1 id="让我们开始吧">让我们开始吧</h1><blockquote>
<p>注意: 这一节是为那些想从头开始写这个项目的开发员所准备的。有经验的开发者可以直接跳过这一节去下一节”UIDynamicAnimator and UIAttachmentBehavior”, 在那我们已为你准备好了这个教程的启动项目。</p>
</blockquote>
<p>运行你的Xcode，选择<code>File\New\Project...</code>, 选择<code>iOS\Application\Single View Application template</code>然后点击<code>Next</code>。将项目命名为DynamicToss，确保语言用的是Swfit然后将设备设为iPhone.</p>
<p>接下来在左边点选项目名称并在Xcode顶部位置点击<strong>General</strong>。在<strong>Deployment Info/Device Orientation</strong>中不要勾选<strong>Landscape Left</strong>和<strong>Landscape Right</strong>，因为你的app只有竖屏这一种显示模式。</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/02/dynamictoss-orientation.png" alt=""></p>
<p>然后，下载你这个项目需要的<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2014/05/flying_goldfish.zip" target="_blank" rel="external">图片</a>，照片提供者：<a href="http://www.vickiwenderlich.com/" target="_blank" rel="external">gameartguppy.com</a>。</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/05/goldfish_feature.jpg" alt=""></p>
<p>将图片解压后添加到你项目中Images asset目录里。</p>
<p>接着，点击<strong>Main.storyboard</strong>然后再右边的工具栏中选择<strong>File Inspector</strong>。在本片教程中你不需要用到auto layout和size classes，所以勾掉<strong>Use Auto Layout</strong>选项。这会自动勾掉size classes。 在弹出的对话框中，在Keep size class data for：这一选项选iPhone，然后点击<strong>Disable Size Classes</strong>。</p>
<p>在storyboard中，在默认视图控制器中添加一个image view，然后将图片设为<strong>goldfish_feature</strong>。在image view的尺寸观察器中设置下列数值：X=33, y=137, Width=254, Height=172。紧接着在autoresizing mask中消掉弹性高度，宽度，右边距和底边距。这意味着只有顶边距和左边距是“被点选“的。</p>
<p>你的屏幕看起来应该像这样：</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/02/dynamictoss-imageview.png" alt=""></p>
<p>然后，在视图控制器中拖入两个view用以跟踪你的手势，并设置为下列数值</p>
<ul>
<li>View 1: (X=156, Y=219, Width=8, Height=8, Background=red)</li>
<li>View 2: (X=80, Y=420, Width=8, Height=8. Background=blue)</li>
</ul>
<p>当你完成之后，你的视图看起来应该是这样的：</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/02/dynamictoss-views.png" alt=""></p>
<p>基本上那就是你在storyboard中要做的所有准备，接下来就是代码了！</p>
<h2 id="Touch_Handling_触摸操作">Touch Handling 触摸操作</h2><p>打开<strong>ViewController.swift</strong>并在类中加入下列属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> imageView: <span class="type">UIImageView</span>!</span><br><span class="line"><span class="preprocessor">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> redSquare: <span class="type">UIView</span>!</span><br><span class="line"><span class="preprocessor">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> blueSquare: <span class="type">UIView</span>!</span><br><span class="line"> </span><br><span class="line">private <span class="keyword">var</span> originalBounds = <span class="type">CGRect</span>.zeroRect</span><br><span class="line">private <span class="keyword">var</span> originalCenter = <span class="type">CGPoint</span>.zeroPoint</span><br><span class="line"> </span><br><span class="line">private <span class="keyword">var</span> animator: <span class="type">UIDynamicAnimator</span>!</span><br><span class="line">private <span class="keyword">var</span> attachmentBehavior: <span class="type">UIAttachmentBehavior</span>!</span><br><span class="line">private <span class="keyword">var</span> pushBehavior: <span class="type">UIPushBehavior</span>!</span><br><span class="line">private <span class="keyword">var</span> itemBehavior: <span class="type">UIDynamicItemBehavior</span>!</span><br></pre></td></tr></table></figure>
<p>你将在等一会连接这些外部引用。其他的属性用来控制image view的运行轨迹和在触摸事件中跟踪image view的状态。</p>
<p>打开<strong>Main.storyboard</strong>然后右键（或者按住control）点击<strong>View Controller</strong>。在外部引用列表中的<strong>blueSquare</strong>右边有一个空心的小圈圈，点选后不要松开鼠标左键，然后拖拽到blue square的视图上来再松手。这会讲属性和视图对象绑定起来。</p>
<p>用同样的方式绑定red square和属性<strong>imageView</strong>。现在三个view属性应该绑定好了，如下图所示：</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/05/finallinking.png" alt=""></p>
<p>红色和蓝色的正方形代表着UIKit dynamics物理引擎用来时图像运动起来的点。</p>
<p>蓝色的正方形就代表着你触摸开始的那个点，也就是当你手指第一次触碰到屏幕的那个点。红色的正方形会跟踪你手指滑动的轨迹。</p>
<p>待会你将对dynamics做一些配置，使得当你在移动那个点的时候，image view也会相应的进行物理运动。</p>
<p>最后你还有一件事要做 － 给view添加一个手势识别。打开<strong>ViewController.swift</strong>然后在文件中加入下列方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">handleAttachmentGesture</span><span class="params">(sender:UIPanGestureRecognizer)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> location = sender.locationInView(<span class="keyword">self</span>.view)</span><br><span class="line">    <span class="keyword">let</span> boxLocation = sender.locationInView(<span class="keyword">self</span>.imageView)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> sender.state &#123;</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Began</span>:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"Your touch start position is <span class="subst">\(location)</span>"</span>)</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"Start location in image is <span class="subst">\(boxLocation)</span>"</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Ended</span>:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"Your touch end position is <span class="subst">\(location)</span>"</span>)</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"End location in image is <span class="subst">\(boxLocation)</span>"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你还要添加一个拖拽手势识别，也就是panning，然后当panning触发时，调用这个方法。现阶段，这个方法就是简单的现实你的手指在两个坐标系(view, image view)中的位置而已。</p>
<p>打开<strong>Main.storyboard</strong>，往视图上拖拽一个<strong>Pan Gesture Recognizer</strong>。然后按住control点住<strong>Pan Gesture Recognizer</strong>拖到你的<strong>View Controller</strong>，然后连接<strong>handleAttachmentGesture:</strong>。</p>
<p>现在编译运行。在屏幕上滑动或者拖拽，你应该能在控制台上看到：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Your touch <span class="operator"><span class="keyword">start</span> <span class="keyword">position</span> <span class="keyword">is</span> (<span class="number">125.0</span>,<span class="number">227.0</span>)</span><br><span class="line"><span class="keyword">Start</span> location <span class="keyword">in</span> image <span class="keyword">is</span> (<span class="number">92.0</span>,<span class="number">90.0</span>)</span><br><span class="line">Your touch <span class="keyword">end</span> <span class="keyword">position</span> <span class="keyword">is</span> (<span class="number">195.5</span>,<span class="number">374.0</span>)</span><br><span class="line"><span class="keyword">End</span> location <span class="keyword">in</span> image <span class="keyword">is</span> (<span class="number">162.5</span>,<span class="number">237.0</span>)</span></span><br></pre></td></tr></table></figure>
<p>棒极了！你已经将一切都准备好了－接下来就是添加动态特效了。</p>
<h1 id="UIDynamicAnimator_和_UIAttachmentBehavior">UIDynamicAnimator 和 UIAttachmentBehavior</h1><blockquote>
<p>注意：如果你略过了之前的内容，先下载<a href="http://cdn4.raywenderlich.com/wp-content/uploads/2015/02/DynamicToss-Starter.zip" target="_blank" rel="external">项目</a>然后继续下面的内容。</p>
</blockquote>
<p>你要做的第一件事就是当你拖拽时，让你的image view也跟着动起来。你会用到UIKit Dynamics类中一个叫UIAttachmentBehavior的类。</p>
<p>打开<strong>ViewController.swift</strong>，然后在<strong>viewDidLoad()</strong>里面，将下边的代码添加到<strong>super.viewDidLoad()</strong>下面。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">animator = <span class="type">UIDynamicAnimator</span>(referenceView: view)</span><br><span class="line">originalBounds = imageView.bounds</span><br><span class="line">originalCenter = imageView.center</span><br></pre></td></tr></table></figure>
<p>上面的代码设立了一个UIDynamicAnimator，这是UIKit的一个引擎，就是为实现物理动画而准备的。这个引擎所参照的坐标系就是你提供的这个视图控制器的view。</p>
<p>通过给animator添加各种行为(behaviors)，你可以实现attaching views, pushing views, 让视图受重力影响等等。</p>
<p>让我们先从UIAttachmentBehavior开始，当你做了一个拖拽手势时让image view跟随你的指尖移动。</p>
<p>为了实现这效果，在<strong>handleAttachmentGesture(sender:)</strong>中添加如下代码，在<strong>case .Began</strong>中的两个<strong>println</strong>语句之后：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">animator.removeAllBehaviors()</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> centerOffset = <span class="type">UIOffset</span>(horizontal: boxLocation.x - imageView.bounds.midX,</span><br><span class="line">                            vertical: boxLocation.y - imageView.bounds.midY)</span><br><span class="line">attachmentBehavior = <span class="type">UIAttachmentBehavior</span>(item: imageView,</span><br><span class="line">    offsetFromCenter: centerOffset, attachedToAnchor: location)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">redSquare.center = attachmentBehavior.anchorPoint</span><br><span class="line">blueSquare.center = location</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line">animator.addBehavior(attachmentBehavior)</span><br></pre></td></tr></table></figure>
<p>让我们来看看每一步都做了些什么：</p>
<ol>
<li>第一步，先移除animtor中任何可能残留的动画行为。</li>
<li>然后，你创建了一个<strong>UIAttachmentBehavior</strong>，用来连接用户在image view内点击的点和一个锚点（刚好这两个点是重合的）。晚点你将改变这个锚点，从而使image view跟着移动。给视图添加一个锚点，就好比在view上一个固定的点和锚点之间添加了一个隐形的拉杆。</li>
<li>更新red square来表示锚点，而blue square就是表示在image view中和锚点相连的点。当手势刚开始时，这两个点是重合的。</li>
<li>在引擎animator添加这个行为使其生效。</li>
</ol>
<p>下一步你要告诉锚点跟随你的指尖。在<strong>handleAttachmentGesture(_:)</strong>，替换掉<strong>default:</strong>中的<strong>break</strong>语句为下列代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">attachmentBehavior.anchorPoint = sender.locationInView(view)</span><br><span class="line">redSquare.center = attachmentBehavior.anchorPoint</span><br></pre></td></tr></table></figure>
<p>当用户拖拽时候，default里面的代码内容来响应手势一直更新这个事件。上面的代码就是简单的将锚点，red square和手指当前位置合为一体。当用户手指移动时，手势识别则调用这个方法更新锚点至指尖移动到的位置。同时，animator也会随着锚点的移动自动更新view。</p>
<p>编译并运行，现在你可以把view拖来拖去了：</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2014/07/004_DraggedView-281x500.png" alt=""></p>
<p>注意观察view并不是在屏幕中简单的变动；如果手势起于图像的某一个角，你会发现当你移动时view会旋转，这就要归功于锚点了。</p>
<p>不过，当你拖拽完后，视图最好能回到自己的初始位置。我们类中添加一个新的方法来完善这个功能：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">resetDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    animator.removeAllBehaviors()</span><br><span class="line">    </span><br><span class="line">    <span class="type">UIView</span>.animateWithDuration(<span class="number">0.45</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.imageView.bounds = <span class="keyword">self</span>.originalBounds</span><br><span class="line">        <span class="keyword">self</span>.imageView.center = <span class="keyword">self</span>.originalCenter</span><br><span class="line">        <span class="keyword">self</span>.imageView.transform = <span class="type">CGAffineTransformIdentiy</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在<strong>handelAttachmentGesture(_:)</strong>中，在<strong>.Ended</strong>中的<strong>println</strong>语句下添加:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resetDemo()</span><br></pre></td></tr></table></figure>
<p>编译运行，现在当你拖拽完之后，视图就应该回到它自己初始的位置了。</p>
<h1 id="UIPushBehavior">UIPushBehavior</h1><p>接下来，我们要实现的是：当你停止拖拽时，使你的view飞离(detach)，我们会给这个view赋予动能，所以当你的手松开时，它能会延续它的既定轨道去运动。我们将通过<strong>UIPushBehavior</strong>来实现这一点。</p>
<p>首先，你需要两个常量。在文件头部添加它们：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ThrowingThreshold: <span class="variable">CGFloat =</span> <span class="number">1000</span></span><br><span class="line"><span class="keyword">let</span> ThrowingVelocityPadding: <span class="variable">CGFloat =</span> <span class="number">35</span></span><br></pre></td></tr></table></figure>
<p><strong>ThrowingThreshold</strong>表明view必须移动多块才能在手指松开后继续移动(而不是马上回到它的初始位置)。<strong>ThrowingVelocityPadding</strong>是一个神奇的常量，它对抛掷view速度快慢产生影响(这个数值是经过反复试错而得出的）。</p>
<p>最后，在<strong>handleAttachmentGesture(_:)</strong>中，在<strong>.Ended</strong>分支下，用下面的代码替换原来的<strong>resetDemo()</strong>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">animator.removeAllBehaviors()</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> velocity = sender.velocityInView(view)</span><br><span class="line"><span class="keyword">let</span> magnitude = sqrt((velocity.x * velocity.x) + (velocity.y * velocity.y))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> magnitude &gt; <span class="type">ThrowingThreshold</span> &#123;</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">let</span> pushBehavior = <span class="type">UIPushBehavior</span>(items: [imageView], mode: .<span class="type">Instantaneous</span>)</span><br><span class="line">    pushBehavior.pushDirection = <span class="type">CGVector</span>(dx: velocity.x / <span class="number">10</span>, dy: velocity.y / <span class="number">10</span>)</span><br><span class="line">    pushBehavior.magnitude = magnitude / <span class="type">ThrowingVelocityPadding</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">self</span>.pushBehavior = pushBehavior</span><br><span class="line">    animator.addBehavior(pushBehavior)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">let</span> angle = <span class="type">Int</span>(arc4random_uniform(<span class="number">20</span>)) - <span class="number">10</span></span><br><span class="line"> </span><br><span class="line">    itemBehavior = <span class="type">UIDynamicItemBehavior</span>(items: [imageView])</span><br><span class="line">    itemBehavior.friction = <span class="number">0.2</span></span><br><span class="line">    itemBehavior.allowsRotation = <span class="literal">true</span></span><br><span class="line">    itemBehavior.addAngularVelocity(<span class="type">CGFloat</span>(angle), forItem: imageView)</span><br><span class="line">    animator.addBehavior(itemBehavior)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">let</span> timeOffset = <span class="type">Int64</span>(<span class="number">0.4</span> * <span class="type">Double</span>(<span class="type">NSEC_PER_SEC</span>))</span><br><span class="line">    dispatch_after(dispatch_time(<span class="type">DISPATCH_TIME_NOW</span>, timeOffset), dispatch_get_main_queue()) &#123;</span><br><span class="line">        <span class="keyword">self</span>.resetDemo()</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    resetDemo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们再来看看每一步干了些什么：</p>
<ol>
<li><p>向手势获取拖拽的速度。通过速度和你的老朋友勾股定理，你可以计算出速度的量级 － 也就是x轴方向的速度和y轴方向的速度所构成的三角形的斜边(弦）。如果想了解这个定理背后的知识，可以瞅瞅<a href="http://www.raywenderlich.com/?p=90520" target="_blank" rel="external">Trigonometry for Game Programming Tutorial</a>.</p>
</li>
<li><p>当速度的量级超过了你设定的临界值，则创建一个push behavior。Push behavior会给特定的对象施加一种力，在这里，我们通过push behavior给图像施加一种瞬间，猝发的力。而运行的方向则是由x轴速度和y轴速度合起来转换出的一个方向向量来决定的。当你创建好push behavior之后，将其添加到animator的行为序列中。</p>
</li>
<li><p>这一步则将添加一下旋转特效，让图像看起来像是“飞离”一样。你可以在这里了解背后复杂的<a href="https://github.com/u10int/URBMediaFocusViewController/blob/master/URBMediaFocusViewController.m#L636-L686" target="_blank" rel="external">数学知识</a>。其中有部分效果取决于当你开始手势时，你的手指离边界的距离。你可以尝试设置其他的值然后观察它们的移动效果。这里用的值，会给出一个非常流畅平滑和酷毙了的旋转效果。</p>
</li>
<li><p>在指定的一段时间过后，图像将会被重置回原来初始的位置，所以“颼”的一下，图像又回到屏幕中 － 就想一个撞到墙弹回来的球一样。</p>
</li>
</ol>
<p>编译并运行，这回你应该可以愉快地把你的view随意的拖拽了。</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/07/UIKitDynamics3.gif" alt=""></p>
<h1 id="接下来可以做什么？">接下来可以做什么？</h1><p>这篇UIKit Dynamics教程中的项目可以在这里<a href="http://cdn5.raywenderlich.com/wp-content/uploads/2015/04/DynamicToss-Final-1.2.zip" target="_blank" rel="external">下载</a>。</p>
<p>恭喜你，你现在已经学了如何添加一些UIKit Dynamics动画特效让你的app的UI看起来更加的酷炫。</p>
<p>如果你想学更多UIKit Dynamics的技巧, 记得去看看<a href="http://www.raywenderlich.com/?page_id=48020" target="_blank" rel="external">iOS 7 by Tutorials</a>中有两章节是专门讲UIKit Dynamics的。</p>
<p>没事就到论坛去留个言分享一下你的成功经验或者问些关于如何在iOS中实现一些酷的动画特效的问题等等。然后善用你新get的技能！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="UIKit_Dynamics_和_Swift_教程：抛掷视图_(Tossing_Views)">UIKit Dynamics 和 Swift 教程：抛掷视图 (Tossing Views)</h2><blockquote>
<ul>
<li>原文链接 : <a href="http://www.raywenderlich.com/94719/uikit-dynamics-swift-tutorial-tossing-views">UIKit Dynamics and Swift Tutorial:Tossing Views</a></li>
<li>原文作者 : <a href="http://www.raywenderlich.com">Ray Wenderlich</a></li>
<li>译文出自 : <a href="http://www.devtf.cn">开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/samw00">samw00</a> </li>
<li>校对者: <a href="https://github.com/mrchenchao">mrchenchao</a></li>
<li>状态 : 完成</li>
</ul>
</blockquote>
<p>在这篇UIKit Dynamics教程中，你将学会如何通过添加手势，用一种很自然的方式将视图抛掷出屏幕的显示区域。如下图所示：</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/07/UIKitDynamics3.gif" alt="效果预览图"></p>
<p>你可能已经在<a href="https://itunes.apple.com/us/app/tweetbot-3-for-twitter-iphone/id722294701">Tweetbot</a>这个流行的app里看到这一个技巧被大量的运用。</p>
<p>这篇教程特别适合中级水平的开发人员，因为内容包括如何实现一些特别棒的特效，比如用原生的UIKit框架实现旋转(rotation)和飞离(fly-away)等动画效果。</p>
<p>如果你刚刚接触UIKit dynamics, 也别紧张 － 因为这篇教程会一步一步引导你如何去做。</p>
<p>废话不多说，让我们直切主题吧！</p>]]>
    
    </summary>
    
      <category term="UIKit Dynamics" scheme="http://ytlvy.com/tags/UIKit-Dynamics/"/>
    
      <category term="Swift" scheme="http://ytlvy.com/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift EventKit - Requesting Permission]]></title>
    <link href="http://ytlvy.com/2015/08/08/Swift-EventKit-Requesting-Permission/"/>
    <id>http://ytlvy.com/2015/08/08/Swift-EventKit-Requesting-Permission/</id>
    <published>2015-08-08T13:22:29.000Z</published>
    <updated>2015-08-08T13:23:03.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Swift_EventKit的初学者指南—请求权限">Swift  EventKit的初学者指南—请求权限</h1><hr>
<blockquote>
<ul>
<li>原文链接 : <a href="http://www.andrewcbancroft.com/2015/05/14/beginners-guide-to-eventkit-in-swift-requesting-permission/" target="_blank" rel="external">Beginner’s Guide to EventKit in Swift – Requesting Permission</a></li>
<li>原文作者 : <a href="http://www.andrewcbancroft.com/" target="_blank" rel="external">Andrew</a></li>
<li><a href="http://www.devtf.cn" target="_blank" rel="external">译文出自 :  开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/MollyMmm" target="_blank" rel="external">MollyMmm</a> </li>
<li>校对者: <a href="https://github.com/bboyfeiyu" target="_blank" rel="external">Mr.Simple</a>  </li>
<li>状态 : 校对完成</li>
</ul>
</blockquote>
<p>EventKit为获取和操作用户日历事件和提醒提供了一系列的类.在下面的教程中,我的目标是带领你走出利用EventKit建立一个应用程序的第.我的目标是带领你迈出利用EventKit建立一个应用程序的第一步.我将演示如何向用户的日历请求许可,我还将展示几个处理用户响应的例子(当他们授予访问权限,或者拒绝).</p>
<h1 id="Example_scenario">Example scenario</h1><h1 id="场景">场景</h1><p>让我们先提出一个基本方案，作为本教程的例子。</p>
<p>假设我们正在构建一个应用程序，现在，有一个单一的视图控制器。在得到用户授权允许的情况下，我们希望这个视图控制器显示日历列表。如果用户拒绝访问,我们将向用户展示一个消息,用来说明我们的应用程序在没有访问权限时不能运行,我们也将允许他们通过单击一个按钮能够在他们的设备的设置中设置授权访问.</p>
<p>我已经创建一个那样的应用程序作为例子—跳到GitHub中查看并研究这个例子的代码.</p>
<blockquote>
<p>资源</p>
<p><a href="https://github.com/andrewcbancroft/EventTracker/tree/ask-for-permission" target="_blank" rel="external">Xcode工程示例</a></p>
</blockquote>
<h1 id="Storyboard_setup">Storyboard setup</h1><h1 id="故事面板设置">故事面板设置</h1><a id="more"></a>
<p>你使用EventKit的第一步就是需要为自己创建一个用户界面来处理当你第一个程序启动时用户对”该程序可以访问你的日历吗?”对出不同的响应,不久,我们将得到如何请求这个许可的详情.但首先,让我们来剖析我们如何用对于一个许可操作导致的给定响应能够做正确的操作的一些视图来安排我们的故事板.</p>
<p>用户可以授予访问权限,也可以拒绝授予访问权限来通知他们的日历或者提醒.我们需要为这两种情况做好准备.</p>
<h1 id="当被授予访问权限时,tableview显示日历列表">当被授予访问权限时,tableview显示日历列表</h1><p>我今天持乐观态度,所以让我们开始处理从一开始用户就授予我们访问他们日历的权限的情况.</p>
<p>当用户授予我们访问权限,我们想列出一个表视图的日历.在接下来的教程中,我们将担心数据源的设置.现在,我们将从实用工具栏中拽一个表格视图过来.</p>
<p>为了得到填满整个屏幕的表视图,我做了几件事情.通常,当你从实用工具栏中拽一个表视图过来的时候,它会在故事板中填满整个场景.在布局中我向下拖顶部边缘知道它”捕捉”到我所期望的状态栏底部被定位的那行.然后,我设置了以下限制:</p>
<blockquote>
<ul>
<li>Center X   </li>
<li>Center Y </li>
<li>Equal width to Superview</li>
<li>Top space to Top Layout Guide for height.</li>
</ul>
</blockquote>
<p>我已经创建了一个设置表视图的简短截屏,如果你想要一个完整的练习,可以参看下面链接的内容:</p>
<blockquote>
<p>Resources<br>资源</p>
<p><a href="http://bit.ly/WatchSetUpTVFromACB" target="_blank" rel="external">Screencast: Setting Up a Table View</a></p>
<p><a href="http://www.andrewcbancroft.com/2015/05/18/swift-how-to-setting-up-a-table-view/" target="_blank" rel="external"> Full transcript</a></p>
</blockquote>
<p>这里有这些约束的详细视图,以及故事板看起来像装表视图的视觉效果.</p>
<p><img src="http://ww1.sinaimg.cn/mw690/a10328aajw1eshuj6c424j20850ciwfn.jpg" alt="Detailed view of constraints"></p>
<p><img src="http://ww2.sinaimg.cn/mw690/a10328aajw1eshuj777a3j212u0oxguc.jpg" alt="Table view in Storyboard"></p>
<p>最后一点,在故事板中我已经将这个表视图的hidden属性设置为true.根据用户允许或者拒绝对日历的访问后,我将切换表的可见性,但我认为值得指出的是在我例子中表视图的初始状态是被隐藏.</p>
<h1 id="访问被拒绝时的”需要许可”视图">访问被拒绝时的”需要许可”视图</h1><p>但有时,用户拒绝授权访问日历,在意识到这样做将导致基本上停止你应用程序所有的功能之前,如果你的整个应用程序或者只是该应用程序的一部分需要访问功能,你需要一种方法来告知用户,并为他们提供一种方法跳到用户设置,如果可能的话让用户手动授予访问权限.</p>
<p>我在示例项目中的方法是在故事板场景中组织一个新的视图,该视图包含一个展示操作说明的标签和一个点击后使用户进入我们应用程序的设置界面的按钮.</p>
<p>再次,一些约束涉及到在运行时使一些事物正确的显示.在这里我不会讲述这个细节,因为它很可能因为每一个执行操作而有一点不同.</p>
<p>我将指出的意见事情是,这个视图的透明度已经被设置为0,以便如果用户拒绝授权,我能够展示一个逐渐消失的效果.下面就来看看在设置了隐藏“NeedPermissionsView”的场景：</p>
<p><img src="http://ww3.sinaimg.cn/mw690/a10328aajw1eshuj6ra19j214p0ou12b.jpg" alt="Need permission view"></p>
<h1 id="Event_Store的角色">Event Store的角色</h1><p>EventKit的核心是EKEventStore.EKEventStore是事物的中心.创建EKEventStore的一个实例,为开发人员提供了对用户的日历和提醒列表中执行各种读/写操作的API.</p>
<p>一个与日历交互的视图控制器应该有一个引用EKEventStore的实例.这很容易被创建—这里是一个例子:</p>
<blockquote>
<p>ViewController.swift</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="typename">UIViewController</span>, <span class="typename">UITableViewDataSource</span>, <span class="typename">UITableViewDelegate &#123;</span></span></span><br><span class="line">    let eventStore = EKEventStore()</span><br><span class="line">    <span class="comment">// ...    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="检查日历的授权">检查日历的授权</h1><p>一旦我们有了引用EKEventStore的实例,我们可以做像检查用户是否授权访问他们的日历这样的事情.根据这里,我们可以做是否需要请求许可的决定,随后确定要显示的视图(表视图或者需要许可视图).</p>
<p>我们在哪里检查日历授权很重要.我的建议是每次在视图出现时检查(即在viewWillAppear()中),因为用户首次授予访问权限,切换设置,拒绝访问的情况是完全有可能的.我们的应用程序需要做出适当的响应.</p>
<p>In the example project provided with this article, I’ve created a function named checkCalendarAuthorizationStatus(). Here a peek at what it does:</p>
<p>在这个文章提供的示例工程中,我已经创建了一个名为checkCalendarAuthorizationStatus()的函数.<br>接下来看看它的实现:</p>
<blockquote>
<p>ViewController.swift<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">UITableViewDataSource</span>, <span class="title">UITableViewDelegate</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...    </span></span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewWillAppear</span><span class="params">(animated: Bool)</span></span> &#123;</span><br><span class="line">        checkCalendarAuthorizationStatus()</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="func"><span class="keyword">func</span> <span class="title">checkCalendarAuthorizationStatus</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> status = <span class="type">EKEventStore</span>.authorizationStatusForEntityType(<span class="type">EKEntityTypeEvent</span>)      </span><br><span class="line">        <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="type">EKAuthorizationStatus</span>.<span class="type">NotDetermined</span>:</span><br><span class="line">                <span class="comment">// This happens on first-run</span></span><br><span class="line">                requestAccessToCalendar()</span><br><span class="line">            <span class="keyword">case</span> <span class="type">EKAuthorizationStatus</span>.<span class="type">Authorized</span>:</span><br><span class="line">                <span class="comment">// Things are in line with being able to show the calendars in the table view</span></span><br><span class="line">                loadCalendars()</span><br><span class="line">                refreshTableView()</span><br><span class="line">            <span class="keyword">case</span> <span class="type">EKAuthorizationStatus</span>.<span class="type">Restricted</span>, <span class="type">EKAuthorizationStatus</span>.<span class="type">Denied</span>:</span><br><span class="line">                <span class="comment">// We need to help them give us permission</span></span><br><span class="line">                needPermissionView.fadeIn()</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">let</span> alert = <span class="type">UIAlertView</span>(title: <span class="string">"Privacy Warning"</span>, message: <span class="string">"You have not granted permission for this app to access your Calendar"</span>, delegate: <span class="literal">nil</span>, cancelButtonTitle: <span class="string">"OK"</span>)</span><br><span class="line">                alert.show()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>这里关键的功能是EKEventStore的 authorizationStatusForEntityType实现的.传入的EKEntityTypeEvent用于跟用户日历进行交互.如果我们想要检查他们的提醒的权限,我们将在这里使用EKEntityTypeReminder.</p>
<p>EKAuthorizationStatus的可能值根据switch里的相应的case来执行封装好的方便阅读的独立功能的逻辑代码.</p>
<p>让我们一步步来看一看这些功能.</p>
<h1 id="请求访问日历">请求访问日历</h1><p>正如标题所说的,所有的事情从这里开始.每当我们的应用程序加载和调用authorizationStatusForEntityType的时候,将返回NotDetermined的状态.就是在这一点上我们想请求访问日历.</p>
<p>为了这样做,按照下面的方法定义requestAccessToCalendar函数:</p>
<blockquote>
<p>requestAccessToCalendar()<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class ViewController: <span class="built_in">UIViewController</span>, <span class="built_in">UITableViewDataSource</span>, <span class="built_in">UITableViewDelegate</span> &#123;</span><br><span class="line">   <span class="comment">// ...  </span></span><br><span class="line">   func requestAccessToCalendar() &#123;</span><br><span class="line">        eventStore<span class="variable">.requestAccessToEntityType</span>(EKEntityTypeEvent, completion: &#123;</span><br><span class="line">            (accessGranted: Bool, error: <span class="built_in">NSError</span>!) <span class="keyword">in</span>            </span><br><span class="line">            <span class="keyword">if</span> accessGranted == <span class="literal">true</span> &#123;</span><br><span class="line">                <span class="comment">// Ensure that UI refreshes happen back on the main thread!</span></span><br><span class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), &#123;</span><br><span class="line">                    <span class="keyword">self</span><span class="variable">.loadCalendars</span>()</span><br><span class="line">                    <span class="keyword">self</span><span class="variable">.refreshTableView</span>()</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Ensure that UI refreshes happen back on the main thread!</span></span><br><span class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), &#123;</span><br><span class="line">                    <span class="keyword">self</span><span class="variable">.needPermissionView</span><span class="variable">.fadeIn</span>()</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>我们的EKEventStore实例提供了一个名为requestAccessToEntityType的函数.再次将EKEntityTypeEvent作为我们请求访问日历的参数传递.剩余的有趣的部分在我们提供的封装完的闭包里能够找到.</p>
<p>在实现里有三个主要的事情需要注意:</p>
<p>1.传递到闭包里的两个参数一个是用来说明访问权限是否被授予的Bool类型的,另一个是NSError.</p>
<p>2.我们需要调用dispatch_async(),并表明我们要调回主队列中执行刷新UI的操作.</p>
<p>3.self.needPermissionView.fadeIn()作为我操作中的一个UIView的拓展,<a href="https://github.com/andrewcbancroft/EventTracker/tree/ask-for-permission" target="_blank" rel="external">Swift中渐入/淡出动画的拓展类(Fade In / Out Animations as Class Extensions in Swift)</a>.</p>
<h1 id="授予访问权限！加载日历和刷新表视图">授予访问权限！加载日历和刷新表视图</h1><p>当被允许访问的时候,我们可以调用eventStore实例中的calendarsForEntityType函数,并传递EKEntityTypeEvent去抓取用户日历的数组在我们的表视图中显示.下面就来看看:</p>
<blockquote>
<p>loadCalendars()<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">UITableViewDataSource</span>, <span class="title">UITableViewDelegate</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">var</span> calendars: [<span class="type">EKCalendar</span>]?</span><br><span class="line">    <span class="comment">// ...    </span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">loadCalendars</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.calendars = eventStore.calendarsForEntityType(<span class="type">EKEntityTypeEvent</span>) <span class="keyword">as</span>? [<span class="type">EKCalendar</span>]</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">refreshTableView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        calendarsTableView.hidden = <span class="literal">false</span></span><br><span class="line">        calendarsTableView.reloadData()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="拒绝访问—显示需要许可视图">拒绝访问—显示需要许可视图</h1><p>当访问被拒绝的时候,我们需要弹出在故事板场景中创建的“Needs Permission View”.</p>
<p>在这个视图中,上面的函数重新被调用,这样有一个能够让用户直接跳转到我们应用程序的设置页面中,以便他们能够从那里授权日历访问.这个按钮连线到了一个IBAction.下面有实现IBAction的例子:</p>
<blockquote>
<p>goToSettingsButtonTapped()<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">UITableViewDataSource</span>, <span class="title">UITableViewDelegate</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">goToSettingsButtonTapped</span><span class="params">(sender: UIButton)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> openSettingsUrl = <span class="type">NSURL</span>(string: <span class="type">UIApplicationOpenSettingsURLString</span>)</span><br><span class="line">        <span class="type">UIApplication</span>.sharedApplication().openURL(openSettingsUrl!)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="结束语">结束语</h1><p>这几乎完成了使用 Event Kit的开始工作!对于checkCalendarAuthorizationStatus()函数的其余案例简单的重用,我只是简单的剖析了请求允许的过程.</p>
<p>我鼓励你们<a href="https://github.com/andrewcbancroft/EventTracker/tree/ask-for-permission" target="_blank" rel="external">跳到Github</a>,并且作为你应用程序中利用Event Kit的开始,自己深入研究这些代码.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Swift_EventKit的初学者指南—请求权限">Swift  EventKit的初学者指南—请求权限</h1><hr>
<blockquote>
<ul>
<li>原文链接 : <a href="http://www.andrewcbancroft.com/2015/05/14/beginners-guide-to-eventkit-in-swift-requesting-permission/">Beginner’s Guide to EventKit in Swift – Requesting Permission</a></li>
<li>原文作者 : <a href="http://www.andrewcbancroft.com/">Andrew</a></li>
<li><a href="http://www.devtf.cn">译文出自 :  开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/MollyMmm">MollyMmm</a> </li>
<li>校对者: <a href="https://github.com/bboyfeiyu">Mr.Simple</a>  </li>
<li>状态 : 校对完成</li>
</ul>
</blockquote>
<p>EventKit为获取和操作用户日历事件和提醒提供了一系列的类.在下面的教程中,我的目标是带领你走出利用EventKit建立一个应用程序的第.我的目标是带领你迈出利用EventKit建立一个应用程序的第一步.我将演示如何向用户的日历请求许可,我还将展示几个处理用户响应的例子(当他们授予访问权限,或者拒绝).</p>
<h1 id="Example_scenario">Example scenario</h1><h1 id="场景">场景</h1><p>让我们先提出一个基本方案，作为本教程的例子。</p>
<p>假设我们正在构建一个应用程序，现在，有一个单一的视图控制器。在得到用户授权允许的情况下，我们希望这个视图控制器显示日历列表。如果用户拒绝访问,我们将向用户展示一个消息,用来说明我们的应用程序在没有访问权限时不能运行,我们也将允许他们通过单击一个按钮能够在他们的设备的设置中设置授权访问.</p>
<p>我已经创建一个那样的应用程序作为例子—跳到GitHub中查看并研究这个例子的代码.</p>
<blockquote>
<p>资源</p>
<p><a href="https://github.com/andrewcbancroft/EventTracker/tree/ask-for-permission">Xcode工程示例</a></p>
</blockquote>
<h1 id="Storyboard_setup">Storyboard setup</h1><h1 id="故事面板设置">故事面板设置</h1>]]>
    
    </summary>
    
      <category term="EventKit" scheme="http://ytlvy.com/tags/EventKit/"/>
    
      <category term="Swift" scheme="http://ytlvy.com/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift Core Graphics Tutorial Part 1: Getting Started]]></title>
    <link href="http://ytlvy.com/2015/08/08/Swift-Core-Graphics-Tutorial-Part-1-Getting-Started/"/>
    <id>http://ytlvy.com/2015/08/08/Swift-Core-Graphics-Tutorial-Part-1-Getting-Started/</id>
    <published>2015-08-08T13:21:23.000Z</published>
    <updated>2015-08-08T13:21:54.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Core_Graphics教程第一部分(Swift)_-_起步">Core Graphics教程第一部分(Swift) - 起步</h2><blockquote>
<ul>
<li>原文链接 : <a href="http://www.raywenderlich.com/90690/modern-core-graphics-with-swift-part-1" target="_blank" rel="external">Core Graphics Tutorial Part 1: Getting Started</a></li>
<li>原文作者 : <a href="http://www.raywenderlich.com/u/caroline" target="_blank" rel="external">Caroline Begbie </a></li>
<li>译文出自 :  <a href="www.devtf.cn">开发技术前线</a></li>
<li>译者 : <a href="https://github.com/sdq/" target="_blank" rel="external">sdq</a>  <a href="https://github.com/StormXX/" target="_blank" rel="external">StormXX</a></li>
<li>校对者:  <a href="https://github.com/StormXX/" target="_blank" rel="external">StormXX</a></li>
</ul>
</blockquote>
<p>想象一下…当你完成了你的应用，它能够很好地运行，但是界面还缺少个人的风格。这时，你可以选择用PS画出一系列尺寸的图片，并希望Apple不会再推出一个<strong>@4x</strong>的retina显示尺寸…   </p>
<p>或者，你可以领先一步，采用Core Graphics进行绘图，保证一个图片可以适应各种尺寸的屏幕。   </p>
<p>Core Graphics是苹果的一个矢量图绘制框架 - 它是一个大型且给力的API、有很多需要去学习。不过别慌，这个系列的文章会带你由简入深地学习Core Graphics，最后你将可以在你的应用中创作令人惊叹的图片。   </p>
<p>这是一个全新的系列，采用最新的方式来学习Core Graphics。这个系列完全和Xcode6与Swift保持同步，并且包含了一些很酷的新特性，比如<strong>@IBDesignable</strong>和<strong>@IBInspectable</strong>，这让学习Core Graphics变得更有趣也更容易。</p>
<p>拿起可乐，让我们开始吧！</p>
<h2 id="介绍Flo_-_一款记录喝水杯数的App">介绍Flo - 一款记录喝水杯数的App</h2><p>你将会完成一个追踪你喝水习惯的app。   </p>
<p>Flo可以让你很轻松地追踪到你喝了多少水。人们说一天喝8杯水才是健康的，但是往往喝了几杯水之后我们就忘了记录了。这就是Flo使用的时候了，每当你喝完一杯水以后，你就可以在Flo上点击计数，Flo会为你记录喝水情况。你也可以在Flo上查看到过去7天的喝水状况。</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/12/1-CompletedApp.gif" alt="demo"></p>
<p>在这个系列的第一部分，你将会通过UIKit的画图方法创建三个控件。<br>第二部分中，你将会深入了解Core Graphics的内容并且学习绘图。<br>最后第三部分，你将会制作一个样式背景，并且获得自制的Core Graphics奖牌 ：）</p>
<a id="more"></a>
<h2 id="让我们开始吧">让我们开始吧</h2><p>你的第一个任务是新建你自己的Flo应用。这边不会提供任何下载，因为只有从零开始，你才能学得更多。   </p>
<p>创建一个新项目<strong>(File\New\Project…)</strong>，选择模板<strong>iOS\Application\Single View Application</strong>，然后点击<strong>Next</strong>。   </p>
<p>弹出一个项目选项框，把项目名设为Flo，语言设置为Swift，设备选为iPhone，然后点击<strong>Next</strong>。   </p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/12/1-Xcode.png" alt="start"></p>
<p>在最后一步，不要选择Git repository，并点击<strong>Create</strong>。<br>现在你已经完成了一个拥有storyboard和view controller的初始项目</p>
<h2 id="在View上画图">在View上画图</h2><p>在画图的时候，你需要实行以下三个步骤：</p>
<ol>
<li>创建一个UIView子类。</li>
<li>重写<code>drawRect(_:)</code>并添加一些Core Graphics绘图代码。</li>
<li>想什么呢！没有第三步了 ：）</li>
</ol>
<p>让我们尝试一下画一个自制的加号按钮。</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2014/12/1-AddButtonFinal.png" alt="button"></p>
<p>创建一个新文件<strong>(File\New\File…)</strong>，选择<strong>iOS\Source\Cocoa Touch Class</strong>，取名为<strong>PushButtonView</strong>。让它继承于<strong>UIButton</strong>，确保选择的语言是<strong>Swift</strong>。点击<strong>Next</strong>并完成<strong>Create</strong>。<br>由于<strong>UIButton</strong>是<strong>UIView</strong>的子类，<strong>UIView</strong>的所有方法，像<code>drawRect(_:)</code>，在UIButton里同样存在。<br>在<strong>Main.storyboard</strong>里，将<strong>UIButton</strong>拖到View Controller的view里，并选择<strong>Document Outline</strong>。<br>在<strong>Identity Inspector</strong>把类改成你自己的<strong>PushButtonView</strong>。</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/12/1-PushButtonViewClass.png" alt="pushButtonView"></p>
<p>在<strong>Size Inspector</strong>里设置X=250, Y=350, Width=100, Height=100：</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/12/1-PlusButtonCoordinates.png" alt="sizeInspector"></p>
<h2 id="自动布局约束">自动布局约束</h2><p>现在你将要设置自动布局约束（文字指导在后面）:</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/12/1-AutoLayout.gif" alt="setUpAutoLayout"></p>
<ul>
<li>选中button，按住control从按钮的中心轻轻拖到左侧（仍旧在按钮内），在弹出的菜单中选择Width。</li>
<li>同样地，用上述方式从中间向上拖动（仍旧在按钮内），在弹出的菜单中选择Height。</li>
<li>按住control从按钮内向左拖动，直到按钮外，选择Center Vertically in Container。</li>
<li>最后，同样地由下至上从按钮内到按钮外，选择Center Horizontally in Container。<br>（以上几步中按住control和点击鼠标右键拖动的效果是一样的）<br>这几步会创建四个需要的auto layout constraints，你可以在Size Inspector看到他们：</li>
</ul>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/12/1-AutoLayoutConstraints-247x500.png" alt="sizeInspector"></p>
<p>在Attributes Inspector里移除默认的文字“Button”。</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/12/1-RemoveTitle2.png" alt="Attributes"></p>
<p>你可以在此刻编译运行程序，不过现在你只能看到一片空白，让我们来继续吧！</p>
<h2 id="画一个按钮">画一个按钮</h2><p>回忆一下，你试着画的按钮是一个圆形：</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2014/12/1-AddButtonFinal.png" alt="button"></p>
<p>为了实现在Core Graphics画一个图形，你需要定义一个路径来告诉Core Graphics如何画线（就像画一个加号需要两条直线）或者是需要填充的线（像这里的圆）。如果你很熟悉Illustrator或者Photoshop里的矢量图形，你可以很容易地就理解路径。<br>这里有三个路径的基本原则：</p>
<ul>
<li>路径可以被描边或者填充。</li>
<li>可以用当前的描边颜色为路径勾边。</li>
<li>可以用当前的填充颜色为闭合路径围起来的区域进行填充。</li>
</ul>
<p>创建Core Graphics路径的一个简单方法是采用一个好用的类UIBezierPath。这个类可以让你通过一个友好的API来创建路径，无论是你想基于线段、曲线、长方形或者是一系列的连接点。<br>让我们尝试用UIBezierPath来创建一个路径，然后用绿色来填充它。打开PushButtonView.swift，并添加以下方法：</p>
<pre><code><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">drawRect</span><span class="params">(rect: CGRect)</span></span> {
  <span class="keyword">var</span> path = <span class="type">UIBezierPath</span>(ovalInRect: rect)
  <span class="type">UIColor</span>.greenColor().setFill()
 path.fill()
}
</code></pre><p>首先，你创建了一个椭圆型的UIBezierPath，尺寸由长方形的大小决定。在本文的例子中，由于我们在storyboard里定义了100x100的按钮，所以“椭圆”其实是一个圆。<br>路径本身不会画任何东西。即使没有可绘图的上下文，你也可以定义路径。如果要绘制路径，你需要给当前的上下文一个填充颜色，然后填充路径。   </p>
<p>编译并运行应用，你会看到一个绿色的圆。</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/1-SimGreenButton2-192x320.png" alt="haha"></p>
<p>到这里，你会发现做一个自定义的view是如此简单。你通过创建一个UIButton的子类、重写<code>drawRect(_:)</code>、把UIButton放进你的storyboard中这几个简单的步骤完成了所有工作。</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/01/custom-views-not-bad-e1422223029562.png" alt="haha"></p>
<h2 id="Core_Graphics的背后实现">Core Graphics的背后实现</h2><p>每一个UIView都会有一个图形上下文，所有针对这个UIView的绘图都会先绘制到此上下文，然后再转换到设备的屏幕上。</p>
<p>iOS更新上下文的方法是<code>drawRect(_:)</code>，这个方法会在以下四种情况被调用：</p>
<ul>
<li>屏幕第一次显示这个view。</li>
<li>它顶部的view被移除。</li>
<li>view的hidden属性被修改。</li>
<li>在view上调用了了setNeedsDisplay()与setNeedsDisplayInRect()方法。</li>
</ul>
<p>注意：所有图形上下文的绘画都需要在<code>drawRect(_:)</code>中完成。最后一章中，你需要创建自己的图形上下文，你需要注意是不是在<code>drawRect(_:)</code>以外进行绘图了。</p>
<p>你还没有在本教程中使用Core Graphics，因为UIKit封装了很多Core Graphics的方法。比如UIBezierPath就是对CGMutablePath的封装，CGMutablePath是Core Graphics的底层API。</p>
<p>Note: Never call <code>drawRect(_:)</code> directly. If your view is not being updated, then call setNeedsDisplay() on the view.</p>
<p>注意：不要直接调用<code>drawRect(_:)</code>，如果你的view并没有被更新，你可以在view上调用setNeedsDisplay()。setNeedsDisplay()不会自己调用<code>drawRect(_:)</code>，但它会把view标记为“未刷新”，并触发<code>drawRect(_:)</code>。所以，即使你在一个方法中调用了五次setNeedsDisplay()，但实际中只会运行一次<code>drawRect(_:)</code>。</p>
<h2 id="@IBDesignable_–_可交互绘图">@IBDesignable – 可交互绘图</h2><p>除了写绘图代码然后运行app看效果之外，你还有其他选择。一个Xcode6的新功能是Live Rendering，你可以设置view为@IBDesignable属性，当你在<code>drawRect(_:)</code>更新view的时候，它会马上在storyboard上展示出来。</p>
<p>在PushButtonView.swift里, 在类的声明前加上:</p>
<pre><code>@IBDesignable</code></pre>
这样就可以开启Live Rendering。

现在把你的屏幕设置为同时可以看代码和storyboard。
方法是：选择PushButtonView.swift现实代码，在顶部右边点击Assistant Editor（它的图标是两个环绕的圆环）。storyboard会在右边展示。如果不是的话，你需要顶部选择到storyboard。

![3](http://cdn4.raywenderlich.com/wp-content/uploads/2014/12/1-Breadcrumbs-700x161.png)

关闭storyboard左边的文件导航栏，这样可以多留出一些空间。可以通过拖动边界或者点击storyboard左下方的按钮实现：

![1](http://cdn5.raywenderlich.com/wp-content/uploads/2014/12/1-DocumentOutline.png)

一切都完成后，你看到的是这样的：

![2](http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/1-SideBySide-638x500.png)

在PushButtonView中把<code>drawRect(_:)</code>
<pre>UIColor.greenColor().setFill()</pre>
改成
<pre>UIColor.blueColor().setFill()</pre>
你会直接在storyboard上看到改变。非常酷~

![3](http://cdn1.raywenderlich.com/wp-content/uploads/2015/01/LiveRendering-700x477.png)

## 在上下文进行绘图

Core Graphics使用的是“绘画者模型”。

当你在上下文中绘图时，就和真实世界中的绘图一样。你先画一条路径，然后填充颜色，接着你再画一条线，再继续填充。你不能改变已经画好的像素点，但是你可以在他们的上面继续作画。

这张苹果官方文档的图片描述了是如何运作的，当你在画板上绘图时，你画图的顺序是非常重要的

![4](http://cdn1.raywenderlich.com/wp-content/uploads/2014/12/1-PaintersModel.gif)

你的加号符号应该在蓝色圆圈的上面，所以你需要先画圆，再画加号。

你可以画两个长方形来完成加号，但如果用粗线绘制路径会更简单一点。

把这些代码加在<code>drawRect(_:)</code>的最后，用来画加号的水平线：

<pre><code>
//set up the width and height variables
//for the horizontal stroke
let plusHeight: CGFloat = 3.0
let plusWidth: CGFloat = min(bounds.width, bounds.height) * 0.6

//create the path
var plusPath = UIBezierPath()

//set the path's line width to the height of the stroke
plusPath.lineWidth = plusHeight

//move the initial point of the path
//to the start of the horizontal stroke
plusPath.moveToPoint(CGPoint(
  x:bounds.width/2 - plusWidth/2,
  y:bounds.height/2))

//add a point to the path at the end of the stroke
plusPath.addLineToPoint(CGPoint(
  x:bounds.width/2 + plusWidth/2,
  y:bounds.height/2))

//set the stroke color
UIColor.whiteColor().setStroke()

//draw the stroke
plusPath.stroke()
</code></pre>

<p>在这一部分中，你先设置了一个UIBezierPath，给它了一个起始为止（圆圈的左侧），然后画到重点（圆圈的右侧）。然后你设置画壁颜色为白色，这个时候你可以在Storyboard中看到如下：</p>
<p>在Storyboard中，你将看到蓝色圆圈中包含了一条水平的白线：</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/01/Dash.png" alt="1"></p>
<p>注意：记住一条路径可以由点组成。这里有一个比较容易理解的理论：当你在创建路径时，想象此时你的手中握着笔。放两个点在纸上，然后把笔放在一个起点，然后往另一个点画线。这就是上述代码中moveToPoint(_:)和addLineToPoint(_:)所做的事。</p>
<p>现在在ipad2和iphone6+的模拟器上运行代码，你会发现横线没有之前显示的那么好了，在它周围产生了淡蓝色的边框。</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2014/12/1-PixelledLine-700x170.png" alt="1"></p>
<h2 id="Points和Pixels">Points和Pixels</h2><p>在早期的iphone中，Points和Pixels所占的空间与大小是相同的。当retina屏幕的iphone问世后，屏幕上Pixels的数量变成了Points的四倍。</p>
<p>同样地，iphone6+在相同points的基础上再一次增加了pixels的数量。</p>
<p>注意：以下只是概念 - 真实的硬件像素可能是不同的。如果要了解更多iphone6+的案例，可以看下这个<a href="http://www.paintcodeapp.com/news/iphone-6-screens-demystified" target="_blank" rel="external">文章</a>。</p>
<p>这里是一个12x12的pixel矩阵，其中point以灰色和白色表示。第一个是ipad2，一个pixel对应一个point。第二个是iphone6，是一个2x的retina屏幕，4个pixel对应一个point。第三个是iphone6+，是一个3x的retina屏幕，9个pixel对应一个point。</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/1-Pixels-700x263.png" alt="1"></p>
<p>你画的线的高度是3points，两边的宽度各是1.5points。</p>
<p>这张图展示了3-point的线在各个设备上的情况。你可以看到ipad2和iphone6+都发生了覆盖一半pixel的情况，这是无法实现的。所以在实际中iOS会采用两种颜色的中间色，所以线看起来会模糊。</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2014/12/1-PixelLineDemonstrated-700x263.png" alt="1"></p>
<p>在实际中，iPhone6+有很多pixels，可能你不会注意到这些模糊的情况，但是你应该在你的app里注意尽量避免。不过如果你是为了非retina屏的设备进行开发，那么你就需要避免这类情况的发生。</p>
<p>如果你要画奇数的直线，你需要加上或减去0.5points来避免模糊。如果你看一下上面的图表，你会看到增加0.5points相当于是在ipad上增加0.5pixels，在iphone6的线顶部上增加1pixel，在iphone6+的顶部增加1.5pixels。</p>
<p>在drawRect(_:)中，把moveToPoint与addLineToPoint的代码替换为：</p>
<pre><code>
//move the initial point of the path
//to the start of the horizontal stroke
plusPath.moveToPoint(CGPoint(
  x:bounds.width/2 - plusWidth/2 + 0.5,
  y:bounds.height/2 + 0.5))

//add a point to the path at the end of the stroke
plusPath.addLineToPoint(CGPoint(
  x:bounds.width/2 + plusWidth/2 + 0.5,
  y:bounds.height/2 + 0.5))
</code></pre>

<p>现在在三种设备上都能很清晰地展示线条了，因为你对其进行了半个point的调整。</p>
<p>注意：为了线条的完美，你可以采用填充UIBezierPath(rect:)方法来代替画线条，并通过view的contentScaleFactor计算出长方形的高和宽。和画线方法会从路径的中间点开始向外计算宽度，而填充只会在路径内部进行。</p>
<p>在上述两行代码后面继续加上一条垂直线段，最后在drawRect(_:)里设置画线的颜色。我想在上述步骤之后，你应该已经知道该怎么完成了：</p>
<p>你可以在storyboard中实时看到最新的图案，这是最终完成的加号按钮：</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/12/1-FinishedPlus.png" alt="1"></p>
<h2 id="@IBInspectable_–_自定义Storyboard属性">@IBInspectable – 自定义Storyboard属性</h2><p>你知道，必须要点击一个没有需求的按钮，却只是为了确认保存是一件多么令人抓狂的事情吗？所以，你需要提供一种方式让用户从这种过于泛滥的点击中解脱出来——你需要一个减号按钮。</p>
<p>减号按钮与加号按钮基本一致，除了它没有一条竖线和并且是另外一种颜色。你需要用同样的PushButtonView类来定义减号按钮，并且在你将按钮添加到storyboard时，需要声明这个按钮的类型和颜色。</p>
<p>为了使得按钮可以被Interfase Builder读取，你需要添加@IBInspectable这一变量给按钮的属性。这也意味着，你可以在storyboard里面定义按钮的颜色，而不是在代码中编写。</p>
<p>在PushButtonView类的顶部，添加两个属性：</p>
<pre><code>
@IBInspectable var fillColor: UIColor = UIColor.greenColor()
@IBInspectable var isAddButton: Bool = true
</code></pre>

<p>从drawRect(_:)的顶部到</p>
<pre><code>
UIColor.blueColor().setFill()
</code></pre>

<p>更改和填充颜色相关的代码</p>
<pre><code>
fillColor.setFill()
</code></pre>

<p>在storyboard的视图中，按钮就会变成绿色。</p>
<p>和垂直相关的代码在drawRect(_:)中用if语句表示</p>
<pre><code>
//Vertical Line

if isAddButton {
  //vertical line code moveToPoint(_:) and addLineToPoint(_:)
}
//existing code
//set the stroke color
UIColor.whiteColor().setStroke()

//draw the stroke
plusPath.stroke()
</code></pre>

<p>这些代码让你只有在isAddButton被设置的时候才能够画垂直线，用这样的方式，一个按钮就可以既是加法按钮，又可以是减法按钮。</p>
<p>完整的PushButtonView如下列所示:</p>
<pre><code>
import UIKit

@IBDesignable
class PushButtonView: UIButton {

  @IBInspectable var fillColor: UIColor = UIColor.greenColor()
  @IBInspectable var isAddButton: Bool = true

  override func drawRect(rect: CGRect) {

    var path = UIBezierPath(ovalInRect: rect)
    fillColor.setFill()
    path.fill()

    //set up the width and height variables
    //for the horizontal stroke
    let plusHeight: CGFloat = 3.0
    let plusWidth: CGFloat = min(bounds.width, bounds.height) * 0.6     

    //create the path
    var plusPath = UIBezierPath()

    //set the path's line width to the height of the stroke
    plusPath.lineWidth = plusHeight

    //move the initial point of the path
    //to the start of the horizontal stroke
    plusPath.moveToPoint(CGPoint(
      x:bounds.width/2 - plusWidth/2 + 0.5,
      y:bounds.height/2 + 0.5))

    //add a point to the path at the end of the stroke
    plusPath.addLineToPoint(CGPoint(
      x:bounds.width/2 + plusWidth/2 + 0.5,
      y:bounds.height/2 + 0.5))

    //Vertical Line
    if isAddButton {
      //move to the start of the vertical stroke
      plusPath.moveToPoint(CGPoint(
        x:bounds.width/2 + 0.5,
        y:bounds.height/2 - plusWidth/2 + 0.5))

      //add the end point to the vertical stroke
      plusPath.addLineToPoint(CGPoint(
        x:bounds.width/2 + 0.5,
        y:bounds.height/2 + plusWidth/2 + 0.5))
    }

    //set the stroke color
    UIColor.whiteColor().setStroke()

    //draw the stroke
    plusPath.stroke()

  }

}
</code></pre>

<p>在storyboard中，选择push button view.你可以看到两个通过@IBInspectable声明的属性出现在Attributes Inspector的顶部。</p>
<p>更改填充颜色为RGB(87, 218, 213),并且设置Is Add Button为off。</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/12/1-InspectableFillColor.png" alt="1"></p>
<p>你可以立即在storyboard中看到相应的变化。</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/12/1-InspectableMinusButton.png" alt="1"></p>
<p>很酷吧？现在把Is Add Button设为on来把按钮设为加号。</p>
<h3 id="第二个按钮">第二个按钮</h3><p>添加一个UIButton到StoryBoard,选中，并在尺寸查看器（size inspector）中更新按钮的位置和大小，这里设置为X=275，Y=480，Width=50，以及Height=50：</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/12/1-PushButtonMinusCoords.png" alt="1"></p>
<p>在Identity Inspector中，选择类型（Class）的下拉菜单，将UIButton更改为PushButtonView。</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/12/1-PushButtonMinusClass.png" alt="1"></p>
<p>一个绿色的plus button功能按钮就会覆盖掉之前的按钮。<br>在Attributes inspector中，将填充颜色设置为RGB（238，77，77），并将 Is Add Button设置为off，将default title button取消。</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/12/1-MinusButtonColor.png" alt="1"></p>
<p>按照之前的步骤，给新的视图添加自动布局的约束条件。</p>
<ul>
<li>选中按钮，按住”Ctrl”键鼠标拖动按钮的中间位置向左（拖动范围在按钮以内），在弹出菜单中选择Width。</li>
<li>相似的，在按钮选中状态下，按住”Ctrl”键鼠标拖动按钮的中间位置向上（拖动范围在按钮以内），在弹出菜单中选择Height。</li>
<li>按住”Ctrl”键鼠标向上拖动，从按钮里面拖动到按钮范围外，选择Center Horizontally in Containner。</li>
<li>按住”Ctrl”键，鼠标从最底部的按钮拖动到顶部按钮，可以选择Vertical Spacing。</li>
</ul>
<p>编译并运行应用，你就可以获得一个可复用的自定义视图，并可以添加到任意app中。并且它还可以适用于任意设备的屏幕尺寸。这里给大家展示的是在iPhone 4S上面的效果。</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/12/1-SimPushButtons-339x500.png" alt="1"></p>
<h2 id="用UIBezierPath来画弧">用UIBezierPath来画弧</h2><p>下一个你要自定义的View就是下面这个：</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2014/12/1-CompletedCounterView.png" alt="1-CompletedCounterView"></p>
<p>这个看起来像是一个被填满的弧形，但是这个弧确确实实仅仅是一个粗笔画路径。而轮廓又是另一个由两个弧组成的粗笔画路径。</p>
<p>新建一个文件，<strong><em>File\New\File…</em></strong>，选择<strong><em>Cocoa Touch Class</em></strong>，然后命名这个类为CounterView。同时，让它为UIView的一个子类，并确认一下编程语言选择的是<strong><em>Swift</em></strong>。点击<strong><em>Next</em></strong>按钮，然后点击创建。然后用下面的代码把生成的代码覆盖掉：</p>
<pre><code><span class="keyword">import</span> <span class="type">UIKit</span>

<span class="keyword">let</span> <span class="type">NoOfGlasses</span> = <span class="number">8</span>
<span class="keyword">let</span> π:<span class="type">CGFloat</span> = <span class="type">CGFloat</span>(<span class="type">M_PI</span>)

<span class="preprocessor">@IBDesignable</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterView</span>: <span class="title">UIView</span> </span>{

    <span class="preprocessor">@IBInspectable</span> <span class="keyword">var</span> counter: <span class="type">Int</span> = <span class="number">5</span> 
    <span class="preprocessor">@IBInspectable</span> <span class="keyword">var</span> outlineColor: <span class="type">UIColor</span> = <span class="type">UIColor</span>.blueColor()
    <span class="preprocessor">@IBInspectable</span> <span class="keyword">var</span> counterColor: <span class="type">UIColor</span> = <span class="type">UIColor</span>.orangeColor()

    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">drawRect</span><span class="params">(rect: CGRect)</span></span> {

    }
}
</code></pre><p>注意：既然Apple允许在常量(let)和变量(var)中使用Unicode编码的字符，你可以把π作为一个常量的名字，用它来储存pi，这样能提高代码的可读性。如何输入π：同时按下Alt和P即可。</p>
<p>在这个代码中，你创建了两个常量。NoOfGlasses 代表着每天需要喝水的目标杯数。当计数到达了这个目标杯数的时候，这个计数器就到了它的最大值。<br>同时你也创建了3个你可以在storyboard里修改的@IBInspectable属性。这个counter变量用来记录当前已经喝的杯数。对于这个变量，能在storyboard里面修改它是很有必要的，尤其是当测试这个CounterView的时候。</p>
<p>打开<strong><em>Main.storyboard</em></strong>然后在“加号”按钮上添加一个UIView</p>
<p>在右边的<strong><em>Size Insepector</em></strong>面板里，设置X=185, Y=70, Width=230, 还有 Height=230：</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/12/1-CounterViewCoords.png" alt="1-CounterViewCoords"></p>
<p>给这个新的view添加几个自动布局的约束，就像你之前做的那样：</p>
<ul>
<li>选中这个View,按住control从这个view(<strong>原文这里是button，应该是view的</strong>)的中心轻轻的向左边拖动鼠标，然后释放（仍然在这个view内），从弹出来的菜单中选择Width</li>
<li>同理，选中这个View，按住control从这个view的中心轻轻的向上面拖动鼠标，然后释放（仍然在这个view内），从弹出来的菜单中选择Height</li>
<li>按住control然后从这个view中拖动鼠标到外面的view然后释放，选择Center Horizontally in Container。</li>
<li>按住control然后从这个view往下拖动鼠标，一直到上面一个button然后释放，选择Vertical Spacing.</li>
</ul>
<p>在右边的Identity Inspector面板中，把这个UIView所属的类改成CounterView。现在你在<code>drawRect(_:)</code>中的代码将会生效。</p>
<h2 id="温习数学知识">温习数学知识</h2><p>我们稍微打断一下这个教程，然后我们回顾一下高中级别的数学知识，千万不要害怕哦！就像Douglas Adams所说 - 不要慌张! :]</p>
<p>在这个context里画任何东西，都基于这个单元圆。一个单元圆就是半径为1的圆。</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/1-FloUnitCircle.png" alt="1-FloUnitCircle"></p>
<p>红色的箭头表示你的弧从哪里开始和结束，并且是按顺时针方向。接下来，你将从 3π/4弧度(135º)的位置开始画弧，然后顺时针到 π/4弧度（45º）</p>
<p>在程序中，弧度经常被使用，而不是用度数。用弧度是非常有利的，因为你不必每次跟圆打交道的时候都要转换为度数。接下来，你需要计算一下这个弧的长度，当然是用弧度来算。</p>
<p>在单元圆（半径为1）中，弧的长度等于这个角度的用弧度表示的数值。比如说，看上面的哪个图，从0º到90º的弧的长度是 π/2。在真实场景中计算弧的长度，用单位圆的弧的长度乘以真实的圆的半径。</p>
<p>计算上面的红色箭头的长度，只要计算它所跨过的弧度数值。</p>
<pre><code><span class="number">2</span><span class="literal">π</span> – <span class="keyword">end</span> of arrow (<span class="number">3</span><span class="literal">π</span>/<span class="number">4</span>) + point of arrow (<span class="literal">π</span>/<span class="number">4</span>) = <span class="number">3</span><span class="literal">π</span>/<span class="number">2</span>
</code></pre><p>用角度表示就是：</p>
<pre><code><span class="attribute">360º – 135º + 45º </span>=<span class="string"> 270º</span>
</code></pre><p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/01/celebrate-all-the-maths-e1422223051445.png" alt="celebrate-all-the-maths"></p>
<h2 id="让我们继续来画弧">让我们继续来画弧</h2><pre><code><span class="comment">// 1</span>
<span class="built_in">let</span> center = CGPoint<span class="params">(x:bounds.width/<span class="number">2</span>, y: bounds.height/<span class="number">2</span>)</span>

<span class="comment">// 2</span>
<span class="built_in">let</span> radius: CGFloat = <span class="built_in">max</span><span class="params">(bounds.width, bounds.height)</span>

<span class="comment">// 3</span>
<span class="built_in">let</span> arcWidth: CGFloat = <span class="number">76</span>

<span class="comment">// 4</span>
<span class="built_in">let</span> startAngle: CGFloat = <span class="number">3</span> <span class="built_in">*</span> π / <span class="number">4</span>
<span class="built_in">let</span> endAngle: CGFloat = π / <span class="number">4</span>

<span class="comment">// 5</span>
var path = UIBezierPath<span class="params">(arcCenter: center,
  radius: radius/<span class="number">2</span> - arcWidth/<span class="number">2</span>,
  startAngle: startAngle,
  endAngle: endAngle,
  clockwise: <span class="literal">true</span>)</span>

<span class="comment">// 6</span>
path.lineWidth = arcWidth
counterColor.setStroke<span class="params">()</span>
path.stroke<span class="params">()</span>
</code></pre><p>想象一下用圆规来画这个，首先把圆规的一个点固定在中间，然后打开圆规臂选择你需要的半径，然后装上一个细港币，然后旋转它来画弧。<br>在这个代码中，center变量代表着圆规的不动点，半径就是圆规打开的宽度（小于钢笔宽度的一半）并且这个弧的宽度就是这个钢笔笔头的宽度。</p>
<p>下面的列表解释了上面代码中每个小节的意思：</p>
<ol>
<li>定义这个view的中点，然后你将会基于这个点来通过旋转生成弧。</li>
<li>通过view的宽和高的最大值来计算弧的半径。</li>
<li>定义这个弧的粗细</li>
<li>为这个弧定义开始和结束的角度。</li>
<li>基于刚刚创建的中点，半径和角度来定义个一个弧的轨道。</li>
<li>在给这个轨道上色之前，设置这个弧的轨道的宽度和颜色。</li>
</ol>
<p>注意：当你在尝试画弧的时候，这些一般是你需要知道的，如果你想在画弧方面研究更深层次一点，你可以尝试阅读Raywenderlich老版本的 <a href="http://www.raywenderlich.com/33193/core-graphics-tutorial-arcs-and-paths" target="_blank" rel="external">Core Graphics Tutorial on Arcs and Paths</a></p>
<p>在storyboard里或者是你运行你的应用的时候，下面这个就是你可以看到的</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/12/1-SimArcStroke.png" alt="1-SimArcStroke"></p>
<h2 id="如何给弧加轮廓">如何给弧加轮廓</h2><p>当用户表示他们已经享受了一杯圣水之后（=。=），这个计数器外面的线条用来表示进度—离8杯还有多少。</p>
<p>这个外面的线由两个弧组成，一个外部一个内部，并且还有两条线来闭合他们。<br>在CounterView.swift里，把下面的代码加在<code>drawRect(_:):</code>的最后面：</p>
<pre><code><span class="comment">//Draw the outline</span>

<span class="comment">//1 - first calculate the difference between the two angles</span>
<span class="comment">//ensuring it is positive</span>
<span class="built_in">let</span> angleDifference: CGFloat = <span class="number">2</span> <span class="built_in">*</span> π - startAngle + endAngle

<span class="comment">//then calculate the arc for each single glass</span>
<span class="built_in">let</span> arcLengthPerGlass = angleDifference / CGFloat<span class="params">(NoOfGlasses)</span>

<span class="comment">//then multiply out by the actual glasses drunk</span>
<span class="built_in">let</span> outlineEndAngle = arcLengthPerGlass <span class="built_in">*</span> CGFloat<span class="params">(counter)</span> + startAngle

<span class="comment">//2 - draw the outer arc</span>
var outlinePath = UIBezierPath<span class="params">(arcCenter: center, 
                               radius: bounds.width/<span class="number">2</span> - <span class="number">2.5</span>,
                           startAngle: startAngle, 
                             endAngle: outlineEndAngle,
                            clockwise: <span class="literal">true</span>)</span>

<span class="comment">//3 - draw the inner arc</span>
outlinePath.addArcWithCenter<span class="params">(center, 
                  radius: bounds.width/<span class="number">2</span> - arcWidth + <span class="number">2.5</span>,
              startAngle: outlineEndAngle, 
                endAngle: startAngle, 
               clockwise: <span class="literal">false</span>)</span>

<span class="comment">//4 - close the path</span>
outlinePath.closePath<span class="params">()</span>

outlineColor.setStroke<span class="params">()</span>
outlinePath.lineWidth = <span class="number">5.0</span>
outlinePath.stroke<span class="params">()</span>
</code></pre><p>下面解释一下各个小节代码的意思：</p>
<ol>
<li>oulineEndAngle表示这个弧应该结束的角度，用当前的counter的值来计算。</li>
<li>outlinePath 就是外面的弧。由于这个弧不是基于单元圆的，所以把半径传给UIBezierPath()这个方法来计算这个弧的真实长度。</li>
<li>在第一个弧的基础上再加一个内部的弧。这个和前面一个弧的角度一样但是是反向的（clockwise的值置为false）。同时，这一段会自动生成一个直线连接内部弧还外部的弧。</li>
<li>在另一个弧的末尾自动画一条直线来关闭整个弧的路径。</li>
</ol>
<p>因为你在CounterView.swift中将counter属性设置为5，你的CounterView现在应该在storyboard中看起来像下面这样：</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/12/1-ArcOutline.png" alt="1-ArcOutline"></p>
<p>打开 <strong><em>Main.storyboard</em></strong>, 选择CounterView然后在右边的<strong><em>Attributes Insepector</em></strong>里，改变Counter的数值来检查你写在drawRect里的代码是否正确。然后你惊喜的发现这个storyboard里面也跟着改变了，它竟然是可以交互的。尝试改变counter的数值去超过8或者小于0。接下来你会修改这个。</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/12/1-CounterView.png" alt="1-CounterView"></p>
<h2 id="让一切都能够正常工作">让一切都能够正常工作</h2><p>祝贺你！你现在已经能够掌控这些了，现在你需要做的就是点击加号按钮来增加这个计数器的数值，或者是点击减号按钮来减少这个计数器的数值。</p>
<p>在<strong><em>Main.storyboard</em></strong>中，拖拽一个UILable控件，放置在CounterView的中间。让它成为CounterView的子View。</p>
<p>然后在右边的<strong><em>Size Inspector</em></strong>中，设置X=93, Y=93, Width=44, 还有Height=44：</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/12/1-LabelCoords.png" alt="1-LabelCoords"></p>
<p>在右边的<strong><em>Attributes Inspector</em></strong>，改变Alignment参数为center,font size为36并且默认的Label title为8.</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/12/1-LabelAttributes.png" alt="1-LabelAttributes"></p>
<p>打开ViewController.swift然后添加下面的属性到这个类的顶部：</p>
<pre><code><span class="comment">//Counter outlets</span>
<span class="variable">@IBOutlet</span> weak var <span class="attribute">counterView</span>: CounterView!
<span class="variable">@IBOutlet</span> weak var <span class="attribute">counterLabel</span>: UILabel!
</code></pre><p>还是在ViewController.swift里，添加下面的方法到这个类的最下面。</p>
<pre><code><span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">btnPushButton</span><span class="params">(button: PushButtonView)</span></span> {
<span class="keyword">if</span> button.isAddButton {
 counterView.counter++
} <span class="keyword">else</span> {
 <span class="keyword">if</span> counterView.counter &gt; <span class="number">0</span> {
   counterView.counter--
 }
}
counterLabel.text = <span class="type">String</span>(counterView.counter)
}
</code></pre><p>现在，你对计数器的增加或者减少都依赖于按钮的<strong><em>isAddButton</em></strong>属性，确保计数器不会降到0以下-没人会喝负数杯数的水。:] 同时你也要在更新label上面的计数器数值。</p>
<p>把下面这段代码也加入到<code>viewDidLoad()</code>的底部，确保这个counterLabel的初始数值也被赋值到。</p>
<pre><code>counterLabel<span class="class">.text</span> = <span class="function"><span class="title">String</span><span class="params">(counterView.counter)</span></span>
</code></pre><p>在<strong><em>Main.storyboard</em></strong>中，连接<strong><em>CounterView</em></strong> outlet和<strong><em>UILabel</em></strong> outlet到ViewController中，同时连接两个按钮的<strong><em>Touch Up Inside</em></strong>事件到ViewController里面的相关方法上。</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/1-ConnectingOutlets2.gif" alt="1-ConnectingOutlets2"></p>
<p>运行这个应用，然后看看是否你的按钮能够更新这个label上面的数字，他们应该能行的。</p>
<p>等等！为什么这个CounterView上面的进度没有更新？</p>
<p>回想一下在这个教程的开始，<code>drawRect(_:)</code>方法只有在某些情况下会被调用，比如：遮住它的view被移开的时候，或者是它的hidden属性被改变的时候，或者是这个view第一次出现在屏幕上，或者是你的app调用了<code>setNeedsDisplay()</code>或者<code>setNeedsDisplayInRect()</code>方法。</p>
<p>然而，一旦counter属性改变的时候，CounterView也必须改变它的进度条。否则，用户就会认为你的app毫无用处。</p>
<p>打开CounterView.swift 然后改变这个counter属性声明为下面的代码：</p>
<pre><code><span class="preprocessor">@IBInspectable</span> <span class="keyword">var</span> counter: <span class="type">Int</span> = <span class="number">5</span> {
    <span class="keyword">didSet</span> {
        <span class="keyword">if</span> counter &lt;=  <span class="type">NoOfGlasses</span> {
        <span class="comment">//the view needs to be refreshed</span>
        setNeedsDisplay()
        }
    }
}
</code></pre><p>这段代码使CounterView仅仅在counter的数值小于或者等于用户的每天目标杯数的时候才会刷新，因为外面的轮廓只会最高到8.</p>
<p>再一次运行你的app，一切都正常工作起来。</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/1-Part1Finished.png" alt="1-Part1Finished"></p>
<h2 id="接下来何去何从？">接下来何去何从？</h2><p>在这个教程你已经学习到了基本的绘图，现在你应该能够在你的UI里改变你的view的形状。但是等等，还有很多需要学习！在这篇教程的<a href="http://www.raywenderlich.com/?p=90693" target="_blank" rel="external">第二部分</a>，你将会尝试更深层次探索Core Graphics context并且创造一个记录你的喝水杯数的图表。</p>
<p>你可以<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2015/02/Flo-Part1-6.31.zip" target="_blank" rel="external">下载</a>这个项目的所有代码，如果你有任何问题和评论，在下面的讨论中提出来。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Core_Graphics教程第一部分(Swift)_-_起步">Core Graphics教程第一部分(Swift) - 起步</h2><blockquote>
<ul>
<li>原文链接 : <a href="http://www.raywenderlich.com/90690/modern-core-graphics-with-swift-part-1">Core Graphics Tutorial Part 1: Getting Started</a></li>
<li>原文作者 : <a href="http://www.raywenderlich.com/u/caroline">Caroline Begbie </a></li>
<li>译文出自 :  <a href="www.devtf.cn">开发技术前线</a></li>
<li>译者 : <a href="https://github.com/sdq/">sdq</a>  <a href="https://github.com/StormXX/">StormXX</a></li>
<li>校对者:  <a href="https://github.com/StormXX/">StormXX</a></li>
</ul>
</blockquote>
<p>想象一下…当你完成了你的应用，它能够很好地运行，但是界面还缺少个人的风格。这时，你可以选择用PS画出一系列尺寸的图片，并希望Apple不会再推出一个<strong>@4x</strong>的retina显示尺寸…   </p>
<p>或者，你可以领先一步，采用Core Graphics进行绘图，保证一个图片可以适应各种尺寸的屏幕。   </p>
<p>Core Graphics是苹果的一个矢量图绘制框架 - 它是一个大型且给力的API、有很多需要去学习。不过别慌，这个系列的文章会带你由简入深地学习Core Graphics，最后你将可以在你的应用中创作令人惊叹的图片。   </p>
<p>这是一个全新的系列，采用最新的方式来学习Core Graphics。这个系列完全和Xcode6与Swift保持同步，并且包含了一些很酷的新特性，比如<strong>@IBDesignable</strong>和<strong>@IBInspectable</strong>，这让学习Core Graphics变得更有趣也更容易。</p>
<p>拿起可乐，让我们开始吧！</p>
<h2 id="介绍Flo_-_一款记录喝水杯数的App">介绍Flo - 一款记录喝水杯数的App</h2><p>你将会完成一个追踪你喝水习惯的app。   </p>
<p>Flo可以让你很轻松地追踪到你喝了多少水。人们说一天喝8杯水才是健康的，但是往往喝了几杯水之后我们就忘了记录了。这就是Flo使用的时候了，每当你喝完一杯水以后，你就可以在Flo上点击计数，Flo会为你记录喝水情况。你也可以在Flo上查看到过去7天的喝水状况。</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/12/1-CompletedApp.gif" alt="demo"></p>
<p>在这个系列的第一部分，你将会通过UIKit的画图方法创建三个控件。<br>第二部分中，你将会深入了解Core Graphics的内容并且学习绘图。<br>最后第三部分，你将会制作一个样式背景，并且获得自制的Core Graphics奖牌 ：）</p>]]>
    
    </summary>
    
      <category term="Core Graphics" scheme="http://ytlvy.com/tags/Core-Graphics/"/>
    
      <category term="Swift" scheme="http://ytlvy.com/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift Core Graphics Tutorial Part 3: Patterns and Playgrounds]]></title>
    <link href="http://ytlvy.com/2015/08/08/Swift-Core-Graphics-Tutorial-Part-3-Patterns-and-Playgrounds/"/>
    <id>http://ytlvy.com/2015/08/08/Swift-Core-Graphics-Tutorial-Part-3-Patterns-and-Playgrounds/</id>
    <published>2015-08-08T13:20:32.000Z</published>
    <updated>2015-08-08T13:21:02.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Core_Graphics_教程第三部分(Swift)_-_Patterns_和_Playgrounds">Core Graphics 教程第三部分(Swift) - Patterns 和 Playgrounds</h2><blockquote>
<ul>
<li>原文链接：<a href="http://www.raywenderlich.com/90695/modern-core-graphics-with-swift-part-3" target="_blank" rel="external">Core Graphics Tutorial Part 3: Patterns and Playgrounds</a></li>
<li>原文作者：<a href="http://www.raywenderlich.com/u/caroline" target="_blank" rel="external"> Caroline Begbie </a></li>
<li>译文出自：<a href="www.devtf.cn">开发者前线</a></li>
<li>译者：<a href="https://github.com/MrLoong" target="_blank" rel="external">MrLoong</a></li>
<li>校对者：<a href="https://github.com/samw00" target="_blank" rel="external">samw00</a></li>
</ul>
</blockquote>
<p>欢迎回到Core Graphics 教学系列的第三也是最后一部分！Flo，你的water drinking tracking app将使用Core Graphics 进行最终的改进。</p>
<p>在<a href="http://www.raywenderlich.com/90690/modern-core-graphics-with-swift-part-1" target="_blank" rel="external">第一部分</a>，你通过UIKit画了三个自定义形状的控件,<a href="http://www.raywenderlich.com/90693/modern-core-graphics-with-swift-part-2" target="_blank" rel="external">在第二部分</a>你创建了一个视图用来显示用户在过去一周的喝水量，并且研究了transforming the context transformation matrix (CTM)</p>
<p>在这第三也是最后一部分，你将使<strong>Flo</strong>升级到它的最终形态，特别的是你将：</p>
<ul>
<li>创建一个重复的背景图案</li>
<li>为成功每天喝掉8杯水的用户从头到尾画一枚奖章</li>
</ul>
<p>如果你还没有这个项目的源代码，从本系列的第二部分下载<a href="http://cdn1.raywenderlich.com/wp-content/uploads/2015/02/Flo-Part2-6.3.zip" target="_blank" rel="external"><strong>Flo工程</strong></a></p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/FinalApp-192x320.png" alt=""></p>
<a id="more"></a>
<h2 id="Background_Repeating_Pattern_背景重复模式">Background Repeating Pattern 背景重复模式</h2><p>你在这部分的任务是使用UIKit的方式创建这个背景图案：</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/12/3-FinalBackground-300x500.png" alt=""></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Note: If you need to <span class="operator"><span class="keyword">optimize</span> <span class="keyword">for</span> speed, <span class="keyword">then</span> <span class="keyword">work</span> through</span><br><span class="line">Core Graphics Tutorial: Patterns which demonstrates a basic </span><br><span class="line">way <span class="keyword">to</span> <span class="keyword">create</span> patterns <span class="keyword">with</span> Objective-C <span class="keyword">and</span> Core Graphics. </span><br><span class="line"><span class="keyword">For</span> most purposes, <span class="keyword">like</span> <span class="keyword">when</span> the background <span class="keyword">is</span> <span class="keyword">only</span> drawn </span><br><span class="line">once, UIKit’s easier wrapper methods should be acceptable.</span></span><br></pre></td></tr></table></figure>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：如果你需要对速度进行优化，可以去看[<span class="link_label">Core Graphics Tutorial:Patters</span>](<span class="link_url">http://www.raywenderlich.com/33496/core-graphics-tutorial-patterns</span>)里面演示一个使用Object－c和Core Graphics的基本方法去创建一个格局.在大多数情况下当背景仅被描绘一次，使用UIKit封装好的简易方法应该是可以接受的。</span><br></pre></td></tr></table></figure>
<p>点击<strong>File\New\File…</strong>并且选择IOS <strong>iOS\Source\Cocoa Touch Class</strong> 模版创建一个类名为<strong>BackgroundView</strong>的UIView。点击下一步然后创建</p>
<p>进入<strong>Main.storyboard</strong>，在 <strong>Identity Inspector</strong>选择ViewController主界面，改变为<strong>BackgroundView</strong></p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/3-BackgroundViewStoryboard3-480x187.png" alt=""></p>
<p>点击<strong>Assistant Editor</strong>，让<strong>BackgroundView.swift</strong>和<strong>Main.storyboard</strong>并排显示。</p>
<p>替换<strong>BackgroundView.swift</strong>的代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">UIKit</span></span><br><span class="line"> </span><br><span class="line"><span class="preprocessor">@IBDesignable</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BackgroundView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//1 </span></span><br><span class="line">  <span class="preprocessor">@IBInspectable</span> <span class="keyword">var</span> lightColor: <span class="type">UIColor</span> = <span class="type">UIColor</span>.orangeColor()</span><br><span class="line">  <span class="preprocessor">@IBInspectable</span> <span class="keyword">var</span> darkColor: <span class="type">UIColor</span> = <span class="type">UIColor</span>.yellowColor()</span><br><span class="line">  <span class="preprocessor">@IBInspectable</span> <span class="keyword">var</span> patternSize:<span class="type">CGFloat</span> = <span class="number">200</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">drawRect</span><span class="params">(rect: CGRect)</span></span> &#123;</span><br><span class="line">    <span class="comment">//2</span></span><br><span class="line">    <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//3</span></span><br><span class="line">    <span class="type">CGContextSetFillColorWithColor</span>(context, darkColor.<span class="type">CGColor</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//4</span></span><br><span class="line">    <span class="type">CGContextFillRect</span>(context, rect)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在你的storyboard背景应该是黄色的，更多的细节参考上面的代码：</p>
<ol>
<li><strong>lightColor</strong>和<strong>darkColor</strong>拥有<strong>@IBInspectable</strong>属性，所以更容易去配置背景颜色。你使用橙色和黄色作为临时色，这样你就能直到到底在发生什么事。<strong>patternSize</strong>控件控制着重复形式的大小。它的初始值设置为large，所以更容易看清发生了什么。</li>
<li><strong>UIGraphicsGetCurrentContext()</strong>让你了解视图上下文同样也是<strong>drawRect(_:)</strong>将会绘画的区域。</li>
<li>使用Core Graphics的方法<strong>CGContextSetFillColorWithColor()</strong> 去设置当前上下文的填充色。注意当你使用Core Graphics时，需要用到<strong>darkColor</strong>的一个属性<strong>CGColor</strong>。</li>
<li><strong>CGContextFillRect()</strong>使用当前填充色填充当前上下文的整个背景，而不是建立一个矩形路径。</li>
</ol>
<p>你现在需要使用<strong>UIBezierPath()</strong>画这三个橙色的三角形。图中的点对应代码中的数字。</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/12/3-GridPattern.png" alt=""></p>
<p>仍然在<strong>BackgroundView.swift</strong>中操作，在 <strong>drawRect(_:)</strong>末尾添加如下代码：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">let drawSize = <span class="function"><span class="title">CGSize</span><span class="params">(width: patternSize, height: patternSize)</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//insert code here</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">let trianglePath = <span class="function"><span class="title">UIBezierPath</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line">trianglePath.moveToPoint(CGPoint(x:drawSize.<span class="attribute">width</span>/<span class="number">2</span>, </span><br><span class="line">                                 y:<span class="number">0</span>)) </span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">trianglePath.addLineToPoint(CGPoint(x:<span class="number">0</span>, </span><br><span class="line">                                    y:drawSize.<span class="attribute">height</span>/<span class="number">2</span>)) </span><br><span class="line"><span class="comment">//3</span></span><br><span class="line">trianglePath.addLineToPoint(CGPoint(x:drawSize<span class="class">.width</span>, </span><br><span class="line">                                    y:drawSize.<span class="attribute">height</span>/<span class="number">2</span>)) </span><br><span class="line"> </span><br><span class="line"><span class="comment">//4</span></span><br><span class="line">trianglePath.moveToPoint(CGPoint(x: <span class="number">0</span>, </span><br><span class="line">                                 y: drawSize.<span class="attribute">height</span>/<span class="number">2</span>)) </span><br><span class="line"><span class="comment">//5</span></span><br><span class="line">trianglePath.addLineToPoint(CGPoint(x: drawSize.<span class="attribute">width</span>/<span class="number">2</span>, </span><br><span class="line">                                    y: drawSize.<span class="attribute">height</span>)) </span><br><span class="line"><span class="comment">//6</span></span><br><span class="line">trianglePath.addLineToPoint(CGPoint(x: <span class="number">0</span>, </span><br><span class="line">                                    y: drawSize.<span class="attribute">height</span>)) </span><br><span class="line"> </span><br><span class="line"><span class="comment">//7</span></span><br><span class="line">trianglePath.moveToPoint(CGPoint(x: drawSize<span class="class">.width</span>, </span><br><span class="line">                                 y: drawSize.<span class="attribute">height</span>/<span class="number">2</span>)) </span><br><span class="line"><span class="comment">//8</span></span><br><span class="line">trianglePath.addLineToPoint(CGPoint(x:drawSize.<span class="attribute">width</span>/<span class="number">2</span>, </span><br><span class="line">                                    y:drawSize.<span class="attribute">height</span>)) </span><br><span class="line"><span class="comment">//9</span></span><br><span class="line">trianglePath.addLineToPoint(CGPoint(x: drawSize<span class="class">.width</span>, </span><br><span class="line">                                    y: drawSize.<span class="attribute">height</span>)) </span><br><span class="line"> </span><br><span class="line">lightColor.<span class="function"><span class="title">setFill</span><span class="params">()</span></span></span><br><span class="line">trianglePath.<span class="function"><span class="title">fill</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>注意你是如何使用一个路径画三个三角形的，<strong>moveToPoint(_:)</strong>就像在纸上抬起你的笔从一个地方绘制和移动到另一个地方。</p>
<p>你的storyboard现在应该有一个橙色和黄的的图像在你背景的左上方。</p>
<p>到目前为止，你都是直接在一个视图的上下文中直接绘画。为了能重复这个图案，你需要在上下文外创建一个图像，然后用这个图像作为上下文中的背景图案。</p>
<p>找到下面这段代码，在drawRect(_:)的顶部，但是在下面这段代码之后：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">et drawSize = <span class="function"><span class="title">CGSize</span><span class="params">(width: patternSize, height: patternSize)</span></span></span><br></pre></td></tr></table></figure>
<p>然后插入下面的代码</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">UIGraphicsBeginImageContextWithOptions</span><span class="params">(drawSize, true, <span class="number">0.0</span>)</span></span></span><br><span class="line">let drawingContext = <span class="function"><span class="title">UIGraphicsGetCurrentContext</span><span class="params">()</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//set the fill color for the new context</span></span><br><span class="line">darkColor.<span class="function"><span class="title">setFill</span><span class="params">()</span></span></span><br><span class="line">CGContextFillRect(drawingContext,</span><br><span class="line">      <span class="function"><span class="title">CGRectMake</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, drawSize.width, drawSize.height)</span></span>)</span><br></pre></td></tr></table></figure>
<p>嘿！那些橘黄色三角形从面板中消失了，它们去哪了？</p>
<p><strong>UIGraphicsBeginImageContextWithOptions()</strong>创建了一个新的上下文，并且将其设置为当前的绘图上下文，所以你在这个新的上下文中作画。刚才方法的参数为：</p>
<ul>
<li>context的大小</li>
<li>背景是否透明— 如果你需要透明的, 这里设置为false.</li>
<li>context scale的大小. 如果要适应视网膜屏幕, 这里应该设置为2, 如果要适应iPhone 6 Plus, 应该为3.0. 然而这里使用0.0将自动适配屏幕</li>
</ul>
<p>然后你用 <strong>UIGraphicsGetCurrentContext()</strong>得到这个新的上下文的引用。</p>
<p>然后你将这个新的context设置为黄色。你可以通过设这context的属性opacity为false让原来的背景色显示，但是画一个不透明的context比画一个透明的要快得多，凭这一点就应该选opaque。</p>
<p>在<strong>drawRect(_:)</strong>的末尾添加下面的代码：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let image = <span class="function"><span class="title">UIGraphicsGetImageFromCurrentImageContext</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">UIGraphicsEndImageContext</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>在当前的context提取一个UIImage。当你使用<strong>UIGraphicsEndImageContext()</strong>结束当前context时，描绘context还原为视图context，所以任何未来在<strong>drawRect(_:)</strong> 中的的绘图都会反应在viwe中。</p>
<p>为了使图像作为一个可重复的图案，在drawRect(_:)末尾添加代码：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">UIColor</span><span class="params">(patternImage: image)</span></span>.<span class="function"><span class="title">setFill</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">CGContextFillRect</span><span class="params">(context, rect)</span></span></span><br></pre></td></tr></table></figure>
<p>这会让图片当作UIColor中的一个新的颜色来用，而不是一个纯色。</p>
<p>编译并且运行app，你现在的app应该有一个相当亮眼的背景：</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/12/3-BoldBackground2.png" alt=""></p>
<p>去Main.storyboard，选择background view，并且在Attributes Inspector改变IBInspectable属性的值为：</p>
<ul>
<li>Light Color: RGB(255, 255, 242)</li>
<li>Dark Color: RGB(223, 255, 247)</li>
<li>Pattern Size: 30</li>
</ul>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/3-BackgroundColors2-473x320.png" alt=""></p>
<p>尝试去画一些不同的背景图案，看看除了三角形，你能不能把背景图案变成polka dot。</p>
<p>当然，你可以使用自己的非矢量图作为背景图案</p>
<h2 id="Drawing_Images_绘制图像">Drawing Images 绘制图像</h2><p>在本教程的最后阶段，你将为喝够水的人送上一个奖牌，当计数器纪录的数量达到8杯的时候这个奖牌将出现。</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/12/3-MedalFinal.png" alt=""></p>
<p>我知道这肯定比不上博物馆里的一件艺术品，但是请你知道，如果你改进它，我并不会生气，甚至你可以通过画一个奖杯而不是奖牌来升华一下。</p>
<p>你将在<strong>Swift Playground</strong>中绘制这个奖牌，而不是用<strong>@IBDesignable</strong>，然后把代码复制到<strong>UIImageView</strong>的子类中。虽然与storyboards互动通长是很有用的，但他们有局限性。他们仅能描绘简单的代码，当你创建一个复杂的设计时，storyboards通长很耗时间。</p>
<p>在这种情况下，只有当用户喝满八杯水的时候才需要画一个图像。如果用户从来没有到达到过目标，那就根本不需要绘制奖牌。</p>
<p>一旦绘制，他也不需要使用drawRect(_:)和setNeedsDisplay().进行重绘。</p>
<p>是时候作画了。首先点击Standard Editor按钮，让Xcode返回单一界面编辑模式。</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/3-StandardEditor.png" alt=""></p>
<p>点击<strong>File\New\File…</strong>并且选择IOS Playground模版。点击 Next 命名playground为MedalDrawing然后点击Create。</p>
<p>把playground中的代码替换为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line"> </span><br><span class="line">let size = <span class="function"><span class="title">CGSize</span><span class="params">(width: <span class="number">120</span>, height: <span class="number">200</span>)</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="title">UIGraphicsBeginImageContextWithOptions</span><span class="params">(size, false, <span class="number">0.0</span>)</span></span></span><br><span class="line">let context = <span class="function"><span class="title">UIGraphicsGetCurrentContext</span><span class="params">()</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//This code must always be at the end of the playground</span></span><br><span class="line">let image = <span class="function"><span class="title">UIGraphicsGetImageFromCurrentImageContext</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">UIGraphicsEndImageContext</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>这将创建一个绘制上下文，就像你之前刚给重复背景图片做的是一回事。</p>
<p>注意最后两行。你总是需要它们在playground底部，这样你就可以在playground中预览图片。</p>
<p>下一步，在灰色的结果栏中单击代码右边的＋按钮：</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/02/ShowFinishedImage.gif" alt=""></p>
<p>这将在代码的底部预览你的图像。图像将根据你代码的每次更新而更新。</p>
<p>在你作画之前，最好能在你的脑海里先有一张绘制草图，看看我在构造这篇tutorial时所构想的“杰作”：</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/12/3-Sketch.png" alt=""></p>
<p>下面是绘制奖牌的顺序:</p>
<ol>
<li>后丝带（红色）</li>
<li>奖章（金色渐变）</li>
<li>扣环（暗金色）</li>
<li>前丝带（蓝色）</li>
<li>数字1（暗金色）</li>
</ol>
<p>记住不要变动playground的最后两行（在你最后提取背景图像的地方），并且在那两行代码前添加描绘代码：</p>
<p>首先设置你要的非标准颜色。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Gold colors</span></span><br><span class="line">let darkGoldColor = UIColor(<span class="string">red:</span> <span class="number">0.6</span>, <span class="string">green:</span> <span class="number">0.5</span>, <span class="string">blue:</span> <span class="number">0.15</span>, <span class="string">alpha:</span> <span class="number">1.0</span>)</span><br><span class="line">let midGoldColor = UIColor(<span class="string">red:</span> <span class="number">0.86</span>, <span class="string">green:</span> <span class="number">0.73</span>, <span class="string">blue:</span> <span class="number">0.3</span>, <span class="string">alpha:</span> <span class="number">1.0</span>)</span><br><span class="line">let lightGoldColor = UIColor(<span class="string">red:</span> <span class="number">1.0</span>, <span class="string">green:</span> <span class="number">0.98</span>, <span class="string">blue:</span> <span class="number">0.9</span>, <span class="string">alpha:</span> <span class="number">1.0</span>)</span><br></pre></td></tr></table></figure>
<p>这些现在应该看起来非常熟悉了。注意当你声明颜色的时候，颜色会出现在palyground的右边。</p>
<p>下面的代码将绘制奖章的红色丝带：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Lower Ribbon</span></span><br><span class="line"><span class="tag">var</span> lowerRibbonPath = <span class="function"><span class="title">UIBezierPath</span><span class="params">()</span></span></span><br><span class="line">lowerRibbonPath.<span class="function"><span class="title">moveToPoint</span><span class="params">(CGPointMake(<span class="number">0</span>, <span class="number">0</span>)</span></span>)</span><br><span class="line">lowerRibbonPath.<span class="function"><span class="title">addLineToPoint</span><span class="params">(CGPointMake(<span class="number">40</span>,<span class="number">0</span>)</span></span>)</span><br><span class="line">lowerRibbonPath.<span class="function"><span class="title">addLineToPoint</span><span class="params">(CGPointMake(<span class="number">78</span>, <span class="number">70</span>)</span></span>)</span><br><span class="line">lowerRibbonPath.<span class="function"><span class="title">addLineToPoint</span><span class="params">(CGPointMake(<span class="number">38</span>, <span class="number">70</span>)</span></span>)</span><br><span class="line">lowerRibbonPath.<span class="function"><span class="title">closePath</span><span class="params">()</span></span></span><br><span class="line">UIColor.<span class="function"><span class="title">redColor</span><span class="params">()</span></span>.<span class="function"><span class="title">setFill</span><span class="params">()</span></span></span><br><span class="line">lowerRibbonPath.<span class="function"><span class="title">fill</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>没有什么新东西，就是创建一个路径并且填充它。你应该看见红色的路径出现在右侧。</p>
<p>添加描绘扣环的代码：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Clasp</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">var</span> claspPath = UIBezierPath(roundedRect: </span><br><span class="line">                           <span class="function"><span class="title">CGRectMake</span><span class="params">(<span class="number">36</span>, <span class="number">62</span>, <span class="number">43</span>, <span class="number">20</span>)</span></span>, </span><br><span class="line">                           cornerRadius: <span class="number">5</span>)</span><br><span class="line">claspPath<span class="class">.lineWidth</span> = <span class="number">5</span></span><br><span class="line">darkGoldColor.<span class="function"><span class="title">setStroke</span><span class="params">()</span></span></span><br><span class="line">claspPath.<span class="function"><span class="title">stroke</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>这里你将通过<strong>UIBezierPath(roundedRect:)</strong>中的<strong>cornerRadius</strong>这个参数来设置圆角。<br>扣环应该在右侧显示了。</p>
<p>添加绘制奖章的代码：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Medallion</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">var</span> medallionPath = UIBezierPath(ovalInRect: </span><br><span class="line">                    <span class="function"><span class="title">CGRect</span><span class="params">(origin: CGPointMake(<span class="number">8</span>, <span class="number">72</span>)</span></span>, </span><br><span class="line">                             size: <span class="function"><span class="title">CGSizeMake</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>))</span><br><span class="line"><span class="comment">//CGContextSaveGState(context)</span></span><br><span class="line"><span class="comment">//medallionPath.addClip()</span></span><br><span class="line">let gradient = CGGradientCreateWithColors(</span><br><span class="line">                      <span class="function"><span class="title">CGColorSpaceCreateDeviceRGB</span><span class="params">()</span></span>, </span><br><span class="line">                      [darkGoldColor<span class="class">.CGColor</span>, </span><br><span class="line">                       midGoldColor<span class="class">.CGColor</span>, </span><br><span class="line">                       lightGoldColor.CGColor],</span><br><span class="line">                      [<span class="number">0</span>, <span class="number">0.51</span>, <span class="number">1</span>])</span><br><span class="line">CGContextDrawLinearGradient(context,</span><br><span class="line">                            gradient, </span><br><span class="line">                            <span class="function"><span class="title">CGPointMake</span><span class="params">(<span class="number">40</span>, <span class="number">40</span>)</span></span>, </span><br><span class="line">                            <span class="function"><span class="title">CGPointMake</span><span class="params">(<span class="number">40</span>,<span class="number">162</span>)</span></span>, </span><br><span class="line">                             <span class="number">0</span>)</span><br><span class="line"><span class="comment">//CGContextRestoreGState(context)</span></span><br></pre></td></tr></table></figure>
<p>注意注释部分，这些都是暂时显示颜色渐变是如何写的：</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/3-SquareGradient.png" alt=""></p>
<p>为了使颜色从左上角至右下角渐变，改变渐变最终点的x坐标，修改<strong>CGContextDrawLinearGradient()</strong>中的代码：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CGContextDrawLinearGradient(context,</span><br><span class="line">                            gradient, </span><br><span class="line">                            <span class="function"><span class="title">CGPointMake</span><span class="params">(<span class="number">40</span>, <span class="number">40</span>)</span></span>, </span><br><span class="line">                            <span class="function"><span class="title">CGPointMake</span><span class="params">(<span class="number">100</span>,<span class="number">160</span>)</span></span>, </span><br><span class="line">                             <span class="number">0</span>)</span><br><span class="line">``` </span><br><span class="line">![](http:<span class="comment">//cdn3.raywenderlich.com/wp-content/uploads/2014/12/3-SkewedGradient.png)</span></span><br><span class="line"></span><br><span class="line">现在取消奖章那部分代码中的三行注释从而创建了一个剪切路径把渐变图案约束在奖章的圈圈内。</span><br><span class="line"></span><br><span class="line">就像你在第二部分绘制图形是一样，你在添加剪切路径前保存了绘画上下文，在渐变画好自后你有将上下文恢复了回去，所以上下文不再是被剪切的状态了。</span><br><span class="line"></span><br><span class="line">![](http:<span class="comment">//cdn5.raywenderlich.com/wp-content/uploads/2014/12/3-ClippedGradient.png)</span></span><br><span class="line"></span><br><span class="line">用奖牌的圆圈路径来绘制奖牌上的实线，但绘制前要改变比例。你只将改变应用到一个路径上而不是转变整个context。</span><br><span class="line"></span><br><span class="line">在绘制奖章的代码下添加：</span><br></pre></td></tr></table></figure>
<p>//Create a transform<br>//Scale it, and translate it right and down<br>var transform = CGAffineTransformMakeScale(0.8, 0.8)<br>transform = CGAffineTransformTranslate(transform, 15, 30)</p>
<p>medallionPath.lineWidth = 2.0</p>
<p>//apply the transform to the path<br>medallionPath.applyTransform(transform)<br>medallionPath.stroke()<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">!<span class="attr_selector">[]</span>(<span class="attribute">http</span>:<span class="comment">//cdn5.raywenderlich.com/wp-content/uploads/2014/12/3-MedalOutline.png)</span></span><br><span class="line"></span><br><span class="line">这将路径的尺寸缩小至原始尺寸的<span class="number">80%</span>，并转换路径使其人在渐变视图中居中。</span><br><span class="line"></span><br><span class="line">之后添加前丝带的绘制代码：</span><br></pre></td></tr></table></figure></p>
<p>//Upper Ribbon</p>
<p>var upperRibbonPath = UIBezierPath()<br>upperRibbonPath.moveToPoint(CGPointMake(68, 0))<br>upperRibbonPath.addLineToPoint(CGPointMake(108, 0))<br>upperRibbonPath.addLineToPoint(CGPointMake(78, 70))<br>upperRibbonPath.addLineToPoint(CGPointMake(38, 70))<br>upperRibbonPath.closePath()</p>
<p>UIColor.blueColor().setFill()<br>upperRibbonPath.fill()<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这和你之前给后丝带添加的代码非常相似，创建一个<span class="tag">bezier</span>路径并且填充。</span><br><span class="line"></span><br><span class="line">!<span class="attr_selector">[]</span>(<span class="rule"><span class="attribute">http</span>:<span class="value">//cdn4.raywenderlich.com/wp-content/uploads/<span class="number">2014</span>/<span class="number">12</span>/<span class="number">3</span>-UpperRibbon.png)</span><br><span class="line"></span><br><span class="line">最后一步是在奖章上画数字<span class="number">1</span>，代码如下：</span></span></span><br></pre></td></tr></table></figure></p>
<p>//Number One</p>
<p>//Must be NSString to be able to use drawInRect()<br>let numberOne = “1”<br>let numberOneRect = CGRectMake(47, 100, 50, 50)<br>let font = UIFont(name: “Academy Engraved LET”, size: 60)<br>let textStyle = NSMutableParagraphStyle.defaultParagraphStyle()<br>let numberOneAttributes = [<br>  NSFontAttributeName: font!,<br>  NSForegroundColorAttributeName: darkGoldColor]<br>numberOne.drawInRect(numberOneRect,<br>                     withAttributes:numberOneAttributes)<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在这里你定义了一个字符串并设置了字体属性，然后使用**<span class="function"><span class="title">drawInRect</span><span class="params">(_:)</span></span>.**在context进行了重绘</span><br><span class="line"></span><br><span class="line">![](http:<span class="comment">//cdn3.raywenderlich.com/wp-content/uploads/2014/12/3-NumberOne.png)</span></span><br><span class="line"></span><br><span class="line">看上去不错</span><br><span class="line"></span><br><span class="line">你已经很接近成功了，但它看起来有一些二维 － 如果加上一些阴影会更好。</span><br><span class="line"></span><br><span class="line">#<span class="id">#Shadows</span> 阴影</span><br><span class="line"></span><br><span class="line">创建一个阴影需要三个要素：颜色，偏移（阴影的距离和方向）和模糊</span><br><span class="line"></span><br><span class="line">在 playground 顶部，位于自定义颜色之后但在<span class="comment">//Lower Ribbon之前，插入实现阴影的代码：</span></span><br></pre></td></tr></table></figure></p>
<p>//Add Shadow<br>let shadow:UIColor = UIColor.blackColor().colorWithAlphaComponent(0.80)<br>let shadowOffset = CGSizeMake(2.0, 2.0)<br>let shadowBlurRadius: CGFloat = 5</p>
<p>CGContextSetShadowWithColor(context,<br>                            shadowOffset,<br>                            shadowBlurRadius,<br>                            shadow.CGColor)<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Okay，这能给我们一个阴影，但结果并不是我们所想象的那样。为什么呢？</span><br><span class="line"></span><br><span class="line">![](<span class="string">http:</span><span class="comment">//cdn5.raywenderlich.com/wp-content/uploads/2014/12/3-MessyShadows.png)</span></span><br><span class="line"></span><br><span class="line">当你在上下文中绘制一个对象时，该代码会给所有的对象都创建阴影。</span><br><span class="line"></span><br><span class="line">![](<span class="string">http:</span><span class="comment">//cdn4.raywenderlich.com/wp-content/uploads/2014/12/3-IndividualShadows.png)</span></span><br><span class="line"></span><br><span class="line">啊！你的奖章由五个对象所组成。难怪看起来有点模糊。幸运的是这改起来比较容易。就是简单的把所有的对象通过一个透明的layer组起来，然后你只需要对整个对象组绘制一个阴影就可以。</span><br><span class="line"></span><br><span class="line">![](<span class="string">http:</span><span class="comment">//cdn5.raywenderlich.com/wp-content/uploads/2014/12/3-GroupedShadow.png)</span></span><br><span class="line"></span><br><span class="line">在阴影代码后添加组合对象的代码。以这段开头：</span><br></pre></td></tr></table></figure></p>
<p>CGContextBeginTransparencyLayer(context, nil)<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">当你开启一组，你也需要结束它。所以在playground末端添加这一段代码，但仍然在截取最后的图像之前：</span><br></pre></td></tr></table></figure></p>
<p>CGContextEndTransparencyLayer(context)<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">现在你将有一个完整的奖牌图像，整洁的阴影。</span><br><span class="line"></span><br><span class="line">![](http://cdn1.raywenderlich.com/wp-content/uploads/2014/12/3-MedalFinal.png)</span><br><span class="line"></span><br><span class="line"><span class="comment">##Image View Using Core Graphics Image创建一个新的图像视图</span></span><br><span class="line"></span><br><span class="line">给这个图像视图创建一个新的文件。</span><br><span class="line"></span><br><span class="line">单击<span class="keyword">*</span><span class="keyword">*</span>File\New\File…<span class="keyword">*</span><span class="keyword">*</span> ,并且选择 <span class="keyword">*</span><span class="keyword">*</span>Cocoa Touch Class<span class="keyword">*</span><span class="keyword">*</span> 模版，单击Next，并且将类命名为<span class="keyword">*</span><span class="keyword">*</span>MedalView<span class="keyword">*</span><span class="keyword">*</span>，父类为<span class="keyword">*</span><span class="keyword">*</span>UIImageView<span class="keyword">*</span><span class="keyword">*</span>，然后点击Next，点击Creat</span><br><span class="line"></span><br><span class="line">进入<span class="keyword">*</span><span class="keyword">*</span>Main.storyboard<span class="keyword">*</span><span class="keyword">*</span>，把<span class="keyword">*</span><span class="keyword">*</span>UIImageView<span class="keyword">*</span><span class="keyword">*</span> 添加为<span class="keyword">*</span><span class="keyword">*</span>Counter View<span class="keyword">*</span><span class="keyword">*</span>的一个子视图。然后选择UIImageView，在<span class="keyword">*</span><span class="keyword">*</span>Identity Inspector<span class="keyword">*</span><span class="keyword">*</span>把类改为 <span class="keyword">*</span><span class="keyword">*</span>MedalView<span class="keyword">*</span><span class="keyword">*</span>。</span><br><span class="line"></span><br><span class="line">![](http://cdn5.raywenderlich.com/wp-content/uploads/2014/12/3-MedalViewClass.png)</span><br><span class="line"></span><br><span class="line">在<span class="keyword">*</span><span class="keyword">*</span>Size Inspector<span class="keyword">*</span><span class="keyword">*</span>给视图设置坐标为x=76,y=147,宽度为80,高度为80：</span><br><span class="line"></span><br><span class="line">![](http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/3-MedalViewCoordinates.png)</span><br><span class="line"></span><br><span class="line">在<span class="keyword">*</span><span class="keyword">*</span>Attributes Inspector<span class="keyword">*</span><span class="keyword">*</span>中改变<span class="keyword">*</span><span class="keyword">*</span>Image Mode<span class="keyword">*</span><span class="keyword">*</span>为<span class="keyword">*</span><span class="keyword">*</span>Aspect Fit<span class="keyword">*</span><span class="keyword">*</span>，这样图像可以自动调整大小适应视图。</span><br><span class="line"></span><br><span class="line">![](http://cdn4.raywenderlich.com/wp-content/uploads/2014/12/3-MedalAspectFit.png)</span><br><span class="line"></span><br><span class="line">去medalview.swift并添加一个方法用来创建奖章：</span><br></pre></td></tr></table></figure></p>
<p>func createMedalImage() -&gt; UIImage {<br>  println(“creating Medal Image”)</p>
<p>}<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这会打印一句话，这样你就能直到图像什么时候被创建。</span><br><span class="line"></span><br><span class="line">进入<span class="keyword">*</span><span class="keyword">*</span>MedalDrawing<span class="keyword">*</span><span class="keyword">*</span> playground，复制整个代码除了开始的 import UIKit。</span><br><span class="line"></span><br><span class="line">返回<span class="keyword">*</span><span class="keyword">*</span>MedalView.swift<span class="keyword">*</span><span class="keyword">*</span>把playground中的代码黏贴到<span class="keyword">*</span><span class="keyword">*</span>createMedalImage()<span class="keyword">*</span><span class="keyword">*</span>中去。</span><br><span class="line"></span><br><span class="line">在<span class="keyword">*</span><span class="keyword">*</span>createMedalImage()<span class="keyword">*</span><span class="keyword">*</span>尾部添加：</span><br></pre></td></tr></table></figure></p>
<p>return image<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">应该会编译错误。</span><br><span class="line">在类的顶部添加一个属性来持有奖牌图像：</span><br></pre></td></tr></table></figure></p>
<p>lazy var medalImage:UIImage = self.createMedalImage()<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">添加一个方法去显示奖牌：</span><br></pre></td></tr></table></figure></p>
<p>func showMedal(show:Bool) {<br>  if show {<br>    image = medalImage<br>  } else {<br>    image = nil<br>  }<br>}<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在<span class="keyword">*</span><span class="keyword">*</span>ViewController.swift<span class="keyword">*</span><span class="keyword">*</span>类顶部添加一个外部应用：</span><br></pre></td></tr></table></figure></p>
<p>@IBOutlet weak var medalView: MedalView!<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">去Main.storyboard将new MedalView和这个外部引用相连。</span><br><span class="line"></span><br><span class="line">返回<span class="keyword">*</span><span class="keyword">*</span>ViewController.swift<span class="keyword">*</span><span class="keyword">*</span>并且添加这个方法：</span><br></pre></td></tr></table></figure></p>
<p>func checkTotal() {<br>  if counterView.counter &gt;= 8 {<br>    medalView.showMedal(true)<br>  } else {<br>    medalView.showMedal(false)<br>  }<br>}<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果你今天喝了足够的水，这个奖牌将显示。</span><br><span class="line"></span><br><span class="line">在<span class="keyword">*</span><span class="keyword">*</span>viewDidLoad()<span class="keyword">*</span><span class="keyword">*</span> 和 <span class="keyword">*</span><span class="keyword">*</span>btnPushButton(_:)<span class="keyword">*</span><span class="keyword">*</span>这两个方法的底部调用:</span><br></pre></td></tr></table></figure></p>
<p>checkTotal()<br>```</p>
<p>编译并运行应用，它应该像这样：</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2014/12/3-CompletedApp.png" alt=""></p>
<p>在调试控制台中，只有当计数器达到8时，你才会看到创建奖章的那句log，这是因为medalImage使用了一个延迟声明lazy declaration。</p>
<h2 id="Where_to_Go_From_Here?_何去何从">Where to Go From Here? 何去何从</h2><p>你已经在这部系列教程中走了很长的路。你应该已经掌握了Core Graphics的基本知识，创建图案和渐变还有转换context，最为重要的是，你学会了如何在app中融汇地使用它们。</p>
<p>在这<a href="http://cdn1.raywenderlich.com/wp-content/uploads/2015/02/Flo-Part3-6.31.zip" target="_blank" rel="external">Flo right here</a>下载完整的版本。这个版本还包括一些额外地数据和辐射渐变让按钮在被按下的时候能给用户一个更好的UI体验。</p>
<p>我希望在制作Flo时你乐在其中，并且你能只用Core Graphics和UIKit做一些惊叹漂亮的UI！如果你有任何问题，意见，或者你想讨论如何绘制一个奖杯，而不是一个奖章，请加入论坛讨论下。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Core_Graphics_教程第三部分(Swift)_-_Patterns_和_Playgrounds">Core Graphics 教程第三部分(Swift) - Patterns 和 Playgrounds</h2><blockquote>
<ul>
<li>原文链接：<a href="http://www.raywenderlich.com/90695/modern-core-graphics-with-swift-part-3">Core Graphics Tutorial Part 3: Patterns and Playgrounds</a></li>
<li>原文作者：<a href="http://www.raywenderlich.com/u/caroline"> Caroline Begbie </a></li>
<li>译文出自：<a href="www.devtf.cn">开发者前线</a></li>
<li>译者：<a href="https://github.com/MrLoong">MrLoong</a></li>
<li>校对者：<a href="https://github.com/samw00">samw00</a></li>
</ul>
</blockquote>
<p>欢迎回到Core Graphics 教学系列的第三也是最后一部分！Flo，你的water drinking tracking app将使用Core Graphics 进行最终的改进。</p>
<p>在<a href="http://www.raywenderlich.com/90690/modern-core-graphics-with-swift-part-1">第一部分</a>，你通过UIKit画了三个自定义形状的控件,<a href="http://www.raywenderlich.com/90693/modern-core-graphics-with-swift-part-2">在第二部分</a>你创建了一个视图用来显示用户在过去一周的喝水量，并且研究了transforming the context transformation matrix (CTM)</p>
<p>在这第三也是最后一部分，你将使<strong>Flo</strong>升级到它的最终形态，特别的是你将：</p>
<ul>
<li>创建一个重复的背景图案</li>
<li>为成功每天喝掉8杯水的用户从头到尾画一枚奖章</li>
</ul>
<p>如果你还没有这个项目的源代码，从本系列的第二部分下载<a href="http://cdn1.raywenderlich.com/wp-content/uploads/2015/02/Flo-Part2-6.3.zip"><strong>Flo工程</strong></a></p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/FinalApp-192x320.png" alt=""></p>]]>
    
    </summary>
    
      <category term="Core Graphics" scheme="http://ytlvy.com/tags/Core-Graphics/"/>
    
      <category term="Swift" scheme="http://ytlvy.com/categories/Swift/"/>
    
  </entry>
  
</feed>