<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Yt's Blog]]></title>
  <subtitle><![CDATA[Valar Morghulis]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://ytlvy.com//"/>
  <updated>2015-07-13T14:03:18.000Z</updated>
  <id>http://ytlvy.com//</id>
  
  <author>
    <name><![CDATA[Yt]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[iOS property attribute]]></title>
    <link href="http://ytlvy.com/2015/07/13/iOS-property-attribute/"/>
    <id>http://ytlvy.com/2015/07/13/iOS-property-attribute/</id>
    <published>2015-07-13T13:36:06.000Z</published>
    <updated>2015-07-13T14:03:18.000Z</updated>
    <content type="html"><![CDATA[<h2 id="iOS_property_&amp;&amp;_ivar_&amp;&amp;_local_variable">iOS property &amp;&amp; ivar &amp;&amp; local variable</h2><h3 id="default_attributes">default attributes</h3><ol>
<li>property: atomic assign readwrite</li>
<li>ivar &amp;&amp; local varibal: strong readwrite non-atomic</li>
</ol>
<blockquote>
<p>atomic 在实现中通过加入 lock 的方式来保证多线程安全, 但是这只是很简单的一种线程安全, 只局限于此属性的读写.实际应用场景中, 业务的原子性, 是需要自己来实现的.</p>
</blockquote>
<h3 id="when_to_use_copy">when to use copy</h3><ol>
<li>NSStrings: 为了防止其他地方修改</li>
<li>block: 防止自动释放</li>
<li>可变数据类型, 当你想阻止其他拥有者变更数据时.</li>
</ol>
<h3 id="尽量使用_copy_关键字">尽量使用 copy 关键字</h3><p>任何实现了<code>NSCopying</code>协议的类型, 都应该尽量采用<code>copy</code>. 因为我们定义的属性,在使用时可能是用一个可变的子属性来赋值的, 例如<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Book</span> : <span class="title">NSObject</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *title;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)stringExample &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">NSMutableString</span> *bookTitle = [<span class="built_in">NSMutableString</span> stringWithString:<span class="string">@"Best book ever"</span>];</span><br><span class="line"> </span><br><span class="line">    Book *book = [[Book alloc] init];</span><br><span class="line">    book<span class="variable">.title</span> = bookTitle;</span><br><span class="line"> </span><br><span class="line">    [bookTitle setString:<span class="string">@"Worst book ever"</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"book title %@"</span>, book<span class="variable">.title</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="@dynamic">@dynamic</h3><p>@synthesize 会自动生成 getter setter方法, @dynamic 只是告诉编译器 getter setter方法 已经定义, 但是不在当前类中(比如在父类中, 或者由 runtime 动态生成).</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">property</span> (nonatomic, retain) NSButton *someButton</span>;</span><br><span class="line">...</span><br><span class="line"><span class="at_rule">@<span class="keyword">synthesize</span> someButton</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, retain) <span class="keyword">IBOutlet</span> <span class="built_in">NSButton</span> *someButton;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">@dynamic</span> someButton;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="iOS_property_&amp;&amp;_ivar_&amp;&amp;_local_variable">iOS property &amp;&amp; ivar &amp;&amp; local variable</h2><h3 id="default_attributes">default attributes</h3><ol>
<li>property: atomic assign readwrite</li>
<li>ivar &amp;&amp; local varibal: strong readwrite non-atomic</li>
</ol>
<blockquote>
<p>atomic 在实现中通过加入 lock 的方式来保证多线程安全, 但是这只是很简单的一种线程安全, 只局限于此属性的读写.实际应用场景中, 业务的原子性, 是需要自己来实现的.</p>
</blockquote>
<h3 id="when_to_use_copy">when to use copy</h3><ol>
<li>NSStrings: 为了防止其他地方修改</li>
<li>block: 防止自动释放</li>
<li>可变数据类型, 当你想阻止其他拥有者变更数据时.</li>
</ol>
<h3 id="尽量使用_copy_关键字">尽量使用 copy 关键字</h3><p>任何实现了<code>NSCopying</code>协议的类型, 都应该尽量采用<code>copy</code>. 因为我们定义的属性,在使用时可能是用一个可变的子属性来赋值的, 例如<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Book</span> : <span class="title">NSObject</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *title;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)stringExample &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">NSMutableString</span> *bookTitle = [<span class="built_in">NSMutableString</span> stringWithString:<span class="string">@"Best book ever"</span>];</span><br><span class="line"> </span><br><span class="line">    Book *book = [[Book alloc] init];</span><br><span class="line">    book<span class="variable">.title</span> = bookTitle;</span><br><span class="line"> </span><br><span class="line">    [bookTitle setString:<span class="string">@"Worst book ever"</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"book title %@"</span>, book<span class="variable">.title</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[NSRunLoop深入理解]]></title>
    <link href="http://ytlvy.com/2015/07/13/NSRunLoop%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    <id>http://ytlvy.com/2015/07/13/NSRunLoop深入理解/</id>
    <published>2015-07-13T13:34:28.000Z</published>
    <updated>2015-07-13T14:02:26.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://www.cocoachina.com/ios/20150601/11970.html" target="_blank" rel="external">转自</a></p>
<h2 id="RunLoop">RunLoop</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;RunLoop 是 iOS 和 OS X 开发中非常基础的一个概念，这篇文章将从 CFRunLoop 的源码入手，介绍 RunLoop 的概念以及底层实现原理。之后会介绍一下在 iOS 中，苹果是如何利用 RunLoop 实现自动释放池、延迟回调、触摸事件、屏幕刷新等功能的。</p>
<h3 id="RunLoop_的概念">RunLoop 的概念</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span><span class="params">()</span> &#123;</span></span><br><span class="line">    initialize<span class="params">()</span>;</span><br><span class="line">    do &#123;</span><br><span class="line">        var message = get_next_message<span class="params">()</span>;</span><br><span class="line">        process_message<span class="params">(message)</span>;</span><br><span class="line">    &#125; while <span class="params">(message != quit)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这种模型通常被称作 Event Loop。 Event Loop 在很多系统和框架里都有实现，比如 Node.js 的事件处理，比如 Windows 程序的消息循环，再比如 OSX/iOS 里的 RunLoop。实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。<br><a id="more"></a><br>&nbsp;&nbsp;&nbsp;&nbsp;OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;CFRunLoopRef 的代码是开源的，你可以在这里 <a href="http://opensource.apple.com/tarballs/CF/CF-855.17.tar.gz" target="_blank" rel="external">http://opensource.apple.com/tarballs/CF/CF-855.17.tar.gz</a> 下载到整个 CoreFoundation 的源码。为了方便跟踪和查看，你可以新建一个 Xcode 工程，把这堆源码拖进去看。</p>
<h3 id="RunLoop_与线程的关系">RunLoop 与线程的关系</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;首先，iOS 开发中能遇到两个线程对象: <code>pthread_t</code> 和 <code>NSThread</code>。过去苹果有份文档标明了<code>NSThread</code> 只是 <code>pthread_t</code> 的封装，但那份文档已经失效了，现在它们也有可能都是直接包装自最底层的 <code>mach thread</code>。苹果并没有提供这两个对象相互转换的接口，但不管怎么样，可以肯定的是 <code>pthread_t</code> 和 <code>NSThread</code> 是一一对应的。比如，你可以通过 <code>pthread_main_np()</code> 或 <code>[NSThread mainThread]</code> 来获取主线程；也可以通过 <code>pthread_self()</code> 或 <code>[NSThread currentThread]</code> 来获取当前线程。<code>CFRunLoop</code> 是基于 <code>pthread</code> 来管理的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：<code>CFRunLoopGetMain()</code> 和 <code>CFRunLoopGetCurrent()</code>。 这两个函数内部的逻辑大概是下面这样:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CFMutableDictionaryRef</span> loopsDic;</span><br><span class="line"><span class="comment">/// 访问 loopsDic 时的锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CFSpinLock_t</span> loopsLock;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/// 获取一个 pthread 对应的 RunLoop。</span></span><br><span class="line"><span class="built_in">CFRunLoopRef</span> _<span class="built_in">CFRunLoopGet</span>(pthread_t thread) &#123;</span><br><span class="line">    OSSpinLockLock(&amp;loopsLock);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (!loopsDic) &#123;</span><br><span class="line">        <span class="comment">// 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。</span></span><br><span class="line">        loopsDic = <span class="built_in">CFDictionaryCreateMutable</span>();</span><br><span class="line">        <span class="built_in">CFRunLoopRef</span> mainLoop = _<span class="built_in">CFRunLoopCreate</span>();</span><br><span class="line">        <span class="built_in">CFDictionarySetValue</span>(loopsDic, pthread_main_thread_np(), mainLoop);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/// 直接从 Dictionary 里获取。</span></span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> loop = <span class="built_in">CFDictionaryGetValue</span>(loopsDic, thread));</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line">        <span class="comment">/// 取不到时，创建一个</span></span><br><span class="line">        loop = _<span class="built_in">CFRunLoopCreate</span>();</span><br><span class="line">        <span class="built_in">CFDictionarySetValue</span>(loopsDic, thread, loop);</span><br><span class="line">        <span class="comment">/// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。</span></span><br><span class="line">        _<span class="built_in">CFSetTSD</span>(..., thread, loop, __<span class="built_in">CFFinalizeRunLoop</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    OSSpinLockUnLock(&amp;loopsLock);</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetMain</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> _<span class="built_in">CFRunLoopGet</span>(pthread_main_thread_np());</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetCurrent</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> _<span class="built_in">CFRunLoopGet</span>(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;从上面的代码可以看出，线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）</p>
<h3 id="RunLoop_对外的接口">RunLoop 对外的接口</h3><p>在 CoreFoundation 里面关于 RunLoop 有5个类:</p>
<ul>
<li>CFRunLoopRef</li>
<li>CFRunLoopModeRef</li>
<li>CFRunLoopSourceRef</li>
<li>CFRunLoopTimerRef</li>
<li>CFRunLoopObserverRef</li>
</ul>
<p>其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:<br><img src="http://cc.cocimg.com/api/uploads/20150528/1432798883604537.png" alt=""><br>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p>
<p><code>CFRunLoopSourceRef</code> 是事件产生的地方。Source有两个版本：Source0 和 Source1。</p>
<ul>
<li>Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</li>
<li>Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。</li>
</ul>
<p><code>CFRunLoopTimerRef</code> 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</p>
<p><code>CFRunLoopObserverRef</code> 是观察者，每个 Observer 都包含了一个回调（函数指针），当 <code>RunLoop</code>的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_OPTIONS</span>(<span class="built_in">CFOptionFlags</span>, <span class="built_in">CFRunLoopActivity</span>) &#123;</span><br><span class="line">    k<span class="built_in">CFRunLoopEntry</span>         = (<span class="number">1</span>UL &lt;&lt; <span class="number">0</span>), <span class="comment">// 即将进入Loop</span></span><br><span class="line">    k<span class="built_in">CFRunLoopBeforeTimers</span>  = (<span class="number">1</span>UL &lt;&lt; <span class="number">1</span>), <span class="comment">// 即将处理 Timer</span></span><br><span class="line">    k<span class="built_in">CFRunLoopBeforeSources</span> = (<span class="number">1</span>UL &lt;&lt; <span class="number">2</span>), <span class="comment">// 即将处理 Source</span></span><br><span class="line">    k<span class="built_in">CFRunLoopBeforeWaiting</span> = (<span class="number">1</span>UL &lt;&lt; <span class="number">5</span>), <span class="comment">// 即将进入休眠</span></span><br><span class="line">    k<span class="built_in">CFRunLoopAfterWaiting</span>  = (<span class="number">1</span>UL &lt;&lt; <span class="number">6</span>), <span class="comment">// 刚从休眠中唤醒</span></span><br><span class="line">    k<span class="built_in">CFRunLoopExit</span>          = (<span class="number">1</span>UL &lt;&lt; <span class="number">7</span>), <span class="comment">// 即将退出Loop</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面的 Source/Timer/Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。</p>
<h3 id="RunLoop_的_Mode">RunLoop 的 Mode</h3><p>CFRunLoopMode 和 CFRunLoop 的结构大致如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __<span class="built_in">CFRunLoopMode</span> &#123;</span><br><span class="line">    <span class="built_in">CFStringRef</span> _name;            <span class="comment">// Mode Name, 例如 @"kCFRunLoopDefaultMode"</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources0;    <span class="comment">// Set</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources1;    <span class="comment">// Set</span></span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _observers; <span class="comment">// Array</span></span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _timers;    <span class="comment">// Array</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">struct</span> __<span class="built_in">CFRunLoop</span> &#123;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModes;     <span class="comment">// Set</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModeItems; <span class="comment">// Set</span></span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> _currentMode;    <span class="comment">// Current Runloop Mode</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _modes;           <span class="comment">// Set</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里有个概念叫 “CommonModes”：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。</p>
<p>应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。</p>
<p>有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。</p>
<p>CFRunLoop对外暴露的管理 Mode 接口只有下面2个:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopAddCommonMode</span>(<span class="built_in">CFRunLoopRef</span> runloop, <span class="built_in">CFStringRef</span> modeName);</span><br><span class="line"><span class="built_in">CFRunLoopRunInMode</span>(<span class="built_in">CFStringRef</span> modeName, ...);</span><br></pre></td></tr></table></figure></p>
<p>Mode 暴露的管理 mode item 的接口有下面几个：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopAddSource</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopSourceRef</span> source, <span class="built_in">CFStringRef</span> modeName);</span><br><span class="line"><span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFStringRef</span> modeName);</span><br><span class="line"><span class="built_in">CFRunLoopAddTimer</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopTimerRef</span> timer, <span class="built_in">CFStringRef</span> mode);</span><br><span class="line"><span class="built_in">CFRunLoopRemoveSource</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopSourceRef</span> source, <span class="built_in">CFStringRef</span> modeName);</span><br><span class="line"><span class="built_in">CFRunLoopRemoveObserver</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFStringRef</span> modeName);</span><br><span class="line"><span class="built_in">CFRunLoopRemoveTimer</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopTimerRef</span> timer, <span class="built_in">CFStringRef</span> mode);</span><br></pre></td></tr></table></figure></p>
<p>你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。</p>
<p>苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。</p>
<p>同时苹果还提供了一个操作 Common 标记的字符串：kCFRunLoopCommonModes (NSRunLoopCommonModes)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 mode name。</p>
<h3 id="RunLoop_的内部逻辑">RunLoop 的内部逻辑</h3><p>根据苹果在文档里的说明，RunLoop 内部的逻辑大致如下:<br><img src="http://cc.cocimg.com/api/uploads/20150528/1432798974517485.png" alt=""><br>其内部代码整理如下 （太长了不想看可以直接跳过去，后面会有说明）：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 用DefaultMode启动</span></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">CFRunLoopRun</span>(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), k<span class="built_in">CFRunLoopDefaultMode</span>, <span class="number">1.0e10</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/// 用指定的Mode启动，允许设置RunLoop超时时间</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">CFRunLoopRunInMode</span>(<span class="built_in">CFStringRef</span> modeName, <span class="built_in">CFTimeInterval</span> seconds, Boolean stopAfterHandle) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/// RunLoop的实现</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">CFRunLoopRunSpecific</span>(runloop, modeName, seconds, stopAfterHandle) &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/// 首先根据modeName找到对应mode</span></span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> currentMode = __<span class="built_in">CFRunLoopFindMode</span>(runloop, modeName, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">/// 如果mode里没有source/timer/observer, 直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (__<span class="built_in">CFRunLoopModeIsEmpty</span>(currentMode)) <span class="keyword">return</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/// 1. 通知 Observers: RunLoop 即将进入 loop。</span></span><br><span class="line">    __<span class="built_in">CFRunLoopDoObservers</span>(runloop, currentMode, k<span class="built_in">CFRunLoopEntry</span>);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/// 内部函数，进入loop</span></span><br><span class="line">    __<span class="built_in">CFRunLoopRun</span>(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</span><br><span class="line">         </span><br><span class="line">        Boolean sourceHandledThisLoop = <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">int</span> retVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">  </span><br><span class="line">            <span class="comment">/// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span></span><br><span class="line">            __<span class="built_in">CFRunLoopDoObservers</span>(runloop, currentMode, k<span class="built_in">CFRunLoopBeforeTimers</span>);</span><br><span class="line">            <span class="comment">/// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span></span><br><span class="line">            __<span class="built_in">CFRunLoopDoObservers</span>(runloop, currentMode, k<span class="built_in">CFRunLoopBeforeSources</span>);</span><br><span class="line">            <span class="comment">/// 执行被加入的block</span></span><br><span class="line">            __<span class="built_in">CFRunLoopDoBlocks</span>(runloop, currentMode);</span><br><span class="line">             </span><br><span class="line">            <span class="comment">/// 4. RunLoop 触发 Source0 (非port) 回调。</span></span><br><span class="line">            sourceHandledThisLoop = __<span class="built_in">CFRunLoopDoSources0</span>(runloop, currentMode, stopAfterHandle);</span><br><span class="line">            <span class="comment">/// 执行被加入的block</span></span><br><span class="line">            __<span class="built_in">CFRunLoopDoBlocks</span>(runloop, currentMode);</span><br><span class="line">  </span><br><span class="line">            <span class="comment">/// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span></span><br><span class="line">            <span class="keyword">if</span> (__Source0DidDispatchPortLastTime) &#123;</span><br><span class="line">                Boolean hasMsg = __<span class="built_in">CFRunLoopServiceMachPort</span>(dispatchPort, &amp;msg)</span><br><span class="line">                <span class="keyword">if</span> (hasMsg) <span class="keyword">goto</span> handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">/// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span></span><br><span class="line">            <span class="keyword">if</span> (!sourceHandledThisLoop) &#123;</span><br><span class="line">                __<span class="built_in">CFRunLoopDoObservers</span>(runloop, currentMode, k<span class="built_in">CFRunLoopBeforeWaiting</span>);</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">/// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span></span><br><span class="line">            <span class="comment">/// ? 一个基于 port 的Source 的事件。</span></span><br><span class="line">            <span class="comment">/// ? 一个 Timer 到时间了</span></span><br><span class="line">            <span class="comment">/// ? RunLoop 自身的超时时间到了</span></span><br><span class="line">            <span class="comment">/// ? 被其他什么调用者手动唤醒</span></span><br><span class="line">            __<span class="built_in">CFRunLoopServiceMachPort</span>(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort) &#123;</span><br><span class="line">                mach_msg(msg, MACH_RCV_MSG, port); <span class="comment">// thread wait for receive msg</span></span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">            <span class="comment">/// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span></span><br><span class="line">            __<span class="built_in">CFRunLoopDoObservers</span>(runloop, currentMode, k<span class="built_in">CFRunLoopAfterWaiting</span>);</span><br><span class="line">             </span><br><span class="line">            <span class="comment">/// 收到消息，处理消息。</span></span><br><span class="line">            handle_msg:</span><br><span class="line">  </span><br><span class="line">            <span class="comment">/// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span></span><br><span class="line">            <span class="keyword">if</span> (msg_is_timer) &#123;</span><br><span class="line">                __<span class="built_in">CFRunLoopDoTimers</span>(runloop, currentMode, mach_absolute_time())</span><br><span class="line">            &#125; </span><br><span class="line">  </span><br><span class="line">            <span class="comment">/// 9.2 如果有dispatch到main_queue的block，执行block。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (msg_is_dispatch) &#123;</span><br><span class="line">                __<span class="built_in">CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</span>(msg);</span><br><span class="line">            &#125; </span><br><span class="line">  </span><br><span class="line">            <span class="comment">/// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">CFRunLoopSourceRef</span> source1 = __<span class="built_in">CFRunLoopModeFindSourceForMachPort</span>(runloop, currentMode, livePort);</span><br><span class="line">                sourceHandledThisLoop = __<span class="built_in">CFRunLoopDoSource1</span>(runloop, currentMode, source1, msg);</span><br><span class="line">                <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">                    mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">/// 执行加入到Loop的block</span></span><br><span class="line">            __<span class="built_in">CFRunLoopDoBlocks</span>(runloop, currentMode);</span><br><span class="line">             </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">                <span class="comment">/// 进入loop时参数说处理完事件就返回。</span></span><br><span class="line">                retVal = k<span class="built_in">CFRunLoopRunHandledSource</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">                <span class="comment">/// 超出传入参数标记的超时时间了</span></span><br><span class="line">                retVal = k<span class="built_in">CFRunLoopRunTimedOut</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__<span class="built_in">CFRunLoopIsStopped</span>(runloop)) &#123;</span><br><span class="line">                <span class="comment">/// 被外部调用者强制停止了</span></span><br><span class="line">                retVal = k<span class="built_in">CFRunLoopRunStopped</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__<span class="built_in">CFRunLoopModeIsEmpty</span>(runloop, currentMode)) &#123;</span><br><span class="line">                <span class="comment">/// source/timer/observer一个都没有了</span></span><br><span class="line">                retVal = k<span class="built_in">CFRunLoopRunFinished</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">/// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (retVal == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/// 10. 通知 Observers: RunLoop 即将退出。</span></span><br><span class="line">    __<span class="built_in">CFRunLoopDoObservers</span>(rl, currentMode, k<span class="built_in">CFRunLoopExit</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。</p>
<h3 id="RunLoop_的底层实现">RunLoop 的底层实现</h3><p>从上面代码可以看到，RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach_msg()。为了解释这个逻辑，下面稍微介绍一下 OSX/iOS 的系统架构。<br><img src="http://cc.cocimg.com/api/uploads/20150528/1432799001829463.png" alt=""></p>
<p>苹果官方将整个系统大致划分为上述4个层次：</p>
<ol>
<li>应用层包括用户能接触到的图形应用，例如 Spotlight、Aqua、SpringBoard 等。</li>
<li>应用框架层即开发人员接触到的 Cocoa 等框架。</li>
<li>核心框架层包括各种核心框架、OpenGL 等内容。</li>
<li>Darwin 即操作系统的核心，包括系统内核、驱动、Shell 等内容，这一层是开源的，其所有源码都可以在 opensource.apple.com 里找到。</li>
</ol>
<p>我们在深入看一下 Darwin 这个核心的架构：<br><img src="http://cc.cocimg.com/api/uploads/20150528/1432799031419231.png" alt=""></p>
<p>其中，在硬件层上面的三个组成部分：Mach、BSD、IOKit (还包括一些上面没标注的内容)，共同组成了 XNU 内核。</p>
<p>XNU 内核的内环被称作 Mach，其作为一个微内核，仅提供了诸如处理器调度、IPC (进程间通信)等非常少量的基础服务。</p>
<p>BSD 层可以看作围绕 Mach 层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。</p>
<p>IOKit 层是为设备驱动提供了一个面向对象(C++)的一个框架。</p>
<p>Mach 本身提供的 API 非常有限，而且苹果也不鼓励使用 Mach 的 API，但是这些API非常基础，如果没有这些API的话，其他任何工作都无法实施。在 Mach 中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为”对象”。和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。”消息”是 Mach 中最基础的概念，消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。</p>
<p>Mach 的消息定义是在头文件的，很简单：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="keyword">mach_msg_header_t</span> header;</span><br><span class="line">  <span class="keyword">mach_msg_body_t</span> body;</span><br><span class="line">&#125; <span class="keyword">mach_msg_base_t</span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="keyword">mach_msg_bits_t</span> msgh_bits;</span><br><span class="line">  <span class="keyword">mach_msg_size_t</span> msgh_size;</span><br><span class="line">  <span class="keyword">mach_port_t</span> msgh_remote_port;</span><br><span class="line">  <span class="keyword">mach_port_t</span> msgh_local_port;</span><br><span class="line">  <span class="keyword">mach_port_name_t</span> msgh_voucher_port;</span><br><span class="line">  <span class="keyword">mach_msg_id_t</span> msgh_id;</span><br><span class="line">&#125; <span class="keyword">mach_msg_header_t</span>;</span><br></pre></td></tr></table></figure></p>
<p>一条 Mach 消息实际上就是一个二进制数据包 (BLOB)，其头部定义了当前端口 local_port 和目标端口 remote_port，</p>
<p>发送和接受消息是通过同一个 API 进行的，其 option 标记了消息传递的方向：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mach_msg_return_t</span> mach_msg(</span><br><span class="line"><span class="keyword">mach_msg_header_t</span> *msg,</span><br><span class="line"><span class="keyword">mach_msg_option_t</span> option,</span><br><span class="line"><span class="keyword">mach_msg_size_t</span> send_size,</span><br><span class="line"><span class="keyword">mach_msg_size_t</span> rcv_size,</span><br><span class="line"><span class="keyword">mach_port_name_t</span> rcv_name,</span><br><span class="line"><span class="keyword">mach_msg_timeout_t</span> timeout,</span><br><span class="line"><span class="keyword">mach_port_name_t</span> notify);</span><br></pre></td></tr></table></figure></p>
<p>为了实现消息的发送和接收，mach_msg() 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数mach_msg_trap()，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作，如下图：<br><img src="http://cc.cocimg.com/api/uploads/20150528/1432799057446598.png" alt=""></p>
<p>这些概念可以参考维基百科: System<em>call、Trap</em>(computing)。</p>
<p>RunLoop 的核心就是一个 mach_msg() (见上面代码的第7步)，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 mach_msg_trap() 这个地方。</p>
<p>关于具体的如何利用 mach port 发送信息，可以看看 <a href="http://nshipster.com/inter-process-communication/" target="_blank" rel="external">NSHipster 这一篇文章</a>，或者这里的中文翻译 。</p>
<p>关于Mach的历史可以看看这篇很有趣的文章：<a href="http://www.programmer.com.cn/8121/" target="_blank" rel="external">Mac OS X 背后的故事（三）Mach 之父 Avie Tevanian</a>。</p>
<h3 id="苹果用_RunLoop_实现的功能">苹果用 RunLoop 实现的功能</h3><p>首先我们可以看一下 App 启动后 RunLoop 的状态：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoop &#123;</span><br><span class="line">    current <span class="variable">mode =</span> kCFRunLoopDefaultMode</span><br><span class="line">    common <span class="variable">modes =</span> &#123;</span><br><span class="line">        UITrackingRunLoopMode</span><br><span class="line">        kCFRunLoopDefaultMode</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    common mode <span class="variable">items =</span> &#123;</span><br><span class="line">  </span><br><span class="line">        // source0 (manual)</span><br><span class="line">        CFRunLoopSource &#123;<span class="variable">order =</span>-<span class="number">1</span>, &#123;</span><br><span class="line">            <span class="variable">callout =</span> _UIApplicationHandleEventQueue&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;<span class="variable">order =</span>-<span class="number">1</span>, &#123;</span><br><span class="line">            <span class="variable">callout =</span> PurpleEventSignalCallback &#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;<span class="variable">order =</span> <span class="number">0</span>, &#123;</span><br><span class="line">            <span class="variable">callout =</span> FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line">  </span><br><span class="line">        // source1 (mach port)</span><br><span class="line">        CFRunLoopSource &#123;<span class="variable">order =</span> <span class="number">0</span>,  &#123;<span class="variable">port =</span> <span class="number">17923</span>&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;<span class="variable">order =</span> <span class="number">0</span>,  &#123;<span class="variable">port =</span> <span class="number">12039</span>&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;<span class="variable">order =</span> <span class="number">0</span>,  &#123;<span class="variable">port =</span> <span class="number">16647</span>&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;<span class="variable">order =</span>-<span class="number">1</span>, &#123;</span><br><span class="line">            <span class="variable">callout =</span> PurpleEventCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;<span class="variable">order =</span> <span class="number">0</span>, &#123;<span class="variable">port =</span> <span class="number">2407</span>,</span><br><span class="line">            <span class="variable">callout =</span> _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;<span class="variable">order =</span> <span class="number">0</span>, &#123;<span class="variable">port =</span> <span class="number">1</span>c03,</span><br><span class="line">            <span class="variable">callout =</span> __IOHIDEventSystemClientAvailabilityCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;<span class="variable">order =</span> <span class="number">0</span>, &#123;<span class="variable">port =</span> <span class="number">1</span>b03,</span><br><span class="line">            <span class="variable">callout =</span> __IOHIDEventSystemClientQueueCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;<span class="variable">order =</span> <span class="number">1</span>, &#123;<span class="variable">port =</span> <span class="number">1903</span>,</span><br><span class="line">            <span class="variable">callout =</span> __IOMIGMachPortPortCallback&#125;&#125;</span><br><span class="line">  </span><br><span class="line">        // Ovserver</span><br><span class="line">        CFRunLoopObserver &#123;<span class="variable">order =</span> -<span class="number">2147483647</span>, <span class="variable">activities =</span> <span class="number">0</span>x1, // Entry</span><br><span class="line">            <span class="variable">callout =</span> _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line">        CFRunLoopObserver &#123;<span class="variable">order =</span> <span class="number">0</span>, <span class="variable">activities =</span> <span class="number">0</span>x20,          // BeforeWaiting</span><br><span class="line">            <span class="variable">callout =</span> _UIGestureRecognizerUpdateObserver&#125;</span><br><span class="line">        CFRunLoopObserver &#123;<span class="variable">order =</span> <span class="number">1999000</span>, <span class="variable">activities =</span> <span class="number">0</span>xa0,    // BeforeWaiting | Exit</span><br><span class="line">            <span class="variable">callout =</span> _afterCACommitHandler&#125;</span><br><span class="line">        CFRunLoopObserver &#123;<span class="variable">order =</span> <span class="number">2000000</span>, <span class="variable">activities =</span> <span class="number">0</span>xa0,    // BeforeWaiting | Exit</span><br><span class="line">            <span class="variable">callout =</span> _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class="line">        CFRunLoopObserver &#123;<span class="variable">order =</span> <span class="number">2147483647</span>, <span class="variable">activities =</span> <span class="number">0</span>xa0, // BeforeWaiting | Exit</span><br><span class="line">            <span class="variable">callout =</span> _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line">  </span><br><span class="line">        // Timer</span><br><span class="line">        CFRunLoopTimer &#123;<span class="variable">firing =</span> No, <span class="variable">interval =</span> <span class="number">3.1536</span>e+<span class="number">09</span>, <span class="variable">tolerance =</span> <span class="number">0</span>,</span><br><span class="line">            next fire <span class="variable">date =</span> <span class="number">453098071</span> (-<span class="number">4421.76019</span> @ <span class="number">96223387169499</span>),</span><br><span class="line">            <span class="variable">callout =</span> _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  </span><br><span class="line">    modes ＝ &#123;</span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            <span class="variable">sources0 =</span>  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">            <span class="variable">sources1 =</span>  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">            <span class="variable">observers =</span> &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">            <span class="variable">timers =</span>    &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">  </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            <span class="variable">sources0 =</span>  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">            <span class="variable">sources1 =</span>  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">            <span class="variable">observers =</span> &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">            <span class="variable">timers =</span>    &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">  </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            <span class="variable">sources0 =</span> &#123;</span><br><span class="line">                CFRunLoopSource &#123;<span class="variable">order =</span> <span class="number">0</span>, &#123;</span><br><span class="line">                    <span class="variable">callout =</span> FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="variable">sources1 =</span> (<span class="constant">null</span>),</span><br><span class="line">            <span class="variable">observers =</span> &#123;</span><br><span class="line">                CFRunLoopObserver &gt;&#123;<span class="variable">activities =</span> <span class="number">0</span>xa0, <span class="variable">order =</span> <span class="number">2000000</span>,</span><br><span class="line">                    <span class="variable">callout =</span> _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class="line">            )&#125;,</span><br><span class="line">            <span class="variable">timers =</span> (<span class="constant">null</span>),</span><br><span class="line">        &#125;,</span><br><span class="line">  </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            <span class="variable">sources0 =</span> &#123;</span><br><span class="line">                CFRunLoopSource &#123;<span class="variable">order =</span> -<span class="number">1</span>, &#123;</span><br><span class="line">                    <span class="variable">callout =</span> PurpleEventSignalCallback&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="variable">sources1 =</span> &#123;</span><br><span class="line">                CFRunLoopSource &#123;<span class="variable">order =</span> -<span class="number">1</span>, &#123;</span><br><span class="line">                    <span class="variable">callout =</span> PurpleEventCallback&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="variable">observers =</span> (<span class="constant">null</span>),</span><br><span class="line">            <span class="variable">timers =</span> (<span class="constant">null</span>),</span><br><span class="line">        &#125;,</span><br><span class="line">         </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            <span class="variable">sources0 =</span> (<span class="constant">null</span>),</span><br><span class="line">            <span class="variable">sources1 =</span> (<span class="constant">null</span>),</span><br><span class="line">            <span class="variable">observers =</span> (<span class="constant">null</span>),</span><br><span class="line">            <span class="variable">timers =</span> (<span class="constant">null</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，系统默认注册了5个Mode:</p>
<ol>
<li><p>kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。</p>
</li>
<li><p>UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</p>
</li>
<li><p>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。</p>
</li>
</ol>
<p>4: GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。</p>
<p>5: kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。</p>
<p>你可以在<a href="http://iphonedevwiki.net/index.php/CFRunLoop" target="_blank" rel="external">这里</a>看到更多的苹果内部的 Mode，但那些 Mode 在开发中就很难遇到了。</p>
<p>当 RunLoop 进行回调时，一般都是通过一个很长的函数调用出去 (call out), 当你在你的代码中下断点调试时，通常能在调用栈上看到这些函数。下面是这几个函数的整理版本，如果你在调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">&#123;</span><br><span class="line">    /// <span class="number">1</span>. 通知Observers，即将进入RunLoop</span><br><span class="line">    /// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush<span class="list">()</span><span class="comment">;</span></span><br><span class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__<span class="list">(<span class="keyword">kCFRunLoopEntry</span>)</span><span class="comment">;</span></span><br><span class="line">    do <span class="collection">&#123;</span><br><span class="line">  </span><br><span class="line">        /// <span class="number">2</span>. 通知 Observers: 即将触发 Timer 回调。</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__<span class="list">(<span class="keyword">kCFRunLoopBeforeTimers</span>)</span><span class="comment">;</span></span><br><span class="line">        /// <span class="number">3</span>. 通知 Observers: 即将触发 Source <span class="list">(非基于port的,Source0)</span> 回调。</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__<span class="list">(<span class="keyword">kCFRunLoopBeforeSources</span>)</span><span class="comment">;</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__<span class="list">(<span class="keyword">block</span>)</span><span class="comment">;</span></span><br><span class="line">  </span><br><span class="line">        /// <span class="number">4</span>. 触发 Source0 <span class="list">(非基于port的)</span> 回调。</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__<span class="list">(<span class="keyword">source0</span>)</span><span class="comment">;</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__<span class="list">(<span class="keyword">block</span>)</span><span class="comment">;</span></span><br><span class="line">  </span><br><span class="line">        /// <span class="number">6</span>. 通知Observers，即将进入休眠</span><br><span class="line">        /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop<span class="list">()</span><span class="comment">; _objc_autoreleasePoolPush();</span></span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__<span class="list">(<span class="keyword">kCFRunLoopBeforeWaiting</span>)</span><span class="comment">;</span></span><br><span class="line">  </span><br><span class="line">        /// <span class="number">7</span>. sleep to wait msg.</span><br><span class="line">        mach_msg<span class="list">()</span> -&gt; mach_msg_trap<span class="list">()</span><span class="comment">;</span></span><br><span class="line">         </span><br><span class="line">  </span><br><span class="line">        /// <span class="number">8</span>. 通知Observers，线程被唤醒</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__<span class="list">(<span class="keyword">kCFRunLoopAfterWaiting</span>)</span><span class="comment">;</span></span><br><span class="line">  </span><br><span class="line">        /// <span class="number">9</span>. 如果是被Timer唤醒的，回调Timer</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__<span class="list">(<span class="keyword">timer</span>)</span><span class="comment">;</span></span><br><span class="line">  </span><br><span class="line">        /// <span class="number">9</span>. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block</span><br><span class="line">        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__<span class="list">(<span class="keyword">dispatched_block</span>)</span><span class="comment">;</span></span><br><span class="line">  </span><br><span class="line">        /// <span class="number">9</span>. 如果如果Runloop是被 Source1 <span class="list">(基于port的)</span> 的事件唤醒了，处理这个事件</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__<span class="list">(<span class="keyword">source1</span>)</span><span class="comment">;</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    &#125;</span> while <span class="list">(<span class="keyword">...</span>)</span><span class="comment">;</span></span><br><span class="line">  </span><br><span class="line">    /// <span class="number">10</span>. 通知Observers，即将退出RunLoop</span><br><span class="line">    /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop<span class="list">()</span><span class="comment">;</span></span><br><span class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__<span class="list">(<span class="keyword">kCFRunLoopExit</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="AutoreleasePool">AutoreleasePool</h4><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p>
<p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p>
<p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p>
<p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p>
<h4 id="事件响应">事件响应</h4><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。</p>
<p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</p>
<p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p>
<h4 id="手势识别">手势识别</h4><p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p>
<p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。</p>
<p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>
<h4 id="界面更新">界面更新</h4><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p>
<p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：</p>
<p>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>
<p>这个函数内部的调用栈大概是这样的：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_<span class="tag">ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv</span>()</span><br><span class="line">    <span class="rule"><span class="attribute">QuartzCore</span>:<span class="value">CA::Transaction::observer_callback:</span><br><span class="line">        CA::Transaction::<span class="function">commit</span>()</span></span>;</span><br><span class="line">            <span class="rule"><span class="attribute">CA</span>:<span class="value">:Context::<span class="function">commit_transaction</span>()</span></span>;</span><br><span class="line">                <span class="rule"><span class="attribute">CA</span>:<span class="value">:Layer::<span class="function">layout_and_display_if_needed</span>()</span></span>;</span><br><span class="line">                    <span class="rule"><span class="attribute">CA</span>:<span class="value">:Layer::<span class="function">layout_if_needed</span>()</span></span>;</span><br><span class="line">                        <span class="attr_selector">[CALayer layoutSublayers]</span>;</span><br><span class="line">                            <span class="attr_selector">[UIView layoutSubviews]</span>;</span><br><span class="line">                    <span class="rule"><span class="attribute">CA</span>:<span class="value">:Layer::<span class="function">display_if_needed</span>()</span></span>;</span><br><span class="line">                        <span class="attr_selector">[CALayer display]</span>;</span><br><span class="line">                            <span class="attr_selector">[UIView drawRect]</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="定时器">定时器</h4><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>
<p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p>
<p>CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。</p>
<h4 id="PerformSelecter">PerformSelecter</h4><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p>
<p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>
<h4 id="关于GCD">关于GCD</h4><p>实际上 RunLoop 底层也会用到 GCD 的东西，比如 RunLoop 是用 dispatch_source_t 实现的 Timer。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。</p>
<p>当调用 dispatch<em>async(dispatch<em>get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</em></em>() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p>
<h4 id="关于网络请求">关于网络请求</h4><p>iOS 中，关于网络请求的接口自下至上有如下几层:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFSocket</span></span><br><span class="line"><span class="built_in">CFNetwork</span>       -&gt;ASIHttpRequest</span><br><span class="line"><span class="built_in">NSURLConnection</span> -&gt;AFNetworking</span><br><span class="line"><span class="built_in">NSURLSession</span>    -&gt;AFNetworking2, Alamofire</span><br></pre></td></tr></table></figure></p>
<ul>
<li>CFSocket 是最底层的接口，只负责 socket 通信。</li>
<li>CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。</li>
<li>NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。</li>
<li>NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如 com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。</li>
</ul>
<p>下面主要介绍下 NSURLConnection 的工作过程。</p>
<p>通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。</p>
<p>当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。<br><img src="http://cc.cocimg.com/api/uploads/20150528/1432799200369980.png" alt=""></p>
<p>NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。</p>
<h3 id="RunLoop_的实际应用举例">RunLoop 的实际应用举例</h3><h4 id="AFNetworking">AFNetworking</h4><p>AFURLConnectionOperation 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)networkRequestThreadEntryPoint:(<span class="keyword">id</span>)__unused object &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [[<span class="built_in">NSThread</span> currentThread] setName:<span class="string">@"AFNetworking"</span>];</span><br><span class="line">        <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">        [runLoop addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">+ (<span class="built_in">NSThread</span> *)networkRequestThread &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSThread</span> *_networkRequestThread = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> oncePredicate;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _networkRequestThread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(networkRequestThreadEntryPoint:) object:<span class="literal">nil</span>];</span><br><span class="line">        [_networkRequestThread start];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _networkRequestThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)start &#123;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.lock</span> lock];</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isCancelled]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(cancelConnection) onThread:[[<span class="keyword">self</span> class] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span><span class="variable">.runLoopModes</span> allObjects]];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span> isReady]) &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.state</span> = AFOperationExecutingState;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(operationDidStart) onThread:[[<span class="keyword">self</span> class] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span><span class="variable">.runLoopModes</span> allObjects]];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.lock</span> unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。</p>
<h4 id="AsyncDisplayKit">AsyncDisplayKit</h4><p>AsyncDisplayKit 是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下：</p>
<p>UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，UI对象操作。</p>
<p>排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。</p>
<p>绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。</p>
<p>UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。</p>
<p>其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如TextView创建时可能需要提前计算出文本的大小）。ASDK 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。</p>
<p>为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了 UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。</p>
<p>ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。</p>
<p>具体的代码可以看这里：<a href="https://github.com/facebook/AsyncDisplayKit/blob/master/AsyncDisplayKit%2FDetails%2FTransactions%2F_ASAsyncTransactionGroup.m" target="_blank" rel="external">_ASAsyncTransactionGroup</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://www.cocoachina.com/ios/20150601/11970.html">转自</a></p>
<h2 id="RunLoop">RunLoop</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;RunLoop 是 iOS 和 OS X 开发中非常基础的一个概念，这篇文章将从 CFRunLoop 的源码入手，介绍 RunLoop 的概念以及底层实现原理。之后会介绍一下在 iOS 中，苹果是如何利用 RunLoop 实现自动释放池、延迟回调、触摸事件、屏幕刷新等功能的。</p>
<h3 id="RunLoop_的概念">RunLoop 的概念</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span><span class="params">()</span> &#123;</span></span><br><span class="line">    initialize<span class="params">()</span>;</span><br><span class="line">    do &#123;</span><br><span class="line">        var message = get_next_message<span class="params">()</span>;</span><br><span class="line">        process_message<span class="params">(message)</span>;</span><br><span class="line">    &#125; while <span class="params">(message != quit)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这种模型通常被称作 Event Loop。 Event Loop 在很多系统和框架里都有实现，比如 Node.js 的事件处理，比如 Windows 程序的消息循环，再比如 OSX/iOS 里的 RunLoop。实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。<br>]]>
    
    </summary>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS Associated Objects]]></title>
    <link href="http://ytlvy.com/2015/07/13/iOS-Associated-Objects/"/>
    <id>http://ytlvy.com/2015/07/13/iOS-Associated-Objects/</id>
    <published>2015-07-13T13:32:41.000Z</published>
    <updated>2015-07-13T14:03:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="iOS_Associated_Objects">iOS Associated Objects</h2><p>关注以下三个问题:</p>
<ol>
<li>关联对象被存储在什么地方，是不是存放在被关联对象本身的内存中？</li>
<li>关联对象的五种关联策略有什么区别，有什么坑？</li>
<li>关联对象的生命周期是怎样的，什么时候被释放，什么时候被移除？</li>
</ol>
<h3 id="使用场景:">使用场景:</h3><p>按照 Mattt Thompson 大神的文章 Associated Objects 中的说法，<a href="http://nshipster.com/associated-objects/" target="_blank" rel="external">Associated Objects</a> 主要有以下三个使用场景</p>
<ol>
<li>为现有的类添加私有变量以帮助实现细节；</li>
<li>为现有的类添加公有属性；</li>
<li>为 KVO 创建一个关联的观察者。</li>
</ol>
<p>从本质上看，第 1 、2 个场景其实是一个意思，唯一的区别就在于新添加的这个属性是公有的还是私有的而已。就目前来说，我在实际工作中使用得最多的是第 2 个场景，而第 3 个场景我还没有使用过<br><a id="more"></a></p>
<h3 id="相关函数">相关函数</h3><p>与 Associated Objects 相关的函数主要有三个，我们可以在 runtime 源码的 runtime.h 文件中找到它们的声明：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setAssociatedObject</span>(<span class="params">id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key, id <span class="keyword">value</span>, objc_AssociationPolicy policy</span>)</span>;</span><br><span class="line"><span class="function">id <span class="title">objc_getAssociatedObject</span>(<span class="params">id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_removeAssociatedObjects</span>(<span class="params">id <span class="keyword">object</span></span>)</span>;</span><br></pre></td></tr></table></figure></p>
<p>这三个函数的命名对程序员非常友好，可以让我们一眼就看出函数的作用：</p>
<ol>
<li>objc_setAssociatedObject 用于给对象添加关联对象，传入 nil 则可以移除已有的关联对象；</li>
<li>objc_getAssociatedObject 用于获取关联对象；</li>
<li>objc_removeAssociatedObjects 用于移除一个对象的所有关联对象。</li>
</ol>
<blockquote>
<p>objc_removeAssociatedObjects 函数我们一般是用不上的，因为这个函数会移除一个对象的所有关联对象，将该对象恢复成“原始”状态。这样做就很有可能把别人添加的关联对象也一并移除，这并不是我们所希望的。所以一般的做法是通过给 objc_setAssociatedObject 函数传入 nil 来移除某个已有的关联对象。</p>
</blockquote>
<h3 id="key_值">key 值</h3><p>关于前两个函数中的 key 值是我们需要重点关注的一个点，这个 key 值必须保证是一个对象级别（为什么是对象级别？看完下面的章节你就会明白了）的唯一常量。一般来说，有以下三种推荐的 key 值</p>
<ol>
<li>声明 <code>static char kAssociatedObjectKey;</code> ，使用 <code>&amp;kAssociatedObjectKey</code> 作为 key 值;</li>
<li>声明 <code>static void *kAssociatedObjectKey = &amp;kAssociatedObjectKey;</code>，使用 <code>kAssociatedObjectKey</code> 作为 key 值；</li>
<li>用 selector ，使用 getter 方法的名称作为 key 值</li>
</ol>
<p>我个人最喜欢的（没有之一）是第 3 种方式，因为它省掉了一个变量名，非常优雅地解决了计算科学中的两大世界难题之一（命名）</p>
<h3 id="关联策略">关联策略</h3><p>在给一个对象添加关联对象时有五种关联策略可供选择：<br><img src="http://cc.cocimg.com/api/uploads/20150629/1435542766477905.png" alt=""></p>
<p>其中，第 2 种与第 4 种、第 3 种与第 5 种关联策略的唯一差别就在于操作是否具有原子性。由于操作的原子性不在本文的讨论范围内，所以下面的实验和讨论就以前三种以例进行展开</p>
<h3 id="实现原理">实现原理</h3><p>在探究 Associated Objects 的实现原理前，我们还是先来动手做一个小实验，研究一下关联对象什么时候会被释放。本实验主要涉及 ViewController 类和它的分类 ViewController+AssociatedObjects 。注：本实验的完整代码可以在这里 <a href="https://github.com/leichunfeng/AssociatedObjects" target="_blank" rel="external">AssociatedObjects</a> 找到，其中关键代码如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *associatedObject_assign;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *associatedObject_retain;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>,   <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *associatedObject_copy;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span> (<span class="title">AssociatedObjects</span>)</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)associatedObject_assign &#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, _cmd);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)setAssociatedObject_assign:(<span class="built_in">NSString</span> *)associatedObject_assign &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(associatedObject_assign), associatedObject_assign, OBJC_ASSO<span class="built_in">CIATION_ASSIGN</span>);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSString</span> *)associatedObject_retain &#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, _cmd);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)setAssociatedObject_retain:(<span class="built_in">NSString</span> *)associatedObject_retain &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(associatedObject_retain), associatedObject_retain, OBJC_ASSO<span class="built_in">CIATION_RETAIN_NONATOMIC</span>);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSString</span> *)associatedObject_copy &#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, _cmd);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)setAssociatedObject_copy:(<span class="built_in">NSString</span> *)associatedObject_copy &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(associatedObject_copy), associatedObject_copy, OBJC_ASSO<span class="built_in">CIATION_COPY_NONATOMIC</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>在 ViewController+AssociatedObjects.h 中声明了三个属性，限定符分别为 assign, nonatomic 、strong, nonatomic 和 copy, nonatomic ，而在 ViewController+AssociatedObjects.m 中相应的分别用 OBJC_ASSOCIATION_ASSIGN 、OBJC_ASSOCIATION_RETAIN_NONATOMIC 、OBJC_ASSOCIATION_COPY_NONATOMIC 三种关联策略为这三个属性添加“实例变量”。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="built_in">NSString</span> *string_weak_retain = <span class="literal">nil</span>;</span><br><span class="line">__<span class="keyword">weak</span> <span class="built_in">NSString</span> *string_weak_copy   = <span class="literal">nil</span>;</span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.associatedObject_assign</span> = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"leichunfeng1"</span>];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.associatedObject_retain</span> = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"leichunfeng2"</span>];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.associatedObject_copy</span>   = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"leichunfeng3"</span>];</span><br><span class="line">    string_weak_assign = <span class="keyword">self</span><span class="variable">.associatedObject_assign</span>;</span><br><span class="line">    string_weak_retain = <span class="keyword">self</span><span class="variable">.associatedObject_retain</span>;</span><br><span class="line">    string_weak_copy   = <span class="keyword">self</span><span class="variable">.associatedObject_copy</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line"><span class="comment">//    NSLog(@"self.associatedObject_assign: %@", self.associatedObject_assign); // Will Crash</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"self.associatedObject_retain: %@"</span>, <span class="keyword">self</span><span class="variable">.associatedObject_retain</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"self.associatedObject_copy:   %@"</span>, <span class="keyword">self</span><span class="variable">.associatedObject_copy</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>在 ViewController 的 viewDidLoad 方法中，我们对三个属性进行了赋值，并声明了三个全局的 __weak 变量来观察相应对象的释放时机。此外，我们重写了 touchesBegan:withEvent: 方法，在方法中分别打印了这三个属性的当前值。</p>
<p>在继续阅读下面章节前，建议读者先自行思考一下 <code>self.associatedObject_assign</code> 、<code>self.associatedObject_retain</code> 和 <code>self.associatedObject_cop</code>y 指向的对象分别会在什么时候被释放，以加深理解。</p>
<h3 id="实验">实验</h3><p>我们先在 viewDidLoad 方法的第 28 行打上断点，然后运行程序，点击导航栏右上角的按钮 Push 到 ViewController 界面，程序将停在断点处。接着，我们使用 lldb 的 watchpoint 命令来设置观察点，观察全局变量 string_weak_assign 、string_weak_retain 和 string_weak_copy 的值的变化(<code>watch set variable string_weak_retain</code>)。正确设置好观察点后，将会在 console 中看到如下的类似输出：<br><img src="http://blog.leichunfeng.com/images/AssociatedObjects1.jpg" alt=""></p>
<p>点击继续运行按钮，有一个观察点将被命中。我们先查看 console 中的输出，通过将这一步打印的 old value 和上一步的 new value 进行对比，我们可以知道本次命中的观察点是 string_weak_assign ，string_weak_assign 的值变成了 0x0000000000000000 ，也就是 nil 。换句话说 self.associatedObject_assign 指向的对象已经被释放了，而通过查看左侧调用栈我们可以知道，这个对象是由于其所在的 autoreleasepool 被 drain 而被释放的，这与我前面的文章<a href="http://www.cocoachina.com/ios/20150610/12093.html" target="_blank" rel="external">《Objective-C Autorelease Pool 的实现原理》</a>中的表述是一致的。提示，待会你也可以放开 touchesBegan:withEvent: 中第 31 行的注释，在 ViewController 出现后，点击一下它的 view ，进一步验证一下这个结论。<br><img src="http://blog.leichunfeng.com/images/AssociatedObjects2.jpg" alt=""><br>接下来，我们点击 ViewController 导航栏左上角的按钮，返回前一个界面，此时，又将有一个观察点被命中。同理，我们可以知道这个观察点是 string_weak_retain 。我们查看左侧的调用栈，将会发现一个非常敏感的函数调用 _object_remove_assocations ，调用这个函数后 ViewController 的所有关联对象被全部移除。最终，self.associatedObject_retain 指向的对象被释放。<br><img src="http://blog.leichunfeng.com/images/AssociatedObjects3.jpg" alt=""></p>
<p>点击继续运行按钮，最后一个观察点 string_weak_copy 被命中。同理，self.associatedObject_copy 指向的对象也由于关联对象的移除被最终释放。</p>
<p><img src="http://blog.leichunfeng.com/images/AssociatedObjects4.jpg" alt=""></p>
<h2 id="结论">结论</h2><p>由这个实验，我们可以得出以下结论：</p>
<ol>
<li>关联对象的释放时机与被移除的时机并不总是一致的，比如上面的 self.associatedObject_assign 所指向的对象在 ViewController 出现后就被释放了，但是 self.associatedObject_assign 仍然有值，还是保存的原对象的地址。如果之后再使用 self.associatedObject_assign 就会造成 Crash ，所以我们在使用弱引用的关联对象时要非常小心</li>
<li>一个对象的所有关联对象是在这个对象被释放时调用的 _object_remove_assocations 函数中被移除的。</li>
</ol>
<p>接下来，我们就一起看看 runtime 中的源码，来验证下我们的实验结论。</p>
<h3 id="objc_setAssociatedObject">objc_setAssociatedObject</h3><p>们可以在 objc-references.mm 文件中找到 objc_setAssociatedObject 函数最终调用的函数：<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// retain the new value (if any) outside the lock.</span></span><br><span class="line">    ObjcAssociation old_association<span class="params">(<span class="number">0</span>, nil)</span>;</span><br><span class="line">    id new_value = value ? acquireValue<span class="params">(value, policy)</span> : nil;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations<span class="params">(manager.associations<span class="params">()</span>)</span>;</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE<span class="params">(object)</span>;</span><br><span class="line">        <span class="keyword">if</span> <span class="params">(new_value)</span> &#123;</span><br><span class="line">            <span class="comment">// break any existing association.</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.find<span class="params">(disguised_object)</span>;</span><br><span class="line">            <span class="keyword">if</span> <span class="params">(i != associations.end<span class="params">()</span>)</span> &#123;</span><br><span class="line">                <span class="comment">// secondary table exists</span></span><br><span class="line">                ObjectAssociationMap <span class="built_in">*</span>refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find<span class="params">(key)</span>;</span><br><span class="line">                <span class="keyword">if</span> <span class="params">(j != refs-&gt;end<span class="params">()</span>)</span> &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    j-&gt;second = ObjcAssociation<span class="params">(policy, new_value)</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="params">(*refs)</span>[key] = ObjcAssociation<span class="params">(policy, new_value)</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// create the new association (first time).</span></span><br><span class="line">                ObjectAssociationMap <span class="built_in">*</span>refs = new ObjectAssociationMap;</span><br><span class="line">                associations[disguised_object] = refs;</span><br><span class="line">                <span class="params">(*refs)</span>[key] = ObjcAssociation<span class="params">(policy, new_value)</span>;</span><br><span class="line">                object-&gt;setHasAssociatedObjects<span class="params">()</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// setting the association to nil breaks the association.</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.find<span class="params">(disguised_object)</span>;</span><br><span class="line">            <span class="keyword">if</span> <span class="params">(i !=  associations.end<span class="params">()</span>)</span> &#123;</span><br><span class="line">                ObjectAssociationMap <span class="built_in">*</span>refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find<span class="params">(key)</span>;</span><br><span class="line">                <span class="keyword">if</span> <span class="params">(j != refs-&gt;end<span class="params">()</span>)</span> &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    refs-&gt;erase<span class="params">(j)</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// release the old value (outside of the lock).</span></span><br><span class="line">    <span class="keyword">if</span> <span class="params">(old_association.hasValue<span class="params">()</span>)</span> ReleaseValue<span class="params">()</span><span class="params">(old_association)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在看这段代码前，我们需要先了解一下几个数据结构以及它们之间的关系：</p>
<ol>
<li>AssociationsManager 是顶级的对象，维护了一个从 spinlock_t 锁到 AssociationsHashMap 哈希表的单例键值对映射；</li>
<li>AssociationsHashMap 是一个无序的哈希表，维护了从对象地址到 ObjectAssociationMap 的映射；</li>
<li>ObjectAssociationMap 是一个 C++ 中的 map ，维护了从 key 到 ObjcAssociation 的映射，即关联记录；</li>
<li>ObjcAssociation 是一个 C++ 的类，表示一个具体的关联结构，主要包括两个实例变量，_policy 表示关联策略，_value 表示关联对象。</li>
</ol>
<p>每一个对象地址对应一个 ObjectAssociationMap 对象，而一个 ObjectAssociationMap 对象保存着这个对象的若干个关联记录。<br>弄清楚这些数据结构之间的关系后，再回过头来看上面的代码就不难了。我们发现，在苹果的底层代码中一般都会充斥着各种 if else ，可见写好 if else 后我们就距离成为高手不远了。开个玩笑，我们来看下面的流程图，一图胜千言：<br><img src="http://blog.leichunfeng.com/images/objc_setAssociatedObject.png" alt=""></p>
<h3 id="objc_getAssociatedObject">objc_getAssociatedObject</h3><p>同样的，我们也可以在 objc-references.mm 文件中找到 objc_getAssociatedObject 函数最终调用的函数：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">id _object_get_associative_reference<span class="list">(<span class="keyword">id</span> object, void <span class="variable">*key) &#123;</span><br><span class="line">    id value = nil;</span><br><span class="line">    uintptr_t policy = OBJC_ASSOCIATION_ASSIGN;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">        if (i != associations.end()) &#123;</span><br><span class="line">            ObjectAssociationMap *</span>refs = i-&gt;second<span class="comment">;</span></span><br><span class="line">            ObjectAssociationMap:<span class="keyword">:iterator</span> j = refs-&gt;find<span class="list">(<span class="keyword">key</span>)</span><span class="comment">;</span></span><br><span class="line">            if <span class="list">(<span class="keyword">j</span> != refs-&gt;end<span class="list">()</span>)</span> &#123;</span><br><span class="line">                ObjcAssociation <span class="keyword">&amp;entry</span> = j-&gt;second<span class="comment">;</span></span><br><span class="line">                value = entry.value<span class="list">()</span><span class="comment">;</span></span><br><span class="line">                policy = entry.policy<span class="list">()</span><span class="comment">;</span></span><br><span class="line">                if <span class="list">(<span class="keyword">policy</span> &amp; OBJC_ASSOCIATION_GETTER_RETAIN)</span> <span class="list">(<span class="list">(<span class="keyword">id</span><span class="list">(<span class="keyword">*</span>)</span><span class="list">(<span class="keyword">id</span>, SEL)</span>)</span>objc_msgSend)</span><span class="list">(<span class="keyword">value</span>, SEL_retain)</span><span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if <span class="list">(<span class="keyword">value</span> <span class="keyword">&amp;&amp;</span> <span class="list">(<span class="keyword">policy</span> &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)</span>)</span> &#123;</span><br><span class="line">        <span class="list">(<span class="list">(<span class="keyword">id</span><span class="list">(<span class="keyword">*</span>)</span><span class="list">(<span class="keyword">id</span>, SEL)</span>)</span>objc_msgSend)</span><span class="list">(<span class="keyword">value</span>, SEL_autorelease)</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    return value<span class="comment">;</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>看懂了 objc_setAssociatedObject 函数后，objc_getAssociatedObject 函数对我们来说就是小菜一碟了。这个函数先根据对象地址在 AssociationsHashMap 中查找其对应的 ObjectAssociationMap 对象，如果能找到则进一步根据 key 在 ObjectAssociationMap 对象中查找这个 key 所对应的关联结构 ObjcAssociation ，如果能找到则返回 ObjcAssociation 对象的 value 值，否则返回 nil 。</p>
<h3 id="objc_removeAssociatedObjects">objc_removeAssociatedObjects</h3><p>同理，我们也可以在 objc-references.mm 文件中找到 objc_removeAssociatedObjects 函数最终调用的函数：<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void _object_remove_assocations<span class="params">(id object)</span> &#123;</span><br><span class="line">    vector&lt; ObjcAssociation,ObjcAllocator &gt; elements;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations<span class="params">(manager.associations<span class="params">()</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> <span class="params">(associations.size<span class="params">()</span> == <span class="number">0</span>)</span> return;</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE<span class="params">(object)</span>;</span><br><span class="line">        AssociationsHashMap::iterator i = associations.find<span class="params">(disguised_object)</span>;</span><br><span class="line">        <span class="keyword">if</span> <span class="params">(i != associations.end<span class="params">()</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// copy all of the associations that need to be removed.</span></span><br><span class="line">            ObjectAssociationMap <span class="built_in">*</span>refs = i-&gt;second;</span><br><span class="line">            <span class="keyword">for</span> <span class="params">(ObjectAssociationMap::iterator j = refs-&gt;begin<span class="params">()</span>, end = refs-&gt;end<span class="params">()</span>; j != end; ++j)</span> &#123;</span><br><span class="line">                elements.push_back<span class="params">(j-&gt;second)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// remove the secondary table.</span></span><br><span class="line">            delete refs;</span><br><span class="line">            associations.erase<span class="params">(i)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// the calls to releaseValue() happen outside of the lock.</span></span><br><span class="line">    for_each<span class="params">(elements.begin<span class="params">()</span>, elements.end<span class="params">()</span>, ReleaseValue<span class="params">()</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数负责移除一个对象的所有关联对象，具体实现也是先根据对象的地址获取其对应的 ObjectAssociationMap 对象，然后将所有的关联结构保存到一个 vector 中，最终释放 vector 中保存的所有关联对象。根据前面的实验观察到的情况，在一个对象被释放时，也正是调用的这个函数来移除其所有的关联对象。</p>
<h3 id="给类对象添加关联对象">给类对象添加关联对象</h3><p>看完源代码后，我们知道对象地址与 AssociationsHashMap 哈希表是一一对应的。那么我们可能就会思考这样一个问题，是否可以给类对象添加关联对象呢？答案是肯定的。我们完全可以用同样的方式给类对象添加关联对象，只不过我们一般情况下不会这样做，因为更多时候我们可以通过 static 变量来实现类级别的变量。我在分类 ViewController+AssociatedObjects 中给 ViewController 类对象添加了一个关联对象 associatedObject ，读者可以亲自在 viewDidLoad 方法中调用一下以下两个方法验证一下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="tag">NSString</span> *)<span class="tag">associatedObject</span>;</span><br><span class="line">+ (<span class="tag">void</span>)<span class="rule"><span class="attribute">setAssociatedObject</span>:<span class="value">(NSString *)associatedObject</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结">总结</h2><p>读到这里，相信你对开篇的那三个问题已经有了一定的认识，下面我们再梳理一下：</p>
<ol>
<li>关联对象与被关联对象本身的存储并没有直接的关系，它是存储在单独的哈希表中的；</li>
<li>关联对象的五种关联策略与属性的限定符非常类似，在绝大多数情况下，我们都会使用 OBJC_ASSOCIATION_RETAIN_NONATOMIC 的关联策略，这可以保证我们持有关联对象；</li>
<li>关联对象的释放时机与移除时机并不总是一致，比如实验中用关联策略 OBJC_ASSOCIATION_ASSIGN 进行关联的对象，很早就已经被释放了，但是并没有被移除，而再使用这个关联对象时就会造成 Crash </li>
</ol>
<p>在弄懂 Associated Objects 的实现原理后，可以帮助我们更好地使用它，在出现问题时也能尽快地定位问题，最后希望本文能够对你有所帮助。</p>
<h3 id="参考链接">参考链接</h3><ul>
<li><a href="http://nshipster.com/associated-objects/" target="_blank" rel="external">http://nshipster.com/associated-objects/</a> </li>
<li><a href="http://kingscocoa.com/tutorials/associated-objects/" target="_blank" rel="external">http://kingscocoa.com/tutorials/associated-objects/</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="iOS_Associated_Objects">iOS Associated Objects</h2><p>关注以下三个问题:</p>
<ol>
<li>关联对象被存储在什么地方，是不是存放在被关联对象本身的内存中？</li>
<li>关联对象的五种关联策略有什么区别，有什么坑？</li>
<li>关联对象的生命周期是怎样的，什么时候被释放，什么时候被移除？</li>
</ol>
<h3 id="使用场景:">使用场景:</h3><p>按照 Mattt Thompson 大神的文章 Associated Objects 中的说法，<a href="http://nshipster.com/associated-objects/">Associated Objects</a> 主要有以下三个使用场景</p>
<ol>
<li>为现有的类添加私有变量以帮助实现细节；</li>
<li>为现有的类添加公有属性；</li>
<li>为 KVO 创建一个关联的观察者。</li>
</ol>
<p>从本质上看，第 1 、2 个场景其实是一个意思，唯一的区别就在于新添加的这个属性是公有的还是私有的而已。就目前来说，我在实际工作中使用得最多的是第 2 个场景，而第 3 个场景我还没有使用过<br>]]>
    
    </summary>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS Category]]></title>
    <link href="http://ytlvy.com/2015/07/13/iOS-Category/"/>
    <id>http://ytlvy.com/2015/07/13/iOS-Category/</id>
    <published>2015-07-13T13:30:25.000Z</published>
    <updated>2015-07-13T14:03:36.000Z</updated>
    <content type="html"><![CDATA[<h2 id="category">category</h2><h3 id="category_简介">category 简介</h3><ul>
<li>为已存在的类, 添加方法</li>
<li>将类的实现, 分别存放在不同的文件中. 好处: a) 减少单体文件体积 b)按照功能划分 c)协作开发 d)按需加载</li>
<li>声明私有方法</li>
<li>模拟多继承</li>
<li>把framework的私有方法公开</li>
</ul>
<h3 id="extension">extension</h3><blockquote>
<p>extension 很像匿名的category. 差异: a)extension在编译器决议, 是类声明的一部分.b)用来隐藏私有属性或方法.c)只有在有类源码的前提下,才能添加extension</p>
<p>category 在运行期决议的. category无法添加实例变量, (通过association来模拟添加)</p>
</blockquote>
<a id="more"></a>
<h3 id="category_声明">category 声明</h3><p>objc-runtime-new.h文件中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">category_t</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;    <span class="comment">//类的名字</span></span><br><span class="line">    <span class="keyword">classref_t</span> cls;      <span class="comment">//类</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">method_list_t</span> *instanceMethods;</span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">method_list_t</span> *classMethods;</span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">protocol_list_t</span> *protocols;</span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">property_list_t</span> *instanceProperties;</span><br><span class="line">&#125; <span class="keyword">category_t</span>;</span><br></pre></td></tr></table></figure>
<p>MyClass.h：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)printName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span>(<span class="title">MyAddition</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)printName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>MyClass.m：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"MyClass.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)printName</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,<span class="string">@"MyClass"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span>(<span class="title">MyAddition</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)printName</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,<span class="string">@"MyAddition"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">clang</span> <span class="tag">-rewrite-objc</span> <span class="tag">MyClass</span><span class="class">.m</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*_method_list_t*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _objc_method)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> method_count;</span><br><span class="line">    <span class="keyword">struct</span> _objc_method method_list[<span class="number">1</span>];</span><br><span class="line">&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_MyClass_$_MyAddition </span><br><span class="line">= &#123;</span><br><span class="line">    <span class="keyword">sizeof</span>(_objc_method),</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;(<span class="keyword">struct</span> objc_selector *)<span class="string">"printName"</span>, </span><br><span class="line">        <span class="string">"v16@0:8"</span>, </span><br><span class="line">        (<span class="keyword">void</span> *)_I_MyClass_MyAddition_printName&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*_prop_list_t*/</span> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _prop_t)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count_of_properties;</span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">_prop_t</span> prop_list[<span class="number">1</span>];</span><br><span class="line">&#125; _OBJC_$_PROP_LIST_MyClass_$_MyAddition </span><br><span class="line">= &#123;</span><br><span class="line">    <span class="keyword">sizeof</span>(<span class="keyword">_prop_t</span>),</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    &#123;&#123;<span class="string">"name"</span>,<span class="string">"T@\"NSString\",C,N"</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __declspec(dllexport) <span class="keyword">struct</span> <span class="keyword">_class_t</span> OBJC_CLASS_$_MyClass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> <span class="keyword">_category_t</span> _OBJC_$_CATEGORY_MyClass_$_MyAddition  =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"MyClass"</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="comment">// &amp;OBJC_CLASS_$_MyClass,</span></span><br><span class="line">    (<span class="keyword">const</span> <span class="keyword">struct</span> <span class="keyword">_method_list_t</span> *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_MyClass_$_MyAddition,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    (<span class="keyword">const</span> <span class="keyword">struct</span> <span class="keyword">_prop_list_t</span> *)&amp;_OBJC_$_PROP_LIST_MyClass_$_MyAddition,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> OBJC_CATEGORY_SETUP_$_MyClass_$_MyAddition(<span class="keyword">void</span> ) &#123;</span><br><span class="line">    _OBJC_$_CATEGORY_MyClass_$_MyAddition.cls = &amp;OBJC_CLASS_$_MyClass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *OBJC_CATEGORY_SETUP[] = &#123;</span><br><span class="line">    (<span class="keyword">void</span> *)&amp;OBJC_CATEGORY_SETUP_$_MyClass_$_MyAddition,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> <span class="keyword">_class_t</span> *L_OBJC_LABEL_CLASS_$ [<span class="number">1</span>] = &#123;</span><br><span class="line">    &amp;OBJC_CLASS_$_MyClass,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> <span class="keyword">_class_t</span> *_OBJC_LABEL_NONLAZY_CLASS_$[] = &#123;</span><br><span class="line">    &amp;OBJC_CLASS_$_MyClass,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> <span class="keyword">_category_t</span> *L_OBJC_LABEL_CATEGORY_$ [<span class="number">1</span>] = &#123;</span><br><span class="line">    &amp;_OBJC_$_CATEGORY_MyClass_$_MyAddition,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>首先编译器生成了实例方法列表OBJC$CATEGORY_INSTANCE_METHODS_MyClass$MyAddition和属性列表_OBJC$PROP_LIST_MyClass$MyAddition，两者的命名都遵循了公共前缀+类名+category名字的命名方式，而且实例方法列表里面填充的正是我们在MyAddition这个category里面写的方法printName，而属性列表里面填充的也正是我们在MyAddition里添加的name属性。还有一个需要注意到的事实就是category的名字用来给各种列表以及后面的category结构体本身命名，而且有static来修饰，所以在同一个编译单元里我们的category名不能重复，否则会出现编译错误。</li>
<li>其次，编译器生成了category本身_OBJC$CATEGORY_MyClass$MyAddition，并用前面生成的列表来初始化category本身。</li>
<li>最后，编译器在DATA段下的objc<em>catlist section里保存了一个大小为1的category_t的数组L_OBJC_LABEL_CATEGORY$（当然，如果有多个category，会生成对应长度的数组^</em>^），用于运行期category的加载。</li>
</ol>
<h3 id="category如何加载">category如何加载</h3><p>对于OC运行时，入口方法如下（在objc-os.mm文件中）：<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void _objc_init<span class="params">(void)</span></span><br><span class="line">&#123;</span><br><span class="line">    static bool initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="params">(initialized)</span> return;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag"><span class="keyword">fixme</span></span> defer initialization until an objc-using image is found?</span></span><br><span class="line">    environ_init<span class="params">()</span>;</span><br><span class="line">    tls_init<span class="params">()</span>;</span><br><span class="line">    lock_init<span class="params">()</span>;</span><br><span class="line">    exception_init<span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register for unmap first, in case some +load unmaps something</span></span><br><span class="line">    _dyld_register_func_for_remove_image<span class="params">(&amp;unmap_image)</span>;</span><br><span class="line">    dyld_register_image_state_change_handler<span class="params">(dyld_image_state_bound,</span><br><span class="line">                                             <span class="number">1</span>/*batch*/, &amp;map_images)</span>;</span><br><span class="line">    dyld_register_image_state_change_handler<span class="params">(dyld_image_state_dependents_initialized, <span class="number">0</span>/*not batch*/, &amp;load_images)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>category被附加到类上面是在map_images的时候发生的，在new-ABI的标准下，_objc_init里面的调用的map_images最终会调用objc-runtime-new.mm里面的_read_images方法，而在_read_images方法的结尾，有以下的代码片段：<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/ Discover categories. </span><br><span class="line">    <span class="keyword">for</span> <span class="params">(EACH_HEADER)</span> &#123;</span><br><span class="line">        category_t <span class="built_in">*</span><span class="built_in">*</span>catlist =</span><br><span class="line">            _getObjc2CategoryList<span class="params">(hi, &amp;count)</span>;</span><br><span class="line">        <span class="keyword">for</span> <span class="params">(i = <span class="number">0</span>; i &lt; count; i++)</span> &#123;</span><br><span class="line">            category_t <span class="built_in">*</span>cat = catlist[i];</span><br><span class="line">            class_t <span class="built_in">*</span>cls = remapClass<span class="params">(cat-&gt;cls)</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="params">(!cls)</span> &#123;</span><br><span class="line">                <span class="comment">// Category's target class is missing (probably weak-linked).</span></span><br><span class="line">                <span class="comment">// Disavow any knowledge of this category.</span></span><br><span class="line">                catlist[i] = NULL;</span><br><span class="line">                <span class="keyword">if</span> <span class="params">(PrintConnecting)</span> &#123;</span><br><span class="line">                    _objc_inform<span class="params">(<span class="string">"CLASS: IGNORING category \?\?\?(%s) %p with "</span></span><br><span class="line">                                 <span class="string">"missing weak-linked target class"</span>,</span><br><span class="line">                                 cat-&gt;name, cat)</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process this category. </span></span><br><span class="line">            <span class="comment">// First, register the category with its target class. </span></span><br><span class="line">            <span class="comment">// Then, rebuild the class's method lists (etc) if </span></span><br><span class="line">            <span class="comment">// the class is realized. </span></span><br><span class="line">            BOOL classExists = NO;</span><br><span class="line">            <span class="keyword">if</span> <span class="params">(cat-&gt;instanceMethods ||  cat-&gt;protocols </span><br><span class="line">                ||  cat-&gt;instanceProperties)</span></span><br><span class="line">            &#123;</span><br><span class="line">                addUnattachedCategoryForClass<span class="params">(cat, cls, hi)</span>;</span><br><span class="line">                <span class="keyword">if</span> <span class="params">(isRealized<span class="params">(cls)</span>)</span> &#123;</span><br><span class="line">                    remethodizeClass<span class="params">(cls)</span>;</span><br><span class="line">                    classExists = YES;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> <span class="params">(PrintConnecting)</span> &#123;</span><br><span class="line">                    _objc_inform<span class="params">(<span class="string">"CLASS: found category -%s(%s) %s"</span>,</span><br><span class="line">                                 getName<span class="params">(cls)</span>, cat-&gt;name,</span><br><span class="line">                                 classExists ? <span class="string">"on existing class"</span> : <span class="string">""</span>)</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="params">(cat-&gt;classMethods  ||  cat-&gt;protocols </span><br><span class="line">                /* ||  cat-&gt;classProperties */)</span></span><br><span class="line">            &#123;</span><br><span class="line">                addUnattachedCategoryForClass<span class="params">(cat, cls-&gt;isa, hi)</span>;</span><br><span class="line">                <span class="keyword">if</span> <span class="params">(isRealized<span class="params">(cls-&gt;isa)</span>)</span> &#123;</span><br><span class="line">                    remethodizeClass<span class="params">(cls-&gt;isa)</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> <span class="params">(PrintConnecting)</span> &#123;</span><br><span class="line">                    _objc_inform<span class="params">(<span class="string">"CLASS: found category +%s(%s)"</span>,</span><br><span class="line">                                 getName<span class="params">(cls)</span>, cat-&gt;name)</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>首先，我们拿到的catlist就是上节中讲到的编译器为我们准备的category_t数组，关于是如何加载catlist本身的，我们暂且不表，这和category本身的关系也不大，有兴趣的同学可以去研究以下Apple的二进制格式和load机制。<br>略去PrintConnecting这个用于log的东西，这段代码很容易理解</p>
<ol>
<li>把category的实例方法、协议以及属性添加到类上</li>
<li>把category的类方法和协议添加到类的metaclass上</li>
</ol>
<p>值得注意的是，在代码中有一小段注释  <code>|| cat-&gt;classProperties</code>，看来苹果有过给类添加属性的计划啊。<br>ok，我们接着往里看，category的各种列表是怎么最终添加到类上的，就拿实例方法列表来说吧：<br>在上述的代码片段里，addUnattachedCategoryForClass只是把类和category做一个关联映射，而remethodizeClass才是真正去处理添加事宜的功臣。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">static void remethodizeClass<span class="params">(class_t *cls)</span></span><br><span class="line">&#123;</span><br><span class="line">    category_list <span class="built_in">*</span>cats;</span><br><span class="line">    BOOL isMeta;</span><br><span class="line"></span><br><span class="line">    rwlock_assert_writing<span class="params">(&amp;runtimeLock)</span>;</span><br><span class="line"></span><br><span class="line">    isMeta = isMetaClass<span class="params">(cls)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-methodizing: check for more categories</span></span><br><span class="line">    <span class="keyword">if</span> <span class="params">(<span class="params">(cats = unattachedCategoriesForClass<span class="params">(cls)</span>)</span>)</span> &#123;</span><br><span class="line">        chained_property_list <span class="built_in">*</span>newproperties;</span><br><span class="line">        const protocol_list_t <span class="built_in">*</span><span class="built_in">*</span>newprotos;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="params">(PrintConnecting)</span> &#123;</span><br><span class="line">            _objc_inform<span class="params">(<span class="string">"CLASS: attaching categories to class '%s' %s"</span>,</span><br><span class="line">                         getName<span class="params">(cls)</span>, isMeta ? <span class="string">"(meta)"</span> : <span class="string">""</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update methods, properties, protocols</span></span><br><span class="line"></span><br><span class="line">        BOOL vtableAffected = NO;</span><br><span class="line">        attachCategoryMethods<span class="params">(cls, cats, &amp;vtableAffected)</span>;</span><br><span class="line"></span><br><span class="line">        newproperties = buildPropertyList<span class="params">(NULL, cats, isMeta)</span>;</span><br><span class="line">        <span class="keyword">if</span> <span class="params">(newproperties)</span> &#123;</span><br><span class="line">            newproperties-&gt;next = cls-&gt;data<span class="params">()</span>-&gt;properties;</span><br><span class="line">            cls-&gt;data<span class="params">()</span>-&gt;properties = newproperties;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        newprotos = buildProtocolList<span class="params">(cats, NULL, cls-&gt;data<span class="params">()</span>-&gt;protocols)</span>;</span><br><span class="line">        <span class="keyword">if</span> <span class="params">(cls-&gt;data<span class="params">()</span>-&gt;protocols  &amp;&amp;  cls-&gt;data<span class="params">()</span>-&gt;protocols != newprotos)</span> &#123;</span><br><span class="line">            _free_internal<span class="params">(cls-&gt;data<span class="params">()</span>-&gt;protocols)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cls-&gt;data<span class="params">()</span>-&gt;protocols = newprotos;</span><br><span class="line"></span><br><span class="line">        _free_internal<span class="params">(cats)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update method caches and vtables</span></span><br><span class="line">        flushCaches<span class="params">(cls)</span>;</span><br><span class="line">        <span class="keyword">if</span> <span class="params">(vtableAffected)</span> flushVtables<span class="params">(cls)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而对于添加类的实例方法而言，又会去调用attachCategoryMethods这个方法，我们去看下attachCategoryMethods：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> </span><br><span class="line"><span class="title">attachCategoryMethods</span><span class="params">(class_t *cls, category_list *cats,</span><br><span class="line">                      BOOL *inoutVtablesAffected)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cats) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line"></span><br><span class="line">    BOOL isMeta = isMetaClass(cls);</span><br><span class="line">    <span class="keyword">method_list_t</span> **mlists = (<span class="keyword">method_list_t</span> **)</span><br><span class="line">        _malloc_internal(cats-&gt;count * <span class="keyword">sizeof</span>(*mlists));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Count backwards through cats to get newest categories first</span></span><br><span class="line">    <span class="keyword">int</span> mcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = cats-&gt;count;</span><br><span class="line">    BOOL fromBundle = NO;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="keyword">method_list_t</span> *mlist = cat_method_list(cats-&gt;<span class="built_in">list</span>[i].cat, isMeta);</span><br><span class="line">        <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">            fromBundle |= cats-&gt;<span class="built_in">list</span>[i].fromBundle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    attachMethodLists(cls, mlists, mcount, NO, fromBundle, inoutVtablesAffected);</span><br><span class="line"></span><br><span class="line">    _free_internal(mlists);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>attachCategoryMethods做的工作相对比较简单，它只是把所有category的实例方法列表拼成了一个大的实例方法列表，然后转交给了attachMethodLists方法（我发誓，这是本节我们看的最后一段代码了^_^），这个方法有点长，我们只看一小段：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (uint32_t m = <span class="number">0</span>;</span><br><span class="line">             (scanForCustomRR || scanForCustomAWZ)  &amp;&amp;  m &lt; mlist-&gt;count;</span><br><span class="line">             m++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">SEL</span> sel = method_list_nth(mlist, m)-&gt;name;</span><br><span class="line">        <span class="keyword">if</span> (scanForCustomRR  &amp;&amp;  isRRSelector(sel)) &#123;</span><br><span class="line">            cls-&gt;setHasCustomRR();</span><br><span class="line">            scanForCustomRR = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scanForCustomAWZ  &amp;&amp;  isAWZSelector(sel)) &#123;</span><br><span class="line">            cls-&gt;setHasCustomAWZ();</span><br><span class="line">            scanForCustomAWZ = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // <span class="type">Fill</span> <span class="keyword">method</span> list <span class="type">array</span></span><br><span class="line">    newLists[newCount++] = mlist;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"></span><br><span class="line">// <span class="type">Copy</span> old methods to the <span class="keyword">method</span> list <span class="type">array</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; oldCount; i++) &#123;</span><br><span class="line">    newLists[newCount++] = oldLists[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的有两点：<br>1)、category的方法没有“完全替换掉”原来类已经有的方法，也就是说如果category和原来类都有methodA，那么category附加完成之后，类的方法列表里会有两个methodA<br>2)、category的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的category的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会罢休^_^，殊不知后面可能还有一样名字的方法。</p>
<h3 id="旁枝末叶-category和+load方法">旁枝末叶-category和+load方法</h3><p>我们知道，在类和category中都可以有+load方法，那么有两个问题：<br>1)、在类的+load方法调用的时候，我们可以调用category中声明的方法么？<br>2)、这么些个+load方法，调用顺序是咋样的呢？<br>鉴于上述几节我们看的代码太多了，对于这两个问题我们先来看一点直观的</p>
<p>我们的代码里有MyClass和MyClass的两个category （Category1和Category2），MyClass和两个category都添加了+load方法，并且Category1和Category2都写了MyClass的printName方法。<br>在Xcode中点击Edit Scheme，添加如下两个环境变量（可以在执行load方法以及加载category的时候打印log信息，更多的环境变量选项可参见objc-private.h）:<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">OBJC_PRINT_LOAD_METHODS</span></span><br><span class="line">OBJC_PRINT_REPLACED_METHODS</span><br></pre></td></tr></table></figure></p>
<p>运行项目，我们会看到控制台打印很多东西出来，我们只找到我们想要的信息，顺序如下：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">objc</span>[<span class="number">1187</span>]: <span class="name">REPLACED</span>: -[<span class="name">MyClass</span> <span class="atom">printName</span>] <span class="atom">by</span> <span class="atom">category</span> <span class="name">Category1</span></span><br><span class="line"><span class="atom">objc</span>[<span class="number">1187</span>]: <span class="name">REPLACED</span>: -[<span class="name">MyClass</span> <span class="atom">printName</span>] <span class="atom">by</span> <span class="atom">category</span> <span class="name">Category2</span></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="atom">objc</span>[<span class="number">1187</span>]: <span class="name">LOAD</span>: <span class="atom">class</span> <span class="string">'MyClass'</span> <span class="atom">scheduled</span> <span class="atom">for</span> +<span class="atom">load</span></span><br><span class="line"><span class="atom">objc</span>[<span class="number">1187</span>]: <span class="name">LOAD</span>: <span class="atom">category</span> <span class="string">'MyClass(Category1)'</span> <span class="atom">scheduled</span> <span class="atom">for</span> +<span class="atom">load</span></span><br><span class="line"><span class="atom">objc</span>[<span class="number">1187</span>]: <span class="name">LOAD</span>: <span class="atom">category</span> <span class="string">'MyClass(Category2)'</span> <span class="atom">scheduled</span> <span class="atom">for</span> +<span class="atom">load</span></span><br><span class="line"><span class="atom">objc</span>[<span class="number">1187</span>]: <span class="name">LOAD</span>: +[<span class="name">MyClass</span> <span class="atom">load</span>]</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="atom">objc</span>[<span class="number">1187</span>]: <span class="name">LOAD</span>: +[<span class="name">MyClass</span>(<span class="name">Category1</span>) <span class="atom">load</span>]</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="atom">objc</span>[<span class="number">1187</span>]: <span class="name">LOAD</span>: +[<span class="name">MyClass</span>(<span class="name">Category2</span>) <span class="atom">load</span>]</span><br></pre></td></tr></table></figure></p>
<p>所以，对于上面两个问题，答案是很明显的：<br>1)、可以调用，因为附加category到类的工作会先于+load方法的执行<br>2)、+load的执行顺序是先类，后category，而category的+load执行顺序是根据编译顺序决定的。<br>虽然对于+load的执行顺序是这样，但是对于“覆盖”掉的方法，则会先找到最后一个编译的category里的对应方法。</p>
<h3 id="category和方法覆盖">category和方法覆盖</h3><p>怎么调用到原来类中被category覆盖掉的方法？<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> currentClass = [<span class="type">MyClass</span> class];</span><br><span class="line"><span class="type">MyClass</span> *my = [[<span class="type">MyClass</span> alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (currentClass) &#123;</span><br><span class="line">    unsigned <span class="type">int</span> methodCount;</span><br><span class="line">    <span class="type">Method</span> *methodList = class_copyMethodList(currentClass, &amp;methodCount);</span><br><span class="line">    <span class="type">IMP</span> lastImp = <span class="type">NULL</span>;</span><br><span class="line">    <span class="type">SEL</span> lastSel = <span class="type">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">NSInteger</span> i = <span class="number">0</span>; i &lt; methodCount; i++) &#123;</span><br><span class="line">        <span class="type">Method</span> <span class="keyword">method</span> = methodList[i];</span><br><span class="line">        <span class="type">NSString</span> *methodName = [<span class="type">NSString</span> stringWithCString:sel_getName(method_getName(<span class="keyword">method</span>)) </span><br><span class="line">                                        encoding:<span class="type">NSUTF8StringEncoding</span>];</span><br><span class="line">        <span class="keyword">if</span> ([@<span class="string">"printName"</span> isEqualToString:methodName]) &#123;</span><br><span class="line">            lastImp = method_getImplementation(<span class="keyword">method</span>);</span><br><span class="line">            lastSel = method_getName(<span class="keyword">method</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    typedef <span class="type">void</span> (*fn)(id,<span class="type">SEL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lastImp != <span class="type">NULL</span>) &#123;</span><br><span class="line">        fn f = (fn)lastImp;</span><br><span class="line">        f(my,lastSel);</span><br><span class="line">    &#125;</span><br><span class="line">    free(methodList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="category和关联对象">category和关联对象</h3><p>我们知道在category里面是无法为category添加实例变量的。但是我们很多时候需要在category中添加和对象关联的值，这个时候可以求助关联对象来实现</p>
<p>MyClass+Category1.h:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"MyClass.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> (<span class="title">Category1</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>MyClass+Category1.m:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"MyClass+Category1.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span> (<span class="title">Category1</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,<span class="string">@"load in Category1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>,</span><br><span class="line">                             <span class="string">"name"</span>,</span><br><span class="line">                             name,</span><br><span class="line">                             OBJC_ASSO<span class="built_in">CIATION_COPY</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span>*)name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *nameObject = objc_getAssociatedObject(<span class="keyword">self</span>, <span class="string">"name"</span>);</span><br><span class="line">    <span class="keyword">return</span> nameObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>但是关联对象又是存在什么地方呢？ 如何存储？ 对象销毁时候如何处理关联对象呢？<br>我们去翻一下runtime的源码，在objc-references.mm文件中有个方法_object_set_associative_reference：<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">void _object_set_associative_reference<span class="params">(id object, void *key, id value, uintptr_t policy)</span> &#123;</span><br><span class="line">    <span class="comment">// retain the new value (if any) outside the lock.</span></span><br><span class="line">    ObjcAssociation old_association<span class="params">(<span class="number">0</span>, nil)</span>;</span><br><span class="line">    id new_value = value ? acquireValue<span class="params">(value, policy)</span> : nil;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations<span class="params">(manager.associations<span class="params">()</span>)</span>;</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE<span class="params">(object)</span>;</span><br><span class="line">        <span class="keyword">if</span> <span class="params">(new_value)</span> &#123;</span><br><span class="line">            <span class="comment">// break any existing association.</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.find<span class="params">(disguised_object)</span>;</span><br><span class="line">            <span class="keyword">if</span> <span class="params">(i != associations.end<span class="params">()</span>)</span> &#123;</span><br><span class="line">                <span class="comment">// secondary table exists</span></span><br><span class="line">                ObjectAssociationMap <span class="built_in">*</span>refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find<span class="params">(key)</span>;</span><br><span class="line">                <span class="keyword">if</span> <span class="params">(j != refs-&gt;end<span class="params">()</span>)</span> &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    j-&gt;second = ObjcAssociation<span class="params">(policy, new_value)</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="params">(*refs)</span>[key] = ObjcAssociation<span class="params">(policy, new_value)</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// create the new association (first time).</span></span><br><span class="line">                ObjectAssociationMap <span class="built_in">*</span>refs = new ObjectAssociationMap;</span><br><span class="line">                associations[disguised_object] = refs;</span><br><span class="line">                <span class="params">(*refs)</span>[key] = ObjcAssociation<span class="params">(policy, new_value)</span>;</span><br><span class="line">                _class_setInstancesHaveAssociatedObjects<span class="params">(_object_getClass<span class="params">(object)</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// setting the association to nil breaks the association.</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.find<span class="params">(disguised_object)</span>;</span><br><span class="line">            <span class="keyword">if</span> <span class="params">(i !=  associations.end<span class="params">()</span>)</span> &#123;</span><br><span class="line">                ObjectAssociationMap <span class="built_in">*</span>refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find<span class="params">(key)</span>;</span><br><span class="line">                <span class="keyword">if</span> <span class="params">(j != refs-&gt;end<span class="params">()</span>)</span> &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    refs-&gt;erase<span class="params">(j)</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// release the old value (outside of the lock).</span></span><br><span class="line">    <span class="keyword">if</span> <span class="params">(old_association.hasValue<span class="params">()</span>)</span> ReleaseValue<span class="params">()</span><span class="params">(old_association)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到所有的关联对象都由AssociationsManager管理，而AssociationsManager定义如下：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AssociationsManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> OSSpinLock _lock;</span><br><span class="line">    <span class="keyword">static</span> AssociationsHashMap *_map;               <span class="comment">// associative references:  object pointer -&gt; PtrPtrHashMap.</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AssociationsManager()   &#123; OSSpinLockLock(&amp;_lock); &#125;</span><br><span class="line">    ~AssociationsManager()  &#123; OSSpinLockUnlock(&amp;_lock); &#125;</span><br><span class="line"></span><br><span class="line">    AssociationsHashMap &amp;associations() &#123;</span><br><span class="line">        <span class="keyword">if</span> (_map == <span class="keyword">NULL</span>)</span><br><span class="line">            _map = <span class="keyword">new</span> AssociationsHashMap();</span><br><span class="line">        <span class="keyword">return</span> *_map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>AssociationsManager里面是由一个静态AssociationsHashMap来存储所有的关联对象的。这相当于把所有对象的关联对象都存在一个全局map里面。而map的的key是这个对象的指针地址（任意两个不同对象的指针地址一定是不同的），而这个map的value又是另外一个AssociationsHashMap，里面保存了关联对象的kv对。<br>而在对象的销毁逻辑里面，见objc-runtime-new.mm:<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void <span class="built_in">*</span>objc_destructInstance<span class="params">(id obj)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="params">(obj)</span> &#123;</span><br><span class="line">        Class isa_gen = _object_getClass<span class="params">(obj)</span>;</span><br><span class="line">        class_t <span class="built_in">*</span>isa = newcls<span class="params">(isa_gen)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read all of the flags at once for performance.</span></span><br><span class="line">        bool cxx = hasCxxStructors<span class="params">(isa)</span>;</span><br><span class="line">        bool assoc = <span class="built_in">!</span>UseGC &amp;&amp; _class_instancesHaveAssociatedObjects<span class="params">(isa_gen)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This order is important.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="params">(cxx)</span> object_cxxDestruct<span class="params">(obj)</span>;</span><br><span class="line">        <span class="keyword">if</span> <span class="params">(assoc)</span> _object_remove_assocations<span class="params">(obj)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="params">(!UseGC)</span> objc_clear_deallocating<span class="params">(obj)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>嗯，runtime的销毁对象函数objc_destructInstance里面会判断这个对象有没有关联对象，如果有，会调用_object_remove_assocations做关联对象的清理工作。</p>
<p>后记<br>正如侯捷先生所讲-“源码面前，了无秘密”，Apple的Cocoa Touch框架虽然并不开源，但是Objective-C的runtime和Core Foundation却是完全开放源码的(在<a href="http://www.opensource.apple.com/tarballs/可以下载到全部的开源代码)。" target="_blank" rel="external">http://www.opensource.apple.com/tarballs/可以下载到全部的开源代码)。</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="category">category</h2><h3 id="category_简介">category 简介</h3><ul>
<li>为已存在的类, 添加方法</li>
<li>将类的实现, 分别存放在不同的文件中. 好处: a) 减少单体文件体积 b)按照功能划分 c)协作开发 d)按需加载</li>
<li>声明私有方法</li>
<li>模拟多继承</li>
<li>把framework的私有方法公开</li>
</ul>
<h3 id="extension">extension</h3><blockquote>
<p>extension 很像匿名的category. 差异: a)extension在编译器决议, 是类声明的一部分.b)用来隐藏私有属性或方法.c)只有在有类源码的前提下,才能添加extension</p>
<p>category 在运行期决议的. category无法添加实例变量, (通过association来模拟添加)</p>
</blockquote>]]>
    
    </summary>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS Runtime 运行时类与对象的编译处理]]></title>
    <link href="http://ytlvy.com/2015/07/13/iOS-Runtime-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BC%96%E8%AF%91%E5%A4%84%E7%90%86/"/>
    <id>http://ytlvy.com/2015/07/13/iOS-Runtime-运行时类与对象的编译处理/</id>
    <published>2015-07-13T13:28:11.000Z</published>
    <updated>2015-07-13T14:02:59.000Z</updated>
    <content type="html"><![CDATA[<h2 id="iOS_Runtime运行时类与对象的编译处理">iOS Runtime运行时类与对象的编译处理</h2><p>Objective-C语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。这种动态语言的优势在于：我们写代码时更具灵活性，如我们可以把消息转发给我们想要的对象，或者随意交换一个方法的实现等。<br>这种特性意味着<code>Objective-C</code>不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。对于Objective-C来说，这个运行时系统就像一个操作系统一样：它让所有的工作可以正常的运行。这个运行时系统即Objc Runtime。Objc Runtime其实是一个Runtime库，它基本上是用C和汇编写的，这个库使得C语言有了面向对象的能力。</p>
<p>Runtime库主要做下面几件事：</p>
<ol>
<li>封装：在这个库中，对象可以用C语言中的结构体表示，而方法可以用C函数来实现，另外再加上了一些额外的特性。这些结构体和函数被runtime函数封装后，我们就可以在程序运行时创建，检查，修改类、对象和它们的方法了。</li>
<li>找出方法的最终执行代码：当程序执行[object doSomething]时，会向消息接收者(object)发送一条消息(doSomething)，runtime会根据消息接收者是否能响应该消息而做出不同的反应。这将在后面详细介绍。</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Objective-C runtime目前有两个版本：Modern runtime和Legacy runtime。Modern Runtime 覆盖了64位的Mac OS X Apps，还有 iOS Apps，Legacy Runtime 是早期用来给32位 Mac OS X Apps 用的，也就是可以不用管就是了。<br>在这一系列文章中，我们将介绍runtime的基本工作原理，以及如何利用它让我们的程序变得更加灵活。在本文中，我们先来介绍一下类与对象，这是面向对象的基础，我们看看在Runtime中，类是如何实现的。<br><a id="more"></a></p>
<h3 id="类与对象基础数据结构">类与对象基础数据结构</h3><h4 id="Class">Class</h4><p>Objective-C类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针。它的定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br></pre></td></tr></table></figure></p>
<p>查看objc/runtime.h中objc_class结构体的定义如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_<span class="built_in">AVAILABILITY</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#if !__OBJC2__</span></span><br><span class="line">    Class super_class                       OBJC2_UN<span class="built_in">AVAILABLE</span>;  <span class="comment">// 父类</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                        OBJC2_UN<span class="built_in">AVAILABLE</span>;  <span class="comment">// 类名</span></span><br><span class="line">    <span class="keyword">long</span> version                            OBJC2_UN<span class="built_in">AVAILABLE</span>;  <span class="comment">// 类的版本信息，默认为0</span></span><br><span class="line">    <span class="keyword">long</span> info                               OBJC2_UN<span class="built_in">AVAILABLE</span>;  <span class="comment">// 类信息，供运行期使用的一些位标识</span></span><br><span class="line">    <span class="keyword">long</span> instance_size                      OBJC2_UN<span class="built_in">AVAILABLE</span>;  <span class="comment">// 该类的实例变量大小</span></span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars            OBJC2_UN<span class="built_in">AVAILABLE</span>;  <span class="comment">// 该类的成员变量链表</span></span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists   OBJC2_UN<span class="built_in">AVAILABLE</span>;  <span class="comment">// 方法定义的链表</span></span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache                OBJC2_UN<span class="built_in">AVAILABLE</span>;  <span class="comment">// 方法缓存</span></span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols    OBJC2_UN<span class="built_in">AVAILABLE</span>;  <span class="comment">// 协议链表</span></span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br></pre></td></tr></table></figure></p>
<p>在这个定义中，下面几个字段是我们感兴趣的</p>
<ol>
<li>isa：需要注意的是在Objective-C中，所有的类自身也是一个对象，这个对象的Class里面也有一个isa指针，它指向metaClass(元类)，我们会在后面介绍它。</li>
<li>super_class：指向该类的父类，如果该类已经是最顶层的根类(如NSObject或NSProxy)，则super_class为NULL。</li>
<li>cache：用于缓存最近使用的方法。一个接收者对象接收到一个消息时，它会根据isa指针去查找能够响应这个消息的对象。在实际使用中，这个对象只有一部分方法是常用的，很多方法其实很少用或者根本用不上。这种情况下，如果每次消息来时，我们都是methodLists中遍历一遍，性能势必很差。这时，cache就派上用场了。在我们每次调用过一个方法后，这个方法就会被缓存到cache列表中，下次调用的时候runtime就会优先去cache中查找，如果cache没有，才去methodLists中查找方法。这样，对于那些经常用到的方法的调用，但提高了调用的效率。</li>
<li>version：我们可以使用这个字段来提供类的版本信息。这对于对象的序列化非常有用，它可是让我们识别出不同类定义版本中实例变量布局的改变</li>
</ol>
<p>针对cache，我们用下面例子来说明其执行过程：<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = <span class="comment">[<span class="comment">[NSArray alloc]</span> init]</span>;</span><br></pre></td></tr></table></figure></p>
<p>其流程是：</p>
<ol>
<li>[NSArray alloc]先被执行。因为NSArray没有+alloc方法，于是去父类NSObject去查找。</li>
<li>检测NSObject是否响应+alloc方法，发现响应，于是检测NSArray类，并根据其所需的内存空间大小开始分配内存空间，然后把isa指针指向NSArray类。同时，+alloc也被加进cache列表里面。</li>
<li>接着，执行-init方法，如果NSArray响应该方法，则直接将其加入cache；如果不响应，则去父类查找。</li>
<li>在后期的操作中，如果再以[[NSArray alloc] init]这种方式来创建数组，则会直接从cache中取出相应的方法，直接调用。</li>
</ol>
<blockquote>
<p>备注上面的说法是错误的, NSArray 采用了类簇来实现, alloc 之后生成的<code>__NSPlacehodlerArray</code>不是NSArray</p>
</blockquote>
<h4 id="objc_object与id">objc_object与id</h4><p>objc_object是表示一个类的实例的结构体，它的定义如下(objc/objc.h)：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">    Class isa  OBJC_ISA_<span class="built_in">AVAILABILITY</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="keyword">id</span>;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这个结构体只有一个字体，即指向其类的isa指针。这样，当我们向一个Objective-C对象发送消息时，运行时库会根据实例对象的isa指针找到这个实例对象所属的类。Runtime库会在类的方法列表及父类的方法列表中去寻找与消息对应的selector指向的方法。找到后即运行这个方法。<br>当创建一个特定类的实例对象时，分配的内存包含一个objc_object数据结构，然后是类的实例变量的数据。NSObject类的alloc和allocWithZone:方法使用函数class_createInstance来创建objc_object数据结构。<br>另外还有我们常见的id，它是一个objc_object结构类型的指针。它的存在可以让我们实现类似于C++中泛型的一些操作。该类型的对象可以转换为任何一种对象，有点类似于C语言中void *指针类型的作用</p>
<h4 id="objc_cache">objc_cache</h4><p>上面提到了objc_class结构体中的cache字段，它用于缓存调用过的方法。这个字段是一个指向objc_cache结构体的指针，其定义如下<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_cache &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask <span class="comment">/* total = mask + 1 */</span>                 OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> occupied                                    OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    Method buckets[<span class="number">1</span>]                                        OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>该结构体的字段描述如下：</p>
<ol>
<li>mask：一个整数，指定分配的缓存bucket的总数。在方法查找过程中，Objective-C runtime使用这个字段来确定开始线性查找数组的索引位置。指向方法selector的指针与该字段做一个AND位操作(index = (mask &amp; selector))。这可以作为一个简单的hash散列算法。</li>
<li>occupied：一个整数，指定实际占用的缓存bucket的总数。</li>
<li>buckets：指向Method数据结构指针的数组。这个数组可能包含不超过mask+1个元素。需要注意的是，指针可能是NULL，表示这个缓存bucket没有被占用，另外被占用的bucket可能是不连续的。这个数组可能会随着时间而增长。</li>
</ol>
<h4 id="元类(Meta_Class)">元类(Meta Class)</h4><p>上面我们提到，所有的类自身也是一个对象，我们可以向这个对象发送消息(即调用类方法)。如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSArray *<span class="built_in">array</span> = [NSArray <span class="built_in">array</span>];</span><br></pre></td></tr></table></figure></p>
<p>这个例子中，<code>+array</code>消息发送给了<code>NSArray</code>类，而这个<code>NSArray</code>也是一个对象。既然是对象，那么它也是一个<code>objc_object</code>指针，它包含一个指向其类的一个<code>isa</code>指针。那么这些就有一个问题了，这个isa指针指向什么呢？为了调用+array方法，这个类的isa指针必须指向一个包含这些类方法的一个<code>objc_class</code>结构体。这就引出了<code>meta-class</code>的概念</p>
<p>meta-class是一个类对象的类。当我们向一个对象发送消息时，runtime会在这个对象所属的这个类的方法列表中查找方法；而向一个类发送消息时，会在这个类的meta-class的方法列表中查找。</p>
<p>meta-class之所以重要，是因为它存储着一个类的所有类方法。每个类都会有一个单独的meta-class，因为每个类的类方法基本不可能完全相同。<br>再深入一下，meta-class也是一个类，也可以向它发送一个消息，那么它的isa又是指向什么呢？为了不让这种结构无限延伸下去，Objective-C的设计者让所有的meta-class的isa指向基类的meta-class，以此作为它们的所属类。即，任何NSObject继承体系下的meta-class都使用NSObject的meta-class作为自己的所属类，而基类的meta-class的isa指针是指向它自己。这样就形成了一个完美的闭环。</p>
<p>通过上面的描述，再加上对objc_class结构体中super_class指针的分析，我们就可以描绘出类及相应meta-class类的一个继承体系了，如下图所示：<br><img src="http://img.blog.csdn.net/20150317161312799" alt=""></p>
<p>对于NSObject继承体系来说，其实例方法对体系中的所有实例、类和meta-class都是有效的；而类方法对于体系内的所有类和meta-class都是有效的。<br>讲了这么多，我们还是来写个例子吧：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> TestMetaClass(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"This objcet is %p"</span>, <span class="keyword">self</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Class is %@, super class is %@"</span>, [<span class="keyword">self</span> class], [<span class="keyword">self</span> superclass]);</span><br><span class="line">    </span><br><span class="line">    Class currentClass = [<span class="keyword">self</span> class];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Following the isa pointer %d times gives %p, %@"</span>, i, currentClass, <span class="built_in">NSStringFromClass</span>(currentClass));</span><br><span class="line">        <span class="keyword">if</span> (class_isMetaClass(currentClass)) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"----current class is MetaClass"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        currentClass = object_getClass(currentClass);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"NSObject's class is %p"</span>, [<span class="built_in">NSObject</span> class]);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"NSObject's meta class is %p"</span>, object_getClass([<span class="built_in">NSObject</span> class]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma mark -</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Test</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)ex_registerClassPair &#123;</span><br><span class="line"></span><br><span class="line">    Class newClass = objc_allocateClassPair([<span class="built_in">NSError</span> class], <span class="string">"TestClass"</span>, <span class="number">0</span>);</span><br><span class="line">    class_addMethod(newClass, <span class="keyword">@selector</span>(testMetaClass), (IMP)TestMetaClass, <span class="string">"v@:"</span>);</span><br><span class="line">    objc_registerClassPair(newClass);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">id</span> instance = [[newClass alloc] initWithDomain:<span class="string">@"some domain"</span> code:<span class="number">0</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">    [instance performSelector:<span class="keyword">@selector</span>(testMetaClass)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>这个例子是在运行时创建了一个NSError的子类TestClass，然后为这个子类添加一个方法testMetaClass，这个方法的实现是TestMetaClass函数。<br>运行后，打印结果是<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2015-07-10</span> <span class="number">14:47:14.32</span>6 iTest[<span class="number">1788:31341</span>] This objcet is 0x7fa<span class="number">281d9e29</span>0</span><br><span class="line"><span class="number">2015-07-10</span> <span class="number">14:47:14.32</span>6 iTest[<span class="number">1788:31341</span>] Class is TestClass, super class is NSError</span><br><span class="line"><span class="number">2015-07-10</span> <span class="number">14:47:14.32</span>6 iTest[<span class="number">1788:31341</span>] Following the isa pointer 0 times gives 0x7fa<span class="number">281d9e59</span>0, TestClass</span><br><span class="line"><span class="number">2015-07-10</span> <span class="number">14:47:14.32</span>7 iTest[<span class="number">1788:31341</span>] Following the isa pointer 1 times gives 0x7fa<span class="number">281d9b89</span>0, TestClass</span><br><span class="line"><span class="number">2015-07-10</span> <span class="number">14:47:14.32</span>7 iTest[<span class="number">1788:31341</span>] ----current class is MetaClass</span><br><span class="line"><span class="number">2015-07-10</span> <span class="number">14:47:14.32</span>7 iTest[<span class="number">1788:31341</span>] Following the isa pointer 2 times gives <span class="number">0x10a0c119</span>8, NSObject</span><br><span class="line"><span class="number">2015-07-10</span> <span class="number">14:47:14.32</span>7 iTest[<span class="number">1788:31341</span>] ----current class is MetaClass</span><br><span class="line"><span class="number">2015-07-10</span> <span class="number">14:47:14.32</span>7 iTest[<span class="number">1788:31341</span>] Following the isa pointer 3 times gives <span class="number">0x10a0c119</span>8, NSObject</span><br><span class="line"><span class="number">2015-07-10</span> <span class="number">14:47:14.32</span>8 iTest[<span class="number">1788:31341</span>] ----current class is MetaClass</span><br><span class="line"><span class="number">2015-07-10</span> <span class="number">14:47:14.32</span>8 iTest[<span class="number">1788:31341</span>] Following the isa pointer 4 times gives <span class="number">0x10a0c119</span>8, NSObject</span><br><span class="line"><span class="number">2015-07-10</span> <span class="number">14:47:14.32</span>8 iTest[<span class="number">1788:31341</span>] ----current class is MetaClass</span><br><span class="line"><span class="number">2015-07-10</span> <span class="number">14:47:14.32</span>9 iTest[<span class="number">1788:31341</span>] Following the isa pointer 5 times gives <span class="number">0x10a0c119</span>8, NSObject</span><br><span class="line"><span class="number">2015-07-10</span> <span class="number">14:47:14.32</span>9 iTest[<span class="number">1788:31341</span>] ----current class is MetaClass</span><br><span class="line"><span class="number">2015-07-10</span> <span class="number">14:47:14.32</span>9 iTest[<span class="number">1788:31341</span>] NSObject's class is <span class="number">0x10a0c117</span>0</span><br><span class="line"><span class="number">2015-07-10</span> <span class="number">14:47:14.32</span>9 iTest[<span class="number">1788:31341</span>] NSObject's meta class is <span class="number">0x10a0c119</span>8</span><br></pre></td></tr></table></figure></p>
<p>我们在for循环中，我们通过object_getClass来获取对象的isa，并将其打印出来，依此一直回溯到NSObject的meta-class。可以分析得出:</p>
<ol>
<li>NSObject 的MetaClass 为RootMetaClass(0x10a0c1198)</li>
<li>RootMetaClass的元类为它自身</li>
<li>TestClass(0x7fa281d9e590) 的元类为TestClass(0x7fa281d9b890)—此类为MetaClass</li>
<li>TestClass(0x7fa281d9b890)的元类为RootMetaClass(0x10a0c1198)</li>
</ol>
<h4 id="类与对象操作函数">类与对象操作函数</h4><p>runtime提供了大量的函数来操作类与对象。类的操作方法大部分是以class为前缀的，而对象的操作方法大部分是以objc或object_为前缀。下面我们将根据这些方法的用途来分类讨论这些方法的使用。</p>
<h4 id="类相关操作函数">类相关操作函数</h4><p>我们可以回过头去看看objc_class的定义，runtime提供的操作类的方法主要就是针对这个结构体中的各个字段的。下面我们分别介绍这一些的函数。并在最后以实例来演示这些函数的具体用法。</p>
<h4 id="类名(name)">类名(name)</h4><p>类名操作的函数主要有:<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> char * class_getName ( <span class="class"><span class="keyword">Class</span> <span class="title">cls</span> );</span></span><br></pre></td></tr></table></figure></p>
<p>对于class_getName函数，如果传入的cls为Nil，则返回一个空字符串。</p>
<h4 id="父类(super_class)和元类(meta-class)">父类(super_class)和元类(meta-class)</h4><p>父类和元类操作的函数主要有：<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 获取类的父类</span><br><span class="line"><span class="class"><span class="keyword">Class</span> <span class="title">class_getSuperclass</span> ( <span class="title">Class</span> <span class="title">cls</span> );</span></span><br><span class="line"></span><br><span class="line">// 判断给定的<span class="class"><span class="keyword">Class</span>是否是一个元类</span></span><br><span class="line">BOOL class_isMetaClass ( <span class="class"><span class="keyword">Class</span> <span class="title">cls</span> );</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>class_getSuperclass函数，当cls为Nil或者cls为根类时，返回Nil。不过通常我们可以使用NSObject类的superclass方法来达到同样的目的。</li>
<li>class_isMetaClass函数，如果是cls是元类，则返回YES；如果否或者传入的cls为Nil，则返回NO。</li>
</ul>
<h4 id="实例变量大小(instance_size)">实例变量大小(instance_size)</h4><p>实例变量大小操作的函数有：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size_t class_getInstanceSize <span class="list">( <span class="keyword">Class</span> cls )</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="成员变量(ivars)及属性">成员变量(ivars)及属性</h4><p>在objc_class中，所有的成员变量、属性的信息是放在链表ivars中的。ivars是一个数组，数组中每个元素是指向Ivar(变量信息)的指针。runtime提供了丰富的函数来操作这一字段。大体上可以分为以下几类：<br>1 成员变量操作函数，主要包含以下函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类中指定名称实例成员变量的信息</span></span><br><span class="line"><span class="function">Ivar <span class="title">class_getInstanceVariable</span> <span class="params">( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类成员变量的信息</span></span><br><span class="line"><span class="function">Ivar <span class="title">class_getClassVariable</span> <span class="params">( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加成员变量</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_addIvar</span> <span class="params">( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t size, uint8_t alignment, <span class="keyword">const</span> <span class="keyword">char</span> *types )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取整个成员变量列表</span></span><br><span class="line">Ivar * class_copyIvarList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br></pre></td></tr></table></figure></p>
<ul>
<li>class_getInstanceVariable函数，它返回一个指向包含name指定的成员变量信息的objc_ivar结构体的指针(Ivar)。</li>
<li>class_getClassVariable函数，目前没有找到关于Objective-C中类变量的信息，一般认为Objective-C不支持类变量。注意，返回的列表不包含父类的成员变量和属性。</li>
<li>Objective-C不支持往已存在的类中添加实例变量，因此不管是系统库提供的提供的类，还是我们自定义的类，都无法动态添加成员变量。但如果我们通过运行时来创建一个类的话，又应该如何给它添加成员变量呢？这时我们就可以使用class_addIvar函数了。不过需要注意的是，这个方法只能在objc_allocateClassPair函数与objc_registerClassPair之间调用。另外，这个类也不能是元类。成员变量的按字节最小对齐量是<code>1&lt;&lt;alignment</code>。这取决于ivar的类型和机器的架构。如果变量的类型是指针类型，则传递log2(sizeof(pointer_type))。</li>
<li>class_copyIvarList函数，它返回一个指向成员变量信息的数组，数组中每个元素是指向该成员变量信息的objc_ivar结构体的指针。这个数组不包含在父类中声明的变量。outCount指针返回数组的大小。需要注意的是，我们必须使用free()来释放这个数组。</li>
</ul>
<p>2 属性操作函数，主要包含以下函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取指定的属性</span></span><br><span class="line"><span class="keyword">objc_property_t</span> class_getProperty ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取属性列表</span></span><br><span class="line"><span class="keyword">objc_property_t</span> * class_copyPropertyList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为类添加属性</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_addProperty</span> <span class="params">( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换类的属性</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">class_replaceProperty</span> <span class="params">( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount )</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>这一种方法也是针对ivars来操作，不过只操作那些是属性的值。我们在后面介绍属性时会再遇到这些函数。</p>
<p>3 在MAC OS X系统中，我们可以使用垃圾回收器。runtime提供了几个函数来确定一个对象的内存区域是否可以被垃圾回收器扫描，以处理strong/weak引用。这几个函数定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> * class_getIvarLayout ( Class cls );</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">class_setIvarLayout</span> <span class="params">( Class cls, <span class="keyword">const</span> uint8_t *layout )</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> * class_getWeakIvarLayout ( Class cls );</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">class_setWeakIvarLayout</span> <span class="params">( Class cls, <span class="keyword">const</span> uint8_t *layout )</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>但通常情况下，我们不需要去主动调用这些方法；在调用objc_registerClassPair时，会生成合理的布局。在此不详细介绍这些函数</p>
<h4 id="方法(methodLists)">方法(methodLists)</h4><p>方法操作主要有以下函数：<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加方法</span></span><br><span class="line">BOOL class_addMethod ( <span class="keyword">Class</span> cls, SEL name, IMP imp, <span class="keyword">const</span> char *types );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取实例方法</span></span><br><span class="line"><span class="function"><span class="keyword">Method</span> <span class="title">class_getInstanceMethod</span> <span class="params">( <span class="keyword">Class</span> cls, SEL name )</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类方法</span></span><br><span class="line"><span class="function"><span class="keyword">Method</span> <span class="title">class_getClassMethod</span> <span class="params">( <span class="keyword">Class</span> cls, SEL name )</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有方法的数组</span></span><br><span class="line"><span class="function"><span class="keyword">Method</span> * <span class="title">class_copyMethodList</span> <span class="params">( <span class="keyword">Class</span> cls, unsigned int *outCount )</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 替代方法的实现</span></span><br><span class="line">IMP class_replaceMethod ( <span class="keyword">Class</span> cls, SEL name, IMP imp, <span class="keyword">const</span> char *types );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回方法的具体实现</span></span><br><span class="line">IMP class_getMethodImplementation ( <span class="keyword">Class</span> cls, SEL name );</span><br><span class="line">IMP class_getMethodImplementation_stret ( <span class="keyword">Class</span> cls, SEL name );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类实例是否响应指定的selector</span></span><br><span class="line">BOOL class_respondsToSelector ( <span class="keyword">Class</span> cls, SEL sel );</span><br></pre></td></tr></table></figure></p>
<p>class_addMethod的实现会覆盖父类的方法实现，但不会取代本类中已存在的实现，如果本类中包含一个同名的实现，则函数会返回NO。如果要修改已存在实现，可以使用method_setImplementation。一个Objective-C方法是一个简单的C函数，它至少包含两个参数—self和_cmd。所以，我们的实现函数(IMP参数指向的函数)至少需要两个参数，如下所示：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> myMethodIMP(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// implementation ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与成员变量不同的是，我们可以为类动态添加方法，不管这个类是否已存在。<br>另外，参数types是一个描述传递给方法的参数类型的字符数组，这就涉及到类型编码，我们将在后面介绍</p>
<p>class_getInstanceMethod、class_getClassMethod函数，与class_copyMethodList不同的是，这两个函数都会去搜索父类的实现</p>
<p>class_copyMethodList函数，返回包含所有实例方法的数组，如果需要获取类方法，则可以使用class_copyMethodList(object_getClass(cls), &amp;count)(一个类的实例方法是定义在元类里面)。该列表不包含父类实现的方法。outCount参数返回方法的个数。在获取到列表后，我们需要使用free()方法来释放它。</p>
<p>class_replaceMethod函数，该函数的行为可以分为两种：如果类中不存在name指定的方法，则类似于class_addMethod函数一样会添加方法；如果类中已存在name指定的方法，则类似于method_setImplementation一样替代原方法的实现。</p>
<p>class_getMethodImplementation函数，该函数在向类实例发送消息时会被调用，并返回一个指向方法实现函数的指针。这个函数会比method_getImplementation(class_getInstanceMethod(cls, name))更快。返回的函数指针可能是一个指向runtime内部的函数，而不一定是方法的实际实现。例如，如果类实例无法响应selector，则返回的函数指针将是运行时消息转发机制的一部分。</p>
<p>class_respondsToSelector函数，我们通常使用NSObject类的respondsToSelector:或instancesRespondToSelector:方法来达到相同目的。</p>
<h4 id="协议(objc_protocol_list)">协议(objc_protocol_list)</h4><p>协议相关的操作包含以下函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加协议</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_addProtocol</span> <span class="params">( Class cls, Protocol *protocol )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回类是否实现指定的协议</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_conformsToProtocol</span> <span class="params">( Class cls, Protocol *protocol )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回类实现的协议列表</span></span><br><span class="line">Protocol * class_copyProtocolList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br></pre></td></tr></table></figure></p>
<ul>
<li>class_conformsToProtocol函数可以使用NSObject类的conformsToProtocol:方法来替代。</li>
<li>class_copyProtocolList函数返回的是一个数组，在使用后我们需要使用free()手动释放。</li>
</ul>
<h4 id="版本(version)">版本(version)</h4><p>版本相关的操作包含以下函数：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取版本号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">class_getVersion</span> <span class="params">( Class cls )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置版本号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">class_setVersion</span> <span class="params">( Class cls, <span class="keyword">int</span> version )</span></span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="其它">其它</h4><p>runtime还提供了两个函数来供CoreFoundation的tool-free bridging使用，即：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Class <span class="title">objc_getFutureClass</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *name )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setFutureClass</span> <span class="params">( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name )</span></span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="实例(Example)">实例(Example)</h4><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line">/-----------------------------------------------------------</span><br><span class="line"><span class="comment">// MyClass.h</span></span><br><span class="line"></span><br><span class="line">@interface MyClass : NSObject </span><br><span class="line"></span><br><span class="line">@property <span class="params">(nonatomic, strong)</span> NSArray <span class="built_in">*</span>array;</span><br><span class="line"></span><br><span class="line">@property <span class="params">(nonatomic, copy)</span> NSString <span class="built_in">*</span>string;</span><br><span class="line"></span><br><span class="line">- <span class="params">(void)</span>method1;</span><br><span class="line"></span><br><span class="line">- <span class="params">(void)</span>method2;</span><br><span class="line"></span><br><span class="line">+ <span class="params">(void)</span>classMethod1;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------------------------</span></span><br><span class="line"><span class="comment">// MyClass.m</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">#</span><span class="built_in">import</span> <span class="string">"MyClass.h"</span></span><br><span class="line"></span><br><span class="line">@interface MyClass <span class="params">()</span> &#123;</span><br><span class="line">    NSInteger       _instance1;</span><br><span class="line"></span><br><span class="line">    NSString    <span class="built_in">*</span>   _instance2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@property <span class="params">(nonatomic, assign)</span> NSUInteger integer;</span><br><span class="line"></span><br><span class="line">- <span class="params">(void)</span>method3WithArg1:<span class="params">(NSInteger)</span>arg1 arg2:<span class="params">(NSString *)</span>arg2;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MyClass</span><br><span class="line"></span><br><span class="line">+ <span class="params">(void)</span>classMethod1 &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- <span class="params">(void)</span>method1 &#123;</span><br><span class="line">    NSLog<span class="params">(@<span class="string">"call method method1"</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- <span class="params">(void)</span>method2 &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- <span class="params">(void)</span>method3WithArg1:<span class="params">(NSInteger)</span>arg1 arg2:<span class="params">(NSString *)</span>arg2 &#123;</span><br><span class="line"></span><br><span class="line">    NSLog<span class="params">(@<span class="string">"arg1 : %ld, arg2 : %@"</span>, arg1, arg2)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------------------------</span></span><br><span class="line"><span class="comment">// main.h</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">#</span><span class="built_in">import</span> <span class="string">"MyClass.h"</span></span><br><span class="line"><span class="built_in">#</span><span class="built_in">import</span> <span class="string">"MySubClass.h"</span></span><br><span class="line"><span class="built_in">#</span><span class="built_in">import</span> </span><br><span class="line"></span><br><span class="line">int main<span class="params">(int argc, const char * argv[])</span> &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line"></span><br><span class="line">        MyClass <span class="built_in">*</span>myClass = [[MyClass alloc] init];</span><br><span class="line">        unsigned int outCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Class cls = myClass.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 类名</span></span><br><span class="line">        NSLog<span class="params">(@<span class="string">"class name: %s"</span>, class_getName<span class="params">(cls)</span>)</span>;</span><br><span class="line"></span><br><span class="line">        NSLog<span class="params">(@<span class="string">"=========================================================="</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父类</span></span><br><span class="line">        NSLog<span class="params">(@<span class="string">"super class name: %s"</span>, class_getName<span class="params">(class_getSuperclass<span class="params">(cls)</span>)</span>)</span>;</span><br><span class="line">        NSLog<span class="params">(@<span class="string">"=========================================================="</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否是元类</span></span><br><span class="line">        NSLog<span class="params">(@<span class="string">"MyClass is %@ a meta-class"</span>, <span class="params">(class_isMetaClass<span class="params">(cls)</span> ? @<span class="string">""</span> : @<span class="string">"not"</span>)</span>)</span>;</span><br><span class="line">        NSLog<span class="params">(@<span class="string">"=========================================================="</span>)</span>;</span><br><span class="line"></span><br><span class="line">        Class meta_class = objc_getMetaClass<span class="params">(class_getName<span class="params">(cls)</span>)</span>;</span><br><span class="line">        NSLog<span class="params">(@<span class="string">"%s's meta-class is %s"</span>, class_getName<span class="params">(cls)</span>, class_getName<span class="params">(meta_class)</span>)</span>;</span><br><span class="line">        NSLog<span class="params">(@<span class="string">"=========================================================="</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 变量实例大小</span></span><br><span class="line">        NSLog<span class="params">(@<span class="string">"instance size: %zu"</span>, class_getInstanceSize<span class="params">(cls)</span>)</span>;</span><br><span class="line">        NSLog<span class="params">(@<span class="string">"=========================================================="</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 成员变量</span></span><br><span class="line">        Ivar <span class="built_in">*</span>ivars = class_copyIvarList<span class="params">(cls, &amp;outCount)</span>;</span><br><span class="line">        <span class="keyword">for</span> <span class="params">(int i = <span class="number">0</span>; i &lt; outCount; i++)</span> &#123;</span><br><span class="line">            Ivar ivar = ivars[i];</span><br><span class="line">            NSLog<span class="params">(@<span class="string">"instance variable's name: %s at index: %d"</span>, ivar_getName<span class="params">(ivar)</span>, i)</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        free<span class="params">(ivars)</span>;</span><br><span class="line"></span><br><span class="line">        Ivar string = class_getInstanceVariable<span class="params">(cls, <span class="string">"_string"</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> <span class="params">(string != NULL)</span> &#123;</span><br><span class="line">            NSLog<span class="params">(@<span class="string">"instace variable %s"</span>, ivar_getName<span class="params">(string)</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NSLog<span class="params">(@<span class="string">"=========================================================="</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 属性操作</span></span><br><span class="line">        objc_property_t <span class="built_in">*</span> properties = class_copyPropertyList<span class="params">(cls, &amp;outCount)</span>;</span><br><span class="line">        <span class="keyword">for</span> <span class="params">(int i = <span class="number">0</span>; i &lt; outCount; i++)</span> &#123;</span><br><span class="line">            objc_property_t property = properties[i];</span><br><span class="line">            NSLog<span class="params">(@<span class="string">"property's name: %s"</span>, property_getName<span class="params">(property)</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        free<span class="params">(properties)</span>;</span><br><span class="line"></span><br><span class="line">        objc_property_t array = class_getProperty<span class="params">(cls, <span class="string">"array"</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> <span class="params">(array != NULL)</span> &#123;</span><br><span class="line">            NSLog<span class="params">(@<span class="string">"property %s"</span>, property_getName<span class="params">(array)</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NSLog<span class="params">(@<span class="string">"=========================================================="</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法操作</span></span><br><span class="line">        Method <span class="built_in">*</span>methods = class_copyMethodList<span class="params">(cls, &amp;outCount)</span>;</span><br><span class="line">        <span class="keyword">for</span> <span class="params">(int i = <span class="number">0</span>; i &lt; outCount; i++)</span> &#123;</span><br><span class="line">            Method method = methods[i];</span><br><span class="line">            NSLog<span class="params">(@<span class="string">"method's signature: %s"</span>, method_getName<span class="params">(method)</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        free<span class="params">(methods)</span>;</span><br><span class="line"></span><br><span class="line">        Method method1 = class_getInstanceMethod<span class="params">(cls, @selector<span class="params">(method1)</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> <span class="params">(method1 != NULL)</span> &#123;</span><br><span class="line">            NSLog<span class="params">(@<span class="string">"method %s"</span>, method_getName<span class="params">(method1)</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Method classMethod = class_getClassMethod<span class="params">(cls, @selector<span class="params">(classMethod1)</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> <span class="params">(classMethod != NULL)</span> &#123;</span><br><span class="line">            NSLog<span class="params">(@<span class="string">"class method : %s"</span>, method_getName<span class="params">(classMethod)</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NSLog<span class="params">(@<span class="string">"MyClass is%@ responsd to selector: method3WithArg1:arg2:"</span>, class_respondsToSelector<span class="params">(cls, @selector<span class="params">(method3WithArg1:arg2:)</span>)</span> ? @<span class="string">""</span> : @<span class="string">" not"</span>)</span>;</span><br><span class="line"></span><br><span class="line">        IMP imp = class_getMethodImplementation<span class="params">(cls, @selector<span class="params">(method1)</span>)</span>;</span><br><span class="line">        imp<span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">        NSLog<span class="params">(@<span class="string">"=========================================================="</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 协议</span></span><br><span class="line">        Protocol <span class="built_in">*</span> __unsafe_unretained <span class="built_in">*</span> protocols = class_copyProtocolList<span class="params">(cls, &amp;outCount)</span>;</span><br><span class="line">        Protocol <span class="built_in">*</span> protocol;</span><br><span class="line">        <span class="keyword">for</span> <span class="params">(int i = <span class="number">0</span>; i &lt; outCount; i++)</span> &#123;</span><br><span class="line">            protocol = protocols[i];</span><br><span class="line">            NSLog<span class="params">(@<span class="string">"protocol name: %s"</span>, protocol_getName<span class="params">(protocol)</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NSLog<span class="params">(@<span class="string">"MyClass is%@ responsed to protocol %s"</span>, class_conformsToProtocol<span class="params">(cls, protocol)</span> ? @<span class="string">""</span> : @<span class="string">" not"</span>, protocol_getName<span class="params">(protocol)</span>)</span>;</span><br><span class="line"></span><br><span class="line">        NSLog<span class="params">(@<span class="string">"=========================================================="</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段程序的输出如下：<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2014</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">19</span>:<span class="number">41</span>:<span class="number">37.452</span> RuntimeTest[<span class="number">3189</span>:<span class="number">156810</span>] <span class="keyword">class</span> name: MyClass</span><br><span class="line"><span class="number">2014</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">19</span>:<span class="number">41</span>:<span class="number">37.453</span> RuntimeTest[<span class="number">3189</span>:<span class="number">156810</span>] ==========================================================</span><br><span class="line"><span class="number">2014</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">19</span>:<span class="number">41</span>:<span class="number">37.454</span> RuntimeTest[<span class="number">3189</span>:<span class="number">156810</span>] super <span class="keyword">class</span> name: NSObject</span><br><span class="line"><span class="number">2014</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">19</span>:<span class="number">41</span>:<span class="number">37.454</span> RuntimeTest[<span class="number">3189</span>:<span class="number">156810</span>] ==========================================================</span><br><span class="line"><span class="number">2014</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">19</span>:<span class="number">41</span>:<span class="number">37.454</span> RuntimeTest[<span class="number">3189</span>:<span class="number">156810</span>] MyClass <span class="keyword">is</span> <span class="keyword">not</span> a meta-<span class="keyword">class</span></span><br><span class="line"><span class="number">2014</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">19</span>:<span class="number">41</span>:<span class="number">37.454</span> RuntimeTest[<span class="number">3189</span>:<span class="number">156810</span>] ==========================================================</span><br><span class="line"><span class="number">2014</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">19</span>:<span class="number">41</span>:<span class="number">37.454</span> RuntimeTest[<span class="number">3189</span>:<span class="number">156810</span>] MyClass<span class="string">'s meta-class is MyClass</span><br><span class="line">2014-10-22 19:41:37.455 RuntimeTest[3189:156810] ==========================================================</span><br><span class="line">2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance size: 48</span><br><span class="line">2014-10-22 19:41:37.455 RuntimeTest[3189:156810] ==========================================================</span><br><span class="line">2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance variable'</span>s name: _instance1 at <span class="keyword">index</span>: <span class="number">0</span></span><br><span class="line"><span class="number">2014</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">19</span>:<span class="number">41</span>:<span class="number">37.455</span> RuntimeTest[<span class="number">3189</span>:<span class="number">156810</span>] instance variable<span class="string">'s name: _instance2 at index: 1</span><br><span class="line">2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance variable'</span>s name: _array at <span class="keyword">index</span>: <span class="number">2</span></span><br><span class="line"><span class="number">2014</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">19</span>:<span class="number">41</span>:<span class="number">37.455</span> RuntimeTest[<span class="number">3189</span>:<span class="number">156810</span>] instance variable<span class="string">'s name: _string at index: 3</span><br><span class="line">2014-10-22 19:41:37.463 RuntimeTest[3189:156810] instance variable'</span>s name: _integer at <span class="keyword">index</span>: <span class="number">4</span></span><br><span class="line"><span class="number">2014</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">19</span>:<span class="number">41</span>:<span class="number">37.463</span> RuntimeTest[<span class="number">3189</span>:<span class="number">156810</span>] instace variable _string</span><br><span class="line"><span class="number">2014</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">19</span>:<span class="number">41</span>:<span class="number">37.463</span> RuntimeTest[<span class="number">3189</span>:<span class="number">156810</span>] ==========================================================</span><br><span class="line"><span class="number">2014</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">19</span>:<span class="number">41</span>:<span class="number">37.463</span> RuntimeTest[<span class="number">3189</span>:<span class="number">156810</span>] <span class="keyword">property</span><span class="string">'s name: array</span><br><span class="line">2014-10-22 19:41:37.463 RuntimeTest[3189:156810] property'</span>s name: string</span><br><span class="line"><span class="number">2014</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">19</span>:<span class="number">41</span>:<span class="number">37.464</span> RuntimeTest[<span class="number">3189</span>:<span class="number">156810</span>] <span class="keyword">property</span><span class="string">'s name: integer</span><br><span class="line">2014-10-22 19:41:37.464 RuntimeTest[3189:156810] property array</span><br><span class="line">2014-10-22 19:41:37.464 RuntimeTest[3189:156810] ==========================================================</span><br><span class="line">2014-10-22 19:41:37.464 RuntimeTest[3189:156810] method'</span>s signature: method1</span><br><span class="line"><span class="number">2014</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">19</span>:<span class="number">41</span>:<span class="number">37.464</span> RuntimeTest[<span class="number">3189</span>:<span class="number">156810</span>] <span class="function"><span class="keyword">method</span>'<span class="title">s</span> <span class="title">signature</span>:</span> method2</span><br><span class="line"><span class="number">2014</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">19</span>:<span class="number">41</span>:<span class="number">37.464</span> RuntimeTest[<span class="number">3189</span>:<span class="number">156810</span>] <span class="function"><span class="keyword">method</span>'<span class="title">s</span> <span class="title">signature</span>:</span> method3WithArg1:arg2:</span><br><span class="line"><span class="number">2014</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">19</span>:<span class="number">41</span>:<span class="number">37.465</span> RuntimeTest[<span class="number">3189</span>:<span class="number">156810</span>] <span class="function"><span class="keyword">method</span>'<span class="title">s</span> <span class="title">signature</span>:</span> integer</span><br><span class="line"><span class="number">2014</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">19</span>:<span class="number">41</span>:<span class="number">37.465</span> RuntimeTest[<span class="number">3189</span>:<span class="number">156810</span>] <span class="function"><span class="keyword">method</span>'<span class="title">s</span> <span class="title">signature</span>:</span> setInteger:</span><br><span class="line"><span class="number">2014</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">19</span>:<span class="number">41</span>:<span class="number">37.465</span> RuntimeTest[<span class="number">3189</span>:<span class="number">156810</span>] <span class="function"><span class="keyword">method</span>'<span class="title">s</span> <span class="title">signature</span>:</span> <span class="keyword">array</span></span><br><span class="line"><span class="number">2014</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">19</span>:<span class="number">41</span>:<span class="number">37.465</span> RuntimeTest[<span class="number">3189</span>:<span class="number">156810</span>] <span class="function"><span class="keyword">method</span>'<span class="title">s</span> <span class="title">signature</span>:</span> string</span><br><span class="line"><span class="number">2014</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">19</span>:<span class="number">41</span>:<span class="number">37.465</span> RuntimeTest[<span class="number">3189</span>:<span class="number">156810</span>] <span class="function"><span class="keyword">method</span>'<span class="title">s</span> <span class="title">signature</span>:</span> setString:</span><br><span class="line"><span class="number">2014</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">19</span>:<span class="number">41</span>:<span class="number">37.465</span> RuntimeTest[<span class="number">3189</span>:<span class="number">156810</span>] <span class="function"><span class="keyword">method</span>'<span class="title">s</span> <span class="title">signature</span>:</span> setArray:</span><br><span class="line"><span class="number">2014</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">19</span>:<span class="number">41</span>:<span class="number">37.466</span> RuntimeTest[<span class="number">3189</span>:<span class="number">156810</span>] <span class="function"><span class="keyword">method</span>'<span class="title">s</span> <span class="title">signature</span>:</span> .cxx_destruct</span><br><span class="line"><span class="number">2014</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">19</span>:<span class="number">41</span>:<span class="number">37.466</span> RuntimeTest[<span class="number">3189</span>:<span class="number">156810</span>] <span class="function"><span class="keyword">method</span> <span class="title">method1</span></span><br><span class="line">2014-10-22 19:</span><span class="number">41</span>:<span class="number">37.466</span> RuntimeTest[<span class="number">3189</span>:<span class="number">156810</span>] <span class="keyword">class</span> <span class="function"><span class="keyword">method</span> :</span> classMethod1</span><br><span class="line"><span class="number">2014</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">19</span>:<span class="number">41</span>:<span class="number">37.466</span> RuntimeTest[<span class="number">3189</span>:<span class="number">156810</span>] MyClass <span class="keyword">is</span> responsd <span class="keyword">to</span> <span class="keyword">selector</span>: method3WithArg1:arg2:</span><br><span class="line"><span class="number">2014</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">19</span>:<span class="number">41</span>:<span class="number">37.467</span> RuntimeTest[<span class="number">3189</span>:<span class="number">156810</span>] call <span class="function"><span class="keyword">method</span> <span class="title">method1</span></span><br><span class="line">2014-10-22 19:</span><span class="number">41</span>:<span class="number">37.467</span> RuntimeTest[<span class="number">3189</span>:<span class="number">156810</span>] ==========================================================</span><br><span class="line"><span class="number">2014</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">19</span>:<span class="number">41</span>:<span class="number">37.467</span> RuntimeTest[<span class="number">3189</span>:<span class="number">156810</span>] protocol name: NSCopying</span><br><span class="line"><span class="number">2014</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">19</span>:<span class="number">41</span>:<span class="number">37.467</span> RuntimeTest[<span class="number">3189</span>:<span class="number">156810</span>] protocol name: NSCoding</span><br><span class="line"><span class="number">2014</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">19</span>:<span class="number">41</span>:<span class="number">37.467</span> RuntimeTest[<span class="number">3189</span>:<span class="number">156810</span>] MyClass <span class="keyword">is</span> responsed <span class="keyword">to</span> protocol NSCoding</span><br><span class="line"><span class="number">2014</span>-<span class="number">10</span>-<span class="number">22</span> <span class="number">19</span>:<span class="number">41</span>:<span class="number">37.468</span> RuntimeTest[<span class="number">3189</span>:<span class="number">156810</span>] ==========================================================</span><br></pre></td></tr></table></figure></p>
<h4 id="动态创建类和对象">动态创建类和对象</h4><p>runtime的强大之处在于它能在运行时创建类和对象。</p>
<h5 id="动态创建类">动态创建类</h5><p>动态创建类涉及到以下几个函数：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个新类和元类</span></span><br><span class="line"><span class="function">Class <span class="title">objc_allocateClassPair</span> <span class="params">( Class superclass, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t extraBytes )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁一个类及其相关联的类</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_disposeClassPair</span> <span class="params">( Class cls )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在应用中注册由objc_allocateClassPair创建的类</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_registerClassPair</span> <span class="params">( Class cls )</span></span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>objc_allocateClassPair函数：如果我们要创建一个根类，则superclass指定为Nil。extraBytes通常指定为0，该参数是分配给类和元类对象尾部的索引ivars的字节数。 为了创建一个新类，我们需要调用objc_allocateClassPair。然后使用诸如class_addMethod，class_addIvar等函数来为新创建的类添加方法、实例变量和属性等。完成这些后，我们需要调用objc_registerClassPair函数来注册类，之后这个新类就可以在程序中使用了。<br>实例方法和实例变量应该添加到类自身上，而类方法应该添加到类的元类上。</p>
</li>
<li><p>objc_disposeClassPair函数用于销毁一个类，不过需要注意的是，如果程序运行中还存在类或其子类的实例，则不能调用针对类调用该方法<br>在前面介绍元类时，我们已经有接触到这几个函数了，在此我们再举个实例来看看这几个函数的使用。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Class cls = objc_allocateClassPair<span class="params">(MyClass.class, <span class="string">"MySubClass"</span>, <span class="number">0</span>)</span>;</span><br><span class="line">class_addMethod<span class="params">(cls, @selector<span class="params">(submethod1)</span>, <span class="params">(IMP)</span>imp_submethod1, <span class="string">"v@:"</span>)</span>;</span><br><span class="line">class_replaceMethod<span class="params">(cls, @selector<span class="params">(method1)</span>, <span class="params">(IMP)</span>imp_submethod1, <span class="string">"v@:"</span>)</span>;</span><br><span class="line">class_addIvar<span class="params">(cls, <span class="string">"_ivar1"</span>, sizeof<span class="params">(NSString *)</span>, log<span class="params">(sizeof<span class="params">(NSString *)</span>)</span>, <span class="string">"i"</span>)</span>;</span><br><span class="line"></span><br><span class="line">objc_property_attribute_t type = &#123;<span class="string">"T"</span>, <span class="string">"@\"NSString\""</span>&#125;;</span><br><span class="line">objc_property_attribute_t ownership = &#123; <span class="string">"C"</span>, <span class="string">""</span> &#125;;</span><br><span class="line">objc_property_attribute_t backingivar = &#123; <span class="string">"V"</span>, <span class="string">"_ivar1"</span>&#125;;</span><br><span class="line">objc_property_attribute_t attrs[] = &#123;type, ownership, backingivar&#125;;</span><br><span class="line"></span><br><span class="line">class_addProperty<span class="params">(cls, <span class="string">"property2"</span>, attrs, <span class="number">3</span>)</span>;</span><br><span class="line">objc_registerClassPair<span class="params">(cls)</span>;</span><br><span class="line"></span><br><span class="line">id instance = [[cls alloc] init];</span><br><span class="line">[instance performSelector:@selector<span class="params">(submethod1)</span>];</span><br><span class="line">[instance performSelector:@selector<span class="params">(method1)</span>];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>程序的输出如下：<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2014</span>-<span class="number">10</span>-<span class="number">23</span> <span class="number">11</span>:<span class="number">35</span>:<span class="number">31.006</span> RuntimeTest[<span class="number">3800</span>:<span class="number">66152</span>] run sub <span class="function"><span class="keyword">method</span> 1</span><br><span class="line">2014-10-23 11:</span><span class="number">35</span>:<span class="number">31.006</span> RuntimeTest[<span class="number">3800</span>:<span class="number">66152</span>] run sub <span class="function"><span class="keyword">method</span> 1</span></span><br></pre></td></tr></table></figure></p>
<h5 id="动态创建对象">动态创建对象</h5><p>动态创建对象的函数如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建类实例</span></span><br><span class="line"><span class="keyword">id</span> class_createInstance ( Class cls, size_t extraBytes );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定位置创建类实例</span></span><br><span class="line"><span class="keyword">id</span> objc_constructInstance ( Class cls, <span class="keyword">void</span> *bytes );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁类实例</span></span><br><span class="line"><span class="keyword">void</span> * objc_destructInstance ( <span class="keyword">id</span> obj );</span><br></pre></td></tr></table></figure></p>
<p>class_createInstance函数：创建实例时，会在默认的内存区域为类分配内存。extraBytes参数表示分配的额外字节数。这些额外的字节可用于存储在类定义中所定义的实例变量之外的实例变量。该函数在ARC环境下无法使用。<br>调用class_createInstance的效果与+alloc方法类似。不过在使用class_createInstance时，我们需要确切的知道我们要用它来做什么。在下面的例子中，我们用NSString来测试一下该函数的实际效果：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> theObject = class_createInstance(<span class="built_in">NSString</span><span class="variable">.class</span>, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>));</span><br><span class="line"><span class="keyword">id</span> str1 = [theObject init];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [str1 class]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> str2 = [[<span class="built_in">NSString</span> alloc] initWithString:<span class="string">@"test"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [str2 class]);</span><br></pre></td></tr></table></figure></p>
<p>输出结果是：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2014<span class="tag">-10-23</span> 12<span class="pseudo">:46</span><span class="pseudo">:50</span><span class="class">.781</span> <span class="tag">RuntimeTest</span><span class="attr_selector">[4039:89088]</span> <span class="tag">NSString</span></span><br><span class="line">2014<span class="tag">-10-23</span> 12<span class="pseudo">:46</span><span class="pseudo">:50</span><span class="class">.781</span> <span class="tag">RuntimeTest</span><span class="attr_selector">[4039:89088]</span> __<span class="tag">NSCFConstantString</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，使用class_createInstance函数获取的是NSString实例，而不是类簇中的默认占位符类_NSCFConstantString</p>
<ul>
<li>objc_constructInstance函数：在指定的位置(bytes)创建类实例。</li>
<li>objc_destructInstance函数：销毁一个类的实例，但不会释放并移除任何与其相关的引用。</li>
</ul>
<h4 id="实例操作函数">实例操作函数</h4><p>实例操作函数主要是针对我们创建的实例对象的一系列操作函数，我们可以使用这组函数来从实例对象中获取我们想要的一些信息，如实例对象中变量的值。这组函数可以分为三小类：</p>
<ol>
<li>针对整个对象进行操作的函数，这类函数包含<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回指定对象的一份拷贝</span></span><br><span class="line"><span class="keyword">id</span> object_copy ( <span class="keyword">id</span> obj, size_t size );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放指定对象占用的内存</span></span><br><span class="line"><span class="keyword">id</span> object_dispose ( <span class="keyword">id</span> obj );</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>有这样一种场景，假设我们有类A和类B，且类B是类A的子类。类B通过添加一些额外的属性来扩展类A。现在我们创建了一个A类的实例对象，并希望在运行时将这个对象转换为B类的实例对象，这样可以添加数据到B类的属性中。这种情况下，我们没有办法直接转换，因为B类的实例会比A类的实例更大，没有足够的空间来放置对象。此时，我们就要以使用以上几个函数来处理这种情况，如下代码所示：<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSObject *a = [[NSObject alloc] init];</span><br><span class="line">id newB = <span class="keyword">object</span><span class="number">_</span>copy(a, <span class="keyword">class</span><span class="number">_</span>getInstanceSize(MyClass.<span class="keyword">class</span>));</span><br><span class="line"><span class="keyword">object</span><span class="number">_</span>setClass(newB, MyClass.<span class="keyword">class</span>);</span><br><span class="line"><span class="keyword">object</span><span class="number">_</span>dispose(a);</span><br></pre></td></tr></table></figure></p>
<ol>
<li>针对对象实例变量进行操作的函数，这类函数包含：<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改类实例的实例变量的值</span></span><br><span class="line">Ivar object_setInstanceVariable ( <span class="keyword">id</span> obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> *value );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取对象实例变量的值</span></span><br><span class="line">Ivar object_getInstanceVariable ( <span class="keyword">id</span> obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> **outValue );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回指向给定对象分配的任何额外字节的指针</span></span><br><span class="line"><span class="keyword">void</span> * object_getIndexedIvars ( <span class="keyword">id</span> obj );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回对象中实例变量的值</span></span><br><span class="line"><span class="keyword">id</span> object_getIvar ( <span class="keyword">id</span> obj, Ivar ivar );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置对象中实例变量的值</span></span><br><span class="line"><span class="keyword">void</span> object_setIvar ( <span class="keyword">id</span> obj, Ivar ivar, <span class="keyword">id</span> value );</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如果实例变量的Ivar已经知道，那么调用object_getIvar会比object_getInstanceVariable函数快，相同情况下，object_setIvar也比object_setInstanceVariable快。</p>
<ol>
<li>针对对象的类进行操作的函数，这类函数包含：<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回给定对象的类名</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * object_getClassName ( <span class="keyword">id</span> obj );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回对象的类</span></span><br><span class="line">Class object_getClass ( <span class="keyword">id</span> obj );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置对象的类</span></span><br><span class="line">Class object_setClass ( <span class="keyword">id</span> obj, Class cls );</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="获取类定义">获取类定义</h4><p>Objective-C动态运行库会自动注册我们代码中定义的所有的类。我们也可以在运行时创建类定义并使用objc_addClass函数来注册它们。runtime提供了一系列函数来获取类定义相关的信息，这些函数主要包括：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取已注册的类定义的列表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">objc_getClassList</span> <span class="params">( Class *buffer, <span class="keyword">int</span> bufferCount )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并返回一个指向所有已注册类的指针列表</span></span><br><span class="line">Class * objc_copyClassList ( <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回指定类的类定义</span></span><br><span class="line"><span class="function">Class <span class="title">objc_lookUpClass</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *name )</span></span>;</span><br><span class="line"><span class="function">Class <span class="title">objc_getClass</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *name )</span></span>;</span><br><span class="line"><span class="function">Class <span class="title">objc_getRequiredClass</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *name )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回指定类的元类</span></span><br><span class="line"><span class="function">Class <span class="title">objc_getMetaClass</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *name )</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>objc_getClassList函数：获取已注册的类定义的列表。我们不能假设从该函数中获取的类对象是继承自NSObject体系的，所以在这些类上调用方法是，都应该先检测一下这个方法是否在这个类中实现<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int numClasses;</span><br><span class="line">Class <span class="built_in">*</span> classes = NULL;</span><br><span class="line"></span><br><span class="line">numClasses = objc_getClassList<span class="params">(NULL, <span class="number">0</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> <span class="params">(numClasses &gt; <span class="number">0</span>)</span> &#123;</span><br><span class="line">    classes = malloc<span class="params">(sizeof<span class="params">(Class)</span> * numClasses)</span>;</span><br><span class="line">    numClasses = objc_getClassList<span class="params">(classes, numClasses)</span>;</span><br><span class="line"></span><br><span class="line">    NSLog<span class="params">(@<span class="string">"number of classes: %d"</span>, numClasses)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="params">(int i = <span class="number">0</span>; i &lt; numClasses; i++)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Class cls = classes[i];</span><br><span class="line">        NSLog<span class="params">(@<span class="string">"class name: %s"</span>, class_getName<span class="params">(cls)</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    free<span class="params">(classes)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下：<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2014-10-23</span> <span class="number">16:20:52.58</span>9 RuntimeTest[<span class="number">8437:188589</span>] number of classes: 1282</span><br><span class="line"><span class="number">2014-10-23</span> <span class="number">16:20:52.58</span>9 RuntimeTest[<span class="number">8437:188589</span>] class name: DDTokenRegexp</span><br><span class="line"><span class="number">2014-10-23</span> <span class="number">16:20:52.59</span>0 RuntimeTest[<span class="number">8437:188589</span>] class name: _NSMostCommonKoreanCharsKeySet</span><br><span class="line"><span class="number">2014-10-23</span> <span class="number">16:20:52.59</span>0 RuntimeTest[<span class="number">8437:188589</span>] class name: OS_xpc_dictionary</span><br><span class="line"><span class="number">2014-10-23</span> <span class="number">16:20:52.59</span>0 RuntimeTest[<span class="number">8437:188589</span>] class name: NSFileCoordinator</span><br><span class="line"><span class="number">2014-10-23</span> <span class="number">16:20:52.59</span>0 RuntimeTest[<span class="number">8437:188589</span>] class name: NSAssertionHandler</span><br><span class="line"><span class="number">2014-10-23</span> <span class="number">16:20:52.59</span>0 RuntimeTest[<span class="number">8437:188589</span>] class name: PFUbiquityTransactionLogMigrator</span><br><span class="line"><span class="number">2014-10-23</span> <span class="number">16:20:52.59</span>1 RuntimeTest[<span class="number">8437:188589</span>] class name: NSNotification</span><br><span class="line"><span class="number">2014-10-23</span> <span class="number">16:20:52.59</span>1 RuntimeTest[<span class="number">8437:188589</span>] class name: NSKeyValueNilSetEnumerator</span><br><span class="line"><span class="number">2014-10-23</span> <span class="number">16:20:52.59</span>1 RuntimeTest[<span class="number">8437:188589</span>] class name: OS_tcp_connection_tls_session</span><br><span class="line"><span class="number">2014-10-23</span> <span class="number">16:20:52.59</span>1 RuntimeTest[<span class="number">8437:188589</span>] class name: _PFRoutines</span><br><span class="line">......还有大量输出</span><br></pre></td></tr></table></figure></p>
<ul>
<li>获取类定义的方法有三个：objc_lookUpClass, objc_getClass和objc_getRequiredClass。如果类在运行时未注册，则objc_lookUpClass会返回nil，而objc_getClass会调用类处理回调，并再次确认类是否注册，如果确认未注册，再返回nil。而objc_getRequiredClass函数的操作与objc_getClass相同，只不过如果没有找到类，则会杀死进程。</li>
<li>objc_getMetaClass函数：如果指定的类没有注册，则该函数会调用类处理回调，并再次确认类是否注册，如果确认未注册，再返回nil。不过，每个类定义都必须有一个有效的元类定义，所以这个函数总是会返回一个元类定义，不管它是否有效。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="iOS_Runtime运行时类与对象的编译处理">iOS Runtime运行时类与对象的编译处理</h2><p>Objective-C语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。这种动态语言的优势在于：我们写代码时更具灵活性，如我们可以把消息转发给我们想要的对象，或者随意交换一个方法的实现等。<br>这种特性意味着<code>Objective-C</code>不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。对于Objective-C来说，这个运行时系统就像一个操作系统一样：它让所有的工作可以正常的运行。这个运行时系统即Objc Runtime。Objc Runtime其实是一个Runtime库，它基本上是用C和汇编写的，这个库使得C语言有了面向对象的能力。</p>
<p>Runtime库主要做下面几件事：</p>
<ol>
<li>封装：在这个库中，对象可以用C语言中的结构体表示，而方法可以用C函数来实现，另外再加上了一些额外的特性。这些结构体和函数被runtime函数封装后，我们就可以在程序运行时创建，检查，修改类、对象和它们的方法了。</li>
<li>找出方法的最终执行代码：当程序执行[object doSomething]时，会向消息接收者(object)发送一条消息(doSomething)，runtime会根据消息接收者是否能响应该消息而做出不同的反应。这将在后面详细介绍。</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Objective-C runtime目前有两个版本：Modern runtime和Legacy runtime。Modern Runtime 覆盖了64位的Mac OS X Apps，还有 iOS Apps，Legacy Runtime 是早期用来给32位 Mac OS X Apps 用的，也就是可以不用管就是了。<br>在这一系列文章中，我们将介绍runtime的基本工作原理，以及如何利用它让我们的程序变得更加灵活。在本文中，我们先来介绍一下类与对象，这是面向对象的基础，我们看看在Runtime中，类是如何实现的。<br>]]>
    
    </summary>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS Event Delivery/ The Responder Chain]]></title>
    <link href="http://ytlvy.com/2015/07/13/iOS-Event-Delivery-The-Responder-Chain/"/>
    <id>http://ytlvy.com/2015/07/13/iOS-Event-Delivery-The-Responder-Chain/</id>
    <published>2015-07-13T13:24:22.000Z</published>
    <updated>2015-07-13T14:03:27.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Event_Delivery:_The_Responder_Chain">Event Delivery: The Responder Chain</h2><p>当你设计应用的时候, 应用需要动态响应事件. 例如: 点击事件, (可以在显示屏上的不同对象上多次触发), 你需要决定那个对象来响应此事件, 并且需要了解这个对象是如何接收事件的.</p>
<p>当用户触发一个事件时, UIKit 创建一个<code>event object</code>, 此对象包含了需要处理的信息. 然后将此事件对象放入到当前 app 的事件队列中. 例如<code>touch</code>事件, 这种事件对象就是一个包含了一组<code>touch</code>的<code>UIEvent</code> 对象. <code>motion</code>事件, 此对象由你使用的<code>framework</code>和你感兴趣的<code>motion</code>类型来决定.</p>
<ul>
<li>Touch events. 当前 window 对象首先尝试将事件传送给 <code>touch</code> 触发的视图.这个视图被称为<code>hit-test</code> 视图. 寻找<code>hit-test</code>视图的过程被称为<code>hit-testing</code>, 将在下面描述.</li>
<li>Motion and remote control events. 对于这些事件, 当前 window 对象会将 <code>shaking-motion</code> 或 <code>emote control event</code> 发送给<code>first responder</code>来响应.<code>first responder</code>也将在下面描述.</li>
</ul>
<h3 id="Hit-Testing_Returns_the_View_Where_a_Touch_Occurred">Hit-Testing Returns the View Where a Touch Occurred</h3><p>iOS 通过<code>hit-testing</code> 来寻找点击下方的视图. <code>Hit-Testing</code> 会查找任何包含该<code>touch</code>点坐标的视图对象, 规则为此坐标位于视图的<code>bounds</code>中, 如果包含, 会继续递归检测此视图的所有子视图. 在视图树中包含该点击的最下层视图, 即是<code>hit-test</code>视图. 当 iOS 决定了 <code>hit-test</code> 视图后, 会将点击事件发送给此视图来处理.</p>
<p>说明如下, 假设用户点击了视图 E, iOS 查找<code>hit-test</code> 视图的逻辑如下:</p>
<ol>
<li>点击在视图 A 的范围内, 然后检测 子视图 B 和 C</li>
<li>点击不再视图 B 范围内, 但是在视图 C 范围内, 继续检测 子视图 D 和 E</li>
<li>点击不再视图 D 里, 但是在视图 E 中.<a id="more"></a>
视图 E 是最下层且包含 <code>touch</code>的视图树, 所以就是<code>hit-test</code></li>
</ol>
<p><img src="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/hit_testing_2x.png" alt=""></p>
<p><code>hitTest:withEvent:</code> 方法接受参数<code>CGPoint</code> 和 <code>UIEvent</code>, 返回<code>hit-test</code> 视图. <code>hitTest:withEvent:</code>方法首先<code>调用</code>在调用者自身使用<code>pointInside:withEvent:</code> 方法. 如果传入的参数<code>point</code> 包含在视图的<code>bounds</code>中, 返回 YES , 然后继续递归调用所有子视图.</p>
<p>如果传入的参数点位置不在当前视图的范围内, 第一次调用<code>pointInside:withEvent:</code>返回 NO. 然后该点将被忽略, 然后<code>hitTest:withEvent:</code>将返回<code>nil</code>. 如意一个子视图返回 NO, 之后的视图树将被忽略, 因为该点如果不再这个子视图, 也必将不会在子视图的子视图. 这意味着<em>任何</em>超出父视图范围的子视图内的所有点, 将不能接受到<code>touch</code>事件,  因为点击的位置要同时位于父视图和子视图中. 在子视图的<code>clipsToBounds</code> 属性被设置为 NO, 可能发生.</p>
<blockquote>
<p>即使点击之后超出了<code>hit-test</code>视图,  该点击对象还会和对应的<code>hit-test</code>视图一直绑定, 直到该点击结束.</p>
</blockquote>
<p><code>hit-test</code>视图拥有优先响应处理该点击事件的权利, 如果该视图不能处理, 则事件将向上沿着这个视图的反应链查找, 直到找到能处理为止.</p>
<p>下面是<a href="http://stackoverflow.com/questions/4961386/event-handling-for-ios-how-hittestwithevent-and-pointinsidewithevent-are-r" target="_blank" rel="external">stackoverflow</a>的相关举例</p>
<h4 id="例子1">例子1</h4><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+--------------------------------------------+</span><br><span class="line">|<span class="string">A                                                      </span>|</span><br><span class="line">|<span class="string"> +--------- +          +-----------------+   </span>|</span><br><span class="line">|<span class="string"> </span>|<span class="string"> B           </span>|<span class="string">          </span>|<span class="string">   C                  </span>|<span class="string">   </span>|</span><br><span class="line">|<span class="string"> </span>|<span class="string">              </span>|<span class="string">           </span>|<span class="string">  +----------+    </span>|<span class="string">    </span>|<span class="string">  </span><br><span class="line"></span>|<span class="string"> +--------- +          </span>|<span class="string">   </span>|<span class="string">  D         </span>|<span class="string">     </span>|<span class="string">   </span>|</span><br><span class="line">|<span class="string">                            </span>|<span class="string">   </span>|<span class="string">+---------+   </span>|<span class="string">    </span>|</span><br><span class="line">|<span class="string">                           +------------------+   </span>|</span><br><span class="line">+--------------------------------------------+</span><br></pre></td></tr></table></figure>
<p>Say you put your finger inside D. Here’s what will happen:</p>
<ol>
<li><p><code>hitTest:withEvent:</code> is called on <code>A</code>, the top-most view of the view hierarchy.</p>
</li>
<li><p><code>pointInside:withEvent:</code> is called recursively on each view.</p>
<ol>
<li>1 <code>pointInside:withEvent:</code>  is called on <code>A</code>, and returns <code>YES</code><br>2.2 <code>pointInside:withEvent:</code>is called on <code>B</code>, and returns <code>NO</code><br>2.3 <code>pointInside:withEvent: i</code>s called on <code>C</code>, and returns <code>YES</code><br>2.4 <code>pointInside:withEvent:</code>is called on <code>D</code>, and returns <code>YES</code></li>
</ol>
</li>
<li><p>On the views that returned <code>YES</code>, it will look down on the hierarchy to see the subview where the touch took place. In this case, from A, C and D, it will be D.</p>
</li>
<li><p>D will be the hit-test view</p>
</li>
</ol>
<h4 id="例子2">例子2</h4><p>+——————————————+<br>|A +————+                  |<br>|  |B    +———————+    |<br>|  |       |C            X  |    |<br>|  |      +———————-+   |<br>|  |            |                    |<br>|  +————+                   |<br>|                                    |<br>+——————————————+</p>
<p>Assume X - user’s touch. pointInside:withEvent: on B returns NO, so hitTest:withEvent: returns A. I wrote category on UIView to handle issue when you need to receive touch on top most visible view.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIView</span> *)overlapHitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span><span class="variable">.userInteractionEnabled</span> || [<span class="keyword">self</span> isHidden] || <span class="keyword">self</span><span class="variable">.alpha</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">UIView</span> *hitView = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> pointInside:point withEvent:event]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.clipsToBounds</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">else</span> hitView = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UIView</span> *subview <span class="keyword">in</span> [<span class="keyword">self</span><span class="variable">.subviewsreverseObjectEnumerator</span>]) &#123;</span><br><span class="line">        <span class="built_in">CGPoint</span> insideSubview = [<span class="keyword">self</span> convertPoint:point toView:subview];</span><br><span class="line">        <span class="built_in">UIView</span> *sview = [subview overlapHitTest:insideSubview withEvent:event];</span><br><span class="line">        <span class="keyword">if</span> (sview) <span class="keyword">return</span> sview;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">return</span> hitView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>We should not send touch events for hidden or transparent views, or views with userInteractionEnabled set to NO;</li>
<li>If touch is inside self, self will be considered as potential result.</li>
<li>Check recursively all subviews for hit. If any, return it.</li>
<li>Else return self or nil depending on result from step 2.</li>
</ol>
<p>Note, <code>[self.subviewsreverseObjectEnumerator]</code>needed to follow view hierarchy from top most to bottom. And check for <code>clipsToBounds</code> to ensure not to test masked subviews.</p>
<p>Usage:</p>
<ol>
<li>Import category in your subclassed view.</li>
<li>Replace hitTest:withEvent: with this<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (UIView *)<span class="string">hitTest:</span>(CGPoint)point <span class="string">withEvent:</span>(UIEvent *)event &#123;</span><br><span class="line">    <span class="keyword">return</span> [self <span class="string">overlapHitTest:</span>point <span class="string">withEvent:</span>event];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="The_Responder_Chain_Is_Made_Up_of_Responder_Objects">The Responder Chain Is Made Up of Responder Objects</h3><p>Many types of events rely on a responder chain for event delivery. The responder chain is a series of linked responder objects. It starts with the first responder and <strong><em>ends with the application object</em></strong>. If the first responder cannot handle an event, it forwards the event to the next responder in the responder chain.</p>
<p>A responder object is an object that can respond to and handle events. The <code>UIResponder</code> class is the base class for all responder objects, and it defines the programmatic interface not only for event handling but also for common responder behavior. Instances of the <code>UIApplication</code>, <code>UIViewController</code>, and <code>UIView</code> classes are responders, which means that all views and most key controller objects are responders. Note that <strong><em>Core Animation layers are not responders</em></strong>.</p>
<p>The first responder is designated to receive events first. Typically, the first responder is a view object. An object becomes the first responder by doing two things:</p>
<ol>
<li>Overriding the <code>canBecomeFirstResponder</code> method to return YES.</li>
<li>Receiving a <code>becomeFirstResponder</code> message. If necessary, an object can send itself this message.</li>
</ol>
<blockquote>
<p>Note: Make sure that your app has established its object graph before assigning an object to be the first responder. For example, you typically call the <code>becomeFirstResponder</code> method in an override of the <code>viewDidAppear:</code>method. If you try to assign the first responder in viewWillAppear:, your object graph is not yet established, so the <code>becomeFirstResponder</code> method returns NO.</p>
</blockquote>
<p>Events are not the only objects that rely on the responder chain. The responder chain is used in all of the following:</p>
<ul>
<li><p>Touch events. If the hit-test view cannot handle a touch event, the event is passed up a chain of responders that starts with the hit-test view.</p>
</li>
<li><p>Motion events. To handle shake-motion events with UIKit, the first responder must implement either the motionBegan:withEvent: or motionEnded:withEvent: method of the UIResponder class, as described in Detecting Shake-Motion Events with UIEvent.</p>
</li>
<li><p>Remote control events. To handle remote control events, the first responder must implement the remoteControlReceivedWithEvent: method of the UIResponder class.</p>
</li>
<li><p>Action messages. When the user manipulates a control, such as a button or switch, and the target for the action method is nil, the message is sent through a chain of responders starting with the control view.</p>
</li>
<li><p>Editing-menu messages. When a user taps the commands of the editing menu, iOS uses a responder chain to find an object that implements the necessary methods (such as cut:, copy:, and paste:). For more information, see Displaying and Managing the Edit Menu and the sample code project, CopyPasteTile.</p>
</li>
<li><p>Text editing. When a user taps a text field or a text view, that view automatically becomes the first responder. By default, the virtual keyboard appears and the text field or text view becomes the focus of editing. You can display a custom input view instead of the keyboard if it’s appropriate for your app. You can also add a custom input view to any responder object. For more information, see Custom Views for Data Input.<br>UIKit automatically sets the text field or text view that a user taps to be the first responder; Apps must explicitly set all other first responder objects with the becomeFirstResponder method.</p>
</li>
</ul>
<p>UIKit automatically sets the text field or text view that a user taps to be the first responder; Apps must explicitly set all other first responder objects with the becomeFirstResponder method.</p>
<h3 id="The_Responder_Chain_Follows_a_Specific_Delivery_Path">The Responder Chain Follows a Specific Delivery Path</h3><p>If the initial object—either the hit-test view or the first responder—doesn’t handle an event, UIKit passes the event to the next responder in the chain. Each responder decides whether it wants to handle the event or pass it along to its own next responder by calling the nextResponder method.This process continues until a responder object either handles the event or there are no more responders.</p>
<p>The responder chain sequence begins when iOS detects an event and passes it to an initial object, which is typically a view. The initial view has the first opportunity to handle an event. Figure 2-2 shows two different event delivery paths for two app configurations. An app’s event delivery path depends on its specific construction, but all event delivery paths adhere to the same heuristics.<br><img src="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/iOS_responder_chain_2x.png" alt=""></p>
<p>For the app on the left, the event follows this path:</p>
<ol>
<li><p>The initial view attempts to handle the event or message. If it can’t handle the event, it passes the event to its superview, because the initial view is not the top most view in its view controller’s view hierarchy.</p>
</li>
<li><p>The superview attempts to handle the event. If the superview can’t handle the event, it passes the event to its superview, because it is still not the top most view in the view hierarchy.</p>
</li>
<li><p>The topmost view in the view controller’s view hierarchy attempts to handle the event. If the topmost view can’t handle the event, it passes the event to its view controller.</p>
</li>
<li><p>The view controller attempts to handle the event, and if it can’t, passes the event to the window.</p>
</li>
<li><p>If the window object can’t handle the event, it passes the event to the singleton app object.</p>
</li>
<li><p>If the app object can’t handle the event, it discards the event.</p>
</li>
</ol>
<p>The app on the right follows a slightly different path, but all event delivery paths follow these heuristics:</p>
<ol>
<li><p>A view passes an event up its view controller’s view hierarchy until it reaches the topmost view.</p>
</li>
<li><p>The topmost view passes the event to its view controller.</p>
</li>
<li><p>The view controller passes the event to its topmost view’s superview.<br>Steps 1-3 repeat until the event reaches the root view controller.</p>
</li>
<li><p>The root view controller passes the event to the window object.</p>
</li>
<li><p>The window passes the event to the app object.</p>
</li>
</ol>
<blockquote>
<p>Important: If you implement a custom view to handle remote control events, action messages, shake-motion events with UIKit, or editing-menu messages, don’t forward the event or message to nextResponder directly to send it up the responder chain. Instead, invoke the superclass implementation of the current event handling method and let UIKit handle the traversal of the responder chain for you.</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Event_Delivery:_The_Responder_Chain">Event Delivery: The Responder Chain</h2><p>当你设计应用的时候, 应用需要动态响应事件. 例如: 点击事件, (可以在显示屏上的不同对象上多次触发), 你需要决定那个对象来响应此事件, 并且需要了解这个对象是如何接收事件的.</p>
<p>当用户触发一个事件时, UIKit 创建一个<code>event object</code>, 此对象包含了需要处理的信息. 然后将此事件对象放入到当前 app 的事件队列中. 例如<code>touch</code>事件, 这种事件对象就是一个包含了一组<code>touch</code>的<code>UIEvent</code> 对象. <code>motion</code>事件, 此对象由你使用的<code>framework</code>和你感兴趣的<code>motion</code>类型来决定.</p>
<ul>
<li>Touch events. 当前 window 对象首先尝试将事件传送给 <code>touch</code> 触发的视图.这个视图被称为<code>hit-test</code> 视图. 寻找<code>hit-test</code>视图的过程被称为<code>hit-testing</code>, 将在下面描述.</li>
<li>Motion and remote control events. 对于这些事件, 当前 window 对象会将 <code>shaking-motion</code> 或 <code>emote control event</code> 发送给<code>first responder</code>来响应.<code>first responder</code>也将在下面描述.</li>
</ul>
<h3 id="Hit-Testing_Returns_the_View_Where_a_Touch_Occurred">Hit-Testing Returns the View Where a Touch Occurred</h3><p>iOS 通过<code>hit-testing</code> 来寻找点击下方的视图. <code>Hit-Testing</code> 会查找任何包含该<code>touch</code>点坐标的视图对象, 规则为此坐标位于视图的<code>bounds</code>中, 如果包含, 会继续递归检测此视图的所有子视图. 在视图树中包含该点击的最下层视图, 即是<code>hit-test</code>视图. 当 iOS 决定了 <code>hit-test</code> 视图后, 会将点击事件发送给此视图来处理.</p>
<p>说明如下, 假设用户点击了视图 E, iOS 查找<code>hit-test</code> 视图的逻辑如下:</p>
<ol>
<li>点击在视图 A 的范围内, 然后检测 子视图 B 和 C</li>
<li>点击不再视图 B 范围内, 但是在视图 C 范围内, 继续检测 子视图 D 和 E</li>
<li>点击不再视图 D 里, 但是在视图 E 中.]]>
    
    </summary>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS Runtime 成员变量与属性]]></title>
    <link href="http://ytlvy.com/2015/07/13/iOS-Runtime-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%9E%E6%80%A7/"/>
    <id>http://ytlvy.com/2015/07/13/iOS-Runtime-成员变量与属性/</id>
    <published>2015-07-13T13:20:33.000Z</published>
    <updated>2015-07-13T14:03:07.000Z</updated>
    <content type="html"><![CDATA[<h3 id="习题内容">习题内容</h3><p>下面代码会? Compile Error / Runtime Crash / NSLog…?<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Sark</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Sark</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)speak &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"my name is %@"</span>, <span class="keyword">self</span><span class="variable">.name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Test</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Test</span></span></span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">id</span> cls = [Sark class];</span><br><span class="line">        <span class="keyword">void</span> *obj = &amp;cls;</span><br><span class="line">        [(__bridge <span class="keyword">id</span>)obj speak];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [[Test alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>答案：代码正常输出，输出结果为：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2014<span class="tag">-11-07</span> 14<span class="pseudo">:08</span><span class="pseudo">:25</span><span class="class">.698</span> <span class="tag">Test</span><span class="attr_selector">[1097:57255]</span> <span class="tag">my</span> <span class="tag">name</span> <span class="tag">is</span> &lt;<span class="rule"><span class="attribute">Test</span>:<span class="value"> <span class="number">0</span>x1001002d0&gt;</span></span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="为什么呢?">为什么呢?</h3><p>前几节博文中多次讲到了<code>objc_class</code>结构体，今天我们再拿出来看一下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_<span class="built_in">AVAILABILITY</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#if !__OBJC2__</span></span><br><span class="line">    Class super_class                                        OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                                         OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">long</span> version                                             OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">long</span> info                                                OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars                             OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists                    OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache                                 OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br></pre></td></tr></table></figure>
<p>其中<code>objc_ivar_list</code>结构体存储着<code>objc_ivar</code>数组列表，而<code>objc_ivar</code>结构体存储了类的单个成员变量的信息。</p>
<p>那么什么是Ivar呢？</p>
<p>Ivar 在objc中被定义为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_ivar *Ivar;</span><br></pre></td></tr></table></figure>
<p>它是一个指向objc_ivar结构体的指针，结构体有如下定义：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_ivar &#123;</span><br><span class="line">    <span class="keyword">char</span> *ivar_name                                          OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">char</span> *ivar_type                                          OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">int</span> ivar_offset                                          OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"><span class="preprocessor">#ifdef __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                                                OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">&#125;                                                            OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br></pre></td></tr></table></figure></p>
<p>这里我们注意第三个成员 <code>ivar_offset</code>。它表示基地址偏移字节。</p>
<p>在编译我们的类时，编译器生成了一个<code>ivar</code>布局，显示了在类中从哪可以访问我们的 ivars 。看下图:</p>
<p><img src="http://106.186.113.24:8888/other/2014031602.png" alt=""></p>
<p>上图中，左侧的数据就是地址偏移字节，我们对 ivar 的访问就可以通过 <code>对象地址 ＋ ivar偏移字节</code>的方法。但是这又引发一个问题，看下图:</p>
<p><img src="http://106.186.113.24:8888/other/2014031603.png" alt=""></p>
<p>我们增加了父类的ivar，这个时候布局就出错了，我们就不得不重新编译子类来恢复兼容性。</p>
<p>而Objective－C Runtime中使用了<code>Non Fragile ivars</code>，看下图:</p>
<p><img src="http://106.186.113.24:8888/other/2014031604.png" alt=""></p>
<p>使用<code>Non Fragile ivars</code>时，Runtime会进行检测来调整类中新增的ivar的偏移量。 这样我们就可以通过 <code>对象地址 + ivar偏移字节</code>的方法来计算出ivar相应的地址，并访问到相应的ivar。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@private</span></span><br><span class="line">    <span class="built_in">NSInteger</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line">- (<span class="built_in">NSString</span> *)description</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"age = %d"</span>, age];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Student *student = [[Student alloc] init];</span><br><span class="line">        student-&gt;age = <span class="number">24</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码，Student有两个被标记为private的ivar，这个时候当我们使用 -&gt; 访问时，编译器会报错。那么我们如何设置一个被标记为private的ivar的值呢?</p>
<p>通过上面的描述，我们知道ivar是通过计算字节偏量来确定地址，并访问的。我们可以改成这样:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">NSObject</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">@private</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)description &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"current pointer = %p"</span>, <span class="keyword">self</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"age pointer = %p"</span>, &amp;age);</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"age = %d"</span>, age];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Student *student = [[Student alloc] init];</span><br><span class="line">        Ivar age_ivar = class_getInstanceVariable(object_getClass(student), <span class="string">"age"</span>);</span><br><span class="line">        <span class="keyword">int</span> *age_pointer = (<span class="keyword">int</span> *)((__bridge <span class="keyword">void</span> *)(student) + ivar_getOffset(age_ivar));</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"age ivar offset = %td"</span>, ivar_getOffset(age_ivar));</span><br><span class="line">        *age_pointer = <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, student);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码的输出结果为:</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2014-11-08</span> <span class="number">18:24:38.89</span>2 Test[<span class="number">4143:46686</span>4] age ivar offset = 8</span><br><span class="line"><span class="number">2014-11-08</span> <span class="number">18:24:38.89</span>3 Test[<span class="number">4143:46686</span>4] current pointer = <span class="number">0x1001002</span>d0</span><br><span class="line"><span class="number">2014-11-08</span> <span class="number">18:24:38.89</span>3 Test[<span class="number">4143:46686</span>4] age pointer = <span class="number">0x1001002</span>d8</span><br><span class="line"><span class="number">2014-11-08</span> <span class="number">18:24:38.89</span>4 Test[<span class="number">4143:46686</span>4] age = 10</span><br></pre></td></tr></table></figure>
<p>我们可以清晰的看到指针地址的变化和偏移量，和我们上述描述一致</p>
<h3 id="说完了Ivar，_那Property又是怎么样的呢？">说完了Ivar， 那Property又是怎么样的呢？</h3><p>使用 <code>clang -rewrite-objc main.m</code> 重写题目中的代码，我们发现<code>Sark</code>类中的<code>name</code>属性被转换成了如下代码:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Sark_I<span class="built_in">MPL</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="built_in">NSObject_IMPL</span> <span class="built_in">NSObject_IVARS</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @property (nonatomic, copy) NSString *name;</span></span><br><span class="line"><span class="comment">/* @end */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// @implementation Sark</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * _I_Sark_name(Sark * <span class="keyword">self</span>, SEL _cmd) &#123; <span class="keyword">return</span> (*(<span class="built_in">NSString</span> **)((<span class="keyword">char</span> *)<span class="keyword">self</span> + OBJC_IVAR_$_Sark$_name)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_Sark_setName_(Sark * <span class="keyword">self</span>, SEL _cmd, <span class="built_in">NSString</span> *name) &#123; objc_setProperty (<span class="keyword">self</span>, _cmd, __OFFSETOFIVAR__(<span class="keyword">struct</span> Sark, _name), (<span class="keyword">id</span>)name, <span class="number">0</span>, <span class="number">1</span>); &#125;</span><br></pre></td></tr></table></figure></p>
<p>类中的 <code>Property</code> 属性被编译器转换成了<code>Ivar</code>，并且自动添加了我们熟悉的<code>Set</code>和<code>Get</code>方法。</p>
<p>我们这个时候回头看一下<code>objc_class</code>结构体中的内容，并没有发现用来专门记录<code>Property</code>的list。我们翻开objc源代码，在<code>objc-runtime-new.h</code>中，发现最终还是会通过在<code>class_ro_t</code>结构体中使用property_list_t存储对应的propertyies。</p>
<p>而在刚刚重写的代码中，我们可以找到这个<code>property_list_t</code>:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> <span class="comment">/*_prop_list_t*/</span> &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _prop_t)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count_of_properties;</span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">_prop_t</span> prop_list[<span class="number">1</span>];</span><br><span class="line">    &#125; _OBJC_$_PROP_LIST_Sark __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = &#123;</span><br><span class="line">        <span class="keyword">sizeof</span>(<span class="keyword">_prop_t</span>),</span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        name</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> <span class="keyword">_class_ro_t</span> _OBJC_CLASS_RO_$_Sark __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = &#123;</span><br><span class="line">    <span class="number">0</span>, __OFFSETOFIVAR__(<span class="keyword">struct</span> Sark, _name), <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Sark_IMPL), </span><br><span class="line">    (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">0</span>, </span><br><span class="line">    <span class="number">0</span>, </span><br><span class="line">    <span class="string">"Sark"</span>,</span><br><span class="line">    (<span class="keyword">const</span> <span class="keyword">struct</span> <span class="keyword">_method_list_t</span> *)&amp;_OBJC_$_INSTANCE_METHODS_Sark,</span><br><span class="line">    <span class="number">0</span>, </span><br><span class="line">    (<span class="keyword">const</span> <span class="keyword">struct</span> <span class="keyword">_ivar_list_t</span> *)&amp;_OBJC_$_INSTANCE_VARIABLES_Sark,</span><br><span class="line">    <span class="number">0</span>, </span><br><span class="line">    (<span class="keyword">const</span> <span class="keyword">struct</span> <span class="keyword">_prop_list_t</span> *)&amp;_OBJC_$_PROP_LIST_Sark,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="解惑">解惑</h3><p>1）为什么能够正常运行，并调用到<code>speak</code>方法？<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="property">id</span> cls = [Sark <span class="type">class</span>];</span><br><span class="line">void *obj = &amp;cls;</span><br><span class="line">[(__bridge <span class="property">id</span>)obj speak];</span><br></pre></td></tr></table></figure></p>
<p>obj被转换成了一个指向<code>cls</code>的指针，而 <code>cls</code> 又指向<code>[Sark Class]</code>, 此时<code>cls</code> 起到了类似<code>isa</code> 指针的作用, 因为<code>isa</code>也是指向一个类. 之后当<code>obj</code>被强制转换为<code>objc_object</code>类型时, <code>obj</code>就被当做了一个<code>[Sark Class]</code>的对象, 但是此对象和实际的对象是有差别的, 实际的对象时分配在堆上的, 而这个变量是临时变量, 本身分配在栈上, 强制转换后, 也同样还在栈上. 同时此对象除了有<code>isa</code> 指针相对应的类能提供的特性外, 其他的一切都是假的.</p>
<p>也正因为<code>obj</code> 此时被强制转换为<code>[Sark Class]</code>, 所以它可以调用<code>speak</code>方法.</p>
<p>2) 为什么self.name的输出为 <test: 0x1001002d0=""> ?<br>在<code>speak</code>方法中, 关于<code>self.name</code>的调用, 由上面的<code>ivar</code> 的获取方法<code>对象地址 + ivar偏移字节</code>,  可以推导出此时 self.name的调用地址为 <code>obj</code>指向对象的地址 + 偏移8(64位系统)而得出.  </test:></p>
<p><code>obj</code>指向的对象地址, 由上面的代码<code>void *obj = &amp;cls;</code> 可知, 是<code>cls</code>变量的地址, 而此局部变量是分配在栈上的. 同时所有的局部变量是按照出现顺序从高到底一个个入栈的.可以参考<a href="/2015/07/06/progress-memory-map/">这篇文章</a>. 而 <code>cls</code> 变量地址+8是 <code>cls</code>局部变量上一个局部变量.</p>
<p>具体的情况,我们在下面来分析</p>
<p>我们在测试代码中加入一些调试代码和Log如下:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)speak</span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> numberOfIvars = <span class="number">0</span>;</span><br><span class="line">    Ivar *ivars = class_copyIvarList([<span class="keyword">self</span> class], &amp;numberOfIvars);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> Ivar *p = ivars; p &lt; ivars+numberOfIvars; p++) &#123;</span><br><span class="line">        Ivar <span class="keyword">const</span> ivar = *p;</span><br><span class="line">        ptrdiff_t offset = ivar_getOffset(ivar);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name = ivar_getName(ivar);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Sark ivar name = %s, offset = %td"</span>, name, offset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"_name变量 本身的地址 %p"</span>, &amp;_name);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"_name变量 指向地址 %p"</span>, _name);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"_name 变量指向对象的内容 %@"</span>, _name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Test</span></span></span><br><span class="line"></span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"================================="</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"self变量 指向对象的地址 = %p ========"</span>, <span class="keyword">self</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"self变量 本身的地址 = %p"</span>, &amp;<span class="keyword">self</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"================================="</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"select address %p"</span>, <span class="keyword">@selector</span>(initWithAttribute:));</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"_cmd address %p"</span>, _cmd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">id</span> cls = [Sark class];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"cls变量 指向的地址 = %p"</span>, cls);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"cls变量 本身地址 = %p"</span>, &amp;cls);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"================================="</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">void</span> *obj = &amp;cls;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"obj变量 指向的虚假对象地址 = %@"</span>, obj);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"obj变量 本身地址 = %p"</span>, &amp;obj);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"================================="</span>);</span><br><span class="line"></span><br><span class="line">        [(__bridge <span class="keyword">id</span>)obj speak];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>输出结果如下:</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2015-07-13</span> <span class="number">20:24:31.48</span>5 iTest[<span class="number">13990:49503</span>5] =================================</span><br><span class="line"><span class="number">2015-07-13</span> <span class="number">20:24:31.48</span>7 iTest[<span class="number">13990:49503</span>5] self变量 指向对象的地址 = <span class="number">0x7f8d32</span>700050 ========</span><br><span class="line"><span class="number">2015-07-13</span> <span class="number">20:24:31.48</span>7 iTest[<span class="number">13990:49503</span>5] self变量 本身的地址 = 0x7fff5cb8f408</span><br><span class="line"><span class="number">2015-07-13</span> <span class="number">20:24:31.48</span>7 iTest[<span class="number">13990:49503</span>5] =================================</span><br><span class="line"><span class="number">2015-07-13</span> <span class="number">20:24:31.48</span>8 iTest[<span class="number">13990:49503</span>5] select address <span class="number">0x103071b4</span>e</span><br><span class="line"><span class="number">2015-07-13</span> <span class="number">20:24:31.48</span>8 iTest[<span class="number">13990:49503</span>5] _cmd address <span class="number">0x10603733</span>b</span><br><span class="line"><span class="number">2015-07-13</span> <span class="number">20:24:31.48</span>9 iTest[<span class="number">13990:49503</span>5] cls变量 指向的地址 = <span class="number">0x103075760</span></span><br><span class="line"><span class="number">2015-07-13</span> <span class="number">20:24:31.48</span>9 iTest[<span class="number">13990:49503</span>5] cls变量 本身地址 = 0x7fff5cb8f3e8</span><br><span class="line"><span class="number">2015-07-13</span> <span class="number">20:24:31.48</span>9 iTest[<span class="number">13990:49503</span>5] =================================</span><br><span class="line"><span class="number">2015-07-13</span> <span class="number">20:24:31.49</span>0 iTest[<span class="number">13990:49503</span>5] obj变量 指向的虚假对象地址 = &lt;Sark: 0x7fff5cb8f3e8&gt;</span><br><span class="line"><span class="number">2015-07-13</span> <span class="number">20:24:31.49</span>0 iTest[<span class="number">13990:49503</span>5] obj变量 本身地址 = 0x7fff5cb8f3e0</span><br><span class="line"><span class="number">2015-07-13</span> <span class="number">20:24:31.49</span>0 iTest[<span class="number">13990:49503</span>5] =================================</span><br><span class="line"><span class="number">2015-07-13</span> <span class="number">20:24:31.49</span>1 iTest[<span class="number">13990:49503</span>5] Sark ivar name = _name, offset = 8</span><br><span class="line"><span class="number">2015-07-13</span> <span class="number">20:24:31.49</span>1 iTest[<span class="number">13990:49503</span>5] _name变量 本身的地址 0x7fff5cb8f3f0</span><br><span class="line"><span class="number">2015-07-13</span> <span class="number">20:24:31.49</span>2 iTest[<span class="number">13990:49503</span>5] _name变量 指向地址 <span class="number">0x7f8d32</span>700050</span><br><span class="line"><span class="number">2015-07-13</span> <span class="number">20:24:31.49</span>2 iTest[<span class="number">13990:49503</span>5] _name 变量指向对象的内容 &lt;Test: <span class="number">0x7f8d32</span>700050&gt;</span><br></pre></td></tr></table></figure>
<p>由上面的分析可知 <code>_name</code>指针本身的地址为<code>0x7fff5cb8f3f0</code> 正好是指针<code>cls</code>本身地址<code>0x7fff5cb8f3e8</code> + <code>8</code>得到的。而此地址由Debug 输出可知为<code>&lt;Test: 0x7f8d32700050&gt;</code>. 但是我们发现<code>cls</code>的上一个变量是<code>self</code>, 而<code>self</code> 的地址确是<code>0x7fff5cb8f408</code>, 是<code>cls</code>地址+<code>32</code>.</p>
<p><img src="http://7jpswx.com1.z0.glb.clouddn.com/iOS%20Runtime%20成员变量与属性1.png" alt=""><br><img src="http://7jpswx.com1.z0.glb.clouddn.com/iOS%20Runtime%20成员变量与属性2.png" alt=""></p>
<p>通过在Xcode自带的内存浏览器中查看, 并通过 <code>LLDB</code> 打印输出3个多出的变量, 分别为 <code>Test对象指针地址</code>, <code>Test类</code>, <code>_cmd</code>. </p>
<h3 id="进一步分析">进一步分析</h3><p>将代码注释如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    self = [super init];</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    if (self) &#123;</span></span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    return self;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="constant">nil</span>;</span><br></pre></td></tr></table></figure></p>
<p>在<code>NSLog(@&quot;cls变量 本身地址 = %p&quot;, &amp;cls);</code>句下面断点, 输出如下:<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2015-07-13</span> <span class="number">20:43:05.37</span>7 iTest[<span class="number">14251:506168</span>] =================================</span><br><span class="line"><span class="number">2015-07-13</span> <span class="number">20:43:05.37</span>8 iTest[<span class="number">14251:506168</span>] self变量 指向对象的地址 = 0x7fda40f02c20 ========</span><br><span class="line"><span class="number">2015-07-13</span> <span class="number">20:43:05.37</span>8 iTest[<span class="number">14251:506168</span>] self变量 本身的地址 = 0x7fff<span class="number">5f003408</span></span><br><span class="line"><span class="number">2015-07-13</span> <span class="number">20:43:05.37</span>8 iTest[<span class="number">14251:506168</span>] =================================</span><br><span class="line"><span class="number">2015-07-13</span> <span class="number">20:43:05.37</span>9 iTest[<span class="number">14251:506168</span>] select address 0x100bfdb4e</span><br><span class="line"><span class="number">2015-07-13</span> <span class="number">20:43:05.37</span>9 iTest[<span class="number">14251:506168</span>] _cmd address 0x103bc333b</span><br><span class="line"><span class="number">2015-07-13</span> <span class="number">20:43:05.37</span>9 iTest[<span class="number">14251:506168</span>] cls变量 指向的地址 = <span class="number">0x100c01758</span></span><br><span class="line"><span class="number">2015-07-13</span> <span class="number">20:43:05.37</span>9 iTest[<span class="number">14251:506168</span>] cls变量 本身地址 = 0x7fff<span class="number">5f0033f8</span></span><br></pre></td></tr></table></figure></p>
<p>此时<code>cls</code> 和<code>self</code>相差 <code>0x7fff5f003408 - 0x7fff5f0033f8 = 16</code> 恰好为两个变量地址, 而我们由 runtime 调用知道, 每个方法都默认隐藏传入了两个变量<code>self</code> 和 <code>_cmd</code>. 从内存浏览器可以看出此时 <code>self</code>变量的上一个地址 <code>0x7fff5f003400</code>恰好为<code>0x103bc333b</code> 是<code>_ cmd</code>的地址. 而此时由于<code>self.name</code>指向了 <code>_cmd</code>的地址, 程序继续运行报错<code>EXC_BAD_ACCESS</code><br><img src="http://7jpswx.com1.z0.glb.clouddn.com/iOS%20Runtime%20成员变量与属性3.png" alt=""></p>
<p>由此可以推论出:<br>1) <code>_cmd</code> 为隐藏参数自动传入, </p>
<p>2)<code>Test类</code>和另外一个<code>Test对象指针地址</code> 应该是 <code>[super init]</code>语句产生的, 经过编译后, <code>objc_super</code>结构体正好包含两个变量分别为<code>(id)self</code>, <code>objc_getClass(&quot;Test&quot;)</code>.</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self = <span class="list">(<span class="list">(<span class="keyword">Test</span> <span class="variable">*(*</span>)</span><span class="list">(<span class="keyword">__rw_objc_super</span> <span class="variable">*, SEL, NSInteger))(void *</span>)</span>objc_msgSendSuper)</span><span class="list">(<span class="list">(<span class="keyword">__rw_objc_super</span>)</span>&#123; <span class="list">(<span class="keyword">id</span>)</span>self, <span class="list">(<span class="keyword">id</span>)</span>class_getSuperclass<span class="list">(<span class="keyword">objc_getClass</span><span class="list">(<span class="string">"Test"</span>)</span>)</span> &#125;, sel_registerName<span class="list">(<span class="string">"init"</span>)</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>看下图，可以清楚的展示整个计算的过程：</p>
<p><img src="http://7jpswx.com1.z0.glb.clouddn.com/iOS%20Runtime%20成员变量与属性.jpg" alt=""></p>
<p>我们可以做一个另外的实验，把<code>Test Class</code> 的<code>init</code>方法改为如下代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Father</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Father</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Test</span></span></span><br><span class="line"></span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"self变量 指向对象的地址 = %p ========"</span>, <span class="keyword">self</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"self变量 本身的地址 = %p"</span>, &amp;<span class="keyword">self</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"================================="</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSString</span> *ss = <span class="string">@"hello world"</span>;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"ss变量 指向对象的地址 = %p ========"</span>, ss);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"ss变量 本身的地址 = %p"</span>, &amp;ss);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"================================="</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">id</span> cls = [Sark class];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"cls变量 指向的地址 = %p"</span>, cls);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"cls变量 本身地址 = %p"</span>, &amp;cls);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"================================="</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">void</span> *obj = &amp;cls;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"obj变量 指向的虚假对象地址 = %@"</span>, obj);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"obj变量 本身地址 = %p"</span>, &amp;obj);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"================================="</span>);</span><br><span class="line"></span><br><span class="line">        [(__bridge <span class="keyword">id</span>)obj speak];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>你会发现这个时候的输出变成了:</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2015-07-13</span> <span class="number">14:16:23.28</span>1 iTest[<span class="number">11586:38183</span>0] self变量 指向对象的地址 = 0x7fa<span class="number">3325007b0</span> ========</span><br><span class="line"><span class="number">2015-07-13</span> <span class="number">14:16:23.28</span>3 iTest[<span class="number">11586:38183</span>0] self变量 本身的地址 = 0x7fff<span class="number">57c6e408</span></span><br><span class="line"><span class="number">2015-07-13</span> <span class="number">14:16:23.28</span>3 iTest[<span class="number">11586:38183</span>0] =================================</span><br><span class="line"><span class="number">2015-07-13</span> <span class="number">14:16:23.28</span>4 iTest[<span class="number">11586:38183</span>0] ss变量 指向对象的地址 = <span class="number">0x107f944</span>e0 ========</span><br><span class="line"><span class="number">2015-07-13</span> <span class="number">14:16:23.28</span>4 iTest[<span class="number">11586:38183</span>0] ss变量 本身的地址 = 0x7fff<span class="number">57c6e3e8</span></span><br><span class="line"><span class="number">2015-07-13</span> <span class="number">14:16:23.28</span>4 iTest[<span class="number">11586:38183</span>0] =================================</span><br><span class="line"><span class="number">2015-07-13</span> <span class="number">14:16:23.28</span>5 iTest[<span class="number">11586:38183</span>0] cls变量 指向的地址 = <span class="number">0x107f966</span>d8</span><br><span class="line"><span class="number">2015-07-13</span> <span class="number">14:16:23.28</span>5 iTest[<span class="number">11586:38183</span>0] cls变量 本身地址 = 0x7fff<span class="number">57c6e3e0</span></span><br><span class="line"><span class="number">2015-07-13</span> <span class="number">14:16:23.28</span>6 iTest[<span class="number">11586:38183</span>0] =================================</span><br><span class="line"><span class="number">2015-07-13</span> <span class="number">14:16:23.28</span>6 iTest[<span class="number">11586:38183</span>0] obj变量 指向的虚假对象地址 = &lt;Sark: 0x7fff<span class="number">57c6e3e0</span>&gt;</span><br><span class="line"><span class="number">2015-07-13</span> <span class="number">14:16:23.28</span>6 iTest[<span class="number">11586:38183</span>0] obj变量 本身地址 = 0x7fff<span class="number">57c6e3d8</span></span><br><span class="line"><span class="number">2015-07-13</span> <span class="number">14:16:23.28</span>7 iTest[<span class="number">11586:38183</span>0] =================================</span><br><span class="line"><span class="number">2015-07-13</span> <span class="number">14:16:23.28</span>7 iTest[<span class="number">11586:38183</span>0] Sark ivar name = _name, offset = 8</span><br><span class="line"><span class="number">2015-07-13</span> <span class="number">14:16:23.28</span>7 iTest[<span class="number">11586:38183</span>0] _name变量 本身的地址 0x7fff<span class="number">57c6e3e8</span></span><br><span class="line"><span class="number">2015-07-13</span> <span class="number">14:16:23.28</span>8 iTest[<span class="number">11586:38183</span>0] _name变量 指向地址 <span class="number">0x107f944</span>e0</span><br><span class="line"><span class="number">2015-07-13</span> <span class="number">14:16:23.28</span>8 iTest[<span class="number">11586:38183</span>0] _name 变量指向对象的内容 hello world</span><br></pre></td></tr></table></figure>
<h3 id="参考">参考</h3><p><a href="http://chun.tips/blog/2014/11/08/bao-gen-wen-di-objective%5Bnil%5Dc-runtime(4)%5Bnil%5D-cheng-yuan-bian-liang-yu-shu-xing/" target="_blank" rel="external">http://chun.tips/blog/2014/11/08/bao-gen-wen-di-objective%5Bnil%5Dc-runtime(4)%5Bnil%5D-cheng-yuan-bian-liang-yu-shu-xing/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="习题内容">习题内容</h3><p>下面代码会? Compile Error / Runtime Crash / NSLog…?<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Sark</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Sark</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)speak &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"my name is %@"</span>, <span class="keyword">self</span><span class="variable">.name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Test</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Test</span></span></span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">id</span> cls = [Sark class];</span><br><span class="line">        <span class="keyword">void</span> *obj = &amp;cls;</span><br><span class="line">        [(__bridge <span class="keyword">id</span>)obj speak];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [[Test alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>答案：代码正常输出，输出结果为：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2014<span class="tag">-11-07</span> 14<span class="pseudo">:08</span><span class="pseudo">:25</span><span class="class">.698</span> <span class="tag">Test</span><span class="attr_selector">[1097:57255]</span> <span class="tag">my</span> <span class="tag">name</span> <span class="tag">is</span> &lt;<span class="rule"><span class="attribute">Test</span>:<span class="value"> <span class="number">0</span>x1001002d0&gt;</span></span></span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS Runtime Message And Category]]></title>
    <link href="http://ytlvy.com/2015/07/13/iOS-Runtime-Message-And-Category/"/>
    <id>http://ytlvy.com/2015/07/13/iOS-Runtime-Message-And-Category/</id>
    <published>2015-07-13T13:20:02.000Z</published>
    <updated>2015-07-13T14:02:51.000Z</updated>
    <content type="html"><![CDATA[<h3 id="习题内容">习题内容</h3><p>下面的代码会？Compile Error / Runtime Crash / NSLog…?<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">Sark</span>)</span></span><br><span class="line">+ (<span class="keyword">void</span>)foo;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Sark</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)foo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"IMP: -[NSObject(Sark) foo]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [<span class="built_in">NSObject</span> foo];</span><br><span class="line">        [[<span class="built_in">NSObject</span> new] foo];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>答案：代码正常输出，输出结果如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2014<span class="tag">-11-06</span> 13<span class="pseudo">:11</span><span class="pseudo">:46</span><span class="class">.694</span> <span class="tag">Test</span><span class="attr_selector">[14872:1110786]</span> <span class="rule"><span class="attribute">IMP</span>:<span class="value"> -[<span class="function">NSObject</span>(Sark) foo]</span><br><span class="line"><span class="number">2014</span>-<span class="number">11</span>-<span class="number">06</span> <span class="number">13</span>:<span class="number">11</span>:<span class="number">46.695</span> Test[<span class="number">14872</span>:<span class="number">1110786</span>] IMP: -[<span class="function">NSObject</span>(Sark) foo]</span></span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>使用<code>clang -rewrite-objc main.m</code>重写，我们可以发现 main 函数中两个方法调用被转换成如下代码：<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="list">(<span class="keyword">void</span> <span class="list">(<span class="keyword"><span class="built_in">*</span></span>)</span><span class="list">(<span class="keyword">id</span>, SEL)</span>)</span><span class="list">(<span class="keyword">void</span> *)</span>objc_msgSend)</span><span class="list">(<span class="list">(<span class="keyword">id</span>)</span>objc_getClass<span class="list">(<span class="string">"NSObject"</span>)</span>, sel_registerName<span class="list">(<span class="string">"foo"</span>)</span>)</span><span class="comment">;</span></span><br><span class="line"> <span class="list">(<span class="list">(<span class="keyword">void</span> <span class="list">(<span class="keyword"><span class="built_in">*</span></span>)</span><span class="list">(<span class="keyword">id</span>, SEL)</span>)</span><span class="list">(<span class="keyword">void</span> *)</span>objc_msgSend)</span><span class="list">(<span class="list">(<span class="keyword">id</span>)</span><span class="list">(<span class="list">(<span class="keyword">NSObject</span> *<span class="list">(<span class="keyword"><span class="built_in">*</span></span>)</span><span class="list">(<span class="keyword">id</span>, SEL)</span>)</span><span class="list">(<span class="keyword">void</span> *)</span>objc_msgSend)</span><span class="list">(<span class="list">(<span class="keyword">id</span>)</span>objc_getClass<span class="list">(<span class="string">"NSObject"</span>)</span>, sel_registerName<span class="list">(<span class="string">"new"</span>)</span>)</span>, sel_registerName<span class="list">(<span class="string">"foo"</span>)</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>我们发现上述两个方法最终转换成使用 <code>objc_msgSend</code> 函数传递消息</p>
<h3 id="这里先看几个概念">这里先看几个概念</h3><p><code>objc_msgSend</code>函数定义如下:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_msgSend(<span class="keyword">id</span> <span class="keyword">self</span>, SEL op, ...)</span><br></pre></td></tr></table></figure>
<p>关于 id 的解释请看objc runtime系列第二篇博文： objc runtime中Object &amp; Class &amp; Meta Class的细节</p>
<h3 id="什么是_SEL">什么是 SEL</h3><p>打开objc.h文件，看下SEL的定义如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector *SEL;</span><br></pre></td></tr></table></figure></p>
<p>SEL是一个指向<code>objc_selector</code>结构体的指针。而 <code>objc_selector</code> 的定义并没有在runtime.h中给出定义。我们可以尝试运行如下代码:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SEL sel = <span class="keyword">@selector</span>(foo);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, (<span class="keyword">char</span> *)sel);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p"</span>, sel);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *selName = [<span class="string">@"foo"</span> UTF8String];</span><br><span class="line">SEL sel2 = sel_registerName(selName);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, (<span class="keyword">char</span> *)sel2);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p"</span>, sel2);</span><br></pre></td></tr></table></figure></p>
<p>输出如下:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2014<span class="tag">-11-06</span> 13<span class="pseudo">:46</span><span class="pseudo">:08</span><span class="class">.058</span> <span class="tag">Test</span><span class="attr_selector">[15053:1132268]</span> <span class="tag">foo</span></span><br><span class="line">2014<span class="tag">-11-06</span> 13<span class="pseudo">:46</span><span class="pseudo">:08</span><span class="class">.058</span> <span class="tag">Test</span><span class="attr_selector">[15053:1132268]</span> 0<span class="tag">x7fff8fde5114</span></span><br><span class="line">2014<span class="tag">-11-06</span> 13<span class="pseudo">:46</span><span class="pseudo">:08</span><span class="class">.058</span> <span class="tag">Test</span><span class="attr_selector">[15053:1132268]</span> <span class="tag">foo</span></span><br><span class="line">2014<span class="tag">-11-06</span> 13<span class="pseudo">:46</span><span class="pseudo">:08</span><span class="class">.058</span> <span class="tag">Test</span><span class="attr_selector">[15053:1132268]</span> 0<span class="tag">x7fff8fde5114</span></span><br></pre></td></tr></table></figure></p>
<p>Objective-C在编译时，会根据方法的名字生成一个用来区分这个方法的唯一的一个ID。只要方法名称相同，<strong><em>那么它们的ID就是相同的</em></strong>。</p>
<p>两个类之间，不管它们是父类与子类的关系，还是之间没有这种关系，只要方法名相同，那么它的SEL就是一样的。每一个方法都对应着一个SEL。编译器会根据每个方法的方法名为那个方法生成唯一的SEL。这些SEL组成了一个Set集合，当我们在这个集合中查找某个方法时，只需要去找这个方法对应的SEL即可。而SEL本质是一个字符串，所以直接比较它们的地址即可。</p>
<p>当然，不同的类可以拥有相同的selector。不同类的实例对象执行相同的selector时，会在各自的方法列表中去根据selector去寻找自己对应的IMP。</p>
<h3 id="那么什么是IMP呢">那么什么是IMP呢</h3><p>继续看定义:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef id <span class="list">(<span class="keyword">*IMP</span>)</span><span class="list">(<span class="keyword">id</span>, SEL, ...)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>IMP本质就是一个函数指针，这个被指向的函数包含一个接收消息的对象id，调用方法的SEL，以及一些方法参数，并返回一个id。</p>
<p>因此我们可以<strong><em>通过SEL获得它所对应的IMP，在取得了函数指针之后，也就意味着我们取得了需要执行方法的代码入口，这样我们就可以像普通的C语言函数调用一样使用这个函数指针。</em></strong></p>
<h3 id="那么_objc_msgSend_到底是怎么工作的呢">那么 objc_msgSend 到底是怎么工作的呢</h3><p>在Objective-C中，消息直到运行时才会绑定到方法的实现上。编译器会把代码中[target doSth]转换成 objc_msgSend消息函数，这个函数完成了动态绑定的所有事情。它的运行流程如下:</p>
<ol>
<li>检查selector是否需要忽略。(ps: Mac开发中开启GC就会忽略retain,release方法。)</li>
<li>检查target是否为nil。如果为nil，直接cleanup，然后return。(这就是我们可以向nil发送消息的原因。)</li>
<li>然后在target的Class中根据Selector去找IMP</li>
</ol>
<p>寻找IMP的过程:</p>
<ol>
<li>先从当前class的cache方法列表（cache methodLists）里去找</li>
<li>找到了，跳到对应函数实现</li>
<li>没找到，就从class的方法列表（methodLists）里找</li>
<li>还找不到，就到super class的方法列表里找，直到找到基类(NSObject)为止</li>
<li>最后再找不到，就会进入动态方法解析和消息转发的机制。(这部分知识，下次再细谈)</li>
</ol>
<h3 id="那么什么是方法列表呢">那么什么是方法列表呢</h3><p>objc_class结构体定义，如下<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_<span class="built_in">AVAILABILITY</span>;</span><br><span class="line">    <span class="preprocessor">#if !__OBJC2__</span></span><br><span class="line">    Class super_class                                        OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                                         OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">long</span> version                                             OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">long</span> info                                                OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars                             OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists                    OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache                                 OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="preprocessor">#endif</span></span><br><span class="line">&#125; OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_method_list &#123;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list *obsolete                        OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> method_count                                         OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"><span class="preprocessor">#ifdef __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                                                OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">    <span class="comment">/* variable length structure */</span></span><br><span class="line">    <span class="keyword">struct</span> objc_method method_list[<span class="number">1</span>]                        OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>1) objc_method_list 就是用来存储当前类的方法链表，objc_method存储了类的某个方法的信息。</p>
<p>Method<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method *<span class="function"><span class="keyword">Method</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>Method 是用来代表类中某个方法的类型，它实际就指向objc_method结构体，如下:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_method &#123;</span><br><span class="line">    SEL method_name                                          OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">char</span> *method_types                                       OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    IMP method_imp                                           OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">&#125;                                                            OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>method_types</code>是个char指针，存储着方法的参数类型和返回值类型。</li>
<li>SEL 和 IMP 就是我们上文提到的，所以我们可以理解为objc_class中 method list保存了一组SEL&lt;-&gt;IMP的映射</li>
</ul>
<p>2) objc_cache 用来缓存用过的方法，提高性能。<br>Cache<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_cache *Cache                             OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br></pre></td></tr></table></figure></p>
<p>实际指向<code>objc_cache</code>结构体，如下:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_cache &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask <span class="comment">/* total = mask + 1 */</span>                 OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> occupied                                    OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    Method buckets[<span class="number">1</span>]                                        OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>mask: 指定分配cache buckets的总数。在方法查找中，Runtime使用这个字段确定数组的索引位置</li>
<li>occupied: 实际占用cache buckets的总数</li>
<li>buckets: 指定Method数据结构指针的数组。这个数组可能包含不超过mask+1个元素。需要注意的是，指针可能是NULL，表示这个缓存bucket没有被占用，另外被占用的bucket可能是不连续的。这个数组可能会随着时间而增长。</li>
</ul>
<p><code>objc_msgSend</code>每调用一次方法后，就会把该方法缓存到cache列表中，下次的时候，就直接优先从cache列表中寻找，如果cache没有，才从methodLists中查找方法。</p>
<h3 id="说完了_objc_msgSend，_那么题目中的Category又是怎么工作的呢?">说完了 objc_msgSend， 那么题目中的Category又是怎么工作的呢?</h3><p>我们知道<code>Catagory</code>可以动态地为已经存在的类添加新的方法。这样可以保证类的原始设计规模较小，功能增加时再逐步扩展。在runtime.h中查看定义:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_category *Category;</span><br></pre></td></tr></table></figure></p>
<p>同样也是指向一个 <code>objc_category</code> 的C 结构体，定义如下:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_category &#123;</span><br><span class="line">    <span class="keyword">char</span> *category_name                                      OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">char</span> *class_name                                         OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list *instance_methods                OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list *class_methods                   OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">&#125;                                                            OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br></pre></td></tr></table></figure>
<p>通过上面的结构体，大家可以很清楚的看出存储的内容。我们继续往下看，打开objc源代码，在 objc-runtime-new.h中我们可以发现如下定义:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="keyword">category_t</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">classref_t</span> cls;</span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">method_list_t</span> *instanceMethods;</span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">method_list_t</span> *classMethods;</span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">protocol_list_t</span> *protocols;</span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">property_list_t</span> *instanceProperties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面的定义需要提到的地方有三点:</p>
<ul>
<li>name 是指 class_name 而不是 category_name</li>
<li>cls是要扩展的类对象，编译期间是不会定义的，而是在Runtime阶段通过name对应到对应的类对象</li>
<li>instanceProperties表示Category里所有的properties，这就是我们可以通过objc_setAssociatedObject和objc_getAssociatedObject增加实例变量的原因，不过这个和一般的实例变量是不一样的</li>
</ul>
<p>为了验证上述内容，我们使用clang -rewrite-objc main.m重写，题目中的Category被编译器转换成了这样:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @interface NSObject (Sark)</span></span><br><span class="line"><span class="comment">// + (void)foo;</span></span><br><span class="line"><span class="comment">/* @end */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// @implementation NSObject (Sark)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_<span class="built_in">NSObject_Sark_foo</span>(<span class="built_in">NSObject</span> * <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__<span class="built_in">NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_dd1ee3_mi_0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> _category_t _OBJC_$_<span class="built_in">CATEGORY_NSObject_</span>$_Sark __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"NSObject"</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="comment">// &amp;OBJC_CLASS_$_NSObject,</span></span><br><span class="line">    (<span class="keyword">const</span> <span class="keyword">struct</span> _method_list_t *)&amp;_OBJC_$_<span class="built_in">CATEGORY_INSTANCE_METHODS_NSObject_</span>$_Sark,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> _category_t *L_OBJC_LABEL_<span class="built_in">CATEGORY_</span>$ [<span class="number">1</span>] __attribute__((used, section (<span class="string">"__DATA, __objc_catlist,regular,no_dead_strip"</span>)))= &#123;</span><br><span class="line">    &amp;_OBJC_$_<span class="built_in">CATEGORY_NSObject_</span>$_Sark,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><em>OBJC</em>$<em>CATEGORY_NSObject</em>$_Sark是按规则生成的字符串，我们可以清楚的看到是NSObject类,且Sark是NSObject类的Category</li>
<li>_category_t结构体第二项 classref_t 没有数据，验证了我们上面的说法</li>
<li>由于题目中只有 - (void)foo方法，所以结构体中存储的list只有第三项instanceMethods被填充。</li>
<li>_I_NSObject_Sark_foo代表了Category的foo方法，I表示实例方法</li>
<li>最后这个类的Category生成了一个数组，存在了<em>_objc_catlist里，目前数组的内容只有一个&amp;_OBJC</em>$<em>CATEGORY_NSObject</em>$_Sark</li>
</ul>
<h3 id="最终这些Category里面的方法是如何被加载的呢?">最终这些Category里面的方法是如何被加载的呢?</h3><ol>
<li><p>打开objc源代码，找到 objc-os.mm, 函数<code>_objc_init</code>为runtime的加载入口，由libSystem调用，进行初始化操作。</p>
</li>
<li><p>之后调用<code>objc-runtime-new.mm</code> -&gt; <code>map_images</code>加载<code>map</code>到内存</p>
</li>
<li><p>之后调用objc-runtime-new.mm-&gt;_<code>read_images</code>初始化内存中的map, 这个时候将会load所有的类，协议还有Category。NSOBject的<code>+load</code>方法就是这个时候调用的</p>
</li>
</ol>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Discover categories. </span></span><br><span class="line"><span class="keyword">for</span> <span class="params">(EACH_HEADER)</span> &#123;</span><br><span class="line">    category_t <span class="built_in">*</span><span class="built_in">*</span>catlist = </span><br><span class="line">        _getObjc2CategoryList<span class="params">(hi, &amp;count)</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="params">(i = <span class="number">0</span>; i &lt; count; i++)</span> &#123;</span><br><span class="line">        category_t <span class="built_in">*</span>cat = catlist[i];</span><br><span class="line">        Class cls = remapClass<span class="params">(cat-&gt;cls)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="params">(!cls)</span> &#123;</span><br><span class="line">            <span class="comment">// Category's target class is missing (probably weak-linked).</span></span><br><span class="line">            <span class="comment">// Disavow any knowledge of this category.</span></span><br><span class="line">            catlist[i] = nil;</span><br><span class="line">            <span class="keyword">if</span> <span class="params">(PrintConnecting)</span> &#123;</span><br><span class="line">                _objc_inform<span class="params">(<span class="string">"CLASS: IGNORING category \?\?\?(%s) %p with "</span></span><br><span class="line">                             <span class="string">"missing weak-linked target class"</span>, </span><br><span class="line">                             cat-&gt;name, cat)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process this category. </span></span><br><span class="line">        <span class="comment">// First, register the category with its target class. </span></span><br><span class="line">        <span class="comment">// Then, rebuild the class's method lists (etc) if </span></span><br><span class="line">        <span class="comment">// the class is realized. </span></span><br><span class="line">        BOOL classExists = NO;</span><br><span class="line">        <span class="keyword">if</span> <span class="params">(cat-&gt;instanceMethods ||  cat-&gt;protocols  </span><br><span class="line">            ||  cat-&gt;instanceProperties)</span> </span><br><span class="line">        &#123;</span><br><span class="line">            addUnattachedCategoryForClass<span class="params">(cat, cls, hi)</span>;</span><br><span class="line">            <span class="keyword">if</span> <span class="params">(cls-&gt;isRealized<span class="params">()</span>)</span> &#123;</span><br><span class="line">                remethodizeClass<span class="params">(cls)</span>;</span><br><span class="line">                classExists = YES;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> <span class="params">(PrintConnecting)</span> &#123;</span><br><span class="line">                _objc_inform<span class="params">(<span class="string">"CLASS: found category -%s(%s) %s"</span>, </span><br><span class="line">                             cls-&gt;nameForLogging<span class="params">()</span>, cat-&gt;name, </span><br><span class="line">                             classExists ? <span class="string">"on existing class"</span> : <span class="string">""</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="params">(cat-&gt;classMethods  ||  cat-&gt;protocols  </span><br><span class="line">            /* ||  cat-&gt;classProperties */)</span> </span><br><span class="line">        &#123;</span><br><span class="line">            addUnattachedCategoryForClass<span class="params">(cat, cls-&gt;ISA<span class="params">()</span>, hi)</span>;</span><br><span class="line">            <span class="keyword">if</span> <span class="params">(cls-&gt;ISA<span class="params">()</span>-&gt;isRealized<span class="params">()</span>)</span> &#123;</span><br><span class="line">                remethodizeClass<span class="params">(cls-&gt;ISA<span class="params">()</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> <span class="params">(PrintConnecting)</span> &#123;</span><br><span class="line">                _objc_inform<span class="params">(<span class="string">"CLASS: found category +%s(%s)"</span>, </span><br><span class="line">                             cls-&gt;nameForLogging<span class="params">()</span>, cat-&gt;name)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1) 循环调用了 _getObjc2CategoryList方法，这个方法的实现是:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETSECT(_getObjc2CategoryList,        <span class="keyword">category_t</span> *,    <span class="string">"__objc_catlist"</span>);</span><br></pre></td></tr></table></figure></p>
<p>方法中最后一个参数<code>__objc_catlist</code>就是编译器刚刚生成的category数组</p>
<p>2) load完所有的categories之后，开始对Category进行处理。</p>
<blockquote>
<p>从上面的代码中我们可以发现：实例方法被加入到了当前的类对象中, 类方法被加入到了当前类的Meta Class中 (cls-&gt;ISA)</p>
</blockquote>
<p>Step 1. 调用<code>addUnattachedCategoryForClass</code>方法</p>
<p>Step 2. 调用<code>remethodizeClass</code>方法, 在<code>remethodizeClass</code>的实现里调用<code>attachCategoryMethods</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> </span><br><span class="line"><span class="title">attachCategoryMethods</span><span class="params">(Class cls, category_list *cats, <span class="keyword">bool</span> flushCaches)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cats) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isMeta = cls-&gt;isMetaClass();</span><br><span class="line">    <span class="keyword">method_list_t</span> **mlists = (<span class="keyword">method_list_t</span> **)</span><br><span class="line">        _malloc_internal(cats-&gt;count * <span class="keyword">sizeof</span>(*mlists));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Count backwards through cats to get newest categories first</span></span><br><span class="line">    <span class="keyword">int</span> mcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = cats-&gt;count;</span><br><span class="line">    BOOL fromBundle = NO;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="keyword">method_list_t</span> *mlist = cat_method_list(cats-&gt;<span class="built_in">list</span>[i].cat, isMeta);</span><br><span class="line">        <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">            fromBundle |= cats-&gt;<span class="built_in">list</span>[i].fromBundle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    attachMethodLists(cls, mlists, mcount, NO, fromBundle, flushCaches);</span><br><span class="line"></span><br><span class="line">    _free_internal(mlists);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里把一个类的<code>category_lis</code>t的所有方法取出来生成了<code>method list</code>。这里是倒序添加的，也就是说，新生成的category的方法会先于旧的category的方法插入。</p>
<p>之后调用<code>attachMethodLists</code>将所有方法前序添加进类的<code>method list</code>中，如果原来类的方法列表是a，b，Category的方法列表是c，d。那么插入之后的方法列表将会是c，d，a，b。</p>
<h3 id="小发现">小发现</h3><ul>
<li><p>看上面被编译器转换的代码，我们发现Category头文件被注释掉了，结合上面category的加载过程。这就是我们即使没有import category的头文件，都能够成功调用到Category方法的原因。</p>
</li>
<li><p>runtime加载完成后，Category的原始信息在类结构中将不会存在。</p>
</li>
</ul>
<h3 id="解惑">解惑</h3><p>根据上面提到的知识，我们对题目中的代码进行分析。</p>
<p>1) objc runtime加载完后，NSObject的<code>Sark Category</code>被加载。而NSObject的<code>Sark Category</code>的头文件<code>+ (void)foo</code> 并没有实质参与到工作中，只是给编译器进行静态检查，所有我们编译上述代码会出现警告，提示我们没有实现 <code>+ (void)foo</code> 方法。而在代码编译中，它已经被注释掉了。</p>
<p>2) 实际被加入到Class的method list的方法是 <code>- (void)foo</code>，它是一个实例方法，所以加入到当前类对象NSObject的方法列表中，而不是NSObject <code>Meta class</code>的方法列表中。</p>
<p>3) 当执行 <code>[NSObject foo]</code>时，我们看下整个objc_msgSend的过程:</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">结合上一篇Meta <span class="keyword">Class</span>的知识：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. objc_msgSend 第一个参数是  “(id)objc_getClass(<span class="string">"NSObject"</span>)”，获得NSObject <span class="keyword">Class</span>的对象</span><br><span class="line"><span class="number">2</span>. 类方法在Meta <span class="keyword">Class</span>的方法列表中找，我们在load Category方法时加入的是- (<span class="keyword">void</span>)foo实例方法，所以</span><br><span class="line">并不在NSOBject Meta <span class="keyword">Class</span>的方法列表中</span><br><span class="line"><span class="number">3</span>. 继续往 <span class="keyword">super</span> <span class="keyword">class</span>中找，在上一篇博客中我们知道，NSObject Meta <span class="keyword">Class</span>的<span class="keyword">super</span> <span class="keyword">class</span>是</span><br><span class="line">NSObject本身。所以，这个时候我们能够找到- (<span class="keyword">void</span>)foo 这个方法。</span><br><span class="line"><span class="number">4</span>. 所以正常输出结果</span><br></pre></td></tr></table></figure>
<p>4) 当执行<code>[[NSObject new] foo]</code>，我们看下整个<code>objc_msgSend</code>的过程:<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1. </span>[NSObject new]生成一个NSObject对象</span><br><span class="line"><span class="bullet">2. </span>直接在该对象的类（NSObject）的方法列表里找</span><br><span class="line"><span class="bullet">3. </span>能够找到，所以正常输出结果</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="习题内容">习题内容</h3><p>下面的代码会？Compile Error / Runtime Crash / NSLog…?<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">Sark</span>)</span></span><br><span class="line">+ (<span class="keyword">void</span>)foo;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Sark</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)foo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"IMP: -[NSObject(Sark) foo]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [<span class="built_in">NSObject</span> foo];</span><br><span class="line">        [[<span class="built_in">NSObject</span> new] foo];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>答案：代码正常输出，输出结果如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2014<span class="tag">-11-06</span> 13<span class="pseudo">:11</span><span class="pseudo">:46</span><span class="class">.694</span> <span class="tag">Test</span><span class="attr_selector">[14872:1110786]</span> <span class="rule"><span class="attribute">IMP</span>:<span class="value"> -[<span class="function">NSObject</span>(Sark) foo]</span><br><span class="line"><span class="number">2014</span>-<span class="number">11</span>-<span class="number">06</span> <span class="number">13</span>:<span class="number">11</span>:<span class="number">46.695</span> Test[<span class="number">14872</span>:<span class="number">1110786</span>] IMP: -[<span class="function">NSObject</span>(Sark) foo]</span></span></span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS Runtime Object & Class & Meta Class]]></title>
    <link href="http://ytlvy.com/2015/07/13/iOS-Runtime-Object-Class-Meta-Class/"/>
    <id>http://ytlvy.com/2015/07/13/iOS-Runtime-Object-Class-Meta-Class/</id>
    <published>2015-07-13T13:19:42.000Z</published>
    <updated>2015-07-13T14:02:43.000Z</updated>
    <content type="html"><![CDATA[<h3 id="习题内容">习题内容</h3><p>下面代码的运行结果是?<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Sark</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Sark</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">BOOL</span> res1 = [(<span class="keyword">id</span>)[<span class="built_in">NSObject</span> class] isKindOfClass:[<span class="built_in">NSObject</span> class]];</span><br><span class="line">        <span class="built_in">BOOL</span> res2 = [(<span class="keyword">id</span>)[<span class="built_in">NSObject</span> class] isMemberOfClass:[<span class="built_in">NSObject</span> class]];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">BOOL</span> res3 = [(<span class="keyword">id</span>)[Sark class] isKindOfClass:[Sark class]];</span><br><span class="line">        <span class="built_in">BOOL</span> res4 = [(<span class="keyword">id</span>)[Sark class] isMemberOfClass:[Sark class]];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%d %d %d %d"</span>, res1, res2, res3, res4);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果为：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2014<span class="tag">-11-05</span> 14<span class="pseudo">:45</span><span class="pseudo">:08</span><span class="class">.474</span> <span class="tag">Test</span><span class="attr_selector">[9412:721945]</span> 1 0 0 0</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="什么是_id">什么是 id</h3><p>id 在 objc.h 中定义如下:<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/// A pointer to an<span class="instruction"> instance </span>of a class.</span><br><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure></p>
<p>就像注释中所说的这样 id 是指向一个 objc_object 结构体的指针。</p>
<blockquote>
<p>id 这个struct的定义本身就带了一个 <em>, 所以我们在使用其他NSObject类型的实例时需要在前面加上 </em>， 而使用 id 时<br>却不用。</p>
</blockquote>
<h3 id="那么objc_object又是什么呢">那么objc_object又是什么呢</h3><p>objc_object 在 objc.h 中定义如下:<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/// Represents an<span class="instruction"> instance </span>of a class.</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个时候我们知道Objective-C中的object在最后会被转换成C的结构体，而在这个struct中有一个 isa 指针，指向它的类别 Class。</p>
<h3 id="那么什么是Class呢">那么什么是Class呢</h3><p>在 objc.h 中定义如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// An opaque type that represents an Objective-C class.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到 Class本身指向的也是一个C的<code>struct objc_class</code>。</p>
<p>继续看在runtime.h中<code>objc_class</code>定义如下:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_<span class="built_in">AVAILABILITY</span>;</span><br><span class="line">    <span class="preprocessor">#if !__OBJC2__</span></span><br><span class="line">    Class super_class                                        OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                                         OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">long</span> version                                             OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">long</span> info                                                OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars                             OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists                    OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache                                 OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="preprocessor">#endif</span></span><br><span class="line">&#125; OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br></pre></td></tr></table></figure></p>
<p>该结构体中，isa 指向所属Class， super_class指向父类别。</p>
<p>下载objc源代码，在 objc-runtime-new.h 中，我们发现 objc_class有如下定义:<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">    // <span class="class"><span class="keyword">Class</span> <span class="title">ISA</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">Class</span> <span class="title">superclass</span>;   </span></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>豁然开朗，我们看到在Objective-C的设计哲学中，一切都是对象。Class在设计中本身也是一个对象。而这个Class对象的对应的类，我们叫它 <code>Meta Class</code>。即Class结构体中的 isa 指向的就是它的 Meta Class。</p>
<h3 id="Meta_Class">Meta Class</h3><p>根据上面的描述，我们可以把Meta Class理解为 一个Class对象的Class。简单的说：</p>
<ul>
<li>当我们发送一个消息给一个NSObject对象时，这条消息会在对象的类的方法列表里查找</li>
<li>当我们发送一个消息给一个类时，这条消息会在类的Meta Class的方法列表里查找</li>
</ul>
<p>而 Meta Class本身也是一个Class，它跟其他Class一样也有自己的 isa 和 super_class 指针。看下图：<br><img src="http://106.186.113.24:8888/other/Class%26MetaClass.001.jpg" alt=""></p>
<ul>
<li>每个Class都有一个isa指针指向一个唯一的Meta Class</li>
<li>每一个Meta Class的isa指针都指向最上层的<code>Meta Class</code>（图中的NSObject的Meta Class）</li>
<li>最上层的<code>Meta Class</code>的<code>isa</code>指针指向自己，形成一个回路</li>
<li>每一个<code>Meta Class</code>的<code>super class</code>指针指向它原本Class的 <code>Super Class</code>的<code>Meta Class</code>。但是最上层的<code>Meta Class</code>的 <code>Super Class</code>指向<code>NSObject Class</code>本身</li>
<li>最上层的NSObject Class的super class指向 nil</li>
</ul>
<h3 id="解惑">解惑</h3><p>为了更加清楚的知道整个函数调用过程，我们使用<code>clang -rewrite-objc main.m</code>重写，可获得如下代码：<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL res1 = <span class="params">(<span class="params">(BOOL <span class="params">(*)</span><span class="params">(id, SEL, Class)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span><span class="params">(<span class="params">(Class <span class="params">(*)</span><span class="params">(id, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span>objc_getClass<span class="params">(<span class="string">"NSObject"</span>)</span>, sel_registerName<span class="params">(<span class="string">"class"</span>)</span>)</span>, sel_registerName<span class="params">(<span class="string">"isKindOfClass:"</span>)</span>, <span class="params">(<span class="params">(Class <span class="params">(*)</span><span class="params">(id, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span>objc_getClass<span class="params">(<span class="string">"NSObject"</span>)</span>, sel_registerName<span class="params">(<span class="string">"class"</span>)</span>)</span>)</span>;</span><br><span class="line"></span><br><span class="line"> BOOL res2 = <span class="params">(<span class="params">(BOOL <span class="params">(*)</span><span class="params">(id, SEL, Class)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span><span class="params">(<span class="params">(Class <span class="params">(*)</span><span class="params">(id, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span>objc_getClass<span class="params">(<span class="string">"NSObject"</span>)</span>, sel_registerName<span class="params">(<span class="string">"class"</span>)</span>)</span>, sel_registerName<span class="params">(<span class="string">"isMemberOfClass:"</span>)</span>, <span class="params">(<span class="params">(Class <span class="params">(*)</span><span class="params">(id, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span>objc_getClass<span class="params">(<span class="string">"NSObject"</span>)</span>, sel_registerName<span class="params">(<span class="string">"class"</span>)</span>)</span>)</span>;</span><br><span class="line"></span><br><span class="line"> BOOL res3 = <span class="params">(<span class="params">(BOOL <span class="params">(*)</span><span class="params">(id, SEL, Class)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span><span class="params">(<span class="params">(Class <span class="params">(*)</span><span class="params">(id, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span>objc_getClass<span class="params">(<span class="string">"Sark"</span>)</span>, sel_registerName<span class="params">(<span class="string">"class"</span>)</span>)</span>, sel_registerName<span class="params">(<span class="string">"isMemberOfClass:"</span>)</span>, <span class="params">(<span class="params">(Class <span class="params">(*)</span><span class="params">(id, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span>objc_getClass<span class="params">(<span class="string">"NSObject"</span>)</span>, sel_registerName<span class="params">(<span class="string">"class"</span>)</span>)</span>)</span>;</span><br><span class="line"></span><br><span class="line"> BOOL res4 = <span class="params">(<span class="params">(BOOL <span class="params">(*)</span><span class="params">(id, SEL, Class)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span><span class="params">(<span class="params">(Class <span class="params">(*)</span><span class="params">(id, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span>objc_getClass<span class="params">(<span class="string">"Sark"</span>)</span>, sel_registerName<span class="params">(<span class="string">"class"</span>)</span>)</span>, sel_registerName<span class="params">(<span class="string">"isMemberOfClass:"</span>)</span>, <span class="params">(<span class="params">(Class <span class="params">(*)</span><span class="params">(id, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span>objc_getClass<span class="params">(<span class="string">"NSObject"</span>)</span>, sel_registerName<span class="params">(<span class="string">"class"</span>)</span>)</span>)</span>;</span><br></pre></td></tr></table></figure></p>
<p>先看前两个调用：</p>
<ul>
<li>最外层是 objc_msgSend函数，转发消息。</li>
<li>函数第一个参数是 <code>(id)((Class (*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;class&quot;))</code></li>
<li>函数第二个参数是转发的selector</li>
<li>函数第三个参数是 <code>((Class (*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;NSObject&quot;), sel_registerName(&quot;class&quot;))</code></li>
</ul>
<p>我们注意到第一个参数和第三个参数对应重写的是[NSObject class]，即使用<code>objc_msgSend</code>向 <code>NSObject Class</code> 发送 <code>@selector(class)</code> 这个消息</p>
<p>打开objc源代码，在 Object.mm 中发现<code>+ (Class)class</code>实现如下:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="constant">Class</span>)<span class="class"><span class="keyword">class</span> &#123;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以即返回Class类的对象本身。看如下输出:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">NSLog</span>(<span class="at_rule">@<span class="keyword">"%p",</span> [NSObject class])</span>;</span><br><span class="line"><span class="tag">NSLog</span>(<span class="at_rule">@<span class="keyword">"%p",</span> [NSObject class])</span>;</span><br><span class="line"></span><br><span class="line">2014<span class="tag">-11-05</span> 18<span class="pseudo">:48</span><span class="pseudo">:30</span><span class="class">.939</span> <span class="tag">Test</span><span class="attr_selector">[11682:865988]</span> 0<span class="tag">x7fff768d40f0</span></span><br><span class="line">2014<span class="tag">-11-05</span> 18<span class="pseudo">:48</span><span class="pseudo">:30</span><span class="class">.940</span> <span class="tag">Test</span><span class="attr_selector">[11682:865988]</span> 0<span class="tag">x7fff768d40f0</span></span><br></pre></td></tr></table></figure></p>
<p>继续打开objc源代码，在 <code>Object.mm</code> 中，我们发现 <code>isKindOfClass</code>的实现如下:<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)isKindOf:aClass</span><br><span class="line">&#123;</span><br><span class="line">    Class <span class="built_in">cls</span>;</span><br><span class="line">    <span class="flow">for</span> (<span class="built_in">cls</span> = isa; <span class="built_in">cls</span>; <span class="built_in">cls</span> = <span class="built_in">cls</span>-&gt;superclass) </span><br><span class="line">        <span class="flow">if</span> (<span class="built_in">cls</span> == (Class)aClass)</span><br><span class="line">            return YES;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对着上面Meta Class的图和实现，我们可以看出</p>
<ul>
<li>当 NSObject Class对象第一次进行比较时，得到它的isa为 NSObject的Meta Class， 这个时候 NSObject Meta Class 和 NSObject Class不相等。</li>
<li>然后取NSObject 的Meta Class 的Super class，这个时候又变成了 NSObject Class， 所以返回相等</li>
</ul>
<p>所以上述第一个输出结果是 YES 。</p>
<p>我们在看下 ‘isMemberOfClass’的实现:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (<span class="tag">BOOL</span>)<span class="rule"><span class="attribute">isMemberOf</span>:<span class="value">aClass</span><br><span class="line">&#123;</span><br><span class="line">    return isa == (Class)aClass</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>综上所述，当前的 isa 指向 NSObject 的 <code>Meta Class</code>， 所以和 <code>NSObject Class</code>不相等。</p>
<p>所以上述第二个输出结果为 NO 。</p>
<p>继续看后面两个调用:</p>
<ul>
<li>Sark Class 的isa指向的是 Sark的Meta Class，和Sark Class不相等</li>
<li>Sark Meta Class的super class 指向的是 NSObject Meta Class， 和 Sark Class不相等</li>
<li>NSObject Meta Class的 super class 指向 NSObject Class，和 Sark Class 不相等</li>
<li>NSObject Class 的super class 指向 nil， 和 Sark Class不相等</li>
</ul>
<p>所以后面两个调用的结果都输出为 NO 。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="习题内容">习题内容</h3><p>下面代码的运行结果是?<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Sark</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Sark</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">BOOL</span> res1 = [(<span class="keyword">id</span>)[<span class="built_in">NSObject</span> class] isKindOfClass:[<span class="built_in">NSObject</span> class]];</span><br><span class="line">        <span class="built_in">BOOL</span> res2 = [(<span class="keyword">id</span>)[<span class="built_in">NSObject</span> class] isMemberOfClass:[<span class="built_in">NSObject</span> class]];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">BOOL</span> res3 = [(<span class="keyword">id</span>)[Sark class] isKindOfClass:[Sark class]];</span><br><span class="line">        <span class="built_in">BOOL</span> res4 = [(<span class="keyword">id</span>)[Sark class] isMemberOfClass:[Sark class]];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%d %d %d %d"</span>, res1, res2, res3, res4);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果为：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2014<span class="tag">-11-05</span> 14<span class="pseudo">:45</span><span class="pseudo">:08</span><span class="class">.474</span> <span class="tag">Test</span><span class="attr_selector">[9412:721945]</span> 1 0 0 0</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS Runtime Self & Super]]></title>
    <link href="http://ytlvy.com/2015/07/13/iOS-Runtime-Self-Super/"/>
    <id>http://ytlvy.com/2015/07/13/iOS-Runtime-Self-Super/</id>
    <published>2015-07-13T13:18:00.000Z</published>
    <updated>2015-07-13T14:02:35.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Self_&amp;&amp;_Super">Self &amp;&amp; Super</h2><h3 id="What_is_Super?">What is Super?</h3><p><code>Super</code> 是和 <code>Self</code> 一样的关键字, 不同的是, 它不能用作函数的参数, 只能接收消息.当接收消息的时候, 它会向父类搜索方法的定义. 如果在向上的类链中没有任何定义, 则程序会 crash.</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithValue<span class="number">1</span>:(id)<span class="keyword">value</span><span class="number">1</span> <span class="keyword">value</span><span class="number">2</span>:(id)<span class="keyword">value</span><span class="number">2</span></span><br><span class="line">&#123;</span><br><span class="line">    self = [<span class="keyword">super</span> initWithValue<span class="number">1</span>:<span class="keyword">value</span><span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (self) &#123;</span><br><span class="line">        <span class="number">_</span><span class="keyword">value</span><span class="number">2</span> = <span class="keyword">value</span><span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="messaging_super">messaging <code>super</code></h3><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_super</span> </span>&#123;</span><br><span class="line">    __unsafe_unretained id receiver;</span><br><span class="line">    __unsafe_unretained Class super_class;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (void)<span class="tag">methodWithArgument</span>:(id)<span class="tag">arg</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr_selector">[super otherMethodWithArgument:arg]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)methodWithArgument:(id)arg</span><br><span class="line">&#123;</span><br><span class="line">    struct objc<span class="number">_</span><span class="keyword">super</span> <span class="keyword">super</span> = &#123;.receiver = self, .<span class="keyword">super</span><span class="number">_</span><span class="keyword">class</span> = <span class="number">0</span>xC<span class="number">0</span>FFEE&#125;;</span><br><span class="line"></span><br><span class="line">    objc<span class="number">_m</span>sgSendSuper(&amp;<span class="keyword">super</span>, <span class="annotation">@selector</span>(otherMethodWithArgument:), arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>objc_msgSendSuper</code> 将从父类的定义开始查找方法的实现. <code>super_class</code>是在 runtime 时, 动态生成的.<br><a id="more"></a></p>
<h4 id="objc_msgSendSuper_例子">objc_msgSendSuper 例子</h4><p><img src="http://cdn.macoscope.com/blog/wp-content/uploads/2015/02/how-does-super-work-1.png" alt=""></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/message.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">A</span> : <span class="title">NSObject</span> @<span class="title">end</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">B</span> : <span class="title">A</span> @<span class="title">end</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">C</span> : <span class="title">B</span> @<span class="title">end</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">X</span> : <span class="title">NSObject</span> @<span class="title">end</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">A</span> </span></span><br><span class="line">- (<span class="keyword">void</span>)abc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"-[A abc] called from class %@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> class]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">B</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">C</span></span></span><br><span class="line">- (<span class="keyword">void</span>)abc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"-[C abc] called from class %@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> class]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">X</span></span></span><br><span class="line">-(<span class="keyword">void</span>)A_abc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> objc_super sup = &#123;<span class="keyword">self</span>, [A class]&#125;;</span><br><span class="line">    objc_msgSendSuper(&amp;sup, <span class="keyword">@selector</span>(abc));</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="keyword">void</span>)B_abc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> objc_super sup = &#123;<span class="keyword">self</span>, [B class]&#125;;</span><br><span class="line">    objc_msgSendSuper(&amp;sup, <span class="keyword">@selector</span>(abc));</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="keyword">void</span>)C_abc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> objc_super sup = &#123;<span class="keyword">self</span>, [C class]&#125;;</span><br><span class="line">    objc_msgSendSuper(&amp;sup, <span class="keyword">@selector</span>(abc));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [[X new] A_abc];</span><br><span class="line">        [[X new] B_abc];</span><br><span class="line">        [[X new] C_abc];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">[<span class="constant">A</span> abc] called from <span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"></span>-<span class="ruby">[<span class="constant">A</span> abc] called from <span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"></span>-<span class="ruby">[<span class="constant">C</span> abc] called from <span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span></span><br></pre></td></tr></table></figure>
<h4 id="Message_Forwarding_Experiment">Message Forwarding Experiment</h4><p><img src="http://cdn.macoscope.com/blog/wp-content/uploads/2015/02/how-does-super-work-2.png" alt=""><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSInvocation</span> (<span class="title">PrivateAPI</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)invokeUsingIMP:(IMP)imp;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">A</span> : <span class="title">NSObject</span> @<span class="title">end</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">B</span> : <span class="title">A</span> @<span class="title">end</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">C</span> : <span class="title">B</span> @<span class="title">end</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">X</span> : <span class="title">NSObject</span> @<span class="title">end</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">A</span> </span></span><br><span class="line">- (<span class="keyword">void</span>)abc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"-[A abc]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">B</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">C</span></span></span><br><span class="line">- (<span class="keyword">void</span>)abc</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> abc];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"-[C abc]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">X</span> (<span class="title">ForwardedMethods</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)xyz;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">X</span></span></span><br><span class="line">- (<span class="built_in">BOOL</span>)respondsToSelector:(SEL)selector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> selector == <span class="keyword">@selector</span>(xyz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)selector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (selector == <span class="keyword">@selector</span>(xyz)) &#123;</span><br><span class="line">        <span class="keyword">return</span> [C instanceMethodSignatureForSelector:<span class="keyword">@selector</span>(abc)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (invocation<span class="variable">.selector</span> == <span class="keyword">@selector</span>(xyz)) &#123;</span><br><span class="line">        Method method = class_getInstanceMethod([C class], <span class="keyword">@selector</span>(abc));</span><br><span class="line">        [invocation invokeUsingIMP:method_getImplementation(method)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [[X new] xyz];  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Output:<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">[<span class="constant">A</span> abc]</span><br><span class="line"></span>-<span class="ruby">[<span class="constant">C</span> abc]</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Method_Copying_Experiment">Method Copying Experiment</h4><p><img src="http://cdn.macoscope.com/blog/wp-content/uploads/2015/02/how-does-super-work-3.png" alt=""><br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#import &lt;Foundation/Foundation.h&gt;</span></span><br><span class="line"><span class="comment">#import &lt;objc/runtime.h&gt;</span></span><br><span class="line"></span><br><span class="line">@<span class="keyword">interface</span> A : <span class="type">NSObject</span> @<span class="keyword">end</span></span><br><span class="line">@<span class="keyword">interface</span> B : A @<span class="keyword">end</span></span><br><span class="line">@<span class="keyword">interface</span> C : B @<span class="keyword">end</span></span><br><span class="line">@<span class="keyword">interface</span> X : <span class="type">NSObject</span> @<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">@implementation A </span><br><span class="line">- (<span class="type">void</span>)abc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">"-[A abc]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">@implementation B</span><br><span class="line">@<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">@implementation C</span><br><span class="line">- (<span class="type">void</span>)abc</span><br><span class="line">&#123;</span><br><span class="line">    [super abc];</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">"-[C abc]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">@<span class="keyword">interface</span> X (<span class="type">CopiedMethods</span>)</span><br><span class="line">- (<span class="type">void</span>)xyz;</span><br><span class="line">@<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">@implementation X</span><br><span class="line">+ (<span class="type">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">Method</span> <span class="keyword">method</span> = class_getInstanceMethod([C class], @selector(abc));</span><br><span class="line">    <span class="type">IMP</span> imp = method_getImplementation(<span class="keyword">method</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *typeEncoding = method_getTypeEncoding(<span class="keyword">method</span>);</span><br><span class="line">    class_addMethod(self, @selector(xyz), imp, typeEncoding);</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        [[X new] xyz];  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Output:<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">[<span class="constant">A</span> abc]</span><br><span class="line"></span>-<span class="ruby">[<span class="constant">C</span> abc]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="刨根问底">刨根问底</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Son</span> : <span class="title">Father</span></span></span><br><span class="line">- (<span class="keyword">id</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> class]));</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">super</span> class]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>解惑：这个题目主要是考察关于objc中对 self 和 super 的理解。</p>
<p>self 是类的隐藏参数，指向当前调用方法的这个类的实例。而 super 是一个 Magic Keyword， 它本质是一个编译器标示符，和 self 是指向的同一个消息接受者。上面的例子不管调用[self class]还是[super class]，接受消息的对象都是当前 Son ＊xxx 这个对象。而不同的是，super是告诉编译器，调用 class 这个方法时，要去父类的方法，而不是本类里的。</p>
<p>当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用 super 时，则从父类的方法列表中开始找。然后调用父类的这个方法。</p>
<p>真的是这样吗？继续看：</p>
<p>使用clang重写命令:<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clang -rewrite-objc <span class="keyword">test</span>.<span class="literal">m</span></span><br></pre></td></tr></table></figure></p>
<p>发现上述代码被转化为:</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSLog<span class="params">( <span class="params">(NSString *)</span> &amp;__NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_0, </span><br><span class="line">    NSStringFromClass<span class="params">(<span class="params">(<span class="params">(Class <span class="params">(*)</span><span class="params">(id, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span>self, sel_registerName<span class="params">(<span class="string">"class"</span>)</span>)</span>)</span> )</span>;</span><br><span class="line"></span><br><span class="line">NSLog<span class="params">( <span class="params">(NSString *)</span> &amp;__NSConstantStringImpl__var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_1, </span><br><span class="line">    NSStringFromClass<span class="params">(<span class="params">(<span class="params">(Class <span class="params">(*)</span><span class="params">(__rw_objc_super *, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSendSuper)</span><span class="params">(<span class="params">(__rw_objc_super)</span>&#123; <span class="params">(id)</span>self, <span class="params">(id)</span>class_getSuperclass<span class="params">(objc_getClass<span class="params">(<span class="string">"Son"</span>)</span>)</span> &#125;, sel_registerName<span class="params">(<span class="string">"class"</span>)</span>)</span>)</span> )</span>;</span><br></pre></td></tr></table></figure>
<p>精简后<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend<span class="list">(<span class="keyword">self</span>,  @selector<span class="string">"class"</span>)</span></span><br><span class="line"></span><br><span class="line">objc_msgSendSuper<span class="list">( &#123;self, class_getSuperclass<span class="list">(<span class="keyword">objc_getClass</span><span class="list">(<span class="string">"Son"</span>)</span>)</span>,  @selector<span class="string">"class"</span>&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>从上面的代码中，我们可以发现在调用 <code>[self class]</code>时，会转化成 <code>objc_msgSend</code>函数。看下函数定义：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_msgSend(<span class="keyword">id</span> <span class="keyword">self</span>, SEL op, ...)</span><br></pre></td></tr></table></figure>
<p>我们把 <code>self</code> 做为第一个参数传递进去。</p>
<p>而在调用 <code>[super class]</code>时，会转化成 <code>objc_msgSendSuper</code>函数。看下函数定义:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_msgSendSuper(<span class="keyword">struct</span> objc_super *<span class="keyword">super</span>, SEL op, ...)</span><br></pre></td></tr></table></figure>
<p>第一个参数是 <code>objc_super</code> 这样一个结构体，其定义如下:</p>
<figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_super</span> </span>&#123;</span><br><span class="line">   __unsafe_unretained id receiver;</span><br><span class="line">   __unsafe_unretained Class super_class;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结构体有两个成员，第一个成员是 <code>receiver</code>, 类似于上面的 <code>objc_msgSend</code>函数第一个参数<code>self</code> 。第二个成员是记录当前类的父类是什么。</p>
<p>所以，当调用 <code>[self class]</code>时，实际先调用的是 <code>objc_msgSend</code>函数，第一个参数是 <code>Son</code>当前的这个实例，然后在 <code>Son</code> 这个类里面去找 <code>- (Class)class</code>这个方法，没有，去父类 Father里找，也没有，最后在 <code>NSObject</code> 类中发现这个方法。而 <code>- (Class)class</code>的实现就是返回self的类别，故上述输出结果为 <code>Son</code>。</p>
<p>objc Runtime开源代码对- (Class)class方法的实现:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="constant">Class</span>)<span class="class"><span class="keyword">class</span> &#123;</span></span><br><span class="line">    <span class="keyword">return</span> object_getClass(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而当调用 <code>[super class]</code>时，会转换成<code>objc_msgSendSuper</code>函数。第一步先构造<code>objc_super</code> 结构体，结构体第一个成员就是 <code>self</code> 。第二个成员是 <code>(id)class_getSuperclass(objc_getClass(“Son”))</code>, 实际该函数输出结果为 Father。第二步是去  <code>Father</code> 这个类里去找 <code>- (Class)class</code> ，没有，然后去NSObject类去找，找到了。最后内部是使用 objc_msgSend(objc_super-&gt;receiver, @selector(class))去调用，此时已经和[self class]调用相同了，故上述输出结果仍然返回 Son</p>
<h3 id="总结">总结</h3><p><code>super</code>的作用主要是告诉编译器 方法的定义从父类开始查找, 并不是生成了一个真的父类对象. 而 <code>class</code> 方法的定义<code>return object_getClass(self);</code> 决定了其返回结果是运行期动态决定的, 而此时的<code>self</code> 变量同样只能是<code>Son</code>的实例对象.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Self_&amp;&amp;_Super">Self &amp;&amp; Super</h2><h3 id="What_is_Super?">What is Super?</h3><p><code>Super</code> 是和 <code>Self</code> 一样的关键字, 不同的是, 它不能用作函数的参数, 只能接收消息.当接收消息的时候, 它会向父类搜索方法的定义. 如果在向上的类链中没有任何定义, 则程序会 crash.</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithValue<span class="number">1</span>:(id)<span class="keyword">value</span><span class="number">1</span> <span class="keyword">value</span><span class="number">2</span>:(id)<span class="keyword">value</span><span class="number">2</span></span><br><span class="line">&#123;</span><br><span class="line">    self = [<span class="keyword">super</span> initWithValue<span class="number">1</span>:<span class="keyword">value</span><span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (self) &#123;</span><br><span class="line">        <span class="number">_</span><span class="keyword">value</span><span class="number">2</span> = <span class="keyword">value</span><span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="messaging_super">messaging <code>super</code></h3><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_super</span> </span>&#123;</span><br><span class="line">    __unsafe_unretained id receiver;</span><br><span class="line">    __unsafe_unretained Class super_class;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (void)<span class="tag">methodWithArgument</span>:(id)<span class="tag">arg</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr_selector">[super otherMethodWithArgument:arg]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)methodWithArgument:(id)arg</span><br><span class="line">&#123;</span><br><span class="line">    struct objc<span class="number">_</span><span class="keyword">super</span> <span class="keyword">super</span> = &#123;.receiver = self, .<span class="keyword">super</span><span class="number">_</span><span class="keyword">class</span> = <span class="number">0</span>xC<span class="number">0</span>FFEE&#125;;</span><br><span class="line"></span><br><span class="line">    objc<span class="number">_m</span>sgSendSuper(&amp;<span class="keyword">super</span>, <span class="annotation">@selector</span>(otherMethodWithArgument:), arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>objc_msgSendSuper</code> 将从父类的定义开始查找方法的实现. <code>super_class</code>是在 runtime 时, 动态生成的.<br>]]>
    
    </summary>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Random]]></title>
    <link href="http://ytlvy.com/2015/07/06/Random/"/>
    <id>http://ytlvy.com/2015/07/06/Random/</id>
    <published>2015-07-06T13:24:11.000Z</published>
    <updated>2015-07-13T14:04:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="arc4random()">arc4random()</h2><h3 id="Random_int_between_0_and_N_-_1">Random int between 0 and N - 1</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSUInteger r = arc4random_uniform<span class="list">(<span class="keyword">N</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h3 id="Random_int_between_1_and_N">Random int between 1 and N</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSUInteger r = arc4random_uniform<span class="list">(<span class="keyword">N</span>)</span> + <span class="number">1</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h3 id="Random_double_between_0_and_1">Random double between 0 and 1</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sra<span class="label">nd48</span><span class="comment">(time(0)</span>);</span><br><span class="line">double r = dra<span class="label">nd48</span><span class="comment">()</span>;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="pick_a_random_element_from_array">pick a random element from array</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([array <span class="command">count</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="property">id</span> obj = array[arc4random_uniform([array <span class="command">count</span>])];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="How_Do_I_Randomly_Order_an_NSArray?">How Do I Randomly Order an NSArray?</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *mutableArray = [<span class="built_in">NSMutableArray</span> arrayWithArray:array];</span><br><span class="line"><span class="built_in">NSUInteger</span> count = [mutableArray count];</span><br><span class="line"><span class="comment">// See http://en.wikipedia.org/wiki/Fisher–Yates_shuffle</span></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = count - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">      [mutableArray exchangeObjectAtIndex:i</span><br><span class="line">           withObjectAtIndex:arc4random_uniform((int32_t)(i + <span class="number">1</span>))];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSArray</span> *randomArray = [<span class="built_in">NSArray</span> arrayWithArray:mutableArray];</span><br></pre></td></tr></table></figure>
<h3 id="TTTRandomizedEnumerator">TTTRandomizedEnumerator</h3><p><a href="https://github.com/mattt/TTTRandomizedEnumerator" target="_blank" rel="external">https://github.com/mattt/TTTRandomizedEnumerator</a></p>
<h3 id="How_Do_I_Generate_a_Random_String?">How Do I Generate a Random String?</h3><p>Generate a Random Lowercase NSString<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *letter = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%c"</span>, arc4random_uniform(<span class="number">26</span>) + <span class="string">'a'</span>];</span><br></pre></td></tr></table></figure></p>
<p>Pick a Random Character From an NSString<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *vowels = <span class="string">@"aeiouy"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *letter = [vowels substringWithRange:<span class="built_in">NSMakeRange</span>(arc4random_uniform([vowels length]), <span class="number">1</span>)];</span><br></pre></td></tr></table></figure></p>
<h2 id="Why_Should_I_Use_arc4random(3)_instead_of_rand(3)_or_random(3)?">Why Should I Use arc4random(3) instead of rand(3) or random(3)?</h2><ol>
<li>arc4random does not require an initial seed (with srand or srandom), making it that much easier to use.</li>
<li>arc4random has a range up to 0x100000000 (4294967296), whereas rand and random top out at RAND_MAX = 0x7fffffff (2147483647).</li>
<li>rand has often been implemented in a way that regularly cycles low bits, making it more predictable.</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="arc4random()">arc4random()</h2><h3 id="Random_int_between_0_and_N_-_1">Random int between 0 and N - 1</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSUInteger r = arc4random_uniform<span class="list">(<span class="keyword">N</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h3 id="Random_int_between_1_and_N">Random int between 1 and N</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSUInteger r = arc4random_uniform<span class="list">(<span class="keyword">N</span>)</span> + <span class="number">1</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h3 id="Random_double_between_0_and_1">Random double between 0 and 1</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sra<span class="label">nd48</span><span class="comment">(time(0)</span>);</span><br><span class="line">double r = dra<span class="label">nd48</span><span class="comment">()</span>;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="IOS" scheme="http://ytlvy.com/tags/IOS/"/>
    
      <category term="Random" scheme="http://ytlvy.com/tags/Random/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[progress memory map]]></title>
    <link href="http://ytlvy.com/2015/07/06/progress-memory-map/"/>
    <id>http://ytlvy.com/2015/07/06/progress-memory-map/</id>
    <published>2015-07-06T13:22:46.000Z</published>
    <updated>2015-07-13T14:04:32.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/" target="_blank" rel="external">翻译子</a></p>
<h2 id="程序在内存中分布">程序在内存中分布</h2><p>内存管理是操作系统的核心. 对系统和编程人员来说这都是非常重要的.下面用 32位 系统举例.首先介绍程序如何在内存中分布.</p>
<h3 id="虚拟地址空间">虚拟地址空间</h3><p>在多任务操作系统中, 每个进程拥有自己独立的内存沙箱. 这个沙箱就是指的<code>虚拟地址空间</code>(virtual address space), 在32位系统中, 就是一块4GB 大小的内存地址块. 这些虚拟地址和物理内存通过<code>page tables</code>来完成映射, <code>page tables</code>是由系统核心管理,进程可以进行访问. 一旦虚拟地址被启用, 会应用到所有的程序中, 包括系统核心. 因此虚拟地址的一部分, 需要被划分出来为系统核心保留使用.<br><img src="http://static.duartes.org/img/blogPosts/kernelUserMemorySplit.png" alt=""></p>
<p>这并不意味着核心会固定占用大量的物理内存, 而是说核心需要按照需要动态映射到足够的物理内存即可.核心空间在 <code>page tables</code>中被标记为被<code>特权码(privilege code)</code>独占, 因此如果用户程序尝试访问此空间, <code>页面错误</code>会被出发并抛出. 在 linux 系统中, 核心空间是常驻内存的, 并且所有程序的核心空间是共享的, 总是映射到同一块物理内存. 核心代码和数据,总是可访问, 并随时准备处理<code>interrupts</code> 或者 系统调用. 相对的用户程序空间块是每个程序独享的, 并在程序切换时, 而随之切换.</p>
<p><img src="http://static.duartes.org/img/blogPosts/virtualMemoryInProcessSwitch.png" alt=""></p>
<p>上图中蓝色区域标示, 虚拟地址已经完成映射到实际地址, 白色区域代表还没有完成映射.上例中, 以内存消耗多著名的火狐使用了更多的虚拟地址. 在内存地址中不同的区块代表了不同的内存段: heap, stack, 等等.请注意这些内存段只是简单的内存地址范围, 与<code>Intel-style segments</code>无关. 下面是linux 系统中标准段分布图:</p>
<p><img src="http://static.duartes.org/img/blogPosts/linuxFlexibleAddressSpaceLayout.png" alt=""><br><a id="more"></a><br>当程序安全, 正常运行时, 几乎所有程序的段的起始位置, 都和上图一致.然而这是很不安全的.攻击脚本需要引用内存的某些绝对地址,例如栈中某个地址, 库函数中得某个地址等.攻击者可以很容易的计算出这些地址.正因此, 地址随机技术变的流行起来.linux通过给起始地址增加随机偏移的方法, 来实现栈, 堆, memory mapping segment等的随机化.然而不幸的是, 32位地址空间太紧凑了, 为随机化留存的空间太少, 从而大大削弱了这一功能.</p>
<h3 id="栈">栈</h3><p>栈, 处于程序地址空间的最上层, 在大部分语言中用于存储临时变量和函数参数.每调用一个函数或方法就会生成一个新的栈帧, 并 push 入栈中. 在函数返回时, 栈帧被自动销毁. 如此简单的设计, 可能因为数据遵从后进先出的原则, 意味着没有复杂的数据结构需要被跟踪监控, 一个简单的栈顶指针就可以搞定一切了.压栈和出栈因此非常快和确定. 同时, 常量栈分区的复用(在 cpu caches中保持), 也大大加速了访问效率.每个进程拥有独立的栈空间.</p>
<p>如果压栈数据大于栈能接纳的容量, 栈空间可能被耗尽.这会激发一个页面错误, 此错误会被 linux 系统接受, 并调用<code>expand_stack()</code>命令, 此命令会进一步调用<code>acct_stack_growth()</code>来检测是否可以对栈进行扩容. 如果栈空间大小低于<code>RLIMIT_STACK</code>(通常为8M) , 通常栈会自动增加, 程序会继续运行, 就像什么都没有发生一样. 这是栈扩展的通常情况.然而, 如果栈大小达到了限制, 我们就制造了一个栈溢出, 程序会收到一个段错误. 此外, 映射的栈空间只会根据需求扩展, 当栈变小时, 并不会自动减少.就像联邦经费一样, 他仅仅是扩展.</p>
<p>动态栈增长是唯一合法的存取未映射内存区域的途径, 其他任何方式都会引起页面错.</p>
<h3 id="MMS">MMS</h3><p>栈下方是内存映射段( memeory mapping segment). 核心会将文件内容直接映射到这里.在 任何程序都可以通过调用 <code>mmap()</code>(linux) 或  <code>CreateFileMapping() / MapViewOfFile()</code> (windows系统)来实现此功能.内存映射是一种便捷高效处理文件 IO 的方式, 一般用来加载动态链接库. 你也可以创建一个匿名内存映射, 此映射与任何文件无关, 用来代替程序数据. 在 linux 系统中, 如果你用 <code>malloc</code> 创建一大块内存区域, 系统会创建一个匿名映射而不是使用堆内存.<code>大</code>意为着, 大于<code>MMAP_THRESHOLD</code> byte, 默认为128KB, 此数值可以通过<code>mallopt()</code>来调整.</p>
<h3 id="堆">堆</h3><p>堆, 像栈一样 提供了运行时内存动态分配的功能; 然而和栈不一样的是, 堆中得数据比函数存活的时间长.大部分语言提供了堆内存管理方案. 满足内存需求是核心和语言运行时之间的纽带.在 C 语言中堆分配的语句为 malloc()相关函数.</p>
<p>系统通过<code>brk()</code>命令来给堆扩容,对管理十分复杂, 需要繁琐的算法来达到速度和效率的平衡.堆有碎片化问题.<br><img src="http://static.duartes.org/img/blogPosts/fragmentedHeap.png" alt=""></p>
<h3 id="BSS_&amp;&amp;_DATA_&amp;&amp;_Program_Text">BSS &amp;&amp; DATA &amp;&amp; Program Text</h3><p>BSS 和 Data 段都是用来存贮静态(全局)变量的. 不同点在于 BSS 存贮的是未初始化的数据.BSS 内存区域是匿名的,他不映射任何文件. 比如<code>static int cntActiveUsers</code>, 此变量就位于<code>BSS</code>段.</p>
<p>数据段, 存储在代码中已初始化的静态变量.这个内存区域是非匿名的. 他映射了程序二进制 image 中存储已初始化静态变量的内容. 例如: <code>static int cntWorkerBees = 10</code>, 此变量就存储在 Data 段中且初始化数值为10; 即使数据段映射了文件, 这也是一种<code>私有内存映射</code>, 它意味着更新内存中得变量,不会对文件中得变量造成影响.这是必须得, 如果对全局变量的修改, 会变更硬盘上的二进制影像文件, 就太不可思议了.</p>
<p>下图中数据的例子因为使用了指针变得很有技巧性. 在这种情况下<code>gonzo</code>指针(4 byte 内存地址), 生存于数据段. 而指针指向的实际字符串并没有在数据段, 而是存在于文本段(<code>text segment</code>). 文本段为只读状态, 它存贮了代码中的边角数据类似 <code>字符串字面量</code>.文本段也映射了二进制影像文件到内存中, 但是写入该字段会引起段错误.这有助于防止指针错误, 虽然在 C语言中没有那么有效率.下面是这些段例子的图:<br><img src="http://static.duartes.org/img/blogPosts/mappingBinaryImage.png" alt=""></p>
<p>在 Linux 进程中, 通过读取<code>/proc/pid_of_process/maps</code>文件, 可以检验这些内存区域.需要注意, 一个段可能包含多个区域, 比如: 在 mmap 段中, 每个内存映射文件通常有独立的区域; 动态链接库有额外类似 BSS 和 Data 段的区域.</p>
<p>你可以通过<code>nm</code> 或者 <code>objdump</code>命令打印符号, 地址, 段等信息, 来检测二进制影像文件.最后, 在 Linux 系统中, 上面虚拟内存的分布是动态分布, 这已经作为默认规则很多年了.他假设我们有一个数值<code>RLIMIT_STACK</code>. 当不是这种状态的时候, Linux 系统退回到经典的分布方式如下图:</p>
<p><img src="http://static.duartes.org/img/blogPosts/linuxClassicAddressSpaceLayout.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/">翻译子</a></p>
<h2 id="程序在内存中分布">程序在内存中分布</h2><p>内存管理是操作系统的核心. 对系统和编程人员来说这都是非常重要的.下面用 32位 系统举例.首先介绍程序如何在内存中分布.</p>
<h3 id="虚拟地址空间">虚拟地址空间</h3><p>在多任务操作系统中, 每个进程拥有自己独立的内存沙箱. 这个沙箱就是指的<code>虚拟地址空间</code>(virtual address space), 在32位系统中, 就是一块4GB 大小的内存地址块. 这些虚拟地址和物理内存通过<code>page tables</code>来完成映射, <code>page tables</code>是由系统核心管理,进程可以进行访问. 一旦虚拟地址被启用, 会应用到所有的程序中, 包括系统核心. 因此虚拟地址的一部分, 需要被划分出来为系统核心保留使用.<br><img src="http://static.duartes.org/img/blogPosts/kernelUserMemorySplit.png" alt=""></p>
<p>这并不意味着核心会固定占用大量的物理内存, 而是说核心需要按照需要动态映射到足够的物理内存即可.核心空间在 <code>page tables</code>中被标记为被<code>特权码(privilege code)</code>独占, 因此如果用户程序尝试访问此空间, <code>页面错误</code>会被出发并抛出. 在 linux 系统中, 核心空间是常驻内存的, 并且所有程序的核心空间是共享的, 总是映射到同一块物理内存. 核心代码和数据,总是可访问, 并随时准备处理<code>interrupts</code> 或者 系统调用. 相对的用户程序空间块是每个程序独享的, 并在程序切换时, 而随之切换.</p>
<p><img src="http://static.duartes.org/img/blogPosts/virtualMemoryInProcessSwitch.png" alt=""></p>
<p>上图中蓝色区域标示, 虚拟地址已经完成映射到实际地址, 白色区域代表还没有完成映射.上例中, 以内存消耗多著名的火狐使用了更多的虚拟地址. 在内存地址中不同的区块代表了不同的内存段: heap, stack, 等等.请注意这些内存段只是简单的内存地址范围, 与<code>Intel-style segments</code>无关. 下面是linux 系统中标准段分布图:</p>
<p><img src="http://static.duartes.org/img/blogPosts/linuxFlexibleAddressSpaceLayout.png" alt=""><br>]]>
    
    </summary>
    
      <category term="BSS" scheme="http://ytlvy.com/tags/BSS/"/>
    
      <category term="DATA" scheme="http://ytlvy.com/tags/DATA/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/tags/IOS/"/>
    
      <category term="Memory" scheme="http://ytlvy.com/tags/Memory/"/>
    
      <category term="Text" scheme="http://ytlvy.com/tags/Text/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[what happen before main]]></title>
    <link href="http://ytlvy.com/2015/07/06/what-happen-before-main/"/>
    <id>http://ytlvy.com/2015/07/06/what-happen-before-main/</id>
    <published>2015-07-06T13:20:25.000Z</published>
    <updated>2015-07-13T14:03:56.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://blog.sunnyxx.com/2014/08/30/objc-pre-main/" target="_blank" rel="external">转自</a></p>
<h2 id="iOS程序main函数之前发生了什么">iOS程序main函数之前发生了什么</h2><h3 id="前言">前言</h3><p>一个iOS app的<code>main()</code>函数位于<code>main.m</code>中，这是我们熟知的程序入口。但对objc了解更多之后发现，程序在进入我们的main函数前已经执行了很多代码，比如熟知的<code>+ load</code>方法等。本文将跟随程序执行顺序，刨根问底，从<code>dyld</code>到<code>runtime</code>，看看main函数之前都发生了什么。</p>
<h3 id="从dyld开始">从dyld开始</h3><h4 id="动态链接库">动态链接库</h4><p>iOS中用到的所有系统<code>framework</code>都是动态链接的，类比成插头和插排，静态链接的代码在编译后的静态链接过程就将插头和插排一个个插好，运行时直接执行二进制文件；而动态链接需要在程序启动时去完成“插插销”的过程，所以在我们写的代码执行前，动态连接器需要完成准备工作。</p>
<p>这个是在xcode中看到的Link列表：<br><img src="http://ww4.sinaimg.cn/mw600/51530583jw1ejx4ul5susj20wg0803zh.jpg" alt=""><br><a id="more"></a><br>这些<code>framework</code>将会在动态链接过程中被加载，另外还有隐含<code>link</code>的<code>framework</code>，可以测试出来：先找到可执行文件，我这里叫TestMain的工程，模拟器路径下找到<code>TestMain.app</code>，可执行文件默认同名，再通过<code>otool</code>命令：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>otool -<span class="constant">L TestMain</span></span><br></pre></td></tr></table></figure></p>
<p>-L参数打印出所有link的framework<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">TestMain:</span></span><br><span class="line">    <span class="regexp">/System/</span>Library<span class="regexp">/Frameworks/</span>CoreGraphics.framework/CoreGraphics </span><br><span class="line">    <span class="regexp">/System/</span>Library<span class="regexp">/Frameworks/</span>UIKit.framework/UIKit</span><br><span class="line">    <span class="regexp">/System/</span>Library<span class="regexp">/Frameworks/</span>Foundation.framework/Foundation</span><br><span class="line">    <span class="regexp">/System/</span>Library<span class="regexp">/Frameworks/</span>CoreFoundation.framework/CoreFoundation </span><br><span class="line">    <span class="regexp">/usr/</span>lib/libobjc.A.dylib </span><br><span class="line">    <span class="regexp">/usr/</span>lib/libSystem.dylib</span><br></pre></td></tr></table></figure></p>
<p>除了多了的<code>CoreGraphics</code>（被<code>UIKit</code>依赖）外，有两个默认添加的<code>lib</code>。<code>libobjc</code>即<code>objc</code>和<code>runtime</code>，<code>libSystem</code>中包含了很多系统级别<code>lib</code>，列几个熟知的：<code>libdispatch(GCD)</code>，<code>libsystem_c(C语言库)</code>，<code>libsystem_blocks(Block)</code>，<code>libcommonCrypto</code>(常用的md5函数)等等。这些lib都是dylib格式（如windows中的dll），系统使用动态链接有几点好处：</p>
<ul>
<li>代码共用：很多程序都动态链接了这些lib，但它们在内存和磁盘中中只有一份</li>
<li>易于维护：由于被依赖的lib是程序执行时才link的，所以这些lib很容易做更新，比如<code>libSystem.dylib</code>是<code>libSystem.B.dylib</code>的替身，哪天想升级直接换成<code>libSystem.C.dylib</code>然后再替换替身就行了</li>
<li>减少可执行文件体积：相比静态链接，可执行文件的体积要小很多</li>
</ul>
<h3 id="dyld">dyld</h3><p><code>dyld</code> - <code>the dynamic link editor</code> apple的动态链接器，系统<code>kernel</code>做好启动程序的初始准备后，交给dyld负责，援引并翻译<a href="https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html" target="_blank" rel="external">《mikeask这篇blog》</a>对dyld作用顺序的概括</p>
<ol>
<li>从kernel留下的原始调用栈引导和启动自己</li>
<li>将程序依赖的动态链接库递归加载进内存，当然这里有<code>缓存机制</code></li>
<li>non-lazy符号立即link到可执行文件，lazy的存表里</li>
<li>Runs static initializers for the executable</li>
<li>找到可执行文件的main函数，准备参数并调用</li>
<li>程序执行中负责绑定lazy符号、提供runtime dynamic loading services、提供调试器接口</li>
<li>程序main函数return后执行static terminator</li>
<li>某些场景下main函数结束后调libSystem的_exit函数</li>
</ol>
<p>得益于dyld是开源的，<img src="https://github.com/opensource-apple/dyld" alt="github地址">，我们可以从源码一探究竟。</p>
<p>一切源于<code>dyldStartup.s</code>这个文件，其中用汇编实现了名为<code>__dyld_start</code>的方法，汇编太生涩，它主要干了两件事：</p>
<ol>
<li>调用dyldbootstrap::start()方法（省去参数）</li>
<li>上个方法返回了main函数地址，填入参数并调用main函数</li>
</ol>
<p>这个步骤随手就能验证出来，设置一个符号断点断在_objc_init：<br><img src="http://ww1.sinaimg.cn/mw600/51530583jw1ejxgn8un3cj20oo09675i.jpg" alt=""></p>
<p>这个函数是<code>runtime</code>的初始化函数，后面会提到。程序运行在很早的时候断住，这时候看调用栈：</p>
<p><img src="http://ww3.sinaimg.cn/mw600/51530583jw1ejxgwiptytj20jw0f0q5r.jpg" alt=""></p>
<p>看到了栈底的<code>dyldbootstrap::start()</code>方法，继而调用了<code>dyld::_main()</code>方法，其中完成了刚才说的递归加载动态库过程，由于<code>libSystem</code>默认引入，栈中出现了<code>libSystem_initializer</code>的初始化方法。</p>
<h3 id="ImageLoader">ImageLoader</h3><p>当然这个<code>image</code>不是图片的意思，它大概表示一个二进制文件（可执行文件或so文件），里面是被编译过的符号、代码等，所以<code>ImageLoader</code>作用是将这些文件加载进内存，且每一个文件对应一个I<code>mageLoader</code>实例来负责加载。<br>两步走：</p>
<ol>
<li>在程序运行时它先将动态链接的image递归加载 （也就是上面测试栈中一串的递归调用的时刻）</li>
<li>再从可执行文件image递归加载所有符号</li>
</ol>
<p>当然所有这些都发生在我们真正的main函数执行前。</p>
<hr>
<h3 id="runtime与+load">runtime与+load</h3><p>刚才讲到<code>libSystem</code>是若干个系统<code>lib</code>的集合，所以它只是一个容器<code>lib</code>而已，而且它也是开源的，里面实质上就一个文件，<code>init.c</code>，细节不说了，由<code>libSystem_initializer</code>逐步调用到了<code>_objc_init</code>，这里就是objc和runtime的初始化入口。</p>
<p>除了runtime环境的初始化外，_objc_init中绑定了新image被加载后的callback：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dyld_register_image_state_change_handler<span class="list">(<span class="keyword">dyld_image_state_bound</span>,</span><br><span class="line">                                             <span class="number">1</span>/*batch*/, <span class="keyword">&amp;map_images</span>)</span><span class="comment">;</span></span><br><span class="line">dyld_register_image_state_change_handler<span class="list">(<span class="keyword">dyld_image_state_dependents_initialized</span>, <span class="number">0</span>/*not batch*/, <span class="keyword">&amp;load_images</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>可见dyld担当了<code>runtime</code>和<code>ImageLoader</code>中间的协调者，当新<code>image</code>加载进来后交由<code>runtime</code>大厨去解析这个二进制文件的符号表和代码。继续上面的断点法，断住神秘的+load函数：<br><img src="http://ww1.sinaimg.cn/mw690/51530583jw1ejyjgvetq1j20jk0bc0uf.jpg" alt=""></p>
<p>清楚的看到整个调用栈和顺序：</p>
<ol>
<li>dyld开始将程序二进制文件初始化</li>
<li>交由ImageLoader读取image，其中包含了我们的类、方法等各种符号</li>
<li>由于runtime向dyld绑定了回调，当image加载到内存后，dyld会通知runtime进行处理</li>
<li>runtime接手后调用map_images做解析和处理，接下来load_images中调用call_load_methods方法，遍历所有加载进来的Class，按继承层级依次调用Class的load方法和其Category的load方法</li>
</ol>
<p>至此，可执行文件中和动态库所有的符号（Class，Protocol，Selector，IMP，…）都已经按格式成功加载到内存中，被runtime所管理，再这之后，runtime的那些方法（动态添加Class、方法混合等等才能生效）</p>
<h4 id="关于load方法的几个QA">关于load方法的几个QA</h4><p>Q: 重载自己Class的load方法时需不需要调父类？<br>A: runtime负责按继承顺序递归调用，所以我们不能调super</p>
<p>Q: 在自己Class的load方法时能不能替换系统framework（比如UIKit）中的某个类的方法实现<br>A: 可以，因为动态链接过程中，所有依赖库的类是先于自己的类加载的</p>
<p>Q: 重载load时需要手动添加@autoreleasepool么？<br>A: 不需要，在runtime调用load方法前后是加了objc_autoreleasePoolPush()和objc_autoreleasePoolPop()的。</p>
<p>Q: 想让一个类的load方法被调用是否需要在某个地方import这个文件<br>A: 不需要，只要这个类的符号被编译到最后的可执行文件中，load方法就会被调用（Reveal SDK就是利用这一点，只要引入到工程中就能工作）</p>
<hr>
<h2 id="简单总结">简单总结</h2><p>整个事件由dyld主导，完成运行环境的初始化后，配合ImageLoader将二进制文件按格式加载到内存， 动态链接依赖库，并由runtime负责加载成objc定义的结构，所有初始化工作结束后，dyld调用真正的main函数。</p>
<p>值得说明的是，这个过程远比写出来的要复杂，这里只提到了runtime这个分支，还有像GCD、XPC等重头的系统库初始化分支没有提及（当然，有缓存机制在，它们也不会玩命初始化），总结起来就是main函数执行之前，系统做了茫茫多的加载和初始化工作，但都被很好的隐藏了，我们无需关心。</p>
<h3 id="孤独的main函数">孤独的main函数</h3><p>当这一切都结束时，dyld会清理现场，将调用栈回归，只剩下：<br><img src="http://ww3.sinaimg.cn/mw690/51530583jw1ejykutdlvsj20fc02smx9.jpg" alt=""></p>
<p>孤独的main函数，看上去是程序的开始，确是一段精彩的终结</p>
<h3 id="References">References</h3><p><a href="https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html" target="_blank" rel="external">https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html</a><br><a href="http://newosxbook.com/articles/DYLD.html" target="_blank" rel="external">http://newosxbook.com/articles/DYLD.html</a><br><a href="http://docstore.mik.ua/orelly/unix3/mac/ch05_02.htm" target="_blank" rel="external">http://docstore.mik.ua/orelly/unix3/mac/ch05_02.htm</a><br><a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/dyld.1.html" target="_blank" rel="external">https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/dyld.1.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://blog.sunnyxx.com/2014/08/30/objc-pre-main/">转自</a></p>
<h2 id="iOS程序main函数之前发生了什么">iOS程序main函数之前发生了什么</h2><h3 id="前言">前言</h3><p>一个iOS app的<code>main()</code>函数位于<code>main.m</code>中，这是我们熟知的程序入口。但对objc了解更多之后发现，程序在进入我们的main函数前已经执行了很多代码，比如熟知的<code>+ load</code>方法等。本文将跟随程序执行顺序，刨根问底，从<code>dyld</code>到<code>runtime</code>，看看main函数之前都发生了什么。</p>
<h3 id="从dyld开始">从dyld开始</h3><h4 id="动态链接库">动态链接库</h4><p>iOS中用到的所有系统<code>framework</code>都是动态链接的，类比成插头和插排，静态链接的代码在编译后的静态链接过程就将插头和插排一个个插好，运行时直接执行二进制文件；而动态链接需要在程序启动时去完成“插插销”的过程，所以在我们写的代码执行前，动态连接器需要完成准备工作。</p>
<p>这个是在xcode中看到的Link列表：<br><img src="http://ww4.sinaimg.cn/mw600/51530583jw1ejx4ul5susj20wg0803zh.jpg" alt=""><br>]]>
    
    </summary>
    
      <category term="IOS" scheme="http://ytlvy.com/tags/IOS/"/>
    
      <category term="dyld" scheme="http://ytlvy.com/tags/dyld/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Autorelease]]></title>
    <link href="http://ytlvy.com/2015/07/06/Autorelease/"/>
    <id>http://ytlvy.com/2015/07/06/Autorelease/</id>
    <published>2015-07-06T13:18:42.000Z</published>
    <updated>2015-07-13T14:04:39.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Autorelease">Autorelease</h2><p><img src="http://blog.sunnyxx.com/tags/objc%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95/page/3/" alt="转自"></p>
<h3 id="Autorelease对象什么时候释放">Autorelease对象什么时候释放</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;在没有手加Autorelease Pool的情况下，Autorelease对象是在当前的runloop迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop</p>
<p>小实验<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">id</span> reference = <span class="literal">nil</span>;</span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="built_in">NSString</span> *str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"sunnyxx"</span>];</span><br><span class="line">    <span class="comment">// str是一个autorelease对象，设置一个weak的引用来观察它</span></span><br><span class="line">    reference = str;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillAppear:animated];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, reference); <span class="comment">// Console: sunnyxx</span></span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)viewDidAppear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidAppear:animated];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, reference); <span class="comment">// Console: (null)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于这个vc在loadView之后便add到了window层级上，所以viewDidLoad和viewWillAppear是在同一个runloop调用的，因此在viewWillAppear中，这个autorelease的变量依然有值。<br><a id="more"></a></p>
<h3 id="手动干预Autorelease对象的释放时机：">手动干预Autorelease对象的释放时机：</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"sunnyxx"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str); <span class="comment">// Console: (null)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Autorelease原理">Autorelease原理</h3><p>ARC下，我们使用@autoreleasepool{}来使用一个AutoreleasePool，随后编译器将其改写成下面的样子：<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void <span class="built_in">*</span>context = objc_autoreleasePoolPush<span class="params">()</span>;</span><br><span class="line"><span class="comment">// &#123;&#125;中的代码</span></span><br><span class="line">objc_autoreleasePoolPop<span class="params">(context)</span>;</span><br></pre></td></tr></table></figure></p>
<p>而这两个函数都是对<code>AutoreleasePoolPage</code>的简单封装，所以自动释放机制的核心就在于这个类。</p>
<p><code>AutoreleasePoolPage</code>是一个C++实现的类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AutoreleasePoolPage&#123;</span><br><span class="line">    <span class="keyword">magic_t</span> <span class="keyword">const</span> magic;</span><br><span class="line">    id *next;</span><br><span class="line">    <span class="keyword">pthread_t</span> <span class="keyword">const</span> thread;</span><br><span class="line">    AutoreleasePoolPage *<span class="keyword">const</span> parent;</span><br><span class="line">    AutoreleasePoolPage *child;</span><br><span class="line">    <span class="keyword">uint32_t</span> <span class="keyword">const</span> depth;</span><br><span class="line">    <span class="keyword">uint32_t</span> hiwat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>AutoreleasePool</code>并没有单独的结构，而是由若干个<code>AutoreleasePoolPage</code>以双向链表的形式组合而成（分别对应结构中的<code>parent</code>指针和<code>child</code>指针）</li>
<li><code>AutoreleasePool</code>是按线程一一对应的（结构中的thread指针指向当前线程）</li>
<li><code>AutoreleasePoolPage</code>每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存<code>autorelease</code>对象的地址</li>
<li>上面的<code>id *next</code>指针作为游标指向栈顶最新<code>add</code>进来的<code>autorelease</code>对象的下一个位置</li>
<li>一个<code>AutoreleasePoolPage</code>的空间被占满时，会新建一个<code>AutoreleasePoolPage</code>对象，连接链表，后来的<code>autorelease</code>对象在新的page加入</li>
</ol>
<p>所以，若当前线程中只有一个<code>AutoreleasePoolPage</code>对象，并记录了很多<code>autorelease</code>对象地址时内存如下图：</p>
<p><img src="http://ww2.sinaimg.cn/mw690/51530583gw1elj5gvphtqj20dy0cx756.jpg" alt=""></p>
<p>图中的情况，这一页再加入一个autorelease对象就要满了（也就是next指针马上指向栈顶），这时就要执行上面说的操作，建立下一页page对象，与这一页链表连接完成后，新page的next指针被初始化在栈底（begin的位置），然后继续向栈顶添加新对象。</p>
<p>所以，向一个对象发送- autorelease消息，就是将这个对象加入到当前AutoreleasePoolPage的栈顶next指针指向的位置</p>
<h3 id="释放时刻">释放时刻</h3><p>每当进行一次<code>objc_autoreleasePoolPush</code>调用时，runtime向当前的<code>AutoreleasePoolPage</code>中<code>add</code>进一个哨兵对象，值为0（也就是个nil），那么这一个<code>page</code>就变成了下面的样子：</p>
<p><img src="http://ww2.sinaimg.cn/large/51530583gw1elj5z7hawej20ji0dewff.jpg" alt=""></p>
<p><code>objc_autoreleasePoolPush</code>的返回值正是这个哨兵对象的地址，被<code>objc_autoreleasePoolPop</code>(哨兵对象)作为入参，于是：</p>
<ol>
<li>根据传入的哨兵对象地址找到哨兵对象所处的page</li>
<li>在当前page中，将晚于哨兵对象插入的所有<code>autorelease</code>对象都发送一次- <code>release</code>消息，并向回移动<code>next</code>指针到正确位置</li>
<li>补充2：从最新加入的对象一直向前清理，可以向前跨越若干个page，直到哨兵所在的page</li>
</ol>
<p>刚才的objc_autoreleasePoolPop执行后，最终变成了下面的样子:<br><img src="http://ww3.sinaimg.cn/mw690/51530583gw1elj6u2i3fyj20dz0bqdgi.jpg" alt=""></p>
<h3 id="嵌套的AutoreleasePool">嵌套的AutoreleasePool</h3><p>知道了上面的原理，嵌套的AutoreleasePool就非常简单了，pop的时候总会释放到上次push的位置为止，多层的pool就是多个哨兵对象而已，就像剥洋葱一样，每次一层，互不影响。</p>
<h3 id="Autorelease返回值的快速释放机制">Autorelease返回值的快速释放机制</h3><p>值得一提的是，ARC下，runtime有一套对autorelease返回值的优化策略。<br>比如一个工厂方法：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)createSark &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> <span class="keyword">new</span>]; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// caller</span></span><br><span class="line">Sark *sark = [Sark createSark];</span><br></pre></td></tr></table></figure>
<p>秉着谁创建谁释放的原则，返回值需要是一个<code>autorelease</code>对象才能配合调用方正确管理内存，于是乎编译器改写成了形如下面的代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)createSark &#123;</span><br><span class="line">    <span class="keyword">id</span> tmp = [<span class="keyword">self</span> new];</span><br><span class="line">    <span class="keyword">return</span> objc_autoreleaseReturnValue(tmp); <span class="comment">// 代替我们调用autorelease</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// caller</span></span><br><span class="line"><span class="keyword">id</span> tmp = objc_retainAutoreleasedReturnValue([Sark createSark]) <span class="comment">// 代替我们调用retain</span></span><br><span class="line">Sark *sark = tmp;</span><br><span class="line">objc_storeStrong(&amp;sark, <span class="literal">nil</span>); <span class="comment">// 相当于代替我们调用了release</span></span><br></pre></td></tr></table></figure>
<p>一切看上去都很好，不过既然编译器知道了这么多信息，干嘛还要劳烦autorelease这个开销不小的机制呢？于是乎，runtime使用了一些黑魔法将这个问题解决了</p>
<h4 id="黑魔法之Thread_Local_Storage">黑魔法之Thread Local Storage</h4><p><code>Thread Local Storage（TLS）</code>线程局部存储，目的很简单，将一块内存作为某个线程专有的存储，以<code>key-value</code>的形式进行读写，比如在非arm架构下，使用<code>pthread</code>提供的方法实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* pthread_getspecific(<span class="keyword">pthread_key_t</span>);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setspecific</span><span class="params">(pthread_key_t , <span class="keyword">const</span> <span class="keyword">void</span> *)</span></span>;</span><br></pre></td></tr></table></figure>
<p>说它是黑魔法可能被懂pthread的笑话- -</p>
<p>在返回值身上调用<code>objc_autoreleaseReturnValue</code>方法时，<code>runtime</code>将这个返回值<code>object</code>储存在TLS中，然后直接返回这个<code>object</code>（不调用<code>autorelease</code>）；同时，在外部接收这个返回值的<code>objc_retainAutoreleasedReturnValue</code>里，发现TLS中正好存了这个对象，那么直接返回这个<code>object</code>（不调用<code>retain</code>）。<br>于是乎，调用方和被调方利用TLS做中转，很有默契的免去了对返回值的内存管理。</p>
<p>于是问题又来了，假如被调方和主调方只有一边是ARC环境编译的该咋办？（比如我们在ARC环境下用了非ARC编译的第三方库，或者反之）<br>只能动用更高级的黑魔法。</p>
<h4 id="黑魔法之__builtin_return_address">黑魔法之__builtin_return_address</h4><p>这个内建函数原型是<code>char *__builtin_return_address(int level)</code>，作用是得到函数的返回地址，参数表示层数，如<code>__builtin_return_address(0)</code>表示当前函数体返回地址，传1是调用这个函数的外层函数的返回值地址，以此类推。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">int</span>)foo &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%p"</span>, __builtin_return_address(<span class="number">0</span>)); <span class="comment">// 根据这个地址能找到下面ret的地址</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// caller</span></span><br><span class="line"><span class="keyword">int</span> ret = [sark foo];</span><br></pre></td></tr></table></figure>
<p>看上去也没啥厉害的，不过要知道，函数的返回值地址，也就对应着调用者结束这次调用的地址（或者相差某个固定的偏移量，根据编译器决定）</p>
<p>也就是说，被调用的函数也有翻身做地主的机会了，可以反过来对主调方干点坏事。<br>回到上面的问题，<strong><em>如果一个函数返回前知道调用方是ARC还是非ARC，就有机会对于不同情况做不同的处理</em></strong></p>
<h4 id="黑魔法之反查汇编指令">黑魔法之反查汇编指令</h4><p>通过上面的__builtin_return_address加某些偏移量，被调方可以定位到主调方在返回值后面的<code>汇编指令</code>：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// caller </span></span><br><span class="line"><span class="keyword">int</span> ret = [sark foo];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存中接下来的汇编指令（x86，我不懂汇编，瞎写的）</span></span><br><span class="line">movq ??? ???</span><br><span class="line">callq ???</span><br></pre></td></tr></table></figure></p>
<p>而这些汇编指令在内存中的值是固定的，比如movq对应着0x48。<br>于是乎，就有了下面的这个函数，入参是调用方<code>__builtin_return_address</code>传入值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">callerAcceptsFastAutorelease</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> * <span class="keyword">const</span> ra0)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> *ra1 = (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)ra0;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint16_t</span> *ra2;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> *ra4 = (<span class="keyword">const</span> <span class="keyword">uint32_t</span> *)ra1;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> **sym;</span><br><span class="line">    <span class="comment">// 48 89 c7    movq  %rax,%rdi</span></span><br><span class="line">    <span class="comment">// e8          callq symbol</span></span><br><span class="line">    <span class="keyword">if</span> (*ra4 != <span class="number">0xe8c78948</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ra1 += (<span class="keyword">long</span>)*(<span class="keyword">const</span> <span class="keyword">int32_t</span> *)(ra1 + <span class="number">4</span>) + <span class="number">8l</span>;</span><br><span class="line">    ra2 = (<span class="keyword">const</span> <span class="keyword">uint16_t</span> *)ra1;</span><br><span class="line">    <span class="comment">// ff 25       jmpq *symbol@DYLDMAGIC(%rip)</span></span><br><span class="line">    <span class="keyword">if</span> (*ra2 != <span class="number">0x25ff</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ra1 += <span class="number">6l</span> + (<span class="keyword">long</span>)*(<span class="keyword">const</span> <span class="keyword">int32_t</span> *)(ra1 + <span class="number">2</span>);</span><br><span class="line">    sym = (<span class="keyword">const</span> <span class="keyword">void</span> **)ra1;</span><br><span class="line">    <span class="keyword">if</span> (*sym != objc_retainAutoreleasedReturnValue)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它检验了主调方在返回值之后是否紧接着调用了<code>objc_retainAutoreleasedReturnValue</code>，如果是，就知道了外部是ARC环境，反之就走没被优化的老逻辑。</p>
<h3 id="其他Autorelease相关知识点">其他Autorelease相关知识点</h3><p>使用容器的block版本的枚举器时，内部会自动添加一个AutoreleasePool：<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[array enumerateObjectsUsingBlock:^<span class="list">(<span class="keyword">id</span> obj, NSUInteger idx, BOOL *stop)</span> <span class="collection">&#123;</span><br><span class="line">    // 这里被一个局部@autoreleasepool包围着</span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>当然，在普通for循环和for in循环中没有，所以，还是新版的block版本枚举器更加方便。for循环中遍历产生大量autorelease变量时，就需要手加局部<code>AutoreleasePool</code>咯。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Autorelease">Autorelease</h2><p><img src="http://blog.sunnyxx.com/tags/objc%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95/page/3/" alt="转自"></p>
<h3 id="Autorelease对象什么时候释放">Autorelease对象什么时候释放</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;在没有手加Autorelease Pool的情况下，Autorelease对象是在当前的runloop迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop</p>
<p>小实验<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">id</span> reference = <span class="literal">nil</span>;</span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="built_in">NSString</span> *str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"sunnyxx"</span>];</span><br><span class="line">    <span class="comment">// str是一个autorelease对象，设置一个weak的引用来观察它</span></span><br><span class="line">    reference = str;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillAppear:animated];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, reference); <span class="comment">// Console: sunnyxx</span></span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)viewDidAppear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidAppear:animated];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, reference); <span class="comment">// Console: (null)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于这个vc在loadView之后便add到了window层级上，所以viewDidLoad和viewWillAppear是在同一个runloop调用的，因此在viewWillAppear中，这个autorelease的变量依然有值。<br>]]>
    
    </summary>
    
      <category term="Autorelease" scheme="http://ytlvy.com/tags/Autorelease/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/tags/IOS/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IOS 进阶工具篇]]></title>
    <link href="http://ytlvy.com/2015/07/04/IOS-%E8%BF%9B%E9%98%B6%E5%B7%A5%E5%85%B7%E7%AF%87/"/>
    <id>http://ytlvy.com/2015/07/04/IOS-进阶工具篇/</id>
    <published>2015-07-04T10:26:58.000Z</published>
    <updated>2015-07-13T14:05:07.000Z</updated>
    <content type="html"><![CDATA[<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">第一部分：<span class="tag">iOS</span> 开发工具</span><br><span class="line">第2章使用<span class="tag">CocoaPods</span> 做依赖管理</span><br><span class="line">2<span class="class">.1</span> <span class="tag">CocoaPods</span> 简介</span><br><span class="line">2<span class="class">.2</span> <span class="tag">CocoaPods</span> 的安装和使用</span><br><span class="line">2<span class="class">.2</span><span class="class">.1</span> <span class="tag">CocoaPods</span> 的安装</span><br><span class="line">2<span class="class">.2</span><span class="class">.2</span> 使用<span class="tag">CocoaPods</span> 的镜像索引</span><br><span class="line">2<span class="class">.2</span><span class="class">.3</span> 使用<span class="tag">CocoaPods</span></span><br><span class="line">2<span class="class">.2</span><span class="class">.4</span> 查找第三方库</span><br><span class="line">2<span class="class">.3</span> 注意事项</span><br><span class="line">2<span class="class">.3</span><span class="class">.1</span> 关于<span class="class">.gitignore</span></span><br><span class="line">2<span class="class">.3</span><span class="class">.2</span> 为自己的项目创建<span class="tag">podspec</span> 文件</span><br><span class="line">2<span class="class">.3</span><span class="class">.3</span> 使用私有的<span class="tag">pods</span></span><br><span class="line">2<span class="class">.3</span><span class="class">.4</span> 不更新<span class="tag">podspec</span></span><br><span class="line">2<span class="class">.3</span><span class="class">.5</span> 生成第三方库的帮助文档</span><br><span class="line">2<span class="class">.3</span><span class="class">.6</span> 原理</span><br><span class="line">第3章网络封包分析工具<span class="tag">Charles</span></span><br><span class="line">3<span class="class">.1</span> <span class="tag">Charles</span> 简介</span><br><span class="line">3<span class="class">.2</span> <span class="tag">Charles</span> 的安装和使用</span><br><span class="line">3<span class="class">.2</span><span class="class">.1</span> 安装<span class="tag">Charles</span></span><br><span class="line">3<span class="class">.2</span><span class="class">.2</span> 安装<span class="tag">SSL</span> 证书</span><br><span class="line">3<span class="class">.2</span><span class="class">.3</span> 将<span class="tag">Charles</span> 设置成系统代理</span><br><span class="line">3<span class="class">.2</span><span class="class">.4</span> <span class="tag">Charles</span> 主界面介绍</span><br><span class="line">3<span class="class">.2</span><span class="class">.5</span> 过滤网络请求</span><br><span class="line">3<span class="class">.3</span> 使用<span class="tag">Charles</span> 协助<span class="tag">iOS</span> 开发</span><br><span class="line">3<span class="class">.3</span><span class="class">.1</span> 截取<span class="tag">iPhone</span> 上的网络封包</span><br><span class="line">3<span class="class">.3</span><span class="class">.2</span> 模拟慢速网络</span><br><span class="line">3<span class="class">.4</span> 高级功能</span><br><span class="line">3<span class="class">.4</span><span class="class">.1</span> 截取<span class="tag">SSL</span> 信息</span><br><span class="line">3<span class="class">.4</span><span class="class">.2</span> 修改网络请求内容</span><br><span class="line">3<span class="class">.4</span><span class="class">.3</span> 修改服务器返回内容</span><br><span class="line">3<span class="class">.5</span> <span class="tag">Map</span> 功能</span><br><span class="line">3<span class="class">.6</span> <span class="tag">Rewrite</span> 功能</span><br><span class="line">3<span class="class">.7</span> <span class="tag">Breakpoints</span> 功能</span><br><span class="line">3<span class="class">.8</span> 总结</span><br><span class="line">3<span class="class">.9</span> 参考链接</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">第4章界面调试工具<span class="tag">Reveal</span></span><br><span class="line">4<span class="class">.1</span> <span class="tag">Reveal</span> 简介</span><br><span class="line">4<span class="class">.2</span> <span class="tag">Reveal</span> 的使用</span><br><span class="line">4<span class="class">.2</span><span class="class">.1</span> 用<span class="tag">Reveal</span> 连接模拟器调试</span><br><span class="line">4<span class="class">.2</span><span class="class">.2</span> 用<span class="tag">Reveal</span> 连接真机调试</span><br><span class="line">4<span class="class">.2</span><span class="class">.3</span> 用<span class="tag">Reveal</span> 调试其他应用界面</span><br><span class="line">4<span class="class">.2</span><span class="class">.4</span> 总结</span><br><span class="line">4<span class="class">.2</span><span class="class">.5</span> 参考资料</span><br><span class="line">第5章移动统计工具<span class="tag">Flurry</span></span><br><span class="line">5<span class="class">.1</span> <span class="tag">Flurry</span> 简介</span><br><span class="line">5<span class="class">.2</span> <span class="tag">Flurry</span> 的基本使用</span><br><span class="line">5<span class="class">.2</span><span class="class">.1</span> 注册和下载对应<span class="tag">SDK</span></span><br><span class="line">5<span class="class">.2</span><span class="class">.2</span> 集成<span class="tag">SDK</span></span><br><span class="line">5<span class="class">.2</span><span class="class">.3</span> 自定义统计项</span><br><span class="line">5<span class="class">.2</span><span class="class">.4</span> 查看统计结果</span><br><span class="line">5<span class="class">.2</span><span class="class">.5</span> 统计<span class="tag">Crashlog</span></span><br><span class="line">5<span class="class">.3</span> 对比和总结</span><br><span class="line">5<span class="class">.3</span><span class="class">.1</span> 和其他统计分析平台的对比</span><br><span class="line">5<span class="class">.3</span><span class="class">.2</span> 总结</span><br><span class="line">第6章崩溃日志记录工具<span class="tag">Crashlytics</span></span><br><span class="line">6<span class="class">.1</span> <span class="tag">Crashlytics</span> 简介</span><br><span class="line">6<span class="class">.2</span> <span class="tag">Crashlytics</span> 的使用</span><br><span class="line">6<span class="class">.3</span> 实现原理和使用体会</span><br><span class="line">第7章<span class="tag">App</span> <span class="tag">Store</span> 统计工具<span class="tag">App</span> <span class="tag">Annie</span></span><br><span class="line">7<span class="class">.1</span> <span class="tag">App</span> <span class="tag">Annie</span> 简介</span><br><span class="line">7<span class="class">.2</span> <span class="tag">App</span> <span class="tag">Annie</span> 的使用</span><br><span class="line">7<span class="class">.3</span> <span class="tag">App</span> <span class="tag">Annie</span> 账号的注册及配置</span><br><span class="line">7<span class="class">.4</span> 和其他工具的对比</span><br><span class="line">7<span class="class">.4</span><span class="class">.1</span> 官方的命令行工具</span><br><span class="line">7<span class="class">.4</span><span class="class">.2</span> 其他类似服务</span><br><span class="line">7<span class="class">.4</span><span class="class">.3</span> 功能对比</span><br><span class="line">第8章<span class="tag">Xcode</span> 插件</span><br><span class="line">8<span class="class">.1</span> <span class="tag">Xcode</span> 插件管理工具<span class="tag">Alcatraz</span></span><br><span class="line">8<span class="class">.1</span><span class="class">.1</span> 简介</span><br><span class="line">8<span class="class">.1</span><span class="class">.2</span> 安装和删除</span><br><span class="line">8<span class="class">.1</span><span class="class">.3</span> 使用</span><br><span class="line">8<span class="class">.1</span><span class="class">.4</span> 插件路径</span><br><span class="line">8<span class="class">.2</span> 关于<span class="tag">Xcode</span> 的插件机制</span><br><span class="line">8<span class="class">.3</span> 常用<span class="tag">Xcode</span> 插件</span><br><span class="line">8<span class="class">.3</span><span class="class">.1</span> <span class="tag">KSImageNamed</span></span><br><span class="line">8<span class="class">.3</span><span class="class">.2</span> <span class="tag">XVim</span></span><br><span class="line">8<span class="class">.3</span><span class="class">.3</span> <span class="tag">FuzzyAutocompletePlugin</span></span><br><span class="line">8<span class="class">.3</span><span class="class">.4</span> <span class="tag">XToDo</span></span><br><span class="line">8<span class="class">.3</span><span class="class">.5</span> <span class="tag">BBUDebuggerTuckAway</span></span><br><span class="line">8<span class="class">.3</span><span class="class">.6</span> <span class="tag">SCXcodeSwitchExpander</span></span><br><span class="line">8<span class="class">.3</span><span class="class">.7</span> <span class="tag">deriveddata-exterminator</span></span><br><span class="line">8<span class="class">.3</span><span class="class">.8</span> <span class="tag">VVDocumenter</span></span><br><span class="line">8<span class="class">.3</span><span class="class">.9</span> <span class="tag">ClangFormat</span></span><br><span class="line">8<span class="class">.3</span><span class="class">.10</span> <span class="tag">ColorSense</span></span><br><span class="line">8<span class="class">.3</span><span class="class">.11</span> <span class="tag">XcodeBoost</span></span><br><span class="line">第9章其他工具介绍</span><br><span class="line">9<span class="class">.1</span> 取色工具：数码测色计（<span class="tag">DigitalColor</span> <span class="tag">Meter</span>）</span><br><span class="line">9<span class="class">.1</span><span class="class">.1</span> 前言</span><br><span class="line">9<span class="class">.1</span><span class="class">.2</span> 使用介绍</span><br><span class="line">9<span class="class">.1</span><span class="class">.3</span> 其他类似工具：<span class="tag">xScope</span></span><br><span class="line">9<span class="class">.2</span> 其他图形工具</span><br><span class="line">9<span class="class">.2</span><span class="class">.1</span> <span class="tag">ImageOptim</span></span><br><span class="line">9<span class="class">.2</span><span class="class">.2</span> 马克鳗</span><br><span class="line">9<span class="class">.2</span><span class="class">.3</span> <span class="tag">Dash</span></span><br><span class="line">9<span class="class">.2</span><span class="class">.4</span> 蒲公英</span><br><span class="line">9<span class="class">.3</span> 命令行工具</span><br><span class="line">9<span class="class">.3</span><span class="class">.1</span> <span class="tag">nomad</span></span><br><span class="line">9<span class="class">.3</span><span class="class">.2</span> <span class="tag">xctool</span></span><br><span class="line">9<span class="class">.3</span><span class="class">.3</span> <span class="tag">appledoc</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">第一部分：<span class="tag">iOS</span> 开发工具</span><br><span class="line">第2章使用<span class="tag">CocoaPods</span> 做依赖管理</span><br><span class="line">2<span class="class">.1</span> <span class="tag">CocoaPods</span> 简介</span><br><span class="line">2<span class="class">.2</span> <span class="tag">CocoaPods</span> 的安装和使用</span><br><span class="line">2<span class="class">.2</span><span class="class">.1</span> <span class="tag">CocoaPods</span> 的安装</span><br><span class="line">2<span class="class">.2</span><span class="class">.2</span> 使用<span class="tag">CocoaPods</span> 的镜像索引</span><br><span class="line">2<span class="class">.2</span><span class="class">.3</span> 使用<span class="tag">CocoaPods</span></span><br><span class="line">2<span class="class">.2</span><span class="class">.4</span> 查找第三方库</span><br><span class="line">2<span class="class">.3</span> 注意事项</span><br><span class="line">2<span class="class">.3</span><span class="class">.1</span> 关于<span class="class">.gitignore</span></span><br><span class="line">2<span class="class">.3</span><span class="class">.2</span> 为自己的项目创建<span class="tag">podspec</span> 文件</span><br><span class="line">2<span class="class">.3</span><span class="class">.3</span> 使用私有的<span class="tag">pods</span></span><br><span class="line">2<span class="class">.3</span><span class="class">.4</span> 不更新<span class="tag">podspec</span></span><br><span class="line">2<span class="class">.3</span><span class="class">.5</span> 生成第三方库的帮助文档</span><br><span class="line">2<span class="class">.3</span><span class="class">.6</span> 原理</span><br><span class="line">第3章网络封包分析工具<span class="tag">Charles</span></span><br><span class="line">3<span class="class">.1</span> <span class="tag">Charles</span> 简介</span><br><span class="line">3<span class="class">.2</span> <span class="tag">Charles</span> 的安装和使用</span><br><span class="line">3<span class="class">.2</span><span class="class">.1</span> 安装<span class="tag">Charles</span></span><br><span class="line">3<span class="class">.2</span><span class="class">.2</span> 安装<span class="tag">SSL</span> 证书</span><br><span class="line">3<span class="class">.2</span><span class="class">.3</span> 将<span class="tag">Charles</span> 设置成系统代理</span><br><span class="line">3<span class="class">.2</span><span class="class">.4</span> <span class="tag">Charles</span> 主界面介绍</span><br><span class="line">3<span class="class">.2</span><span class="class">.5</span> 过滤网络请求</span><br><span class="line">3<span class="class">.3</span> 使用<span class="tag">Charles</span> 协助<span class="tag">iOS</span> 开发</span><br><span class="line">3<span class="class">.3</span><span class="class">.1</span> 截取<span class="tag">iPhone</span> 上的网络封包</span><br><span class="line">3<span class="class">.3</span><span class="class">.2</span> 模拟慢速网络</span><br><span class="line">3<span class="class">.4</span> 高级功能</span><br><span class="line">3<span class="class">.4</span><span class="class">.1</span> 截取<span class="tag">SSL</span> 信息</span><br><span class="line">3<span class="class">.4</span><span class="class">.2</span> 修改网络请求内容</span><br><span class="line">3<span class="class">.4</span><span class="class">.3</span> 修改服务器返回内容</span><br><span class="line">3<span class="class">.5</span> <span class="tag">Map</span> 功能</span><br><span class="line">3<span class="class">.6</span> <span class="tag">Rewrite</span> 功能</span><br><span class="line">3<span class="class">.7</span> <span class="tag">Breakpoints</span> 功能</span><br><span class="line">3<span class="class">.8</span> 总结</span><br><span class="line">3<span class="class">.9</span> 参考链接</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Tool" scheme="http://ytlvy.com/tags/Tool/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Stack And Heap OverFlow]]></title>
    <link href="http://ytlvy.com/2015/07/03/Stack-And-Heap-OverFlow/"/>
    <id>http://ytlvy.com/2015/07/03/Stack-And-Heap-OverFlow/</id>
    <published>2015-07-03T01:44:56.000Z</published>
    <updated>2015-07-13T14:07:41.000Z</updated>
    <content type="html"><![CDATA[<p>翻译自<a href="https://developer.apple.com/library/mac/documentation/Security/Conceptual/SecureCodingGuide/Articles/BufferOverflows.html" target="_blank" rel="external">https://developer.apple.com/library/mac/documentation/Security/Conceptual/SecureCodingGuide/Articles/BufferOverflows.html</a></p>
<h2 id="栈溢出">栈溢出</h2><blockquote>
<p>在大部分操作系统中, 每个程序拥有一个<strong><em>栈</em></strong>(多线程程序,每个线程拥有一个单独的栈), 栈用于局部变量的存储.<br>栈被划分为单元, 此单元被成为帧(frame), 每个帧包含了某个函数的某一调用的全部数据.这些数据包含: 函数参数, 全部的临时变量,和 linkage 信息(就是调用函数的地址. 以便当前代码执行完毕后, 返回原位置继续执行). 通过配置编译参数,也可以包含下一帧的顶部地址.数据的布局以及排序,由操作系统决定,不同系统略有差异.<br>当函数被调用的时候, 一个新的栈帧被添加到栈的顶部. 当函数返回时,顶部的栈帧被移除.在执行过程中, 程序只能直接访问栈顶帧得数据(指针除外, 但是不建议如此设计).这种设计,方便了递归调用的实现, 因为每个子递归调用拥有独立的临时变量和参数备份.<br>下图介绍了栈的组织结构.(这只是示意图, 实际情况要根据 cpu设计来决定)</p>
</blockquote>
<p><img src="https://developer.apple.com/library/mac/documentation/Security/Conceptual/SecureCodingGuide/Art/stack.gif" alt=""><br><a id="more"></a><br><img src="http://d2o58evtke57tz.cloudfront.net/wp-content/uploads/Memory-Layout-300x255.gif" alt="Memory Layout of C Programs"></p>
<blockquote>
<p>通常情况下, 程序应该检测所有的输入数据, 来确认此数据是否符合需求.不幸的是, 很多情况下, 程序员都假定用户输入是没有危害的.<br>当程序需要将数据存入固定大小的 buffer 时, 将发生灾难性后果. 恶意的攻击者可能提供大于存储区大小的数据, 因为函数只是在栈帧中分配了有限的空间, 这个数据会覆盖栈帧中得其他数据.<br>下面的例子, 演示了一个聪明的攻击者,可以通过这个技术来覆盖函数的返回值区域,来指向他自己的代码块.然后当此函数执行完毕,将不会按照原设计返回调用函数 funcB, 而是跳转到了攻击者的恶意代码.</p>
</blockquote>
<p><img src="https://developer.apple.com/library/mac/documentation/Security/Conceptual/SecureCodingGuide/Art/cracked_stack.jpg" alt="Figure 2-2  Stack after malicious buffer overflow"></p>
<p>除了攻击函数执行链( linkage )外, 攻击者可以通过更改临时变量的值,以及函数参数的方式来造成破坏.</p>
<h3 id="个人理解">个人理解</h3><ol>
<li>由于栈是从高地址到低地址(high -&gt; low)增长的</li>
<li><code>main</code> 函数作为入口, 系统调用 main 函数的栈帧(只是部分数据, 因为系统函数的变量等已经入栈不再考虑)将第一个入栈.因此位于栈底,也就是说位于高地址位, 同时位于下图的顶部位置.</li>
<li>此栈帧入栈顺序 <code>main 函数参数列表</code>(逆序入栈) ==&gt; <code>main 函数返回地址</code> (被调用的下一条语句的地址)</li>
<li><code>main</code> 函数栈帧 生成并入栈数据: <code>系统函数 EBP 地址</code>  ==&gt; <code>main 函数临时变量列表</code>(正序入栈)</li>
<li><code>main</code> 调用 <code>test</code> 入栈顺序: <code>test 参数列表</code>(逆序入栈,先入栈最后一个, 方便 EBP 计算获取) ==&gt; <code>test 返回地址</code></li>
<li><code>test</code>函数栈帧 生成并入栈: <code>main 函数 EBP 地址</code> ==&gt; <code>test 临时变量</code>(正序入栈)</li>
</ol>
<h4 id="返回地址和EBP_入栈的意义">返回地址和EBP 入栈的意义</h4><ul>
<li>返回地址用来当前调用执行完毕后, 进行下一代码执行.</li>
<li>EBP需要保留和恢复, 是因为 当前函数的三种主要数据需要依靠 EBP 来计算获得:</li>
<li><strong><em>临时变量</em></strong>(EBP - 4..  向下 低地址) -4为第一个临时变量</li>
<li><strong><em>返回地址</em></strong>(EBP + 4)</li>
<li><strong><em>参数列表</em></strong>( EBP + 8 .. 向上高地址) +8 为第一个参数</li>
</ul>
<p>所以当输入数据超过分配大小的时候, 数据会向高地址覆盖,而当前函数的执行的返回地址位于<br><img src="/images/stackLayout.gif" alt=""></p>
<h4 id="函数调用栈">函数调用栈</h4><p>以下转自(<a href="http://hutaow.com/blog/2013/10/15/dump-stack/" target="_blank" rel="external">http://hutaow.com/blog/2013/10/15/dump-stack/</a>)</p>
<p>要了解调用栈，首先需要了解函数的调用过程，下面用一段代码作为例子：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> test(<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="literal">result</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="literal">result</span> = a + b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="type">char</span> *argv[]) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="literal">result</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="literal">result</span> = test(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    printf(<span class="string">"result = %d \r\n"</span>, <span class="literal">result</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用gcc编译，然后gdb反汇编main函数，看看它是如何调用add函数的：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble main </span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   <span class="number">0x08048439</span> &lt;+<span class="number">0</span>&gt;:     <span class="keyword">push</span>   %<span class="literal">ebp</span></span><br><span class="line">   <span class="number">0x0804843a</span> &lt;+<span class="number">1</span>&gt;:     <span class="keyword">mov</span>    %<span class="literal">esp</span>,%<span class="literal">ebp</span></span><br><span class="line">   <span class="number">0x0804843c</span> &lt;+<span class="number">3</span>&gt;:     <span class="keyword">and</span>    <span class="number">$0</span>xfffffff0,%<span class="literal">esp</span></span><br><span class="line">   <span class="number">0x0804843f</span> &lt;+<span class="number">6</span>&gt;:     <span class="keyword">sub</span>    <span class="number">$0</span>x20,%<span class="literal">esp</span>       # 分配栈空间(栈向低地址方向生长)</span><br><span class="line">   <span class="number">0x08048442</span> &lt;+<span class="number">9</span>&gt;:     movl   <span class="number">$0</span>x0,<span class="number">0x1c</span>(%<span class="literal">esp</span>)  # 给result变量赋<span class="number">0</span>值</span><br><span class="line">   <span class="number">0x0804844a</span> &lt;+<span class="number">17</span>&gt;:    movl   <span class="number">$0</span>x2,<span class="number">0x4</span>(%<span class="literal">esp</span>)   # 将第<span class="number">2</span>个参数压栈(该参数偏移为<span class="literal">esp</span>+<span class="number">0x04</span>)</span><br><span class="line">   <span class="number">0x08048452</span> &lt;+<span class="number">25</span>&gt;:    movl   <span class="number">$0</span>x1,(%<span class="literal">esp</span>)      # 将第<span class="number">1</span>个参数压栈(该参数偏移为<span class="literal">esp</span>+<span class="number">0x00</span>)</span><br><span class="line">   <span class="number">0x08048459</span> &lt;+<span class="number">32</span>&gt;:    <span class="keyword">call</span>   <span class="number">0x804841c</span> &lt;<span class="keyword">add</span>&gt;  # 调用<span class="keyword">add</span>函数</span><br><span class="line">   <span class="number">0x0804845e</span> &lt;+<span class="number">37</span>&gt;:    <span class="keyword">mov</span>    %<span class="number">eax</span>,<span class="number">0x1c</span>(%<span class="literal">esp</span>)  # 将<span class="keyword">add</span>函数的返回值赋给result变量</span><br><span class="line">   <span class="number">0x08048462</span> &lt;+<span class="number">41</span>&gt;:    <span class="keyword">mov</span>    <span class="number">0x1c</span>(%<span class="literal">esp</span>),%<span class="number">eax</span></span><br><span class="line">   <span class="number">0x08048466</span> &lt;+<span class="number">45</span>&gt;:    <span class="keyword">mov</span>    %<span class="number">eax</span>,<span class="number">0x4</span>(%<span class="literal">esp</span>)</span><br><span class="line">   <span class="number">0x0804846a</span> &lt;+<span class="number">49</span>&gt;:    movl   <span class="number">$0</span>x8048510,(%<span class="literal">esp</span>)</span><br><span class="line">   <span class="number">0x08048471</span> &lt;+<span class="number">56</span>&gt;:    <span class="keyword">call</span>   <span class="number">0x80482f0</span> &lt;printf@plt&gt;</span><br><span class="line">   <span class="number">0x08048476</span> &lt;+<span class="number">61</span>&gt;:    <span class="keyword">mov</span>    <span class="number">$0</span>x0,%<span class="number">eax</span></span><br><span class="line">   <span class="number">0x0804847b</span> &lt;+<span class="number">66</span>&gt;:    <span class="keyword">leave</span>  </span><br><span class="line">   <span class="number">0x0804847c</span> &lt;+<span class="number">67</span>&gt;:    <span class="keyword">ret</span>    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure></p>
<p>可以看到，参数是在add函数调用前压栈，换句话说，参数压栈由调用者进行，参数存储在调用者的栈空间中，下面再看一下进入add函数后都做了什么：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble <span class="keyword">add</span></span><br><span class="line">Dump of assembler code for function <span class="keyword">add</span>:</span><br><span class="line">   <span class="number">0x0804841c</span> &lt;+<span class="number">0</span>&gt;:     <span class="keyword">push</span>   %<span class="literal">ebp</span>             # 将<span class="literal">ebp</span>压栈(保存函数调用者的栈基址)</span><br><span class="line">   <span class="number">0x0804841d</span> &lt;+<span class="number">1</span>&gt;:     <span class="keyword">mov</span>    %<span class="literal">esp</span>,%<span class="literal">ebp</span>        # 将<span class="literal">ebp</span>指向栈顶<span class="literal">esp</span>(设置当前函数的栈基址)</span><br><span class="line">   <span class="number">0x0804841f</span> &lt;+<span class="number">3</span>&gt;:     <span class="keyword">sub</span>    <span class="number">$0</span>x10,%<span class="literal">esp</span>       # 分配栈空间(栈向低地址方向生长)</span><br><span class="line">   <span class="number">0x08048422</span> &lt;+<span class="number">6</span>&gt;:     movl   <span class="number">$0</span>x0,-<span class="number">0x4</span>(%<span class="literal">ebp</span>)  # 给result变量赋<span class="number">0</span>值(该变量偏移为<span class="literal">ebp</span>-<span class="number">0x04</span>)</span><br><span class="line">   <span class="number">0x08048429</span> &lt;+<span class="number">13</span>&gt;:    <span class="keyword">mov</span>    <span class="number">0xc</span>(%<span class="literal">ebp</span>),%<span class="number">eax</span>   # 将第<span class="number">2</span>个参数的值赋给<span class="number">eax</span>(准备运算)</span><br><span class="line">   <span class="number">0x0804842c</span> &lt;+<span class="number">16</span>&gt;:    <span class="keyword">mov</span>    <span class="number">0x8</span>(%<span class="literal">ebp</span>),%<span class="number">edx</span>   # 将第<span class="number">1</span>个参数的值赋给<span class="number">edx</span>(准备运算)</span><br><span class="line">   <span class="number">0x0804842f</span> &lt;+<span class="number">19</span>&gt;:    <span class="keyword">add</span>    %<span class="number">edx</span>,%<span class="number">eax</span>        # 加法运算(<span class="number">edx</span>+<span class="number">eax</span>)，结果保存在<span class="number">eax</span>中</span><br><span class="line">   <span class="number">0x08048431</span> &lt;+<span class="number">21</span>&gt;:    <span class="keyword">mov</span>    %<span class="number">eax</span>,-<span class="number">0x4</span>(%<span class="literal">ebp</span>)  # 将运算结果<span class="number">eax</span>赋给result变量</span><br><span class="line">   <span class="number">0x08048434</span> &lt;+<span class="number">24</span>&gt;:    <span class="keyword">mov</span>    -<span class="number">0x4</span>(%<span class="literal">ebp</span>),%<span class="number">eax</span>  # 将result变量的值赋给<span class="number">eax</span>(<span class="number">eax</span>将作为函数返回值)</span><br><span class="line">   <span class="number">0x08048437</span> &lt;+<span class="number">27</span>&gt;:    <span class="keyword">leave</span>                   # 恢复函数调用者的栈基址(<span class="keyword">pop</span> %<span class="literal">ebp</span>)</span><br><span class="line">   <span class="number">0x08048438</span> &lt;+<span class="number">28</span>&gt;:    <span class="keyword">ret</span>                     # 返回(准备执行下条指令)</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure></p>
<p>进入add函数后，首先进行的操作是将当前的栈基址ebp压栈(此栈基址是调用者main函数的)，然后将ebp指向栈顶esp，接下来再进行函数内的处理流程。函数结束前，会将函数调用者的栈基址恢复，然后返回准备执行下一指令。这个过程中，栈上的空间会是下面的样子：<br><img src="/images/dia_function_stack.png" alt=""></p>
<p>可以发现，每调用一次函数，都会对调用者的栈基址(ebp)进行压栈操作，并且由于栈基址是由当时栈顶指针(esp)而来，会发现，各层函数的栈基址很巧妙的构成了一个链，即当前的栈基址指向下一层函数栈基址所在的位置，如下图所示：<br><img src="/images/dia_dump_stack.png" alt=""></p>
<p>了解了函数的调用过程，想要回溯调用栈也就很简单了，首先获取当前函数的栈基址(寄存器ebp)的值，然后获取该地址所指向的栈的值，该值也就是下层函数的栈基址，找到下层函数的栈基址后，重复刚才的动作，即可以将每一层函数的栈基址都找出来，这也就是我们所需要的调用栈了。</p>
<p>下面是根据原理实现的一段获取函数调用栈的代码，供参考。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打印调用栈的最大深度 */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DUMP_STACK_DEPTH_MAX 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取寄存器ebp的值 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_ebp</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> *ebp)</span> </span>&#123;</span><br><span class="line">    __asm__ __volatile__ (</span><br><span class="line">        <span class="string">"mov %%ebp, %0"</span></span><br><span class="line">        :<span class="string">"=m"</span>(*ebp)</span><br><span class="line">        ::<span class="string">"memory"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取调用栈 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dump_stack</span><span class="params">(<span class="keyword">void</span> **<span class="built_in">stack</span>, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ebp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1.得到首层函数的栈基址 */</span></span><br><span class="line">    get_ebp(&amp;ebp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2.逐层回溯栈基址 */</span></span><br><span class="line">    <span class="keyword">for</span> (depth = <span class="number">0</span>; (depth &lt; size) &amp;&amp; (<span class="number">0</span> != ebp) &amp;&amp; (<span class="number">0</span> != *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)ebp) &amp;&amp; (ebp != *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)ebp); ++depth) &#123;</span><br><span class="line">        <span class="built_in">stack</span>[depth] = (<span class="keyword">void</span> *)(*(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(ebp + <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>)));</span><br><span class="line">        ebp = *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)ebp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 测试函数 2 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_meloner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *<span class="built_in">stack</span>[DUMP_STACK_DEPTH_MAX] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> stack_depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取调用栈 */</span></span><br><span class="line">    stack_depth = dump_stack(<span class="built_in">stack</span>, DUMP_STACK_DEPTH_MAX);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印调用栈 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" Stack Track: \r\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; stack_depth; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" [%d] %p \r\n"</span>, i, <span class="built_in">stack</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 测试函数 1 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_hutaow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test_meloner();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 主函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    test_hutaow();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行gcc dumpstack.c -o dumpstack编译并运行，执行结果如下：<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stack Track: </span><br><span class="line"> [0] <span class="number">0x8048475</span> </span><br><span class="line"> [1] <span class="number">0x8048508</span> </span><br><span class="line"> [2] <span class="number">0x804855</span>c </span><br><span class="line"> [3] <span class="number">0x804856</span>a</span><br></pre></td></tr></table></figure></p>
<h2 id="堆溢出">堆溢出</h2><p>堆, 用来在程序运行时动态分配内存. 当使用<code>malloc</code>相关函数, 来分配一块地址空间或初始化一个对象时, 内存地址就是在堆上分配的.</p>
<p>因为堆只是被用来存储数据, 而没有用于存储函数返回地址( returnAddress ), 并且由于堆上的数据的变化,在程序运行中难于监控, 所以攻击者对堆溢出的攻击很难发现.正因如此, 堆溢出备受攻击者青睐.</p>
<p><img src="https://developer.apple.com/library/mac/documentation/Security/Conceptual/SecureCodingGuide/Art/heap_overflow.gif" alt="Heap overflow"></p>
<p>通常来说, 堆溢出的难度远大于栈溢出. 然而, 现在有很多成功的脚本都涉及堆溢出.堆溢出有两种实现方式:修改数据以及修改对象.</p>
<p>攻击者可以利用堆上的 buffer 溢出来覆盖敏感区域数据.很多语言中, 比如 C++和 Objective-C, 对象(包含函数列表 function vtable和数据指针)是分配在堆上的. 通过利用堆溢出来修改这些指针的方式, 攻击者可以替换成不同的数据, 甚至替换函数的实现. </p>
<p>利用堆溢出可能极其困难, 但正因如此才更具吸引力, 某些攻击者甚至将此当做了挑战的目标.比如:</p>
<ol>
<li>解码图片的代码中, 通过堆溢出可以允许远程攻击者执行随意指令</li>
<li>攻击者, 通过构造一个无效的 <code>&quot;Content-Length&quot; header</code> 发送 HTTP POST 请求 到存在堆溢出漏洞的网络服务器, 来执行任意指令 </li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>翻译自<a href="https://developer.apple.com/library/mac/documentation/Security/Conceptual/SecureCodingGuide/Articles/BufferOverflows.html">https://developer.apple.com/library/mac/documentation/Security/Conceptual/SecureCodingGuide/Articles/BufferOverflows.html</a></p>
<h2 id="栈溢出">栈溢出</h2><blockquote>
<p>在大部分操作系统中, 每个程序拥有一个<strong><em>栈</em></strong>(多线程程序,每个线程拥有一个单独的栈), 栈用于局部变量的存储.<br>栈被划分为单元, 此单元被成为帧(frame), 每个帧包含了某个函数的某一调用的全部数据.这些数据包含: 函数参数, 全部的临时变量,和 linkage 信息(就是调用函数的地址. 以便当前代码执行完毕后, 返回原位置继续执行). 通过配置编译参数,也可以包含下一帧的顶部地址.数据的布局以及排序,由操作系统决定,不同系统略有差异.<br>当函数被调用的时候, 一个新的栈帧被添加到栈的顶部. 当函数返回时,顶部的栈帧被移除.在执行过程中, 程序只能直接访问栈顶帧得数据(指针除外, 但是不建议如此设计).这种设计,方便了递归调用的实现, 因为每个子递归调用拥有独立的临时变量和参数备份.<br>下图介绍了栈的组织结构.(这只是示意图, 实际情况要根据 cpu设计来决定)</p>
</blockquote>
<p><img src="https://developer.apple.com/library/mac/documentation/Security/Conceptual/SecureCodingGuide/Art/stack.gif" alt=""><br>]]>
    
    </summary>
    
      <category term="Heap" scheme="http://ytlvy.com/tags/Heap/"/>
    
      <category term="OverFlow" scheme="http://ytlvy.com/tags/OverFlow/"/>
    
      <category term="Stack" scheme="http://ytlvy.com/tags/Stack/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Dispatch_semaphore]]></title>
    <link href="http://ytlvy.com/2015/06/30/Dispatch-semaphore/"/>
    <id>http://ytlvy.com/2015/06/30/Dispatch-semaphore/</id>
    <published>2015-06-30T08:28:07.000Z</published>
    <updated>2015-07-13T14:09:35.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/images/DispatchSemaphore.jpg" alt=""></p>
<h2 id="Dispatch_semaphore">Dispatch_semaphore</h2><p><code>semaphore</code> 通过<code>dispatch_semaphore_create</code>创建一个信号量来实现多线程并发数控制, 此信号量为最高可进行的并发数. 通过<code>dispatch_semaphore_wait</code>来消耗一个信号量,并进入其后的执行逻辑, 在逻辑执行完毕后,通过<code>dispatch_semaphore_signal</code>来释放一个信号量, 并唤醒正在等待的线程. 如果<code>dispatch_semaphore_wait</code>操作时,信号量为0则进入等待状态.</p>
<h3 id="functions">functions</h3><ul>
<li>dispatch_semaphore_create</li>
<li>dispatch_semaphore_wait (减少一个信号量)</li>
<li>dispatch_semaphore_signal (增加一个信号量)</li>
</ul>
<h3 id="实例">实例</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)test4&#123;</span><br><span class="line">    <span class="keyword">int</span> data = <span class="number">3</span>;</span><br><span class="line">    __block <span class="keyword">int</span> mainData = <span class="number">0</span>;</span><br><span class="line">    __block <span class="keyword">int</span> <span class="keyword">sum</span> = <span class="number">0</span>;</span><br><span class="line">    __block dispatch_semaphore_t sem = dispatch_semaphore_create(<span class="number">2</span>);</span><br><span class="line">    dispatch_queue_t ioQueue = dispatch_queue_create(<span class="string">"com.dreamingwish.imagegcd.io"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(<span class="string">"StudyBlocks"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_group_t <span class="keyword">group</span> = dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span> ; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">            dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);  <span class="comment">// -1 非零即通过</span></span><br><span class="line">            dispatch_group_async(<span class="keyword">group</span>, ioQueue, ^&#123;</span><br><span class="line"><span class="comment">//                dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</span></span><br><span class="line">                dispatch_group_async(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">                    <span class="keyword">sum</span> += data;</span><br><span class="line">                    </span><br><span class="line">                    __block <span class="keyword">int</span> nsum = <span class="keyword">sum</span>;</span><br><span class="line">                    dispatch_group_async(<span class="keyword">group</span>, ioQueue, ^&#123;</span><br><span class="line">                        NSLog(@<span class="string">" &gt;&gt; Sum: %d"</span>, nsum);</span><br><span class="line">                        </span><br><span class="line">                        dispatch_semaphore_signal(sem);  <span class="comment">// +1</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                    </span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_group_wait(<span class="keyword">group</span>, DISPATCH_TIME_FOREVER);</span><br><span class="line"><span class="comment">//    dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j =<span class="number">0</span>; j&lt;<span class="number">5</span>; j++) &#123;</span><br><span class="line">        mainData++;</span><br><span class="line">        NSLog(@<span class="string">" &gt;&gt; MainData: %d"</span>, mainData);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    dispatch_semaphore_signal(sem);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)test3&#123;</span><br><span class="line">    <span class="keyword">int</span> data = <span class="number">3</span>;</span><br><span class="line">    __block <span class="keyword">int</span> mainData = <span class="number">0</span>;</span><br><span class="line">    __block <span class="keyword">dispatch_semaphore_t</span> sem = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"StudyBlocks"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(<span class="built_in">queue</span>, ^&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            sum += data;</span><br><span class="line">            NSLog(@<span class="string">" &gt;&gt; Sum: %d"</span>, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dispatch_semaphore_signal(sem);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j =<span class="number">0</span>; j&lt;<span class="number">5</span>; j++) &#123;</span><br><span class="line">        mainData++;</span><br><span class="line">        NSLog(@<span class="string">" &gt;&gt; MainData: %d"</span>, mainData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/images/DispatchSemaphore.jpg" alt=""></p>
<h2 id="Dispatch_semaphore">Dispatch_semaphore</h2><p><code>semaphore</code> 通过<code>dispatch_semaphore_create</code>创建一个信号量来实现多线程并发数控制, 此信号量为最高可进行的并发数. 通过<code>dispatch_semaphore_wait</code>来消耗一个信号量,并进入其后的执行逻辑, 在逻辑执行完毕后,通过<code>dispatch_semaphore_signal</code>来释放一个信号量, 并唤醒正在等待的线程. 如果<code>dispatch_semaphore_wait</code>操作时,信号量为0则进入等待状态.</p>
<h3 id="functions">functions</h3><ul>
<li>dispatch_semaphore_create</li>
<li>dispatch_semaphore_wait (减少一个信号量)</li>
<li>dispatch_semaphore_signal (增加一个信号量)</li>
</ul>
<h3 id="实例">实例</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)test4&#123;</span><br><span class="line">    <span class="keyword">int</span> data = <span class="number">3</span>;</span><br><span class="line">    __block <span class="keyword">int</span> mainData = <span class="number">0</span>;</span><br><span class="line">    __block <span class="keyword">int</span> <span class="keyword">sum</span> = <span class="number">0</span>;</span><br><span class="line">    __block dispatch_semaphore_t sem = dispatch_semaphore_create(<span class="number">2</span>);</span><br><span class="line">    dispatch_queue_t ioQueue = dispatch_queue_create(<span class="string">"com.dreamingwish.imagegcd.io"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(<span class="string">"StudyBlocks"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_group_t <span class="keyword">group</span> = dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span> ; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">            dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);  <span class="comment">// -1 非零即通过</span></span><br><span class="line">            dispatch_group_async(<span class="keyword">group</span>, ioQueue, ^&#123;</span><br><span class="line"><span class="comment">//                dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</span></span><br><span class="line">                dispatch_group_async(<span class="keyword">group</span>, queue, ^&#123;</span><br><span class="line">                    <span class="keyword">sum</span> += data;</span><br><span class="line">                    </span><br><span class="line">                    __block <span class="keyword">int</span> nsum = <span class="keyword">sum</span>;</span><br><span class="line">                    dispatch_group_async(<span class="keyword">group</span>, ioQueue, ^&#123;</span><br><span class="line">                        NSLog(@<span class="string">" &gt;&gt; Sum: %d"</span>, nsum);</span><br><span class="line">                        </span><br><span class="line">                        dispatch_semaphore_signal(sem);  <span class="comment">// +1</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                    </span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_group_wait(<span class="keyword">group</span>, DISPATCH_TIME_FOREVER);</span><br><span class="line"><span class="comment">//    dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j =<span class="number">0</span>; j&lt;<span class="number">5</span>; j++) &#123;</span><br><span class="line">        mainData++;</span><br><span class="line">        NSLog(@<span class="string">" &gt;&gt; MainData: %d"</span>, mainData);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    dispatch_semaphore_signal(sem);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="IOS" scheme="http://ytlvy.com/tags/IOS/"/>
    
      <category term="dispatch semaphore" scheme="http://ytlvy.com/tags/dispatch-semaphore/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[DispatchOnce]]></title>
    <link href="http://ytlvy.com/2015/06/30/DispatchOnce/"/>
    <id>http://ytlvy.com/2015/06/30/DispatchOnce/</id>
    <published>2015-06-30T07:31:31.000Z</published>
    <updated>2015-07-13T14:09:08.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/images/DispatchOnce.jpg" alt=""></p>
<h2 id="Dispatch_Once">Dispatch_Once</h2><p>四种场景如上图</p>
<ol>
<li>第一次执行，<code>block调用</code>，调用结束后需要置标记变量</li>
<li>非第一次执行，而此时#1<code>block调用</code>尚未完成(预执行拿到的 obj 为 nil, 此时需要废弃此次预执行)，线程需进入等待#1状态</li>
<li>非第一次执行，而此时#1<code>block调用</code>已经完成(预执行拿到的 obj 已经初始化完毕)此时线程的预执行是正确的, 之后可能继续执行,也可能由于时间问题,废弃此次预执行进入等待</li>
<li>非第一次执行，而此时#1已经完成，线程预执行后, 直接跳过block而进行后续任务</li>
</ol>
<p>Dispatch_Once 保证了当第一个线程在进行alloc 对象时，有其他线程发起, 会废弃此线程的预执行，进入等待。在第一个线程结束时，将正在等待的线程唤醒。而实现这一机制的方法是在生成对象和变更identifier之间加入一个大于预执行时间的等待来实现的。</p>
<h3 id="Dispatch_Once实现用到的技术">Dispatch_Once实现用到的技术</h3><ul>
<li>原子操作 “原子比较交换函数” __sync_bool_compare_and_swap</li>
<li>cpuid指令 实现大于预执行时间的延迟等待</li>
<li>dispatch_thread_semaphore 来实现线程之间的等待和唤醒<a id="more"></a>
<h3 id="cpu的分支预测和预执行">cpu的分支预测和预执行</h3><blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;流水线特性使得CPU能更快地执行线性指令序列，但是当遇到条件判断分支时，麻烦来了，在判定语句返回结果之前，cpu不知道该执行哪个分支，那就得等着（术语叫做pipeline stall），这怎么能行呢，所以，CPU会进行预执行，cpu先猜测一个可能的分支，然后开始执行分支中的指令。现代CPU一般都能做到超过90%的猜测命中率，这可比NBA选手发球命中率高多了。然后当判定语句返回，加入cpu猜错分支，那么之前进行的执行都会被抛弃，然后从正确的分支重新开始执行。<br>&nbsp;&nbsp;&nbsp;&nbsp;在dispatch_once中，唯一一个判断分支就是predicate，dispatch_once会让CPU预执行条件不成立的分支，这样可以大大提升函数执行速度。但是这样的预执行导致的结果是使用了未初始化的obj并将函数返回，这显然不是预期结果。</p>
</blockquote>
</li>
</ul>
<h3 id="不对称barrier">不对称barrier</h3><blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在intel的CPU上，dispatch_once动用了cpuid指令来达成这个目的。cpuid本来是用作取得cpu的信息，但是这个指令也同时强制将指令流串行化，并且这个指令是需要比较长的执行时间的(在某些cpu上，甚至需要几百圈cpu时钟).这个指令保证了, 当其他线程预执行读取到 nil时,可以废弃当前的预执行操作,从而进入 dispatch_once 的 else 方法进入等待.</p>
</blockquote>
<h3 id="dispatch_once读取端的实现">dispatch_once读取端的实现</h3><blockquote>
<p>DISPATCH_EXPECT 是用来告诉cpu *predicate等于~0l是更有可能的判定结果，这就使得cpu能猜测到更正确的分支，并提高效率</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_INLINE DISPATCH_ALWAYS_INLINE DISPATCH_NONNULL_ALL DISPATCH_NOTHROW</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_dispatch_once(<span class="keyword">dispatch_once_t</span> *predicate, <span class="keyword">dispatch_block_t</span> block)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (DISPATCH_EXPECT(*predicate, ~<span class="number">0l</span>) != ~<span class="number">0l</span>) &#123;</span><br><span class="line">        dispatch_once(predicate, block);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> dispatch_once _dispatch_once</span></span><br></pre></td></tr></table></figure>
<h3 id="dispatch_once的实现">dispatch_once的实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> _dispatch_once_waiter_s &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">struct</span> _dispatch_once_waiter_s *<span class="keyword">volatile</span> dow_next;</span><br><span class="line">    <span class="keyword">_dispatch_thread_semaphore_t</span> dow_sema;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DISPATCH_ONCE_DONE ((struct _dispatch_once_waiter_s *)~0l)</span></span><br><span class="line"> </span><br><span class="line"><span class="preprocessor">#ifdef __BLOCKS__</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span><br><span class="line"><span class="title">dispatch_once</span><span class="params">(dispatch_once_t *val, dispatch_block_t block)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> Block_basic *bb = (<span class="keyword">void</span> *)block;</span><br><span class="line"> </span><br><span class="line">    dispatch_once_f(val, block, (<span class="keyword">void</span> *)bb-&gt;Block_invoke);</span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line"><span class="title">dispatch_once_f</span><span class="params">(dispatch_once_t *val, <span class="keyword">void</span> *ctxt, dispatch_function_t func)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> _dispatch_once_waiter_s * <span class="keyword">volatile</span> *vval = (<span class="keyword">struct</span> _dispatch_once_waiter_s**)val;</span><br><span class="line">    <span class="keyword">struct</span> _dispatch_once_waiter_s dow = &#123; NULL, <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">struct</span> _dispatch_once_waiter_s *tail, *tmp;</span><br><span class="line">    <span class="keyword">_dispatch_thread_semaphore_t</span> sema;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (dispatch_atomic_cmpxchg(vval, NULL, &amp;dow)) &#123;</span><br><span class="line">        dispatch_atomic_acquire_barrier();<span class="comment">//这是一个空的宏函数，什么也不做</span></span><br><span class="line">        _dispatch_client_callout(ctxt, func);</span><br><span class="line">        dispatch_atomic_maximally_synchronizing_barrier();</span><br><span class="line">        <span class="comment">//dispatch_atomic_release_barrier(); // assumed contained in above</span></span><br><span class="line">        tmp = dispatch_atomic_xchg(vval, DISPATCH_ONCE_DONE);</span><br><span class="line">        tail = &amp;dow;</span><br><span class="line">        <span class="keyword">while</span> (tail != tmp) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!tmp-&gt;dow_next) &#123;</span><br><span class="line">                _dispatch_hardware_pause();</span><br><span class="line">            &#125;</span><br><span class="line">            sema = tmp-&gt;dow_sema;</span><br><span class="line">            tmp = (<span class="keyword">struct</span> _dispatch_once_waiter_s*)tmp-&gt;dow_next;</span><br><span class="line">            <span class="keyword">_dispatch_t</span>hread_semaphore_signal(sema);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dow.dow_sema = <span class="keyword">_dispatch_get_t</span>hread_semaphore();</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            tmp = *vval;</span><br><span class="line">            <span class="keyword">if</span> (tmp == DISPATCH_ONCE_DONE) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dispatch_atomic_store_barrier();</span><br><span class="line">            <span class="keyword">if</span> (dispatch_atomic_cmpxchg(vval, tmp, &amp;dow)) &#123;</span><br><span class="line">                dow.dow_next = tmp;</span><br><span class="line">                <span class="keyword">_dispatch_t</span>hread_semaphore_wait(dow.dow_sema);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">_dispatch_put_t</span>hread_semaphore(dow.dow_sema);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>dispatch_atomic_cmpxchg 是 “原子比较交换函数”__sync_bool_compare_and_swap的宏替换</p>
</blockquote>
<h4 id="执行block的分支">执行block的分支</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;当dispatch_once第一次执行时，predicate也即val为0，那么此“原子比较交换函数”将返回true并将vval指向值赋值为&amp;dow，即为“等待中”，_dispatch_client_callout其内部做了一些判定，但实际上是调用了func而已。到此，block中的用户代码执行完毕。<br>&nbsp;&nbsp;&nbsp;&nbsp; 接下来就是上篇提及的cpuid指令等待，使得其他线程的【读取到未初始化值的】预执行能被判定为猜测未命中，从而使得这些线程能够进入dispatch_once_f里的另一个分支从而进行等待。<br>&nbsp;&nbsp;&nbsp;&nbsp; cpuid指令完毕后，调用dispatch_atomic_xchg进行赋值，置其为DISPATCH_ONCE_DONE，即“完成”，这里dispatch_atomic_xchg是内建“原子交换函数”__sync_swap的优化版宏替换，其将第二个参数的值赋给第一个参数（解引用指针），然后返回第一个参数被赋值前的解引用值，其原型为：</p>
<blockquote>
<p>type __sync_swap(type *ptr, type value, …)</p>
</blockquote>
<p>接下来是对信号量链的处理：</p>
<ol>
<li>在block执行过程中，没有其他线程进入本函数来等待，则vval指向值保持为&amp;dow，即tmp被赋值为&amp;dow，即下方while循环不会被执行，此分支结束。</li>
<li>在block执行过程中，有其他线程进入本函数来等待，那么会构造一个信号量链表（vval指向值变为信号量链的头部，链表的尾部为&amp;dow），此时就会进入while循环，在此while循环中，遍历链表，逐个signal每个信号量，然后结束循环。</li>
</ol>
<blockquote>
<p>while (!tmp-&gt;dow_next)此循环是等待在&amp;dow上，因为线程等待分支#2会中途将val赋值为&amp;dow，然后为-&gt;dow_next赋值，这期间-&gt;dow_next值为NULL，需要等待，详见下面线程等待分支#2的描述<br>_dispatch_hardware_pause此句是为了提示cpu减少额外处理，提升性能，节省电力</p>
</blockquote>
<h4 id="线程等待分支">线程等待分支</h4><p>当执行block分支#1未完成，且有线程再进入本函数时，将进入线程等待分支：</p>
<ol>
<li>先调用_dispatch_get_thread_semaphore创建一个信号量，此信号量被赋值给dow.dow_sema</li>
<li>然后进入一个无限for循环，假如发现vval的指向值已经为DISPATCH_ONCE_DONE，即“完成”，则直接break，然后调用_dispatch_put_thread_semaphore函数销毁信号量并退出函数</li>
</ol>
<blockquote>
<p>_dispatch_get_thread_semaphore内部使用的是“有即取用，无即创建”策略来获取信号量。<br>_dispatch_put_thread_semaphore内部使用的是“销毁旧的，存储新的”策略来缓存信号量。</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp; 假如vval的解引用值并非DISPATCH_ONCE_DONE，则进行一个“原子比较并交换”操作（此操作可以避免两个等待线程同时操作链表带来的问题），假如此时vval指向值已不再是tmp（这种情况发生在多个线程同时进入线程等待分支#2，并交错修改链表）则for循环重新开始，再尝试重新获取一次vval来进行同样的操作；若指向值还是tmp，则将vval的指向值赋值为&amp;dow，此时val-&gt;dow_next值为NULL，可能会使得block执行分支#1进行while等待（如前述），紧接着执行dow.dow_next = tmp这句来增加链表节点（同时也使得block执行分支#1的while等待结束），然后等待在信号量上，当block执行分支#1完成并遍历链表来signal时，唤醒、释放信号量，然后一切就完成了。</p>
<h3 id="小结">小结</h3><ol>
<li>线程A执行Block时，任何其它线程都需要等待。</li>
<li>线程A执行完Block应该立即标记任务完成状态，然后遍历信号量链来唤醒所有等待线程。</li>
<li>线程A遍历信号量链来signal时，任何其他新进入函数的线程都应该直接返回而无需等待。</li>
<li>线程A遍历信号量链来signal时，若有其它等待线程B仍在更新或试图更新信号量链，应该保证此线程B能正确_完成其任务：a.直接返回 b.等待在信号量上并很快又被唤醒。</li>
<li>线程B构造信号量时，应该考虑线程A随时可能改变状态（“等待”、“完成”、“遍历信号量链”）。</li>
<li>线程B构造信号量时，应该考虑到另一个线程C也可能正在更新或试图更新信号量链，应该保证B、C都能正常_完成其任务：a.增加链节并等待在信号量上 b.发现线程A已经标记“完成”然后直接销毁信号量并退出函数。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/images/DispatchOnce.jpg" alt=""></p>
<h2 id="Dispatch_Once">Dispatch_Once</h2><p>四种场景如上图</p>
<ol>
<li>第一次执行，<code>block调用</code>，调用结束后需要置标记变量</li>
<li>非第一次执行，而此时#1<code>block调用</code>尚未完成(预执行拿到的 obj 为 nil, 此时需要废弃此次预执行)，线程需进入等待#1状态</li>
<li>非第一次执行，而此时#1<code>block调用</code>已经完成(预执行拿到的 obj 已经初始化完毕)此时线程的预执行是正确的, 之后可能继续执行,也可能由于时间问题,废弃此次预执行进入等待</li>
<li>非第一次执行，而此时#1已经完成，线程预执行后, 直接跳过block而进行后续任务</li>
</ol>
<p>Dispatch_Once 保证了当第一个线程在进行alloc 对象时，有其他线程发起, 会废弃此线程的预执行，进入等待。在第一个线程结束时，将正在等待的线程唤醒。而实现这一机制的方法是在生成对象和变更identifier之间加入一个大于预执行时间的等待来实现的。</p>
<h3 id="Dispatch_Once实现用到的技术">Dispatch_Once实现用到的技术</h3><ul>
<li>原子操作 “原子比较交换函数” __sync_bool_compare_and_swap</li>
<li>cpuid指令 实现大于预执行时间的延迟等待</li>
<li>dispatch_thread_semaphore 来实现线程之间的等待和唤醒]]>
    
    </summary>
    
      <category term="Dispatch Once" scheme="http://ytlvy.com/tags/Dispatch-Once/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/tags/IOS/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[UITableView Cancel Request]]></title>
    <link href="http://ytlvy.com/2015/06/30/UITableView-Cancel-Request/"/>
    <id>http://ytlvy.com/2015/06/30/UITableView-Cancel-Request/</id>
    <published>2015-06-30T01:22:03.000Z</published>
    <updated>2015-07-13T14:08:24.000Z</updated>
    <content type="html"><![CDATA[<h3 id="仅加载可见Cell的图片">仅加载可见Cell的图片</h3><p>load images for just the visible rows in viewDidLoad and when the user stops scrolling<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span>(void)<span class="tag">viewDidLoad</span>&#123;</span><br><span class="line">    <span class="tag">for</span> (NSIndexPath *indexPath in [self.tableView indexPathsForVisibleRows]) &#123;</span><br><span class="line">        <span class="attr_selector">[self loadImageForCellAtPath:indexPath]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">-</span>(void)<span class="tag">scrollViewDidEndDecelerating</span>:(UIScrollView *)<span class="tag">scrollView</span> &#123;</span><br><span class="line">    <span class="tag">for</span> (NSIndexPath *indexPath in [self.tableView indexPathsForVisibleRows]) &#123;</span><br><span class="line">        <span class="attr_selector">[self loadImageForCellAtPath:indexPath]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="取消Request_—-_NSBlockOperation">取消Request —- NSBlockOperation</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span><span class="variable">.operationQueue</span> = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.operationQueue</span> setMaxConcurrentOperationCount:<span class="built_in">NSOperationQueueDefaultMaxConcurrentOperationCount</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)loadImageForCellAtPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    __block <span class="built_in">NSBlockOperation</span> *operation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="keyword">if</span> (![operation isCancelled]) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *galleryTinyImageUrl = [[<span class="keyword">self</span><span class="variable">.smapi</span> getImageUrls:imageId imageKey:imageKey] objectForKey:<span class="string">@"TinyURL"</span>];</span><br><span class="line">            <span class="built_in">NSData</span> *imageData = [[<span class="built_in">NSData</span> alloc] initWithContentsOfURL:[<span class="built_in">NSURL</span> URLWithString:galleryTinyImageUrl]];</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                <span class="keyword">if</span> (imageData != <span class="literal">nil</span>) &#123;</span><br><span class="line">                    <span class="built_in">UITableViewCell</span> *cell = [tableView cellForRowAtIndexPath:indexPath];</span><br><span class="line">                    cell<span class="variable">.imageView</span><span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageWithData:imageData];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSValue</span> *nonRetainedOperation = [<span class="built_in">NSValue</span> valueWithNonretainedObjectValue:operation];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.operations</span> addObject:nonRetainedOperation forKey:indexPath];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.operationQueue</span> addOperation:operation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Here operations is an NSMutableDictionary. When you want to cancel an operation, you retrieve it by the cell’s indexPath, cancel it, and remove it from the dictionary:</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSValue *operationHolder = [self.operations objectForKey:indexPath]<span class="comment">;</span></span><br><span class="line">NSOperation *operation = [operationHolder nonretainedObjectValue]<span class="comment">;</span></span><br><span class="line">[operation cancel]<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h3 id="prefetch_the_images_—-_SDWebImagePrefetcher">prefetch the images —-  SDWebImagePrefetcher</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr_selector">[self.tableView reloadData]</span>;</span><br><span class="line"><span class="tag">dispatch_async</span>(<span class="function">dispatch_get_main_queue</span>(), ^&#123;</span><br><span class="line">    <span class="attr_selector">[self prefetchImagesForTableView:self.tableView]</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>anytime I stop scrolling, I do the same:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)scrollViewDidEndDecelerating:(<span class="built_in">UIScrollView</span> *)scrollView &#123;</span><br><span class="line">    [<span class="keyword">self</span> prefetchImagesForTableView:<span class="keyword">self</span><span class="variable">.tableView</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView willDecelerate:(<span class="built_in">BOOL</span>)decelerate &#123;</span><br><span class="line">    <span class="keyword">if</span> (!decelerate)</span><br><span class="line">        [<span class="keyword">self</span> prefetchImagesForTableView:<span class="keyword">self</span><span class="variable">.tableView</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#pragma mark - Prefetch cells</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSInteger</span> <span class="keyword">const</span> kPrefetchRowCount = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Prefetch a certain number of images for rows prior to and subsequent to the currently visible cells</span><br><span class="line"> *</span><br><span class="line"> * @param  tableView   The tableview for which we're going to prefetch images.</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)prefetchImagesForTableView:(<span class="built_in">UITableView</span> *)tableView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *indexPaths = [<span class="keyword">self</span><span class="variable">.tableView</span> indexPathsForVisibleRows];</span><br><span class="line">    <span class="keyword">if</span> ([indexPaths count] == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSIndexPath</span> *minimumIndexPath = indexPaths[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">NSIndexPath</span> *maximumIndexPath = [indexPaths lastObject];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// they should be sorted already, but if not, update min and max accordingly</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSIndexPath</span> *indexPath <span class="keyword">in</span> indexPaths) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([minimumIndexPath compare:indexPath] == <span class="built_in">NSOrderedDescending</span>)</span><br><span class="line">            minimumIndexPath = indexPath;</span><br><span class="line">        <span class="keyword">if</span> ([maximumIndexPath compare:indexPath] == <span class="built_in">NSOrderedAscending</span>)</span><br><span class="line">            maximumIndexPath = indexPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build array of imageURLs for cells to prefetch</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *imageURLs = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSArray</span> *precedingRows = [<span class="keyword">self</span> tableView:tableView indexPathsForPrecedingRows:kPrefetchRowCount fromIndexPath:minimumIndexPath];</span><br><span class="line">    [imageURLs addObjectsFromArray:precedingRows];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSArray</span> *followingRows = [<span class="keyword">self</span> tableView:tableView indexPathsForFollowingRows:kPrefetchRowCount fromIndexPath:maximumIndexPath];</span><br><span class="line">    [imageURLs addObjectsFromArray:followingRows];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now prefetch</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([imageURLs count] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        [[SDWebImagePrefetcher sharedImagePrefetcher] prefetchURLs:imageURLs];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Retrieve NSIndexPath for a certain number of rows preceding particular NSIndexPath in the table view.</span><br><span class="line"> *</span><br><span class="line"> * @param  tableView  The tableview for which we're going to retrieve indexPaths.</span><br><span class="line"> * @param  count      The number of rows to retrieve</span><br><span class="line"> * @param  indexPath  The indexPath where we're going to start (presumably the first visible indexPath)</span><br><span class="line"> *</span><br><span class="line"> * @return            An array of indexPaths.</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView indexPathsForPrecedingRows:(<span class="built_in">NSInteger</span>)count fromIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *indexPaths = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="built_in">NSInteger</span> row = indexPath<span class="variable">.row</span>;</span><br><span class="line">    <span class="built_in">NSInteger</span> section = indexPath<span class="variable">.section</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (row == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (section == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> indexPaths;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                section--;</span><br><span class="line">                row = [tableView numberOfRowsInSection:section] - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            row--;</span><br><span class="line">        &#125;</span><br><span class="line">        [indexPaths addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:row inSection:section]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> indexPaths;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Retrieve NSIndexPath for a certain number of following particular NSIndexPath in the table view.</span><br><span class="line"> *</span><br><span class="line"> * @param  tableView  The tableview for which we're going to retrieve indexPaths.</span><br><span class="line"> * @param  count      The number of rows to retrieve</span><br><span class="line"> * @param  indexPath  The indexPath where we're going to start (presumably the last visible indexPath)</span><br><span class="line"> *</span><br><span class="line"> * @return            An array of indexPaths.</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSArray</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView indexPathsForFollowingRows:(<span class="built_in">NSInteger</span>)count fromIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *indexPaths = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="built_in">NSInteger</span> row = indexPath<span class="variable">.row</span>;</span><br><span class="line">    <span class="built_in">NSInteger</span> section = indexPath<span class="variable">.section</span>;</span><br><span class="line">    <span class="built_in">NSInteger</span> rowCountForSection = [tableView numberOfRowsInSection:section];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        row++;</span><br><span class="line">        <span class="keyword">if</span> (row == rowCountForSection) &#123;</span><br><span class="line">            row = <span class="number">0</span>;</span><br><span class="line">            section++;</span><br><span class="line">            <span class="keyword">if</span> (section == [tableView numberOfSections]) &#123;</span><br><span class="line">                <span class="keyword">return</span> indexPaths;</span><br><span class="line">            &#125;</span><br><span class="line">            rowCountForSection = [tableView numberOfRowsInSection:section];</span><br><span class="line">        &#125;</span><br><span class="line">        [indexPaths addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:row inSection:section]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> indexPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="仅加载可见Cell的图片">仅加载可见Cell的图片</h3><p>load images for just the visible rows in viewDidLoad and when the user stops scrolling<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span>(void)<span class="tag">viewDidLoad</span>&#123;</span><br><span class="line">    <span class="tag">for</span> (NSIndexPath *indexPath in [self.tableView indexPathsForVisibleRows]) &#123;</span><br><span class="line">        <span class="attr_selector">[self loadImageForCellAtPath:indexPath]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">-</span>(void)<span class="tag">scrollViewDidEndDecelerating</span>:(UIScrollView *)<span class="tag">scrollView</span> &#123;</span><br><span class="line">    <span class="tag">for</span> (NSIndexPath *indexPath in [self.tableView indexPathsForVisibleRows]) &#123;</span><br><span class="line">        <span class="attr_selector">[self loadImageForCellAtPath:indexPath]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="IOS" scheme="http://ytlvy.com/tags/IOS/"/>
    
      <category term="UITableView" scheme="http://ytlvy.com/tags/UITableView/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CFRunLoop examples]]></title>
    <link href="http://ytlvy.com/2015/06/30/CFRunLoop-examples/"/>
    <id>http://ytlvy.com/2015/06/30/CFRunLoop-examples/</id>
    <published>2015-06-30T01:16:56.000Z</published>
    <updated>2015-07-13T14:09:43.000Z</updated>
    <content type="html"><![CDATA[<h3 id="第一个">第一个</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#include <span class="title">&lt;CoreFoundation/CoreFoundation.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>  </span><br><span class="line">_perform(<span class="keyword">void</span> *info __unused)  </span><br><span class="line">&#123;  </span><br><span class="line">    printf(<span class="string">"hello\n"</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>  </span><br><span class="line">_timer(<span class="built_in">CFRunLoopTimerRef</span> timer __unused, <span class="keyword">void</span> *info)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">CFRunLoopSourceSignal</span>(info);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span>  </span><br><span class="line">main()  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">CFRunLoopSourceRef</span> source;  </span><br><span class="line">    <span class="built_in">CFRunLoopSourceContext</span> source_context;  </span><br><span class="line">    <span class="built_in">CFRunLoopTimerRef</span> timer;  </span><br><span class="line">    <span class="built_in">CFRunLoopTimerContext</span> timer_context;  </span><br><span class="line">  </span><br><span class="line">    bzero(&amp;source_context, <span class="keyword">sizeof</span>(source_context));  </span><br><span class="line">    source_context<span class="variable">.perform</span> = _perform;  </span><br><span class="line">    source = <span class="built_in">CFRunLoopSourceCreate</span>(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;source_context);  </span><br><span class="line">    <span class="built_in">CFRunLoopAddSource</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), source, k<span class="built_in">CFRunLoopCommonModes</span>);  </span><br><span class="line">  </span><br><span class="line">    bzero(&amp;timer_context, <span class="keyword">sizeof</span>(timer_context));  </span><br><span class="line">    timer_context<span class="variable">.info</span> = source;  </span><br><span class="line">    timer = <span class="built_in">CFRunLoopTimerCreate</span>(<span class="literal">NULL</span>, <span class="built_in">CFAbsoluteTimeGetCurrent</span>(), <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, </span><br><span class="line">    _timer, &amp;timer_context);  </span><br><span class="line">    <span class="built_in">CFRunLoopAddTimer</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), timer, k<span class="built_in">CFRunLoopCommonModes</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">CFRunLoopRun</span>();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="第二个：">第二个：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;dispatch/dispatch.h&gt;  </span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;  </span></span><br><span class="line">  </span><br><span class="line">int  </span><br><span class="line"><span class="function"><span class="title">main</span></span>()  </span><br><span class="line">&#123;  </span><br><span class="line">    dispatch_<span class="built_in">source</span>_t <span class="built_in">source</span>, timer;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">source</span> = dispatch_<span class="built_in">source</span>_create(DISPATCH_SOURCE_TYPE_DATA_ADD, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>));  </span><br><span class="line">    dispatch_<span class="built_in">source</span>_<span class="built_in">set</span>_event_handler(<span class="built_in">source</span>, ^&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"hello\n"</span>);  </span><br><span class="line">    &#125;);  </span><br><span class="line">    dispatch_resume(<span class="built_in">source</span>);  </span><br><span class="line">  </span><br><span class="line">    timer = dispatch_<span class="built_in">source</span>_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, </span><br><span class="line">    dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>));  </span><br><span class="line">    dispatch_<span class="built_in">source</span>_<span class="built_in">set</span>_timer(timer, DISPATCH_TIME_NOW, <span class="number">1</span>ull * NSEC_PER_SEC, <span class="number">0</span>);  </span><br><span class="line">    dispatch_<span class="built_in">source</span>_<span class="built_in">set</span>_event_handler(timer, ^&#123;  </span><br><span class="line">        dispatch_<span class="built_in">source</span>_merge_data(<span class="built_in">source</span>, <span class="number">1</span>);  </span><br><span class="line">    &#125;);  </span><br><span class="line">    dispatch_resume(timer);  </span><br><span class="line">  </span><br><span class="line">    dispatch_main();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>功能是向main线程中加入两个input source，一个是timer，一个是自定义input source，然后这个timer中触发自定义source，于是调用其回调方法。 在这儿timer触发source来调用回调方法，显得有点多此一举。但是在多线程开发当中，这就很有用了，我们可以把这个自定义的source加入到子线程的runloop中，然后在主线程中触发source，这样在子线程中就可以调用回调方法了。  这样做的好久是什么呀？ 节约用电，因为runloop一般情况下是休眠的，只有事件触发的时候才开始工作。 这与windows下的waitforsingleobject有点类似， 与多线程中的信号量，事件也有些雷同。</p>
<p>上面说到的input source（输入源例）到底是什么呢？输入源样例可能包括用户输入设备（如点击button）、网络链接(socket收到数据)、定期或时间延迟事件（NSTimer），还有异步回调(NSURLConnection的异步请求)。然后我们对其进行了分类，有三类可以被runloop监控，分别是sources、timers、observers。<br>在苹果文档中对runloop有详细介绍，下面参考中有中文版。那文档中的代码关于NSPort的部份在iOS上是不行的，不过可以用其CF方法实现，在我的demo中有展示。</p>
<p>每一个线程都有自己的runloop, 主线程是默认开启的，创建的子线程要手动开启，因为NSApplication 只启动main applicaiton thread。<br>没有source的runloop会自动结束。<br>事件由NSRunLoop 类处理。<br>RunLoop监视操作系统的输入源，如果没有事件数据， 不消耗任何CPU 资源。<br>如果有事件数据，run loop 就发送消息，通知各个对象。<br>用 currentRunLoop 获得 runloop的 reference<br>给 runloop 发送run 消息启动它。</p>
<p>文档中介绍下面四种情况是使用runloop的场合：<br> 1.使用端口或自定义输入源和其他线程通信<br> 2.子线程中使用了定时器<br> 3.cocoa中使用任何performSelector到了线程中运行方法<br> 4.使线程履行周期性任务，（我把这个理解与2相同）<br>如果我们在子线程中用了NSURLConnection异步请求，那也需要用到runloop，不然线程退出了，相应的delegate方法就不能触发。</p>
<h3 id="用户事件事例：累计更新">用户事件事例：累计更新</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dispatch_source_t source = dispatch_source_create<span class="list">(<span class="keyword">DISPATCH_SOURCE_TYPE_DATA_ADD</span>, <span class="number">0</span>, <span class="number">0</span>, dispatch_get_main_queue<span class="list">()</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_source_set_event_handler<span class="list">(<span class="keyword">source</span>, ^&#123;</span><br><span class="line">    [progressIndicator incrementBy<span class="keyword">:dispatch_source_get_data</span><span class="list">(<span class="keyword">source</span>)</span>]<span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_resume<span class="list">(<span class="keyword">source</span>)</span><span class="comment">;</span></span><br><span class="line"> </span><br><span class="line">dispatch_apply<span class="list">([array count], globalQueue, ^<span class="list">(<span class="keyword">size_t</span> index)</span> &#123;</span><br><span class="line">    // do some work on data at index</span><br><span class="line">    dispatch_source_merge_data<span class="list">(<span class="keyword">source</span>, <span class="number">1</span>)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>假设你已经将进度条的min/max值设置好了，那么这段代码就完美了。数据会被并发处理。当每一段数据完成后，会通知dispatch source并将dispatch source data加1，这样我们就认为一个单元的工作完成了。事件句柄根据已完成的工作单元来更新进度条。若主线程比较空闲并且这些工作单元进行的比较慢，那么事件句柄会在每个工作单元完成的时候被调用，实时更新。如果主线程忙于其他工作，或者工作单元完成速度很快，那么完成事件会被联结起来，导致进度条只在主线程变得可用时才被更新，并且一次将积累的改变更新至GUI。使用的dispatch source而不使用dispatch_async的唯一原因就是利用联结的优势。</p>
<h3 id="内建事件">内建事件</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t globalQueue = dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><span class="comment">;</span></span><br><span class="line">dispatch_source_t stdinSource = dispatch_source_create<span class="list">(<span class="keyword">DISPATCH_SOURCE_TYPE_READ</span>,</span><br><span class="line">                                                       STDIN_FILENO,</span><br><span class="line">                                                       <span class="number">0</span>,</span><br><span class="line">                                                       globalQueue)</span><span class="comment">;</span></span><br><span class="line">dispatch_source_set_event_handler<span class="list">(<span class="keyword">stdinSource</span>, ^&#123;</span><br><span class="line">    char buf[<span class="number">1024</span>]<span class="comment">;</span></span><br><span class="line">    int len = read<span class="list">(<span class="keyword">STDIN_FILENO</span>, buf, sizeof<span class="list">(<span class="keyword">buf</span>)</span>)</span><span class="comment">;</span></span><br><span class="line">    if<span class="list">(<span class="keyword">len</span> &gt; <span class="number">0</span>)</span></span><br><span class="line">        NSLog<span class="list">(@<span class="string">"Got data from stdin: %.*s"</span>, len, buf)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_resume<span class="list">(<span class="keyword">stdinSource</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>这是标准的UNIX方式来处理事务的好处，不用去写loop。如果使用经典的 read调用，我们还得万分留神，因为返回的数据可能比请求的少，还得忍受无厘头的“errors”，比如 EINTR (系统调用中断)。使用GCD，我们啥都不用管，就从这些蛋疼的情况里解脱了。如果我们在文件描述符中留下了未读取的数据，GCD会再次调用我们的句柄。<br>对于标准输入，这没什么问题，但是对于其他文件描述符，我们必须考虑在完成读写之后怎样清除描述符。对于dispatch source还处于活跃状态时，我们决不能关闭描述符。如果另一个文件描述符被创建了（可能是另一个线程创建的）并且新的描述符刚好被分配了相同的数字，那么你的dispatch source可能会在不应该的时候突然进入读写状态。de这个bug可不是什么好玩的事儿。<br>适当的清除方式是使用 dispatch_source_set_cancel_handler，并传入一个block来关闭文件描述符。然后我们使用 dispatch_source_cancel来取消dispatch source，使得句柄被调用，然后文件描述符被关闭。<br>使用其他dispatch source类型也差不多。总的来说，你提供一个source（mach port、文件描述符、进程ID等等）的区分符来作为diapatch source的句柄。mask参数通常不会被使用，但是对于 DISPATCH_SOURCE_TYPE_PROC 来说mask指的是我们想要接受哪一种进程事件。然后我们提供一个句柄，然后恢复这个source（前面我加粗字体所说的，得先恢复），搞定。dispatch source也提供一个特定于source的data，我们使用 dispatch_source_get_data函数来访问它。例如，文件描述符会给出大致可用的字节数。进程source会给出上次调用之后发生的事件的mask。具体每种source给出的data的含义，</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="第一个">第一个</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#include <span class="title">&lt;CoreFoundation/CoreFoundation.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>  </span><br><span class="line">_perform(<span class="keyword">void</span> *info __unused)  </span><br><span class="line">&#123;  </span><br><span class="line">    printf(<span class="string">"hello\n"</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>  </span><br><span class="line">_timer(<span class="built_in">CFRunLoopTimerRef</span> timer __unused, <span class="keyword">void</span> *info)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">CFRunLoopSourceSignal</span>(info);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span>  </span><br><span class="line">main()  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">CFRunLoopSourceRef</span> source;  </span><br><span class="line">    <span class="built_in">CFRunLoopSourceContext</span> source_context;  </span><br><span class="line">    <span class="built_in">CFRunLoopTimerRef</span> timer;  </span><br><span class="line">    <span class="built_in">CFRunLoopTimerContext</span> timer_context;  </span><br><span class="line">  </span><br><span class="line">    bzero(&amp;source_context, <span class="keyword">sizeof</span>(source_context));  </span><br><span class="line">    source_context<span class="variable">.perform</span> = _perform;  </span><br><span class="line">    source = <span class="built_in">CFRunLoopSourceCreate</span>(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;source_context);  </span><br><span class="line">    <span class="built_in">CFRunLoopAddSource</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), source, k<span class="built_in">CFRunLoopCommonModes</span>);  </span><br><span class="line">  </span><br><span class="line">    bzero(&amp;timer_context, <span class="keyword">sizeof</span>(timer_context));  </span><br><span class="line">    timer_context<span class="variable">.info</span> = source;  </span><br><span class="line">    timer = <span class="built_in">CFRunLoopTimerCreate</span>(<span class="literal">NULL</span>, <span class="built_in">CFAbsoluteTimeGetCurrent</span>(), <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, </span><br><span class="line">    _timer, &amp;timer_context);  </span><br><span class="line">    <span class="built_in">CFRunLoopAddTimer</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), timer, k<span class="built_in">CFRunLoopCommonModes</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">CFRunLoopRun</span>();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="CFRunLoop" scheme="http://ytlvy.com/tags/CFRunLoop/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/tags/IOS/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
</feed>