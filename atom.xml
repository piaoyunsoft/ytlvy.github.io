<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Yt's Blog]]></title>
  <subtitle><![CDATA[Valar Morghulis]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://ytlvy.com//"/>
  <updated>2015-08-08T13:26:00.000Z</updated>
  <id>http://ytlvy.com//</id>
  
  <author>
    <name><![CDATA[Yt]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Notes: The interesting things from WWDC, iOS 9, Swift 2]]></title>
    <link href="http://ytlvy.com/2015/08/08/Notes-The-interesting-things-from-WWDC-iOS-9-Swift-2/"/>
    <id>http://ytlvy.com/2015/08/08/Notes-The-interesting-things-from-WWDC-iOS-9-Swift-2/</id>
    <published>2015-08-08T13:25:39.000Z</published>
    <updated>2015-08-08T13:26:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="WWDC中那些令人感兴趣的事物:iOS_9,_Swift_2">WWDC中那些令人感兴趣的事物:iOS 9, Swift 2</h2><blockquote>
<ul>
<li>原文链接 : <a href="http://iosdevtips.co/post/121053658888/wwdc-ios-9-swift-2-notes" target="_blank" rel="external">Notes: The interesting things from WWDC, iOS 9, Swift 2</a></li>
<li>原文作者: <a href="http://iosdevtips.co" target="_blank" rel="external">Rounak Jain</a></li>
<li>译文出自: <a href="http://www.devtf.cn/" target="_blank" rel="external">开发技术前线http://www.devtf.cn/</a></li>
<li>译者 : <a href="https://github.com/Lollypo" target="_blank" rel="external">Lollypo</a> </li>
<li>校对者:<a href="https://github.com/bboyfeiyu" target="_blank" rel="external">Mr.Simple</a></li>
<li>状态 :  完成</li>
</ul>
</blockquote>
<p>今天WWDC上的Keynote非常棒,即便到目前为止还未结束.在开发者方面,已经有大量的新事物出现,其中包括有Swift 2, iOS 9, CloudKit等等.</p>
<p>这里是我在浏览发布日志,API差异,新特性等内容时记录的笔记</p>
<ul>
<li><p>你不需要加入$99的开发者计划就可以在真机上调试应用程序.此外,Mac与iOS开发者计划合并,可以节省一半支出:<br><img src="http://40.media.tumblr.com/ab8cf0d95f459e63bb10ded612e2fa34/tumblr_inline_npnb64YpK31qh9cw7_500.png" alt=""></p>
</li>
<li><p>Interface Builder支持实时预览模糊与透明效果<br><img src="http://40.media.tumblr.com/ed19a7cbd80fe5ccb49f5a9102744eec/tumblr_inline_npnb8aLtBC1qh9cw7_500.png" alt=""></p>
</li>
<li><p>Objective-C支持泛型,这意味着集合对象,如数组,字典可以像Swift一样指定类型<br><img src="http://40.media.tumblr.com/4ed77823bca27d89db84f654080d7d28/tumblr_inline_npnbbdudd01qh9cw7_500.png" alt=""></p>
</li>
<li><p>新的名为 <a href="https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIStackView_Class_Reference/index.html#//apple_ref/doc/uid/TP40015256" target="_blank" rel="external">UIStackView</a>UI类,是Mac中NSStackView的一种实现.</p>
</li>
<li><p><a href="https://developer.apple.com/library/prerelease/ios/documentation/DataManagement/Conceptual/CloutKitWebServicesReference/Introduction/Introduction.html#//apple_ref/doc/uid/TP40015240" target="_blank" rel="external">CloudKit现在也可以在Web中使用</a></p>
</li>
<li><p>开放 CASpringAnimation!<br><img src="http://40.media.tumblr.com/65c41c82d295034c23ef986214404c6d/tumblr_inline_npnbg2mCrc1qh9cw7_500.png" alt=""></p>
</li>
<li><p>应用程序现在可以作为拓展插入到Safari中,听起来有点像广告拦截器.此外,应用程序可以在Safari的共享链接填充内容</p>
</li>
<li><p>开发者现在可以使用 <code>SFSafariViewController</code>, 这可以共享Safari中中cookies, 自动填充以及其他Safari中的特性.</p>
</li>
<li><p><code>UIPickerView</code> 可转换为任意尺寸,而不必再使用那些丑陋的转换技巧.</p>
</li>
<li><p>iOS应用程序可在发出提醒展示一段文本域,此前仅限于Messages使用.</p>
</li>
<li><p>通讯录可通过面向对象的API来访问,而不是之前的C</p>
</li>
<li><p>电话API在低版本设备上不支持,这也许会导致编译时错误.现在有新的判断条件来决定是否执行代码,这可以有效避免使用新的API导致的应用程序崩溃:<br><img src="http://41.media.tumblr.com/c1875f851f168467e8e3bd435fa31f8d/tumblr_inline_npnbnvrUp31qh9cw7_500.png" alt=""></p>
</li>
<li><p><code>UICollectionView</code> 新添加了许多方法来支持交互式移动</p>
</li>
<li><p>新的名为 <code>UIFieldBehavior</code> 的 UIKit Dynamics类</p>
</li>
<li><p>Xcode Assets Catalog: 设备不会一次性下载所有尺寸的图片,而根据其自身的需要下载 1x, 2x 或 3x 的图片,大大减少了应用程序的大小.</p>
</li>
</ul>
<h2 id="其他一些你可能感兴趣的链接:">其他一些你可能感兴趣的链接:</h2><ul>
<li><a href="https://t.co/cOdmXdQ0EQ" target="_blank" rel="external">API差异</a></li>
<li><a href="https://itunes.apple.com/us/book/swift-programming-language/id1002622538?mt=11" target="_blank" rel="external">Swift 2提前发布版电子书</a></li>
<li><a href="http://t.co/5pU8P4iNEH" target="_blank" rel="external">Xcode 7 发布日志</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="WWDC中那些令人感兴趣的事物:iOS_9,_Swift_2">WWDC中那些令人感兴趣的事物:iOS 9, Swift 2</h2><blockquote>
<ul>
<li>原文链接 : <a href="http://iosdevtips.co/post/1]]>
    </summary>
    
      <category term="WWDC" scheme="http://ytlvy.com/tags/WWDC/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift UIKit Dynamics Tutorial: Getting Started]]></title>
    <link href="http://ytlvy.com/2015/08/08/Swift-UIKit-Dynamics-Tutorial-Getting-Started/"/>
    <id>http://ytlvy.com/2015/08/08/Swift-UIKit-Dynamics-Tutorial-Getting-Started/</id>
    <published>2015-08-08T13:24:37.000Z</published>
    <updated>2015-08-08T13:25:06.000Z</updated>
    <content type="html"><![CDATA[<h2 id="UIKit_Dynamics_教程:_起步">UIKit Dynamics 教程: 起步</h2><blockquote>
<ul>
<li>原文链接 : <a href="http://www.raywenderlich.com/76147/uikit-dynamics-tutorial-swift" target="_blank" rel="external">UIKit Dynamics Tutorial: Getting Started</a></li>
<li>原文作者: <a href="http://www.raywenderlich.com/u/frosty" target="_blank" rel="external">James Frost</a></li>
<li>译文出自: <a href="http://www.devtf.cn/" target="_blank" rel="external">开发技术前线http://www.devtf.cn/</a></li>
<li>译者 : <a href="https://github.com/Lollypo" target="_blank" rel="external">Lollypo</a> </li>
<li>校对者: <a href="https://github.com/mrchenhao" target="_blank" rel="external">Harries Chen</a></li>
<li>状态 :  完成</li>
</ul>
</blockquote>
<p><strong>更新备注</strong>:本教程是由<a href="http://www.raywenderlich.com/u/ColinEberhardt" target="_blank" rel="external">Colin Eberhardt</a>编写的<a href="http://www.raywenderlich.com/?page_id=48020" target="_blank" rel="external"> iOS 7 by Tutorials</a>其中某章节的精简版本.由James Frost更新到iOS8并用Swift重写,在Xcode 6 beta 7版本上测试通过。</p>
<p>iOS的设计目标鼓励你去创建数字界面模拟触摸，手势，改变方向等，就好像它们真实的物理对象而远非像素的集合。最终给予用户更深层级的交互而不是肤浅的拟真设计。</p>
<p>这听起来感觉挺难的，因为让数字界面看起来是真实的远比让它感觉是真实的简单。不过好在你有一些漂亮的新工具:</p>
<ul>
<li><strong>UIKit Dynamics</strong> 是集成到UIKit中的物理引擎。这允许你创建一个感觉像是真实的界面，通过添加一些行为，例如重力，锚连接 (弹簧)以及力. 你可以定义你希望你的界面需要的物理特征, Dynamics会帮你关心其他的细枝末节。</li>
<li><strong>Motion Effects</strong> 允许你创建类似于iOS 7 主屏幕中酷酷的视差效果. 基本上你可以利用手机加速器提供的数据来创建界面来模拟手机方向发生改变的反应。</li>
</ul>
<p>当一起使用的时候，由 Dynamics 与 Motion形成用户体验的工具，让你的界面给用户生活带来非同一般的体验。当观察到他们的操作是通过一种自然、动态的方式，你的用户将会与你的app进行更深层次的连接。</p>
<blockquote>
<p><strong>注意</strong>: 由于本教程编写的时候iOS 8 还处于测试中，因此<a href="http://www.raywenderlich.com/?p=74138" target="_blank" rel="external">没有提供iOS8的截图</a>. 所有的截图都是iOS7环境下的,不过看起来与iOS 8相差不大.</p>
</blockquote>
<a id="more"></a>
<h3 id="Getting_started_起步">Getting started  起步</h3><p>UIKit Dynamics是非常有趣的；最好的学习方法就是脚踏实地先学一些小例子。</p>
<p>打开Xcode，依次选择<strong>File / New / Project …</strong> 然后选择 <strong>iOS Application / Single View Application</strong> 最后命名你的项目为<strong>DynamicsDemo</strong>。项目创建完成之后，打开 <strong>ViewController.swift</strong> ，然后在<code>viewDidLoad</code>方法中添加如下代码:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> square = <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">100</span>, y: <span class="number">100</span>, width: <span class="number">100</span>, height: <span class="number">100</span>))</span><br><span class="line">square.backgroundColor = <span class="type">UIColor</span>.grayColor()</span><br><span class="line">view.addSubview(square)</span><br></pre></td></tr></table></figure>
<p>以上代码仅仅是在界面上添加一个方形的<code>UIView</code>。</p>
<p>运行你的App,你就可以在模拟器中看到如下的正方形:</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/09/LonelySquare.png" alt=""></p>
<p>如果你在真机中运行此app,可以尝试倾斜、颠倒甚至是摇晃它.你会发现这样做没什么效果.这是因为一切是按照设计来工作的.当你添加一个View到界面上时,你希望它一直固定在设定好的坐标上,除非是你给界面添加一些动态的效果.</p>
<h3 id="Adding_gravity_添加重力">Adding gravity   添加重力</h3><p>还是在 <strong>ViewController.swift</strong>中，在<code>viewDidLoad</code>之上加上下面这些属性:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> animator: <span class="type">UIDynamicAnimator</span>!</span><br><span class="line"><span class="keyword">var</span> gravity: <span class="type">UIGravityBehavior</span>!</span><br></pre></td></tr></table></figure>
<p>这些属性是表示自动拆包可选类型(在类型后由!表示).这些属性必须是可选类型的,因为我们在<code>init</code>方法中不会初始化它们.同时也是因为在你初始化之后它们不可能为空.这样通过!就可以避免每一次都手动拆包.</p>
<p>在<code>viewDidLoad</code>方法的最后加上这段代码:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">animator = <span class="type">UIDynamicAnimator</span>(referenceView: view)</span><br><span class="line">gravity = <span class="type">UIGravityBehavior</span>(items: [square])</span><br><span class="line">animator.addBehavior(gravity)</span><br></pre></td></tr></table></figure>
<p>我会在一会儿之后解释这个.现在,运行你的程序.你会看到你的方块慢慢的开始加速向下运行,直到掉落在屏幕的底部.</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/09/FallingSquare.png" alt=""></p>
<p>刚刚添加的代码中,有两个Dynamics的类在起作用:</p>
<ul>
<li><strong>UIDynamicAnimator</strong> 是UIKit物理引擎.这个类跟踪你添加到Dynamics中的各种行为,例如重力,并且提供了整体的上下文.当你创建一个动画实例时, 你需要传递一个该动画用来定义坐标系统的View.</li>
<li><strong>UIGravityBehavior</strong> 模拟重力行为以及对一个或者多个物体施力,允许你模拟物理行为.当你创建一个行为的实例时, 你需要将此行为关联到一系列的物体上  — 通常来说是View. 这样你就可以选择哪些物体受到该行为的影响,在这个案例中物体受重力影响.</li>
</ul>
<p>大多数的行为有一些配置属性;例如,重力行为允许你改变它的角度和大小.尝试修改这些属性让你的对象降落,侧移,或者是不同加速度的对角线.</p>
<p>注意:稍微说一下,在物理世界中,重力(g)表示米每秒平方,约等于9.8m/s2.使用牛顿第二定律,运用下列公式可以计算出在重力的影响下物体将会下滑多远.</p>
<p><strong>distance = 0.5 × g × time2</strong></p>
<p>在UIKit Dynamics中,该公式是一样的不过单位却是有所不同.你使用的是每千像素平方秒而不是米.使用牛顿第二定律,基于你所提供的重力组件,仍然可以计算出在任意时间点你的View的地点.</p>
<p>但是你真的需要全部了解么?并不是这样;你真正需要知道的是<strong>g</strong>越大就表示物体下降的越快,这在数学的角度来看并不难理解.</p>
<h3 id="Setting_boundaries_设定边界">Setting boundaries  设定边界</h3><p>虽然你看不到它，这个方块甚至会继续下落后即便它已经消失在屏幕的底部.为了让它在屏幕的范围内，你需要定义一个边界.</p>
<p>在<strong>ViewController.swift</strong>中添加另外一个属性:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> collision: <span class="type">UICollisionBehavior</span>!</span><br></pre></td></tr></table></figure>
<p>在<code>viewDidLoad</code>方法的最后加上这几行:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">collision = <span class="type">UICollisionBehavior</span>(items: [square])</span><br><span class="line">collision.translatesReferenceBoundsIntoBoundary = <span class="literal">true</span></span><br><span class="line">animator.addBehavior(collision)</span><br></pre></td></tr></table></figure>
<p>以上代码创建了一个碰撞行为,其中定义了若干边界与该物体交互.</p>
<p>以上代码将<code>translatesReferenceBoundsIntoBoundary</code> 属性设为<code>true</code>,而不是显示的定义边界坐标. 这表示被关联的View的坐标被用于<code>UIDynamicAnimator</code>.</p>
<p>运行程序,你会看到方块碰撞屏幕的底部,然后反弹一下,停了下来,就像这样:</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/09/SquareAtRest.png" alt=""></p>
<p>这是一些令人印象深刻的行为,特别是考虑到你此时只添加了这一点代码.</p>
<h3 id="Handling_collisions_处理碰撞">Handling collisions  处理碰撞</h3><p>接下来,你将添加一个不可移动的障碍物来与下落的方块进行碰撞交互.</p>
<p>将下面的代码添加到<code>viewDidLoad</code>方法中添加方块View的后面:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> barrier = <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">300</span>, width: <span class="number">130</span>, height: <span class="number">20</span>))</span><br><span class="line">barrier.backgroundColor = <span class="type">UIColor</span>.redColor()</span><br><span class="line">view.addSubview(barrier)</span><br></pre></td></tr></table></figure>
<p>运行你的程序;你会看到一个红色的”障碍物”在屏幕的中间穿过.然而事实是障碍物并未对下落的方块产生影响:</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2013/09/BadBarrier.png" alt=""></p>
<p>这并不是你想要的效果,但这却是一个重要的提醒:Dynamics为只对已关联的行为的View产生影响.</p>
<p>可以看一下这张图:</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/09/DynamicClasses.png" alt=""></p>
<p><strong>UIDynamicAnimator</strong>与一个提供了坐标系统的View相关联.然后你在与此关联的物体上添加了若干个行为对它们施力.大多数行为可以与多个物体关联,同样的一个物体也可以与若干个行为关联.上面的图显示当前程序中有关联的行为.</p>
<p>无论是你现在代码中的行为还是障碍物都是不被知道的,所以从引擎系统角度看,障碍物是不存在的.</p>
<h3 id="Making_objects_respond_to_collisions_让物体对碰撞做出反应">Making objects respond to collisions  让物体对碰撞做出反应</h3><p>为了使方块与障碍物相碰撞,找到初始化碰撞行为的那行,然后替换成下面的:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collision = <span class="type">UICollisionBehavior</span>(items: [square, barrier])</span><br></pre></td></tr></table></figure>
<p>碰撞对象需要知道应该与之几乎的每一个View;因此添加障碍物到物体列表中,这样就允许碰撞对象与之发生作用.</p>
<p>运行你的程序;这两个对象产生碰撞行为,如下面的截图所示:</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2013/09/GoodBarrier.png" alt=""></p>
<p>这个碰撞的行为围绕与之关联的每个物体,形成了一个”边界”.将他们从对象改变成更坚固的物体.</p>
<p>更新之前的图示,现在可以看到现在碰撞行为与View相关联了:</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2013/09/DynamicClasses2.png" alt=""></p>
<p>然后,两个物体的相互作用还是有些不太对劲.障碍物应该是不可移动的,但是当两个物体碰撞时,你当前的配置的障碍物向着屏幕的底部移动了.</p>
<p>更奇怪的是,障碍物居然在屏幕底部弹跳,而且不像方块那样停止下来 -这样是因为重力行为没有与障碍物交互.这同样也解释了为什么障碍物直到与方块碰撞才移动.</p>
<p>看起来你需要一个不一样的解决问题的办法.由于障碍物是不可移动的,没有任何必须要让运动引擎直到它的存在,但这样如何检测碰撞呢?</p>
<h3 id="Invisible_boundaries_and_collisions_可见的边界与碰撞">Invisible boundaries and collisions  可见的边界与碰撞</h3><p>恢复碰撞行为的初始化到原来的状态，让它只知道方块：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collision = <span class="type">UICollisionBehavior</span>(items: [square])</span><br></pre></td></tr></table></figure>
<p>此行之后,添加以下内容:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add a boundary that has the same frame as the barrier</span></span><br><span class="line">collision.addBoundaryWithIdentifier(<span class="string">"barrier"</span>, forPath: <span class="type">UIBezierPath</span>(rect: barrier.frame))</span><br></pre></td></tr></table></figure>
<p>上面的代码添加了一个具有同样结构的障碍物View作为可见的边界.这个红色的障碍物保持着对用户可见,但对Dynamics引擎不可见,同时,边界对于Dynamics引擎可见,对于用户却不可见.当方块落下时,看起来似乎是与障碍物交互的,然而实际上却是撞到了不可移动的边界.</p>
<p>运行你的程序看看这个动作,如下图:</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2013/09/BestBarrier.png" alt=""></p>
<p>现在方块在边界处反弹,旋转了一下,然后继续继续朝屏幕底部落下.</p>
<p>现在的UIKit Dynamics的能力变得相当清楚：你可以用少量代码完成效果.在这之中有很多细节;接下来的部分我将向你展示一些Dynamics在你的应用程序中与对象的交互细节。</p>
<h3 id="Behind_the_scenes_of_collisions_碰撞背后的知识">Behind the scenes of collisions  碰撞背后的知识</h3><p>任何Dynamic行为都有一个action属性,用来提供一个block,在动画的每一步都执行:添加以下代码到<code>viewDidLoad</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">collision.action = &#123;</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">"<span class="subst">\(NSStringFromCGAffineTransform(square.transform)</span>) <span class="subst">\(NSStringFromCGPoint(square.center)</span>)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码的日志记录了下落方块的center与transform属性.运行程序,然后你就会在Xcode的输出窗口看到这些输出.</p>
<p>从开始到400毫秒这段时间,你应该是看到类似下面的日志信息:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], &#123;<span class="number">150</span>, <span class="number">236</span>&#125;</span><br><span class="line">[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], &#123;<span class="number">150</span>, <span class="number">243</span>&#125;</span><br><span class="line">[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], &#123;<span class="number">150</span>, <span class="number">250</span>&#125;</span><br></pre></td></tr></table></figure>
<p>这里你可以看到运动引擎一直在改变方块的center — 也就是动画执行中的每一步的frame值.</p>
<p>只要方块撞到障碍物,就开始旋转,这就会生成类似以下的日志信息:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0.99797821</span>, <span class="number">0.063557133</span>, -<span class="number">0.063557133</span>, <span class="number">0.99797821</span>, <span class="number">0</span>, <span class="number">0</span>] &#123;<span class="number">152</span>, <span class="number">247</span>&#125;</span><br><span class="line">[<span class="number">0.99192101</span>, <span class="number">0.12685727</span>, -<span class="number">0.12685727</span>, <span class="number">0.99192101</span>, <span class="number">0</span>, <span class="number">0</span>] &#123;<span class="number">154</span>, <span class="number">244</span>&#125;</span><br><span class="line">[<span class="number">0.97873402</span>, <span class="number">0.20513339</span>, -<span class="number">0.20513339</span>, <span class="number">0.97873402</span>, <span class="number">0</span>, <span class="number">0</span>] &#123;<span class="number">157</span>, <span class="number">241</span>&#125;</span><br></pre></td></tr></table></figure>
<p>这里你可以看到Dynamics使用的是transform与基于底层物理模型定位视图偏移的组合.</p>
<p>虽然对于Dynamics的这些属性的兴趣可能不大,不过重要的是要知道,他们正在发挥作用.因此,如果你以编程方式更改frame或transform的属性,你可以假设这些值将被覆盖.这意味着当对象被Dynamics控制时,你就不能使用transform缩放对象了.</p>
<p>该方法为Dynamics行为签名,选择物体而不是View.应用动力学行为的唯一需要就是让对象实现 <code>UIDynamicItem</code> 协议,这样:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">UIDynamicItem</span> : <span class="title">NSObjectProtocol</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> center: <span class="type">CGPoint</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">  <span class="keyword">var</span> bounds: <span class="type">CGRect</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  <span class="keyword">var</span> transform: <span class="type">CGAffineTransform</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>UIDynamicItem</code>协议允许Dynamics读写center和transform属性,允许其基于其内部计算来移动物体.它对bounds也有读取的权限,用来确定物体的大小。这允许它来创建碰撞边界的四周的物体以及计算当前物体的质量.</p>
<p>这个协议意味着引擎不与UIView耦合,此外还有一个UIKit类不是视图但仍然遵循这个协议:<code>UICollectionViewLayoutAttributes</code>.这允许引擎在集合视图内执行动画.</p>
<h3 id="Collision_notifications_碰撞提醒">Collision notifications 碰撞提醒</h3><p>到目前为止,你已经添加了一些视图和行为然后让Dynamics控制.在这一节你会看看如何在物体碰撞时接收通知.</p>
<p>还是在<strong>ViewController.swift</strong>文件中,修改类的声明来遵循 <code>UICollisionBehaviorDelegate</code>协议:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="typename">UIViewController</span>, <span class="typename">UICollisionBehaviorDelegate &#123;</span></span></span><br></pre></td></tr></table></figure>
<p>在 <code>viewDidLoad</code>方法中,将视图控制器设置为刚刚初始化的碰撞代理对象,如下:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collision<span class="class">.collisionDelegate</span> = self</span><br></pre></td></tr></table></figure>
<p>接下来,在类中实现碰撞行为代理中的一个方法:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">collisionBehavior</span><span class="params">(behavior: UICollisionBehavior!, beganContactForItem item: UIDynamicItem!, withBoundaryIdentifier identifier: NSCopying!, atPoint p: CGPoint)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">println</span>(<span class="string">"Boundary contact occurred - <span class="subst">\(identifier)</span>"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该代理方法会在发生碰撞时调用.这会在控制台输出日志信息.为了避免太多的日志信息搞乱了控制台的消息,请随意删除上一节添加的<code>collision.action</code>日志.</p>
<p>运行程序,物体发生交互,然后控制台会输出这些:</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Boundary </span>contact occurred - <span class="keyword">barrier</span><br><span class="line"></span><span class="keyword">Boundary </span>contact occurred - <span class="keyword">barrier</span><br><span class="line"></span><span class="keyword">Boundary </span>contact occurred - nil</span><br><span class="line"><span class="keyword">Boundary </span>contact occurred - nil</span><br><span class="line"><span class="keyword">Boundary </span>contact occurred - nil</span><br><span class="line"><span class="keyword">Boundary </span>contact occurred - nil</span><br></pre></td></tr></table></figure>
<p>从上面的日志消息中可以看到,方块与标识的边界发生两次碰撞;这是您前面添加的不可见的边界。(null)标识符是指外部引用视图边界.</p>
<p>这些日志消息可以引人入胜(很严肃的说!),不过需要提供一个视觉指示项来表示反弹.</p>
<p>在第二次输出日志的行后,添加以下代码:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> collidingView = item <span class="keyword">as</span> <span class="type">UIView</span></span><br><span class="line">collidingView.backgroundColor = <span class="type">UIColor</span>.yellowColor()</span><br><span class="line"><span class="type">UIView</span>.animateWithDuration(<span class="number">0.3</span>) &#123;</span><br><span class="line">collidingView.backgroundColor = <span class="type">UIColor</span>.grayColor()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码将碰撞物体的的背景颜色更改为黄色,然后再消褪到灰色.</p>
<p>运行程序然后查看这个效果:</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2013/09/YellowCollision.png" alt=""></p>
<p>方块每次碰撞到边界都会变化成黄色.</p>
<p>到目前为止UIKit Dynamics 通过计算它们的bounds自动为你的物体设置物理属性(如质量和弹性).接下来你将看到如何自己使用<code>UIDynamicItemBehavior</code>类来控制这些物理属性.</p>
<h3 id="Configuring_item_properties_设置属性">Configuring item properties  设置属性</h3><p>在<code>viewDidLoad</code>方法中,在方法的末尾加上以下代码:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let itemBehaviour = <span class="function"><span class="title">UIDynamicItemBehavior</span><span class="params">(items: [square])</span></span></span><br><span class="line">itemBehaviour<span class="class">.elasticity</span> = <span class="number">0.6</span></span><br><span class="line">animator.<span class="function"><span class="title">addBehavior</span><span class="params">(itemBehaviour)</span></span></span><br></pre></td></tr></table></figure>
<p>以上代码创建了一个物体行为,并与方块关联上,接着将其添加到animator中. elasticity属性控制物体的弹力;其值为1.0时表示碰撞完全反弹;也就是说,碰撞不消耗能量或者减缓速度.你为方块设置的elasticity为0.6,这意味着你的方块每次碰撞时都会减缓速度.</p>
<p>运行你的程序,然后你会发现方块现在的行为很有弹性,如下所示:</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2013/09/PrettyBounce.png" alt=""></p>
<blockquote>
<p>注意:如果你想知道我是如何产生上图的方块轨迹图的,这实际上很简单!我只是添加了一个block到每个行为中的action属性中,该block每三秒执行一次,然后使用当前方块的center和transform属性在视图中添加一个新的方块.下面就是我的解决方案.<br>解决方案:<br><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var updateCount = 0</span><br><span class="line"><span class="component">collision.action = &#123;</span><br><span class="line">  if (updateCount % 3 == 0) &#123;</span><br><span class="line">    let outline = UIView(frame: square<span class="string">.bounds)</span></span><br><span class="line">    outline<span class="string">.transform</span> = square<span class="string">.transform</span></span><br><span class="line">    outline<span class="string">.center</span> = square<span class="string">.center</span></span><br><span class="line">    outline<span class="string">.alpha</span> = 0.5</span><br><span class="line">    outline<span class="string">.backgroundColor</span> = UIColor<span class="string">.clearColor()</span></span><br><span class="line">    outline<span class="string">.layer.borderColor</span> = square<span class="string">.layer.presentationLayer().backgroundColor</span></span><br><span class="line">    outline<span class="string">.layer.borderWidth</span> = 1.0</span><br><span class="line">    self<span class="string">.view.addSubview(outline)</span></span><br><span class="line">  &#125;</span></span><br><span class="line">    ++updateCount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>在上面的代码你只改变了物体的弹力;然而,物体的行为类有许多可以控制的属性,如下:</p>
<ul>
<li><code>elasticity</code> – 弹力,决定碰撞时的弹力,例如,当物体发生碰撞行为时的弹力或者韧性.</li>
<li><code>friction</code>   –  摩擦力,决定物体滑动时的抵抗力.</li>
<li><code>density</code>   –  密度,如果加上大小,就能表示物体的质量.质量越大,物体越难加速或减速.</li>
<li><code>resistance</code> – 阻力,任何线性运动的抵抗力.与摩擦力不同的是,摩擦力只对滑动有效.</li>
<li><code>angularResistance</code> – 旋转的阻力.</li>
<li><code>allowsRotation</code> – 这个有点意思,因为这不表示真实物理世界中的属性. 将这个属性设置为NO可以让物体不管任何发生力量的旋转都无效.</li>
</ul>
<h3 id="Adding_behaviors_dynamically_动态添加行为">Adding behaviors dynamically  动态添加行为</h3><p>在当前情况下,你的程序为系统设置全部的行为,然后让Dynamics处理系统中的物理事件直到是全部的物体都静止下来.接下来,你将看到如何动态的添加与删除行为.</p>
<p>打开<strong>ViewController.swift</strong>,然后在<code>viewDidLoad</code>方法中添加以下属性:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> firstContact</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>添加以下代码到碰撞的代理方法<code>collisionBehavior(behavior:beganContactForItem:withBoundaryIdentifier:atPoint:)</code>的最后</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="params">(!firstContact)</span> &#123;</span><br><span class="line">  firstContact = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">let</span> <span class="built_in">square</span> = UIView<span class="params">(frame: CGRect<span class="params">(x: <span class="number">30</span>, y: <span class="number">0</span>, width: <span class="number">100</span>, height: <span class="number">100</span>)</span>)</span></span><br><span class="line">  <span class="built_in">square</span>.backgroundColor = UIColor.grayColor<span class="params">()</span></span><br><span class="line">  view.addSubview<span class="params">(square)</span></span><br><span class="line"></span><br><span class="line">  collision.addItem<span class="params">(square)</span></span><br><span class="line">  gravity.addItem<span class="params">(square)</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">let</span> attach = UIAttachmentBehavior<span class="params">(item: collidingView, attachedToItem:square)</span></span><br><span class="line">  animator.addBehavior<span class="params">(attach)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码检测初次接触时的障碍物和方块,然后创建第二个方块,并为其添加碰撞与重力行为.此外,你创建一个锚链接行为来为一对对象创建虚拟的弹簧效果.</p>
<p>运行你的程序;当最初的方块碰撞到障碍物时,你将会看到一个新的方块出现,就像下面这样:</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2013/09/Attachment.png" alt=""></p>
<p>尽管这样看起来两个方块之间似乎是连接着的,不过你在屏幕上是无法看到线条或者弹簧之类的.</p>
<h3 id="User_Interaction_用户交互">User Interaction  用户交互</h3><p>正如刚刚所看到的那样,你可以动态的添加或是删除你定义的物理系统中正在运动的行为.在最后一节,你将添加另一种类型的Dynamics行为-<code>UISnapBehavior</code>,当用户点击屏幕时,<code>UISnapBehavior</code>会生成一个弹簧动画跳转到指定位置.</p>
<p>删除你在上一节添加的代码:<code>firstContact</code>属性与<code>collisionBehavior()</code>中的if语句.这样当界面中只有一个方块时,就很容易看出来<code>UISnapBehavior</code>的作用.</p>
<p>在<code>viewDidLoad</code>中加上这两个属性:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> square</span>: UIView!</span><br><span class="line"><span class="variable"><span class="keyword">var</span> snap</span>: UISnapBehavior!</span><br></pre></td></tr></table></figure>
<p>这记录了方块视图,这样你就可以在控制器的任何地方访问到它.接下来你就会用到<code>snap</code>对象.</p>
<p>在<code>viewDidLoad</code>方法中,从声明方块的地方移除<code>let</code>关键字,这样就可以使用新的属性来替代局部变量:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">square = UIView(<span class="string">frame:</span> CGRect(<span class="string">x:</span> <span class="number">100</span>, <span class="string">y:</span> <span class="number">100</span>, <span class="string">width:</span> <span class="number">100</span>, <span class="string">height:</span> <span class="number">100</span>))</span><br></pre></td></tr></table></figure>
<p>最后,实现<code>touchesEnded</code>方法,每当用户点击屏幕的时候就创建新的触摸行为:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">touchesEnded</span><span class="params">(touches: NSSet, withEvent event: UIEvent)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (snap != <span class="literal">nil</span>) &#123;</span><br><span class="line">    animator.removeBehavior(snap)</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">let</span> touch = touches.anyObject() <span class="keyword">as</span> <span class="type">UITouch</span> </span><br><span class="line">  snap = <span class="type">UISnapBehavior</span>(item: square, snapToPoint: touch.locationInView(view))</span><br><span class="line">  animator.addBehavior(snap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码相当简单.首先,它会检查当前是否已经存在触摸行为并且移除.然后创建一个新的触摸行为来检测用户是否触摸方块,最后添加到animator中.</p>
<p>运行你的程序.尝试点击一下;无论你点击哪个地方,方块都应该会放大.</p>
<h3 id="Where_To_Go_From_Here?_何去何从">Where To Go From Here? 何去何从</h3><p>此时,你应该对于Dynamics的核心概念有了一定的理解.你可以下载本教程最后<a href="http://cdn5.raywenderlich.com/wp-content/uploads/2014/07/DynamicsDemo-Final-7.zip" target="_blank" rel="external">DynamicsDemo项目</a> 进行进一步的研究。</p>
<p>UIKit Dynamics 给你的应用带来物理引擎的能力.通过精妙的的反弹和弹簧和重力效果,给你的应用程序注入新的血液,让用户如同身临其境.</p>
<p>如果你想要更深入的学习UIKit Dynamics,请查阅我们编写的<a href="http://www.raywenderlich.com/?page_id=48020" target="_blank" rel="external">iOS 7 By Tutorials</a>. 这本书让你的知识更进一步,向你展示如何在真实场景中使用UIKit Dynamics:</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2013/09/SandwichFlowDynamics.png" alt=""></p>
<p>用户可以把菜谱上一瞥,当他们将菜谱放回时,它会掉回菜谱堆中,或者靠近屏幕顶部.最终给予应用程序一个真实的物理效果。</p>
<p>我希望你能喜欢这个UIKit Dynamics的教程,我们觉得这是非常炫酷的,期待你在程序中创造性的使用他们.如果你有任何的问题或意见,请在一下进行讨论!</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="UIKit_Dynamics_教程:_起步">UIKit Dynamics 教程: 起步</h2><blockquote>
<ul>
<li>原文链接 : <a href="http://www.raywenderlich.com/76147/uikit-dynamics-tutorial-swift">UIKit Dynamics Tutorial: Getting Started</a></li>
<li>原文作者: <a href="http://www.raywenderlich.com/u/frosty">James Frost</a></li>
<li>译文出自: <a href="http://www.devtf.cn/">开发技术前线http://www.devtf.cn/</a></li>
<li>译者 : <a href="https://github.com/Lollypo">Lollypo</a> </li>
<li>校对者: <a href="https://github.com/mrchenhao">Harries Chen</a></li>
<li>状态 :  完成</li>
</ul>
</blockquote>
<p><strong>更新备注</strong>:本教程是由<a href="http://www.raywenderlich.com/u/ColinEberhardt">Colin Eberhardt</a>编写的<a href="http://www.raywenderlich.com/?page_id=48020"> iOS 7 by Tutorials</a>其中某章节的精简版本.由James Frost更新到iOS8并用Swift重写,在Xcode 6 beta 7版本上测试通过。</p>
<p>iOS的设计目标鼓励你去创建数字界面模拟触摸，手势，改变方向等，就好像它们真实的物理对象而远非像素的集合。最终给予用户更深层级的交互而不是肤浅的拟真设计。</p>
<p>这听起来感觉挺难的，因为让数字界面看起来是真实的远比让它感觉是真实的简单。不过好在你有一些漂亮的新工具:</p>
<ul>
<li><strong>UIKit Dynamics</strong> 是集成到UIKit中的物理引擎。这允许你创建一个感觉像是真实的界面，通过添加一些行为，例如重力，锚连接 (弹簧)以及力. 你可以定义你希望你的界面需要的物理特征, Dynamics会帮你关心其他的细枝末节。</li>
<li><strong>Motion Effects</strong> 允许你创建类似于iOS 7 主屏幕中酷酷的视差效果. 基本上你可以利用手机加速器提供的数据来创建界面来模拟手机方向发生改变的反应。</li>
</ul>
<p>当一起使用的时候，由 Dynamics 与 Motion形成用户体验的工具，让你的界面给用户生活带来非同一般的体验。当观察到他们的操作是通过一种自然、动态的方式，你的用户将会与你的app进行更深层次的连接。</p>
<blockquote>
<p><strong>注意</strong>: 由于本教程编写的时候iOS 8 还处于测试中，因此<a href="http://www.raywenderlich.com/?p=74138">没有提供iOS8的截图</a>. 所有的截图都是iOS7环境下的,不过看起来与iOS 8相差不大.</p>
</blockquote>]]>
    
    </summary>
    
      <category term="UIKit Dynamics" scheme="http://ytlvy.com/tags/UIKit-Dynamics/"/>
    
      <category term="Swift" scheme="http://ytlvy.com/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift UIKit Dynamics - Tossing Views]]></title>
    <link href="http://ytlvy.com/2015/08/08/Swift-UIKit-Dynamics-Tossing-Views/"/>
    <id>http://ytlvy.com/2015/08/08/Swift-UIKit-Dynamics-Tossing-Views/</id>
    <published>2015-08-08T13:23:36.000Z</published>
    <updated>2015-08-08T13:24:14.000Z</updated>
    <content type="html"><![CDATA[<h2 id="UIKit_Dynamics_和_Swift_教程：抛掷视图_(Tossing_Views)">UIKit Dynamics 和 Swift 教程：抛掷视图 (Tossing Views)</h2><blockquote>
<ul>
<li>原文链接 : <a href="http://www.raywenderlich.com/94719/uikit-dynamics-swift-tutorial-tossing-views" target="_blank" rel="external">UIKit Dynamics and Swift Tutorial:Tossing Views</a></li>
<li>原文作者 : <a href="http://www.raywenderlich.com" target="_blank" rel="external">Ray Wenderlich</a></li>
<li>译文出自 : <a href="http://www.devtf.cn" target="_blank" rel="external">开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/samw00" target="_blank" rel="external">samw00</a> </li>
<li>校对者: <a href="https://github.com/mrchenchao" target="_blank" rel="external">mrchenchao</a></li>
<li>状态 : 完成</li>
</ul>
</blockquote>
<p>在这篇UIKit Dynamics教程中，你将学会如何通过添加手势，用一种很自然的方式将视图抛掷出屏幕的显示区域。如下图所示：</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/07/UIKitDynamics3.gif" alt="效果预览图"></p>
<p>你可能已经在<a href="https://itunes.apple.com/us/app/tweetbot-3-for-twitter-iphone/id722294701" target="_blank" rel="external">Tweetbot</a>这个流行的app里看到这一个技巧被大量的运用。</p>
<p>这篇教程特别适合中级水平的开发人员，因为内容包括如何实现一些特别棒的特效，比如用原生的UIKit框架实现旋转(rotation)和飞离(fly-away)等动画效果。</p>
<p>如果你刚刚接触UIKit dynamics, 也别紧张 － 因为这篇教程会一步一步引导你如何去做。</p>
<p>废话不多说，让我们直切主题吧！</p>
<a id="more"></a>
<h1 id="让我们开始吧">让我们开始吧</h1><blockquote>
<p>注意: 这一节是为那些想从头开始写这个项目的开发员所准备的。有经验的开发者可以直接跳过这一节去下一节”UIDynamicAnimator and UIAttachmentBehavior”, 在那我们已为你准备好了这个教程的启动项目。</p>
</blockquote>
<p>运行你的Xcode，选择<code>File\New\Project...</code>, 选择<code>iOS\Application\Single View Application template</code>然后点击<code>Next</code>。将项目命名为DynamicToss，确保语言用的是Swfit然后将设备设为iPhone.</p>
<p>接下来在左边点选项目名称并在Xcode顶部位置点击<strong>General</strong>。在<strong>Deployment Info/Device Orientation</strong>中不要勾选<strong>Landscape Left</strong>和<strong>Landscape Right</strong>，因为你的app只有竖屏这一种显示模式。</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/02/dynamictoss-orientation.png" alt=""></p>
<p>然后，下载你这个项目需要的<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2014/05/flying_goldfish.zip" target="_blank" rel="external">图片</a>，照片提供者：<a href="http://www.vickiwenderlich.com/" target="_blank" rel="external">gameartguppy.com</a>。</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/05/goldfish_feature.jpg" alt=""></p>
<p>将图片解压后添加到你项目中Images asset目录里。</p>
<p>接着，点击<strong>Main.storyboard</strong>然后再右边的工具栏中选择<strong>File Inspector</strong>。在本片教程中你不需要用到auto layout和size classes，所以勾掉<strong>Use Auto Layout</strong>选项。这会自动勾掉size classes。 在弹出的对话框中，在Keep size class data for：这一选项选iPhone，然后点击<strong>Disable Size Classes</strong>。</p>
<p>在storyboard中，在默认视图控制器中添加一个image view，然后将图片设为<strong>goldfish_feature</strong>。在image view的尺寸观察器中设置下列数值：X=33, y=137, Width=254, Height=172。紧接着在autoresizing mask中消掉弹性高度，宽度，右边距和底边距。这意味着只有顶边距和左边距是“被点选“的。</p>
<p>你的屏幕看起来应该像这样：</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/02/dynamictoss-imageview.png" alt=""></p>
<p>然后，在视图控制器中拖入两个view用以跟踪你的手势，并设置为下列数值</p>
<ul>
<li>View 1: (X=156, Y=219, Width=8, Height=8, Background=red)</li>
<li>View 2: (X=80, Y=420, Width=8, Height=8. Background=blue)</li>
</ul>
<p>当你完成之后，你的视图看起来应该是这样的：</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/02/dynamictoss-views.png" alt=""></p>
<p>基本上那就是你在storyboard中要做的所有准备，接下来就是代码了！</p>
<h2 id="Touch_Handling_触摸操作">Touch Handling 触摸操作</h2><p>打开<strong>ViewController.swift</strong>并在类中加入下列属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> imageView: <span class="type">UIImageView</span>!</span><br><span class="line"><span class="preprocessor">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> redSquare: <span class="type">UIView</span>!</span><br><span class="line"><span class="preprocessor">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> blueSquare: <span class="type">UIView</span>!</span><br><span class="line"> </span><br><span class="line">private <span class="keyword">var</span> originalBounds = <span class="type">CGRect</span>.zeroRect</span><br><span class="line">private <span class="keyword">var</span> originalCenter = <span class="type">CGPoint</span>.zeroPoint</span><br><span class="line"> </span><br><span class="line">private <span class="keyword">var</span> animator: <span class="type">UIDynamicAnimator</span>!</span><br><span class="line">private <span class="keyword">var</span> attachmentBehavior: <span class="type">UIAttachmentBehavior</span>!</span><br><span class="line">private <span class="keyword">var</span> pushBehavior: <span class="type">UIPushBehavior</span>!</span><br><span class="line">private <span class="keyword">var</span> itemBehavior: <span class="type">UIDynamicItemBehavior</span>!</span><br></pre></td></tr></table></figure>
<p>你将在等一会连接这些外部引用。其他的属性用来控制image view的运行轨迹和在触摸事件中跟踪image view的状态。</p>
<p>打开<strong>Main.storyboard</strong>然后右键（或者按住control）点击<strong>View Controller</strong>。在外部引用列表中的<strong>blueSquare</strong>右边有一个空心的小圈圈，点选后不要松开鼠标左键，然后拖拽到blue square的视图上来再松手。这会讲属性和视图对象绑定起来。</p>
<p>用同样的方式绑定red square和属性<strong>imageView</strong>。现在三个view属性应该绑定好了，如下图所示：</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/05/finallinking.png" alt=""></p>
<p>红色和蓝色的正方形代表着UIKit dynamics物理引擎用来时图像运动起来的点。</p>
<p>蓝色的正方形就代表着你触摸开始的那个点，也就是当你手指第一次触碰到屏幕的那个点。红色的正方形会跟踪你手指滑动的轨迹。</p>
<p>待会你将对dynamics做一些配置，使得当你在移动那个点的时候，image view也会相应的进行物理运动。</p>
<p>最后你还有一件事要做 － 给view添加一个手势识别。打开<strong>ViewController.swift</strong>然后在文件中加入下列方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">handleAttachmentGesture</span><span class="params">(sender:UIPanGestureRecognizer)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> location = sender.locationInView(<span class="keyword">self</span>.view)</span><br><span class="line">    <span class="keyword">let</span> boxLocation = sender.locationInView(<span class="keyword">self</span>.imageView)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> sender.state &#123;</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Began</span>:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"Your touch start position is <span class="subst">\(location)</span>"</span>)</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"Start location in image is <span class="subst">\(boxLocation)</span>"</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Ended</span>:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"Your touch end position is <span class="subst">\(location)</span>"</span>)</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"End location in image is <span class="subst">\(boxLocation)</span>"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你还要添加一个拖拽手势识别，也就是panning，然后当panning触发时，调用这个方法。现阶段，这个方法就是简单的现实你的手指在两个坐标系(view, image view)中的位置而已。</p>
<p>打开<strong>Main.storyboard</strong>，往视图上拖拽一个<strong>Pan Gesture Recognizer</strong>。然后按住control点住<strong>Pan Gesture Recognizer</strong>拖到你的<strong>View Controller</strong>，然后连接<strong>handleAttachmentGesture:</strong>。</p>
<p>现在编译运行。在屏幕上滑动或者拖拽，你应该能在控制台上看到：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Your touch <span class="operator"><span class="keyword">start</span> <span class="keyword">position</span> <span class="keyword">is</span> (<span class="number">125.0</span>,<span class="number">227.0</span>)</span><br><span class="line"><span class="keyword">Start</span> location <span class="keyword">in</span> image <span class="keyword">is</span> (<span class="number">92.0</span>,<span class="number">90.0</span>)</span><br><span class="line">Your touch <span class="keyword">end</span> <span class="keyword">position</span> <span class="keyword">is</span> (<span class="number">195.5</span>,<span class="number">374.0</span>)</span><br><span class="line"><span class="keyword">End</span> location <span class="keyword">in</span> image <span class="keyword">is</span> (<span class="number">162.5</span>,<span class="number">237.0</span>)</span></span><br></pre></td></tr></table></figure>
<p>棒极了！你已经将一切都准备好了－接下来就是添加动态特效了。</p>
<h1 id="UIDynamicAnimator_和_UIAttachmentBehavior">UIDynamicAnimator 和 UIAttachmentBehavior</h1><blockquote>
<p>注意：如果你略过了之前的内容，先下载<a href="http://cdn4.raywenderlich.com/wp-content/uploads/2015/02/DynamicToss-Starter.zip" target="_blank" rel="external">项目</a>然后继续下面的内容。</p>
</blockquote>
<p>你要做的第一件事就是当你拖拽时，让你的image view也跟着动起来。你会用到UIKit Dynamics类中一个叫UIAttachmentBehavior的类。</p>
<p>打开<strong>ViewController.swift</strong>，然后在<strong>viewDidLoad()</strong>里面，将下边的代码添加到<strong>super.viewDidLoad()</strong>下面。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">animator = <span class="type">UIDynamicAnimator</span>(referenceView: view)</span><br><span class="line">originalBounds = imageView.bounds</span><br><span class="line">originalCenter = imageView.center</span><br></pre></td></tr></table></figure>
<p>上面的代码设立了一个UIDynamicAnimator，这是UIKit的一个引擎，就是为实现物理动画而准备的。这个引擎所参照的坐标系就是你提供的这个视图控制器的view。</p>
<p>通过给animator添加各种行为(behaviors)，你可以实现attaching views, pushing views, 让视图受重力影响等等。</p>
<p>让我们先从UIAttachmentBehavior开始，当你做了一个拖拽手势时让image view跟随你的指尖移动。</p>
<p>为了实现这效果，在<strong>handleAttachmentGesture(sender:)</strong>中添加如下代码，在<strong>case .Began</strong>中的两个<strong>println</strong>语句之后：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">animator.removeAllBehaviors()</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> centerOffset = <span class="type">UIOffset</span>(horizontal: boxLocation.x - imageView.bounds.midX,</span><br><span class="line">                            vertical: boxLocation.y - imageView.bounds.midY)</span><br><span class="line">attachmentBehavior = <span class="type">UIAttachmentBehavior</span>(item: imageView,</span><br><span class="line">    offsetFromCenter: centerOffset, attachedToAnchor: location)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">redSquare.center = attachmentBehavior.anchorPoint</span><br><span class="line">blueSquare.center = location</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line">animator.addBehavior(attachmentBehavior)</span><br></pre></td></tr></table></figure>
<p>让我们来看看每一步都做了些什么：</p>
<ol>
<li>第一步，先移除animtor中任何可能残留的动画行为。</li>
<li>然后，你创建了一个<strong>UIAttachmentBehavior</strong>，用来连接用户在image view内点击的点和一个锚点（刚好这两个点是重合的）。晚点你将改变这个锚点，从而使image view跟着移动。给视图添加一个锚点，就好比在view上一个固定的点和锚点之间添加了一个隐形的拉杆。</li>
<li>更新red square来表示锚点，而blue square就是表示在image view中和锚点相连的点。当手势刚开始时，这两个点是重合的。</li>
<li>在引擎animator添加这个行为使其生效。</li>
</ol>
<p>下一步你要告诉锚点跟随你的指尖。在<strong>handleAttachmentGesture(_:)</strong>，替换掉<strong>default:</strong>中的<strong>break</strong>语句为下列代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">attachmentBehavior.anchorPoint = sender.locationInView(view)</span><br><span class="line">redSquare.center = attachmentBehavior.anchorPoint</span><br></pre></td></tr></table></figure>
<p>当用户拖拽时候，default里面的代码内容来响应手势一直更新这个事件。上面的代码就是简单的将锚点，red square和手指当前位置合为一体。当用户手指移动时，手势识别则调用这个方法更新锚点至指尖移动到的位置。同时，animator也会随着锚点的移动自动更新view。</p>
<p>编译并运行，现在你可以把view拖来拖去了：</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2014/07/004_DraggedView-281x500.png" alt=""></p>
<p>注意观察view并不是在屏幕中简单的变动；如果手势起于图像的某一个角，你会发现当你移动时view会旋转，这就要归功于锚点了。</p>
<p>不过，当你拖拽完后，视图最好能回到自己的初始位置。我们类中添加一个新的方法来完善这个功能：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">resetDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    animator.removeAllBehaviors()</span><br><span class="line">    </span><br><span class="line">    <span class="type">UIView</span>.animateWithDuration(<span class="number">0.45</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.imageView.bounds = <span class="keyword">self</span>.originalBounds</span><br><span class="line">        <span class="keyword">self</span>.imageView.center = <span class="keyword">self</span>.originalCenter</span><br><span class="line">        <span class="keyword">self</span>.imageView.transform = <span class="type">CGAffineTransformIdentiy</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在<strong>handelAttachmentGesture(_:)</strong>中，在<strong>.Ended</strong>中的<strong>println</strong>语句下添加:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resetDemo()</span><br></pre></td></tr></table></figure>
<p>编译运行，现在当你拖拽完之后，视图就应该回到它自己初始的位置了。</p>
<h1 id="UIPushBehavior">UIPushBehavior</h1><p>接下来，我们要实现的是：当你停止拖拽时，使你的view飞离(detach)，我们会给这个view赋予动能，所以当你的手松开时，它能会延续它的既定轨道去运动。我们将通过<strong>UIPushBehavior</strong>来实现这一点。</p>
<p>首先，你需要两个常量。在文件头部添加它们：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ThrowingThreshold: <span class="variable">CGFloat =</span> <span class="number">1000</span></span><br><span class="line"><span class="keyword">let</span> ThrowingVelocityPadding: <span class="variable">CGFloat =</span> <span class="number">35</span></span><br></pre></td></tr></table></figure>
<p><strong>ThrowingThreshold</strong>表明view必须移动多块才能在手指松开后继续移动(而不是马上回到它的初始位置)。<strong>ThrowingVelocityPadding</strong>是一个神奇的常量，它对抛掷view速度快慢产生影响(这个数值是经过反复试错而得出的）。</p>
<p>最后，在<strong>handleAttachmentGesture(_:)</strong>中，在<strong>.Ended</strong>分支下，用下面的代码替换原来的<strong>resetDemo()</strong>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">animator.removeAllBehaviors()</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> velocity = sender.velocityInView(view)</span><br><span class="line"><span class="keyword">let</span> magnitude = sqrt((velocity.x * velocity.x) + (velocity.y * velocity.y))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> magnitude &gt; <span class="type">ThrowingThreshold</span> &#123;</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">let</span> pushBehavior = <span class="type">UIPushBehavior</span>(items: [imageView], mode: .<span class="type">Instantaneous</span>)</span><br><span class="line">    pushBehavior.pushDirection = <span class="type">CGVector</span>(dx: velocity.x / <span class="number">10</span>, dy: velocity.y / <span class="number">10</span>)</span><br><span class="line">    pushBehavior.magnitude = magnitude / <span class="type">ThrowingVelocityPadding</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">self</span>.pushBehavior = pushBehavior</span><br><span class="line">    animator.addBehavior(pushBehavior)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">let</span> angle = <span class="type">Int</span>(arc4random_uniform(<span class="number">20</span>)) - <span class="number">10</span></span><br><span class="line"> </span><br><span class="line">    itemBehavior = <span class="type">UIDynamicItemBehavior</span>(items: [imageView])</span><br><span class="line">    itemBehavior.friction = <span class="number">0.2</span></span><br><span class="line">    itemBehavior.allowsRotation = <span class="literal">true</span></span><br><span class="line">    itemBehavior.addAngularVelocity(<span class="type">CGFloat</span>(angle), forItem: imageView)</span><br><span class="line">    animator.addBehavior(itemBehavior)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">let</span> timeOffset = <span class="type">Int64</span>(<span class="number">0.4</span> * <span class="type">Double</span>(<span class="type">NSEC_PER_SEC</span>))</span><br><span class="line">    dispatch_after(dispatch_time(<span class="type">DISPATCH_TIME_NOW</span>, timeOffset), dispatch_get_main_queue()) &#123;</span><br><span class="line">        <span class="keyword">self</span>.resetDemo()</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    resetDemo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们再来看看每一步干了些什么：</p>
<ol>
<li><p>向手势获取拖拽的速度。通过速度和你的老朋友勾股定理，你可以计算出速度的量级 － 也就是x轴方向的速度和y轴方向的速度所构成的三角形的斜边(弦）。如果想了解这个定理背后的知识，可以瞅瞅<a href="http://www.raywenderlich.com/?p=90520" target="_blank" rel="external">Trigonometry for Game Programming Tutorial</a>.</p>
</li>
<li><p>当速度的量级超过了你设定的临界值，则创建一个push behavior。Push behavior会给特定的对象施加一种力，在这里，我们通过push behavior给图像施加一种瞬间，猝发的力。而运行的方向则是由x轴速度和y轴速度合起来转换出的一个方向向量来决定的。当你创建好push behavior之后，将其添加到animator的行为序列中。</p>
</li>
<li><p>这一步则将添加一下旋转特效，让图像看起来像是“飞离”一样。你可以在这里了解背后复杂的<a href="https://github.com/u10int/URBMediaFocusViewController/blob/master/URBMediaFocusViewController.m#L636-L686" target="_blank" rel="external">数学知识</a>。其中有部分效果取决于当你开始手势时，你的手指离边界的距离。你可以尝试设置其他的值然后观察它们的移动效果。这里用的值，会给出一个非常流畅平滑和酷毙了的旋转效果。</p>
</li>
<li><p>在指定的一段时间过后，图像将会被重置回原来初始的位置，所以“颼”的一下，图像又回到屏幕中 － 就想一个撞到墙弹回来的球一样。</p>
</li>
</ol>
<p>编译并运行，这回你应该可以愉快地把你的view随意的拖拽了。</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/07/UIKitDynamics3.gif" alt=""></p>
<h1 id="接下来可以做什么？">接下来可以做什么？</h1><p>这篇UIKit Dynamics教程中的项目可以在这里<a href="http://cdn5.raywenderlich.com/wp-content/uploads/2015/04/DynamicToss-Final-1.2.zip" target="_blank" rel="external">下载</a>。</p>
<p>恭喜你，你现在已经学了如何添加一些UIKit Dynamics动画特效让你的app的UI看起来更加的酷炫。</p>
<p>如果你想学更多UIKit Dynamics的技巧, 记得去看看<a href="http://www.raywenderlich.com/?page_id=48020" target="_blank" rel="external">iOS 7 by Tutorials</a>中有两章节是专门讲UIKit Dynamics的。</p>
<p>没事就到论坛去留个言分享一下你的成功经验或者问些关于如何在iOS中实现一些酷的动画特效的问题等等。然后善用你新get的技能！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="UIKit_Dynamics_和_Swift_教程：抛掷视图_(Tossing_Views)">UIKit Dynamics 和 Swift 教程：抛掷视图 (Tossing Views)</h2><blockquote>
<ul>
<li>原文链接 : <a href="http://www.raywenderlich.com/94719/uikit-dynamics-swift-tutorial-tossing-views">UIKit Dynamics and Swift Tutorial:Tossing Views</a></li>
<li>原文作者 : <a href="http://www.raywenderlich.com">Ray Wenderlich</a></li>
<li>译文出自 : <a href="http://www.devtf.cn">开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/samw00">samw00</a> </li>
<li>校对者: <a href="https://github.com/mrchenchao">mrchenchao</a></li>
<li>状态 : 完成</li>
</ul>
</blockquote>
<p>在这篇UIKit Dynamics教程中，你将学会如何通过添加手势，用一种很自然的方式将视图抛掷出屏幕的显示区域。如下图所示：</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/07/UIKitDynamics3.gif" alt="效果预览图"></p>
<p>你可能已经在<a href="https://itunes.apple.com/us/app/tweetbot-3-for-twitter-iphone/id722294701">Tweetbot</a>这个流行的app里看到这一个技巧被大量的运用。</p>
<p>这篇教程特别适合中级水平的开发人员，因为内容包括如何实现一些特别棒的特效，比如用原生的UIKit框架实现旋转(rotation)和飞离(fly-away)等动画效果。</p>
<p>如果你刚刚接触UIKit dynamics, 也别紧张 － 因为这篇教程会一步一步引导你如何去做。</p>
<p>废话不多说，让我们直切主题吧！</p>]]>
    
    </summary>
    
      <category term="UIKit Dynamics" scheme="http://ytlvy.com/tags/UIKit-Dynamics/"/>
    
      <category term="Swift" scheme="http://ytlvy.com/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift EventKit - Requesting Permission]]></title>
    <link href="http://ytlvy.com/2015/08/08/Swift-EventKit-Requesting-Permission/"/>
    <id>http://ytlvy.com/2015/08/08/Swift-EventKit-Requesting-Permission/</id>
    <published>2015-08-08T13:22:29.000Z</published>
    <updated>2015-08-08T13:23:03.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Swift_EventKit的初学者指南—请求权限">Swift  EventKit的初学者指南—请求权限</h1><hr>
<blockquote>
<ul>
<li>原文链接 : <a href="http://www.andrewcbancroft.com/2015/05/14/beginners-guide-to-eventkit-in-swift-requesting-permission/" target="_blank" rel="external">Beginner’s Guide to EventKit in Swift – Requesting Permission</a></li>
<li>原文作者 : <a href="http://www.andrewcbancroft.com/" target="_blank" rel="external">Andrew</a></li>
<li><a href="http://www.devtf.cn" target="_blank" rel="external">译文出自 :  开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/MollyMmm" target="_blank" rel="external">MollyMmm</a> </li>
<li>校对者: <a href="https://github.com/bboyfeiyu" target="_blank" rel="external">Mr.Simple</a>  </li>
<li>状态 : 校对完成</li>
</ul>
</blockquote>
<p>EventKit为获取和操作用户日历事件和提醒提供了一系列的类.在下面的教程中,我的目标是带领你走出利用EventKit建立一个应用程序的第.我的目标是带领你迈出利用EventKit建立一个应用程序的第一步.我将演示如何向用户的日历请求许可,我还将展示几个处理用户响应的例子(当他们授予访问权限,或者拒绝).</p>
<h1 id="Example_scenario">Example scenario</h1><h1 id="场景">场景</h1><p>让我们先提出一个基本方案，作为本教程的例子。</p>
<p>假设我们正在构建一个应用程序，现在，有一个单一的视图控制器。在得到用户授权允许的情况下，我们希望这个视图控制器显示日历列表。如果用户拒绝访问,我们将向用户展示一个消息,用来说明我们的应用程序在没有访问权限时不能运行,我们也将允许他们通过单击一个按钮能够在他们的设备的设置中设置授权访问.</p>
<p>我已经创建一个那样的应用程序作为例子—跳到GitHub中查看并研究这个例子的代码.</p>
<blockquote>
<p>资源</p>
<p><a href="https://github.com/andrewcbancroft/EventTracker/tree/ask-for-permission" target="_blank" rel="external">Xcode工程示例</a></p>
</blockquote>
<h1 id="Storyboard_setup">Storyboard setup</h1><h1 id="故事面板设置">故事面板设置</h1><a id="more"></a>
<p>你使用EventKit的第一步就是需要为自己创建一个用户界面来处理当你第一个程序启动时用户对”该程序可以访问你的日历吗?”对出不同的响应,不久,我们将得到如何请求这个许可的详情.但首先,让我们来剖析我们如何用对于一个许可操作导致的给定响应能够做正确的操作的一些视图来安排我们的故事板.</p>
<p>用户可以授予访问权限,也可以拒绝授予访问权限来通知他们的日历或者提醒.我们需要为这两种情况做好准备.</p>
<h1 id="当被授予访问权限时,tableview显示日历列表">当被授予访问权限时,tableview显示日历列表</h1><p>我今天持乐观态度,所以让我们开始处理从一开始用户就授予我们访问他们日历的权限的情况.</p>
<p>当用户授予我们访问权限,我们想列出一个表视图的日历.在接下来的教程中,我们将担心数据源的设置.现在,我们将从实用工具栏中拽一个表格视图过来.</p>
<p>为了得到填满整个屏幕的表视图,我做了几件事情.通常,当你从实用工具栏中拽一个表视图过来的时候,它会在故事板中填满整个场景.在布局中我向下拖顶部边缘知道它”捕捉”到我所期望的状态栏底部被定位的那行.然后,我设置了以下限制:</p>
<blockquote>
<ul>
<li>Center X   </li>
<li>Center Y </li>
<li>Equal width to Superview</li>
<li>Top space to Top Layout Guide for height.</li>
</ul>
</blockquote>
<p>我已经创建了一个设置表视图的简短截屏,如果你想要一个完整的练习,可以参看下面链接的内容:</p>
<blockquote>
<p>Resources<br>资源</p>
<p><a href="http://bit.ly/WatchSetUpTVFromACB" target="_blank" rel="external">Screencast: Setting Up a Table View</a></p>
<p><a href="http://www.andrewcbancroft.com/2015/05/18/swift-how-to-setting-up-a-table-view/" target="_blank" rel="external"> Full transcript</a></p>
</blockquote>
<p>这里有这些约束的详细视图,以及故事板看起来像装表视图的视觉效果.</p>
<p><img src="http://ww1.sinaimg.cn/mw690/a10328aajw1eshuj6c424j20850ciwfn.jpg" alt="Detailed view of constraints"></p>
<p><img src="http://ww2.sinaimg.cn/mw690/a10328aajw1eshuj777a3j212u0oxguc.jpg" alt="Table view in Storyboard"></p>
<p>最后一点,在故事板中我已经将这个表视图的hidden属性设置为true.根据用户允许或者拒绝对日历的访问后,我将切换表的可见性,但我认为值得指出的是在我例子中表视图的初始状态是被隐藏.</p>
<h1 id="访问被拒绝时的”需要许可”视图">访问被拒绝时的”需要许可”视图</h1><p>但有时,用户拒绝授权访问日历,在意识到这样做将导致基本上停止你应用程序所有的功能之前,如果你的整个应用程序或者只是该应用程序的一部分需要访问功能,你需要一种方法来告知用户,并为他们提供一种方法跳到用户设置,如果可能的话让用户手动授予访问权限.</p>
<p>我在示例项目中的方法是在故事板场景中组织一个新的视图,该视图包含一个展示操作说明的标签和一个点击后使用户进入我们应用程序的设置界面的按钮.</p>
<p>再次,一些约束涉及到在运行时使一些事物正确的显示.在这里我不会讲述这个细节,因为它很可能因为每一个执行操作而有一点不同.</p>
<p>我将指出的意见事情是,这个视图的透明度已经被设置为0,以便如果用户拒绝授权,我能够展示一个逐渐消失的效果.下面就来看看在设置了隐藏“NeedPermissionsView”的场景：</p>
<p><img src="http://ww3.sinaimg.cn/mw690/a10328aajw1eshuj6ra19j214p0ou12b.jpg" alt="Need permission view"></p>
<h1 id="Event_Store的角色">Event Store的角色</h1><p>EventKit的核心是EKEventStore.EKEventStore是事物的中心.创建EKEventStore的一个实例,为开发人员提供了对用户的日历和提醒列表中执行各种读/写操作的API.</p>
<p>一个与日历交互的视图控制器应该有一个引用EKEventStore的实例.这很容易被创建—这里是一个例子:</p>
<blockquote>
<p>ViewController.swift</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="typename">UIViewController</span>, <span class="typename">UITableViewDataSource</span>, <span class="typename">UITableViewDelegate &#123;</span></span></span><br><span class="line">    let eventStore = EKEventStore()</span><br><span class="line">    <span class="comment">// ...    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="检查日历的授权">检查日历的授权</h1><p>一旦我们有了引用EKEventStore的实例,我们可以做像检查用户是否授权访问他们的日历这样的事情.根据这里,我们可以做是否需要请求许可的决定,随后确定要显示的视图(表视图或者需要许可视图).</p>
<p>我们在哪里检查日历授权很重要.我的建议是每次在视图出现时检查(即在viewWillAppear()中),因为用户首次授予访问权限,切换设置,拒绝访问的情况是完全有可能的.我们的应用程序需要做出适当的响应.</p>
<p>In the example project provided with this article, I’ve created a function named checkCalendarAuthorizationStatus(). Here a peek at what it does:</p>
<p>在这个文章提供的示例工程中,我已经创建了一个名为checkCalendarAuthorizationStatus()的函数.<br>接下来看看它的实现:</p>
<blockquote>
<p>ViewController.swift<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">UITableViewDataSource</span>, <span class="title">UITableViewDelegate</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...    </span></span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewWillAppear</span><span class="params">(animated: Bool)</span></span> &#123;</span><br><span class="line">        checkCalendarAuthorizationStatus()</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="func"><span class="keyword">func</span> <span class="title">checkCalendarAuthorizationStatus</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> status = <span class="type">EKEventStore</span>.authorizationStatusForEntityType(<span class="type">EKEntityTypeEvent</span>)      </span><br><span class="line">        <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="type">EKAuthorizationStatus</span>.<span class="type">NotDetermined</span>:</span><br><span class="line">                <span class="comment">// This happens on first-run</span></span><br><span class="line">                requestAccessToCalendar()</span><br><span class="line">            <span class="keyword">case</span> <span class="type">EKAuthorizationStatus</span>.<span class="type">Authorized</span>:</span><br><span class="line">                <span class="comment">// Things are in line with being able to show the calendars in the table view</span></span><br><span class="line">                loadCalendars()</span><br><span class="line">                refreshTableView()</span><br><span class="line">            <span class="keyword">case</span> <span class="type">EKAuthorizationStatus</span>.<span class="type">Restricted</span>, <span class="type">EKAuthorizationStatus</span>.<span class="type">Denied</span>:</span><br><span class="line">                <span class="comment">// We need to help them give us permission</span></span><br><span class="line">                needPermissionView.fadeIn()</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">let</span> alert = <span class="type">UIAlertView</span>(title: <span class="string">"Privacy Warning"</span>, message: <span class="string">"You have not granted permission for this app to access your Calendar"</span>, delegate: <span class="literal">nil</span>, cancelButtonTitle: <span class="string">"OK"</span>)</span><br><span class="line">                alert.show()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>这里关键的功能是EKEventStore的 authorizationStatusForEntityType实现的.传入的EKEntityTypeEvent用于跟用户日历进行交互.如果我们想要检查他们的提醒的权限,我们将在这里使用EKEntityTypeReminder.</p>
<p>EKAuthorizationStatus的可能值根据switch里的相应的case来执行封装好的方便阅读的独立功能的逻辑代码.</p>
<p>让我们一步步来看一看这些功能.</p>
<h1 id="请求访问日历">请求访问日历</h1><p>正如标题所说的,所有的事情从这里开始.每当我们的应用程序加载和调用authorizationStatusForEntityType的时候,将返回NotDetermined的状态.就是在这一点上我们想请求访问日历.</p>
<p>为了这样做,按照下面的方法定义requestAccessToCalendar函数:</p>
<blockquote>
<p>requestAccessToCalendar()<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class ViewController: <span class="built_in">UIViewController</span>, <span class="built_in">UITableViewDataSource</span>, <span class="built_in">UITableViewDelegate</span> &#123;</span><br><span class="line">   <span class="comment">// ...  </span></span><br><span class="line">   func requestAccessToCalendar() &#123;</span><br><span class="line">        eventStore<span class="variable">.requestAccessToEntityType</span>(EKEntityTypeEvent, completion: &#123;</span><br><span class="line">            (accessGranted: Bool, error: <span class="built_in">NSError</span>!) <span class="keyword">in</span>            </span><br><span class="line">            <span class="keyword">if</span> accessGranted == <span class="literal">true</span> &#123;</span><br><span class="line">                <span class="comment">// Ensure that UI refreshes happen back on the main thread!</span></span><br><span class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), &#123;</span><br><span class="line">                    <span class="keyword">self</span><span class="variable">.loadCalendars</span>()</span><br><span class="line">                    <span class="keyword">self</span><span class="variable">.refreshTableView</span>()</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Ensure that UI refreshes happen back on the main thread!</span></span><br><span class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), &#123;</span><br><span class="line">                    <span class="keyword">self</span><span class="variable">.needPermissionView</span><span class="variable">.fadeIn</span>()</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>我们的EKEventStore实例提供了一个名为requestAccessToEntityType的函数.再次将EKEntityTypeEvent作为我们请求访问日历的参数传递.剩余的有趣的部分在我们提供的封装完的闭包里能够找到.</p>
<p>在实现里有三个主要的事情需要注意:</p>
<p>1.传递到闭包里的两个参数一个是用来说明访问权限是否被授予的Bool类型的,另一个是NSError.</p>
<p>2.我们需要调用dispatch_async(),并表明我们要调回主队列中执行刷新UI的操作.</p>
<p>3.self.needPermissionView.fadeIn()作为我操作中的一个UIView的拓展,<a href="https://github.com/andrewcbancroft/EventTracker/tree/ask-for-permission" target="_blank" rel="external">Swift中渐入/淡出动画的拓展类(Fade In / Out Animations as Class Extensions in Swift)</a>.</p>
<h1 id="授予访问权限！加载日历和刷新表视图">授予访问权限！加载日历和刷新表视图</h1><p>当被允许访问的时候,我们可以调用eventStore实例中的calendarsForEntityType函数,并传递EKEntityTypeEvent去抓取用户日历的数组在我们的表视图中显示.下面就来看看:</p>
<blockquote>
<p>loadCalendars()<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">UITableViewDataSource</span>, <span class="title">UITableViewDelegate</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">var</span> calendars: [<span class="type">EKCalendar</span>]?</span><br><span class="line">    <span class="comment">// ...    </span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">loadCalendars</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.calendars = eventStore.calendarsForEntityType(<span class="type">EKEntityTypeEvent</span>) <span class="keyword">as</span>? [<span class="type">EKCalendar</span>]</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">refreshTableView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        calendarsTableView.hidden = <span class="literal">false</span></span><br><span class="line">        calendarsTableView.reloadData()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="拒绝访问—显示需要许可视图">拒绝访问—显示需要许可视图</h1><p>当访问被拒绝的时候,我们需要弹出在故事板场景中创建的“Needs Permission View”.</p>
<p>在这个视图中,上面的函数重新被调用,这样有一个能够让用户直接跳转到我们应用程序的设置页面中,以便他们能够从那里授权日历访问.这个按钮连线到了一个IBAction.下面有实现IBAction的例子:</p>
<blockquote>
<p>goToSettingsButtonTapped()<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">UITableViewDataSource</span>, <span class="title">UITableViewDelegate</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">goToSettingsButtonTapped</span><span class="params">(sender: UIButton)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> openSettingsUrl = <span class="type">NSURL</span>(string: <span class="type">UIApplicationOpenSettingsURLString</span>)</span><br><span class="line">        <span class="type">UIApplication</span>.sharedApplication().openURL(openSettingsUrl!)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="结束语">结束语</h1><p>这几乎完成了使用 Event Kit的开始工作!对于checkCalendarAuthorizationStatus()函数的其余案例简单的重用,我只是简单的剖析了请求允许的过程.</p>
<p>我鼓励你们<a href="https://github.com/andrewcbancroft/EventTracker/tree/ask-for-permission" target="_blank" rel="external">跳到Github</a>,并且作为你应用程序中利用Event Kit的开始,自己深入研究这些代码.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Swift_EventKit的初学者指南—请求权限">Swift  EventKit的初学者指南—请求权限</h1><hr>
<blockquote>
<ul>
<li>原文链接 : <a href="http://www.andrewcbancroft.com/2015/05/14/beginners-guide-to-eventkit-in-swift-requesting-permission/">Beginner’s Guide to EventKit in Swift – Requesting Permission</a></li>
<li>原文作者 : <a href="http://www.andrewcbancroft.com/">Andrew</a></li>
<li><a href="http://www.devtf.cn">译文出自 :  开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/MollyMmm">MollyMmm</a> </li>
<li>校对者: <a href="https://github.com/bboyfeiyu">Mr.Simple</a>  </li>
<li>状态 : 校对完成</li>
</ul>
</blockquote>
<p>EventKit为获取和操作用户日历事件和提醒提供了一系列的类.在下面的教程中,我的目标是带领你走出利用EventKit建立一个应用程序的第.我的目标是带领你迈出利用EventKit建立一个应用程序的第一步.我将演示如何向用户的日历请求许可,我还将展示几个处理用户响应的例子(当他们授予访问权限,或者拒绝).</p>
<h1 id="Example_scenario">Example scenario</h1><h1 id="场景">场景</h1><p>让我们先提出一个基本方案，作为本教程的例子。</p>
<p>假设我们正在构建一个应用程序，现在，有一个单一的视图控制器。在得到用户授权允许的情况下，我们希望这个视图控制器显示日历列表。如果用户拒绝访问,我们将向用户展示一个消息,用来说明我们的应用程序在没有访问权限时不能运行,我们也将允许他们通过单击一个按钮能够在他们的设备的设置中设置授权访问.</p>
<p>我已经创建一个那样的应用程序作为例子—跳到GitHub中查看并研究这个例子的代码.</p>
<blockquote>
<p>资源</p>
<p><a href="https://github.com/andrewcbancroft/EventTracker/tree/ask-for-permission">Xcode工程示例</a></p>
</blockquote>
<h1 id="Storyboard_setup">Storyboard setup</h1><h1 id="故事面板设置">故事面板设置</h1>]]>
    
    </summary>
    
      <category term="EventKit" scheme="http://ytlvy.com/tags/EventKit/"/>
    
      <category term="Swift" scheme="http://ytlvy.com/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift Core Graphics Tutorial Part 1: Getting Started]]></title>
    <link href="http://ytlvy.com/2015/08/08/Swift-Core-Graphics-Tutorial-Part-1-Getting-Started/"/>
    <id>http://ytlvy.com/2015/08/08/Swift-Core-Graphics-Tutorial-Part-1-Getting-Started/</id>
    <published>2015-08-08T13:21:23.000Z</published>
    <updated>2015-08-08T13:21:54.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Core_Graphics教程第一部分(Swift)_-_起步">Core Graphics教程第一部分(Swift) - 起步</h2><blockquote>
<ul>
<li>原文链接 : <a href="http://www.raywenderlich.com/90690/modern-core-graphics-with-swift-part-1" target="_blank" rel="external">Core Graphics Tutorial Part 1: Getting Started</a></li>
<li>原文作者 : <a href="http://www.raywenderlich.com/u/caroline" target="_blank" rel="external">Caroline Begbie </a></li>
<li>译文出自 :  <a href="www.devtf.cn">开发技术前线</a></li>
<li>译者 : <a href="https://github.com/sdq/" target="_blank" rel="external">sdq</a>  <a href="https://github.com/StormXX/" target="_blank" rel="external">StormXX</a></li>
<li>校对者:  <a href="https://github.com/StormXX/" target="_blank" rel="external">StormXX</a></li>
</ul>
</blockquote>
<p>想象一下…当你完成了你的应用，它能够很好地运行，但是界面还缺少个人的风格。这时，你可以选择用PS画出一系列尺寸的图片，并希望Apple不会再推出一个<strong>@4x</strong>的retina显示尺寸…   </p>
<p>或者，你可以领先一步，采用Core Graphics进行绘图，保证一个图片可以适应各种尺寸的屏幕。   </p>
<p>Core Graphics是苹果的一个矢量图绘制框架 - 它是一个大型且给力的API、有很多需要去学习。不过别慌，这个系列的文章会带你由简入深地学习Core Graphics，最后你将可以在你的应用中创作令人惊叹的图片。   </p>
<p>这是一个全新的系列，采用最新的方式来学习Core Graphics。这个系列完全和Xcode6与Swift保持同步，并且包含了一些很酷的新特性，比如<strong>@IBDesignable</strong>和<strong>@IBInspectable</strong>，这让学习Core Graphics变得更有趣也更容易。</p>
<p>拿起可乐，让我们开始吧！</p>
<h2 id="介绍Flo_-_一款记录喝水杯数的App">介绍Flo - 一款记录喝水杯数的App</h2><p>你将会完成一个追踪你喝水习惯的app。   </p>
<p>Flo可以让你很轻松地追踪到你喝了多少水。人们说一天喝8杯水才是健康的，但是往往喝了几杯水之后我们就忘了记录了。这就是Flo使用的时候了，每当你喝完一杯水以后，你就可以在Flo上点击计数，Flo会为你记录喝水情况。你也可以在Flo上查看到过去7天的喝水状况。</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/12/1-CompletedApp.gif" alt="demo"></p>
<p>在这个系列的第一部分，你将会通过UIKit的画图方法创建三个控件。<br>第二部分中，你将会深入了解Core Graphics的内容并且学习绘图。<br>最后第三部分，你将会制作一个样式背景，并且获得自制的Core Graphics奖牌 ：）</p>
<a id="more"></a>
<h2 id="让我们开始吧">让我们开始吧</h2><p>你的第一个任务是新建你自己的Flo应用。这边不会提供任何下载，因为只有从零开始，你才能学得更多。   </p>
<p>创建一个新项目<strong>(File\New\Project…)</strong>，选择模板<strong>iOS\Application\Single View Application</strong>，然后点击<strong>Next</strong>。   </p>
<p>弹出一个项目选项框，把项目名设为Flo，语言设置为Swift，设备选为iPhone，然后点击<strong>Next</strong>。   </p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/12/1-Xcode.png" alt="start"></p>
<p>在最后一步，不要选择Git repository，并点击<strong>Create</strong>。<br>现在你已经完成了一个拥有storyboard和view controller的初始项目</p>
<h2 id="在View上画图">在View上画图</h2><p>在画图的时候，你需要实行以下三个步骤：</p>
<ol>
<li>创建一个UIView子类。</li>
<li>重写<code>drawRect(_:)</code>并添加一些Core Graphics绘图代码。</li>
<li>想什么呢！没有第三步了 ：）</li>
</ol>
<p>让我们尝试一下画一个自制的加号按钮。</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2014/12/1-AddButtonFinal.png" alt="button"></p>
<p>创建一个新文件<strong>(File\New\File…)</strong>，选择<strong>iOS\Source\Cocoa Touch Class</strong>，取名为<strong>PushButtonView</strong>。让它继承于<strong>UIButton</strong>，确保选择的语言是<strong>Swift</strong>。点击<strong>Next</strong>并完成<strong>Create</strong>。<br>由于<strong>UIButton</strong>是<strong>UIView</strong>的子类，<strong>UIView</strong>的所有方法，像<code>drawRect(_:)</code>，在UIButton里同样存在。<br>在<strong>Main.storyboard</strong>里，将<strong>UIButton</strong>拖到View Controller的view里，并选择<strong>Document Outline</strong>。<br>在<strong>Identity Inspector</strong>把类改成你自己的<strong>PushButtonView</strong>。</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/12/1-PushButtonViewClass.png" alt="pushButtonView"></p>
<p>在<strong>Size Inspector</strong>里设置X=250, Y=350, Width=100, Height=100：</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/12/1-PlusButtonCoordinates.png" alt="sizeInspector"></p>
<h2 id="自动布局约束">自动布局约束</h2><p>现在你将要设置自动布局约束（文字指导在后面）:</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/12/1-AutoLayout.gif" alt="setUpAutoLayout"></p>
<ul>
<li>选中button，按住control从按钮的中心轻轻拖到左侧（仍旧在按钮内），在弹出的菜单中选择Width。</li>
<li>同样地，用上述方式从中间向上拖动（仍旧在按钮内），在弹出的菜单中选择Height。</li>
<li>按住control从按钮内向左拖动，直到按钮外，选择Center Vertically in Container。</li>
<li>最后，同样地由下至上从按钮内到按钮外，选择Center Horizontally in Container。<br>（以上几步中按住control和点击鼠标右键拖动的效果是一样的）<br>这几步会创建四个需要的auto layout constraints，你可以在Size Inspector看到他们：</li>
</ul>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/12/1-AutoLayoutConstraints-247x500.png" alt="sizeInspector"></p>
<p>在Attributes Inspector里移除默认的文字“Button”。</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/12/1-RemoveTitle2.png" alt="Attributes"></p>
<p>你可以在此刻编译运行程序，不过现在你只能看到一片空白，让我们来继续吧！</p>
<h2 id="画一个按钮">画一个按钮</h2><p>回忆一下，你试着画的按钮是一个圆形：</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2014/12/1-AddButtonFinal.png" alt="button"></p>
<p>为了实现在Core Graphics画一个图形，你需要定义一个路径来告诉Core Graphics如何画线（就像画一个加号需要两条直线）或者是需要填充的线（像这里的圆）。如果你很熟悉Illustrator或者Photoshop里的矢量图形，你可以很容易地就理解路径。<br>这里有三个路径的基本原则：</p>
<ul>
<li>路径可以被描边或者填充。</li>
<li>可以用当前的描边颜色为路径勾边。</li>
<li>可以用当前的填充颜色为闭合路径围起来的区域进行填充。</li>
</ul>
<p>创建Core Graphics路径的一个简单方法是采用一个好用的类UIBezierPath。这个类可以让你通过一个友好的API来创建路径，无论是你想基于线段、曲线、长方形或者是一系列的连接点。<br>让我们尝试用UIBezierPath来创建一个路径，然后用绿色来填充它。打开PushButtonView.swift，并添加以下方法：</p>
<pre><code><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">drawRect</span><span class="params">(rect: CGRect)</span></span> {
  <span class="keyword">var</span> path = <span class="type">UIBezierPath</span>(ovalInRect: rect)
  <span class="type">UIColor</span>.greenColor().setFill()
 path.fill()
}
</code></pre><p>首先，你创建了一个椭圆型的UIBezierPath，尺寸由长方形的大小决定。在本文的例子中，由于我们在storyboard里定义了100x100的按钮，所以“椭圆”其实是一个圆。<br>路径本身不会画任何东西。即使没有可绘图的上下文，你也可以定义路径。如果要绘制路径，你需要给当前的上下文一个填充颜色，然后填充路径。   </p>
<p>编译并运行应用，你会看到一个绿色的圆。</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/1-SimGreenButton2-192x320.png" alt="haha"></p>
<p>到这里，你会发现做一个自定义的view是如此简单。你通过创建一个UIButton的子类、重写<code>drawRect(_:)</code>、把UIButton放进你的storyboard中这几个简单的步骤完成了所有工作。</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/01/custom-views-not-bad-e1422223029562.png" alt="haha"></p>
<h2 id="Core_Graphics的背后实现">Core Graphics的背后实现</h2><p>每一个UIView都会有一个图形上下文，所有针对这个UIView的绘图都会先绘制到此上下文，然后再转换到设备的屏幕上。</p>
<p>iOS更新上下文的方法是<code>drawRect(_:)</code>，这个方法会在以下四种情况被调用：</p>
<ul>
<li>屏幕第一次显示这个view。</li>
<li>它顶部的view被移除。</li>
<li>view的hidden属性被修改。</li>
<li>在view上调用了了setNeedsDisplay()与setNeedsDisplayInRect()方法。</li>
</ul>
<p>注意：所有图形上下文的绘画都需要在<code>drawRect(_:)</code>中完成。最后一章中，你需要创建自己的图形上下文，你需要注意是不是在<code>drawRect(_:)</code>以外进行绘图了。</p>
<p>你还没有在本教程中使用Core Graphics，因为UIKit封装了很多Core Graphics的方法。比如UIBezierPath就是对CGMutablePath的封装，CGMutablePath是Core Graphics的底层API。</p>
<p>Note: Never call <code>drawRect(_:)</code> directly. If your view is not being updated, then call setNeedsDisplay() on the view.</p>
<p>注意：不要直接调用<code>drawRect(_:)</code>，如果你的view并没有被更新，你可以在view上调用setNeedsDisplay()。setNeedsDisplay()不会自己调用<code>drawRect(_:)</code>，但它会把view标记为“未刷新”，并触发<code>drawRect(_:)</code>。所以，即使你在一个方法中调用了五次setNeedsDisplay()，但实际中只会运行一次<code>drawRect(_:)</code>。</p>
<h2 id="@IBDesignable_–_可交互绘图">@IBDesignable – 可交互绘图</h2><p>除了写绘图代码然后运行app看效果之外，你还有其他选择。一个Xcode6的新功能是Live Rendering，你可以设置view为@IBDesignable属性，当你在<code>drawRect(_:)</code>更新view的时候，它会马上在storyboard上展示出来。</p>
<p>在PushButtonView.swift里, 在类的声明前加上:</p>
<pre><code>@IBDesignable</code></pre>
这样就可以开启Live Rendering。

现在把你的屏幕设置为同时可以看代码和storyboard。
方法是：选择PushButtonView.swift现实代码，在顶部右边点击Assistant Editor（它的图标是两个环绕的圆环）。storyboard会在右边展示。如果不是的话，你需要顶部选择到storyboard。

![3](http://cdn4.raywenderlich.com/wp-content/uploads/2014/12/1-Breadcrumbs-700x161.png)

关闭storyboard左边的文件导航栏，这样可以多留出一些空间。可以通过拖动边界或者点击storyboard左下方的按钮实现：

![1](http://cdn5.raywenderlich.com/wp-content/uploads/2014/12/1-DocumentOutline.png)

一切都完成后，你看到的是这样的：

![2](http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/1-SideBySide-638x500.png)

在PushButtonView中把<code>drawRect(_:)</code>
<pre>UIColor.greenColor().setFill()</pre>
改成
<pre>UIColor.blueColor().setFill()</pre>
你会直接在storyboard上看到改变。非常酷~

![3](http://cdn1.raywenderlich.com/wp-content/uploads/2015/01/LiveRendering-700x477.png)

## 在上下文进行绘图

Core Graphics使用的是“绘画者模型”。

当你在上下文中绘图时，就和真实世界中的绘图一样。你先画一条路径，然后填充颜色，接着你再画一条线，再继续填充。你不能改变已经画好的像素点，但是你可以在他们的上面继续作画。

这张苹果官方文档的图片描述了是如何运作的，当你在画板上绘图时，你画图的顺序是非常重要的

![4](http://cdn1.raywenderlich.com/wp-content/uploads/2014/12/1-PaintersModel.gif)

你的加号符号应该在蓝色圆圈的上面，所以你需要先画圆，再画加号。

你可以画两个长方形来完成加号，但如果用粗线绘制路径会更简单一点。

把这些代码加在<code>drawRect(_:)</code>的最后，用来画加号的水平线：

<pre><code>
//set up the width and height variables
//for the horizontal stroke
let plusHeight: CGFloat = 3.0
let plusWidth: CGFloat = min(bounds.width, bounds.height) * 0.6

//create the path
var plusPath = UIBezierPath()

//set the path's line width to the height of the stroke
plusPath.lineWidth = plusHeight

//move the initial point of the path
//to the start of the horizontal stroke
plusPath.moveToPoint(CGPoint(
  x:bounds.width/2 - plusWidth/2,
  y:bounds.height/2))

//add a point to the path at the end of the stroke
plusPath.addLineToPoint(CGPoint(
  x:bounds.width/2 + plusWidth/2,
  y:bounds.height/2))

//set the stroke color
UIColor.whiteColor().setStroke()

//draw the stroke
plusPath.stroke()
</code></pre>

<p>在这一部分中，你先设置了一个UIBezierPath，给它了一个起始为止（圆圈的左侧），然后画到重点（圆圈的右侧）。然后你设置画壁颜色为白色，这个时候你可以在Storyboard中看到如下：</p>
<p>在Storyboard中，你将看到蓝色圆圈中包含了一条水平的白线：</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/01/Dash.png" alt="1"></p>
<p>注意：记住一条路径可以由点组成。这里有一个比较容易理解的理论：当你在创建路径时，想象此时你的手中握着笔。放两个点在纸上，然后把笔放在一个起点，然后往另一个点画线。这就是上述代码中moveToPoint(_:)和addLineToPoint(_:)所做的事。</p>
<p>现在在ipad2和iphone6+的模拟器上运行代码，你会发现横线没有之前显示的那么好了，在它周围产生了淡蓝色的边框。</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2014/12/1-PixelledLine-700x170.png" alt="1"></p>
<h2 id="Points和Pixels">Points和Pixels</h2><p>在早期的iphone中，Points和Pixels所占的空间与大小是相同的。当retina屏幕的iphone问世后，屏幕上Pixels的数量变成了Points的四倍。</p>
<p>同样地，iphone6+在相同points的基础上再一次增加了pixels的数量。</p>
<p>注意：以下只是概念 - 真实的硬件像素可能是不同的。如果要了解更多iphone6+的案例，可以看下这个<a href="http://www.paintcodeapp.com/news/iphone-6-screens-demystified" target="_blank" rel="external">文章</a>。</p>
<p>这里是一个12x12的pixel矩阵，其中point以灰色和白色表示。第一个是ipad2，一个pixel对应一个point。第二个是iphone6，是一个2x的retina屏幕，4个pixel对应一个point。第三个是iphone6+，是一个3x的retina屏幕，9个pixel对应一个point。</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/1-Pixels-700x263.png" alt="1"></p>
<p>你画的线的高度是3points，两边的宽度各是1.5points。</p>
<p>这张图展示了3-point的线在各个设备上的情况。你可以看到ipad2和iphone6+都发生了覆盖一半pixel的情况，这是无法实现的。所以在实际中iOS会采用两种颜色的中间色，所以线看起来会模糊。</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2014/12/1-PixelLineDemonstrated-700x263.png" alt="1"></p>
<p>在实际中，iPhone6+有很多pixels，可能你不会注意到这些模糊的情况，但是你应该在你的app里注意尽量避免。不过如果你是为了非retina屏的设备进行开发，那么你就需要避免这类情况的发生。</p>
<p>如果你要画奇数的直线，你需要加上或减去0.5points来避免模糊。如果你看一下上面的图表，你会看到增加0.5points相当于是在ipad上增加0.5pixels，在iphone6的线顶部上增加1pixel，在iphone6+的顶部增加1.5pixels。</p>
<p>在drawRect(_:)中，把moveToPoint与addLineToPoint的代码替换为：</p>
<pre><code>
//move the initial point of the path
//to the start of the horizontal stroke
plusPath.moveToPoint(CGPoint(
  x:bounds.width/2 - plusWidth/2 + 0.5,
  y:bounds.height/2 + 0.5))

//add a point to the path at the end of the stroke
plusPath.addLineToPoint(CGPoint(
  x:bounds.width/2 + plusWidth/2 + 0.5,
  y:bounds.height/2 + 0.5))
</code></pre>

<p>现在在三种设备上都能很清晰地展示线条了，因为你对其进行了半个point的调整。</p>
<p>注意：为了线条的完美，你可以采用填充UIBezierPath(rect:)方法来代替画线条，并通过view的contentScaleFactor计算出长方形的高和宽。和画线方法会从路径的中间点开始向外计算宽度，而填充只会在路径内部进行。</p>
<p>在上述两行代码后面继续加上一条垂直线段，最后在drawRect(_:)里设置画线的颜色。我想在上述步骤之后，你应该已经知道该怎么完成了：</p>
<p>你可以在storyboard中实时看到最新的图案，这是最终完成的加号按钮：</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/12/1-FinishedPlus.png" alt="1"></p>
<h2 id="@IBInspectable_–_自定义Storyboard属性">@IBInspectable – 自定义Storyboard属性</h2><p>你知道，必须要点击一个没有需求的按钮，却只是为了确认保存是一件多么令人抓狂的事情吗？所以，你需要提供一种方式让用户从这种过于泛滥的点击中解脱出来——你需要一个减号按钮。</p>
<p>减号按钮与加号按钮基本一致，除了它没有一条竖线和并且是另外一种颜色。你需要用同样的PushButtonView类来定义减号按钮，并且在你将按钮添加到storyboard时，需要声明这个按钮的类型和颜色。</p>
<p>为了使得按钮可以被Interfase Builder读取，你需要添加@IBInspectable这一变量给按钮的属性。这也意味着，你可以在storyboard里面定义按钮的颜色，而不是在代码中编写。</p>
<p>在PushButtonView类的顶部，添加两个属性：</p>
<pre><code>
@IBInspectable var fillColor: UIColor = UIColor.greenColor()
@IBInspectable var isAddButton: Bool = true
</code></pre>

<p>从drawRect(_:)的顶部到</p>
<pre><code>
UIColor.blueColor().setFill()
</code></pre>

<p>更改和填充颜色相关的代码</p>
<pre><code>
fillColor.setFill()
</code></pre>

<p>在storyboard的视图中，按钮就会变成绿色。</p>
<p>和垂直相关的代码在drawRect(_:)中用if语句表示</p>
<pre><code>
//Vertical Line

if isAddButton {
  //vertical line code moveToPoint(_:) and addLineToPoint(_:)
}
//existing code
//set the stroke color
UIColor.whiteColor().setStroke()

//draw the stroke
plusPath.stroke()
</code></pre>

<p>这些代码让你只有在isAddButton被设置的时候才能够画垂直线，用这样的方式，一个按钮就可以既是加法按钮，又可以是减法按钮。</p>
<p>完整的PushButtonView如下列所示:</p>
<pre><code>
import UIKit

@IBDesignable
class PushButtonView: UIButton {

  @IBInspectable var fillColor: UIColor = UIColor.greenColor()
  @IBInspectable var isAddButton: Bool = true

  override func drawRect(rect: CGRect) {

    var path = UIBezierPath(ovalInRect: rect)
    fillColor.setFill()
    path.fill()

    //set up the width and height variables
    //for the horizontal stroke
    let plusHeight: CGFloat = 3.0
    let plusWidth: CGFloat = min(bounds.width, bounds.height) * 0.6     

    //create the path
    var plusPath = UIBezierPath()

    //set the path's line width to the height of the stroke
    plusPath.lineWidth = plusHeight

    //move the initial point of the path
    //to the start of the horizontal stroke
    plusPath.moveToPoint(CGPoint(
      x:bounds.width/2 - plusWidth/2 + 0.5,
      y:bounds.height/2 + 0.5))

    //add a point to the path at the end of the stroke
    plusPath.addLineToPoint(CGPoint(
      x:bounds.width/2 + plusWidth/2 + 0.5,
      y:bounds.height/2 + 0.5))

    //Vertical Line
    if isAddButton {
      //move to the start of the vertical stroke
      plusPath.moveToPoint(CGPoint(
        x:bounds.width/2 + 0.5,
        y:bounds.height/2 - plusWidth/2 + 0.5))

      //add the end point to the vertical stroke
      plusPath.addLineToPoint(CGPoint(
        x:bounds.width/2 + 0.5,
        y:bounds.height/2 + plusWidth/2 + 0.5))
    }

    //set the stroke color
    UIColor.whiteColor().setStroke()

    //draw the stroke
    plusPath.stroke()

  }

}
</code></pre>

<p>在storyboard中，选择push button view.你可以看到两个通过@IBInspectable声明的属性出现在Attributes Inspector的顶部。</p>
<p>更改填充颜色为RGB(87, 218, 213),并且设置Is Add Button为off。</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/12/1-InspectableFillColor.png" alt="1"></p>
<p>你可以立即在storyboard中看到相应的变化。</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/12/1-InspectableMinusButton.png" alt="1"></p>
<p>很酷吧？现在把Is Add Button设为on来把按钮设为加号。</p>
<h3 id="第二个按钮">第二个按钮</h3><p>添加一个UIButton到StoryBoard,选中，并在尺寸查看器（size inspector）中更新按钮的位置和大小，这里设置为X=275，Y=480，Width=50，以及Height=50：</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/12/1-PushButtonMinusCoords.png" alt="1"></p>
<p>在Identity Inspector中，选择类型（Class）的下拉菜单，将UIButton更改为PushButtonView。</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/12/1-PushButtonMinusClass.png" alt="1"></p>
<p>一个绿色的plus button功能按钮就会覆盖掉之前的按钮。<br>在Attributes inspector中，将填充颜色设置为RGB（238，77，77），并将 Is Add Button设置为off，将default title button取消。</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/12/1-MinusButtonColor.png" alt="1"></p>
<p>按照之前的步骤，给新的视图添加自动布局的约束条件。</p>
<ul>
<li>选中按钮，按住”Ctrl”键鼠标拖动按钮的中间位置向左（拖动范围在按钮以内），在弹出菜单中选择Width。</li>
<li>相似的，在按钮选中状态下，按住”Ctrl”键鼠标拖动按钮的中间位置向上（拖动范围在按钮以内），在弹出菜单中选择Height。</li>
<li>按住”Ctrl”键鼠标向上拖动，从按钮里面拖动到按钮范围外，选择Center Horizontally in Containner。</li>
<li>按住”Ctrl”键，鼠标从最底部的按钮拖动到顶部按钮，可以选择Vertical Spacing。</li>
</ul>
<p>编译并运行应用，你就可以获得一个可复用的自定义视图，并可以添加到任意app中。并且它还可以适用于任意设备的屏幕尺寸。这里给大家展示的是在iPhone 4S上面的效果。</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/12/1-SimPushButtons-339x500.png" alt="1"></p>
<h2 id="用UIBezierPath来画弧">用UIBezierPath来画弧</h2><p>下一个你要自定义的View就是下面这个：</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2014/12/1-CompletedCounterView.png" alt="1-CompletedCounterView"></p>
<p>这个看起来像是一个被填满的弧形，但是这个弧确确实实仅仅是一个粗笔画路径。而轮廓又是另一个由两个弧组成的粗笔画路径。</p>
<p>新建一个文件，<strong><em>File\New\File…</em></strong>，选择<strong><em>Cocoa Touch Class</em></strong>，然后命名这个类为CounterView。同时，让它为UIView的一个子类，并确认一下编程语言选择的是<strong><em>Swift</em></strong>。点击<strong><em>Next</em></strong>按钮，然后点击创建。然后用下面的代码把生成的代码覆盖掉：</p>
<pre><code><span class="keyword">import</span> <span class="type">UIKit</span>

<span class="keyword">let</span> <span class="type">NoOfGlasses</span> = <span class="number">8</span>
<span class="keyword">let</span> π:<span class="type">CGFloat</span> = <span class="type">CGFloat</span>(<span class="type">M_PI</span>)

<span class="preprocessor">@IBDesignable</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterView</span>: <span class="title">UIView</span> </span>{

    <span class="preprocessor">@IBInspectable</span> <span class="keyword">var</span> counter: <span class="type">Int</span> = <span class="number">5</span> 
    <span class="preprocessor">@IBInspectable</span> <span class="keyword">var</span> outlineColor: <span class="type">UIColor</span> = <span class="type">UIColor</span>.blueColor()
    <span class="preprocessor">@IBInspectable</span> <span class="keyword">var</span> counterColor: <span class="type">UIColor</span> = <span class="type">UIColor</span>.orangeColor()

    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">drawRect</span><span class="params">(rect: CGRect)</span></span> {

    }
}
</code></pre><p>注意：既然Apple允许在常量(let)和变量(var)中使用Unicode编码的字符，你可以把π作为一个常量的名字，用它来储存pi，这样能提高代码的可读性。如何输入π：同时按下Alt和P即可。</p>
<p>在这个代码中，你创建了两个常量。NoOfGlasses 代表着每天需要喝水的目标杯数。当计数到达了这个目标杯数的时候，这个计数器就到了它的最大值。<br>同时你也创建了3个你可以在storyboard里修改的@IBInspectable属性。这个counter变量用来记录当前已经喝的杯数。对于这个变量，能在storyboard里面修改它是很有必要的，尤其是当测试这个CounterView的时候。</p>
<p>打开<strong><em>Main.storyboard</em></strong>然后在“加号”按钮上添加一个UIView</p>
<p>在右边的<strong><em>Size Insepector</em></strong>面板里，设置X=185, Y=70, Width=230, 还有 Height=230：</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/12/1-CounterViewCoords.png" alt="1-CounterViewCoords"></p>
<p>给这个新的view添加几个自动布局的约束，就像你之前做的那样：</p>
<ul>
<li>选中这个View,按住control从这个view(<strong>原文这里是button，应该是view的</strong>)的中心轻轻的向左边拖动鼠标，然后释放（仍然在这个view内），从弹出来的菜单中选择Width</li>
<li>同理，选中这个View，按住control从这个view的中心轻轻的向上面拖动鼠标，然后释放（仍然在这个view内），从弹出来的菜单中选择Height</li>
<li>按住control然后从这个view中拖动鼠标到外面的view然后释放，选择Center Horizontally in Container。</li>
<li>按住control然后从这个view往下拖动鼠标，一直到上面一个button然后释放，选择Vertical Spacing.</li>
</ul>
<p>在右边的Identity Inspector面板中，把这个UIView所属的类改成CounterView。现在你在<code>drawRect(_:)</code>中的代码将会生效。</p>
<h2 id="温习数学知识">温习数学知识</h2><p>我们稍微打断一下这个教程，然后我们回顾一下高中级别的数学知识，千万不要害怕哦！就像Douglas Adams所说 - 不要慌张! :]</p>
<p>在这个context里画任何东西，都基于这个单元圆。一个单元圆就是半径为1的圆。</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/1-FloUnitCircle.png" alt="1-FloUnitCircle"></p>
<p>红色的箭头表示你的弧从哪里开始和结束，并且是按顺时针方向。接下来，你将从 3π/4弧度(135º)的位置开始画弧，然后顺时针到 π/4弧度（45º）</p>
<p>在程序中，弧度经常被使用，而不是用度数。用弧度是非常有利的，因为你不必每次跟圆打交道的时候都要转换为度数。接下来，你需要计算一下这个弧的长度，当然是用弧度来算。</p>
<p>在单元圆（半径为1）中，弧的长度等于这个角度的用弧度表示的数值。比如说，看上面的哪个图，从0º到90º的弧的长度是 π/2。在真实场景中计算弧的长度，用单位圆的弧的长度乘以真实的圆的半径。</p>
<p>计算上面的红色箭头的长度，只要计算它所跨过的弧度数值。</p>
<pre><code><span class="number">2</span><span class="literal">π</span> – <span class="keyword">end</span> of arrow (<span class="number">3</span><span class="literal">π</span>/<span class="number">4</span>) + point of arrow (<span class="literal">π</span>/<span class="number">4</span>) = <span class="number">3</span><span class="literal">π</span>/<span class="number">2</span>
</code></pre><p>用角度表示就是：</p>
<pre><code><span class="attribute">360º – 135º + 45º </span>=<span class="string"> 270º</span>
</code></pre><p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/01/celebrate-all-the-maths-e1422223051445.png" alt="celebrate-all-the-maths"></p>
<h2 id="让我们继续来画弧">让我们继续来画弧</h2><pre><code><span class="comment">// 1</span>
<span class="built_in">let</span> center = CGPoint<span class="params">(x:bounds.width/<span class="number">2</span>, y: bounds.height/<span class="number">2</span>)</span>

<span class="comment">// 2</span>
<span class="built_in">let</span> radius: CGFloat = <span class="built_in">max</span><span class="params">(bounds.width, bounds.height)</span>

<span class="comment">// 3</span>
<span class="built_in">let</span> arcWidth: CGFloat = <span class="number">76</span>

<span class="comment">// 4</span>
<span class="built_in">let</span> startAngle: CGFloat = <span class="number">3</span> <span class="built_in">*</span> π / <span class="number">4</span>
<span class="built_in">let</span> endAngle: CGFloat = π / <span class="number">4</span>

<span class="comment">// 5</span>
var path = UIBezierPath<span class="params">(arcCenter: center,
  radius: radius/<span class="number">2</span> - arcWidth/<span class="number">2</span>,
  startAngle: startAngle,
  endAngle: endAngle,
  clockwise: <span class="literal">true</span>)</span>

<span class="comment">// 6</span>
path.lineWidth = arcWidth
counterColor.setStroke<span class="params">()</span>
path.stroke<span class="params">()</span>
</code></pre><p>想象一下用圆规来画这个，首先把圆规的一个点固定在中间，然后打开圆规臂选择你需要的半径，然后装上一个细港币，然后旋转它来画弧。<br>在这个代码中，center变量代表着圆规的不动点，半径就是圆规打开的宽度（小于钢笔宽度的一半）并且这个弧的宽度就是这个钢笔笔头的宽度。</p>
<p>下面的列表解释了上面代码中每个小节的意思：</p>
<ol>
<li>定义这个view的中点，然后你将会基于这个点来通过旋转生成弧。</li>
<li>通过view的宽和高的最大值来计算弧的半径。</li>
<li>定义这个弧的粗细</li>
<li>为这个弧定义开始和结束的角度。</li>
<li>基于刚刚创建的中点，半径和角度来定义个一个弧的轨道。</li>
<li>在给这个轨道上色之前，设置这个弧的轨道的宽度和颜色。</li>
</ol>
<p>注意：当你在尝试画弧的时候，这些一般是你需要知道的，如果你想在画弧方面研究更深层次一点，你可以尝试阅读Raywenderlich老版本的 <a href="http://www.raywenderlich.com/33193/core-graphics-tutorial-arcs-and-paths" target="_blank" rel="external">Core Graphics Tutorial on Arcs and Paths</a></p>
<p>在storyboard里或者是你运行你的应用的时候，下面这个就是你可以看到的</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/12/1-SimArcStroke.png" alt="1-SimArcStroke"></p>
<h2 id="如何给弧加轮廓">如何给弧加轮廓</h2><p>当用户表示他们已经享受了一杯圣水之后（=。=），这个计数器外面的线条用来表示进度—离8杯还有多少。</p>
<p>这个外面的线由两个弧组成，一个外部一个内部，并且还有两条线来闭合他们。<br>在CounterView.swift里，把下面的代码加在<code>drawRect(_:):</code>的最后面：</p>
<pre><code><span class="comment">//Draw the outline</span>

<span class="comment">//1 - first calculate the difference between the two angles</span>
<span class="comment">//ensuring it is positive</span>
<span class="built_in">let</span> angleDifference: CGFloat = <span class="number">2</span> <span class="built_in">*</span> π - startAngle + endAngle

<span class="comment">//then calculate the arc for each single glass</span>
<span class="built_in">let</span> arcLengthPerGlass = angleDifference / CGFloat<span class="params">(NoOfGlasses)</span>

<span class="comment">//then multiply out by the actual glasses drunk</span>
<span class="built_in">let</span> outlineEndAngle = arcLengthPerGlass <span class="built_in">*</span> CGFloat<span class="params">(counter)</span> + startAngle

<span class="comment">//2 - draw the outer arc</span>
var outlinePath = UIBezierPath<span class="params">(arcCenter: center, 
                               radius: bounds.width/<span class="number">2</span> - <span class="number">2.5</span>,
                           startAngle: startAngle, 
                             endAngle: outlineEndAngle,
                            clockwise: <span class="literal">true</span>)</span>

<span class="comment">//3 - draw the inner arc</span>
outlinePath.addArcWithCenter<span class="params">(center, 
                  radius: bounds.width/<span class="number">2</span> - arcWidth + <span class="number">2.5</span>,
              startAngle: outlineEndAngle, 
                endAngle: startAngle, 
               clockwise: <span class="literal">false</span>)</span>

<span class="comment">//4 - close the path</span>
outlinePath.closePath<span class="params">()</span>

outlineColor.setStroke<span class="params">()</span>
outlinePath.lineWidth = <span class="number">5.0</span>
outlinePath.stroke<span class="params">()</span>
</code></pre><p>下面解释一下各个小节代码的意思：</p>
<ol>
<li>oulineEndAngle表示这个弧应该结束的角度，用当前的counter的值来计算。</li>
<li>outlinePath 就是外面的弧。由于这个弧不是基于单元圆的，所以把半径传给UIBezierPath()这个方法来计算这个弧的真实长度。</li>
<li>在第一个弧的基础上再加一个内部的弧。这个和前面一个弧的角度一样但是是反向的（clockwise的值置为false）。同时，这一段会自动生成一个直线连接内部弧还外部的弧。</li>
<li>在另一个弧的末尾自动画一条直线来关闭整个弧的路径。</li>
</ol>
<p>因为你在CounterView.swift中将counter属性设置为5，你的CounterView现在应该在storyboard中看起来像下面这样：</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/12/1-ArcOutline.png" alt="1-ArcOutline"></p>
<p>打开 <strong><em>Main.storyboard</em></strong>, 选择CounterView然后在右边的<strong><em>Attributes Insepector</em></strong>里，改变Counter的数值来检查你写在drawRect里的代码是否正确。然后你惊喜的发现这个storyboard里面也跟着改变了，它竟然是可以交互的。尝试改变counter的数值去超过8或者小于0。接下来你会修改这个。</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/12/1-CounterView.png" alt="1-CounterView"></p>
<h2 id="让一切都能够正常工作">让一切都能够正常工作</h2><p>祝贺你！你现在已经能够掌控这些了，现在你需要做的就是点击加号按钮来增加这个计数器的数值，或者是点击减号按钮来减少这个计数器的数值。</p>
<p>在<strong><em>Main.storyboard</em></strong>中，拖拽一个UILable控件，放置在CounterView的中间。让它成为CounterView的子View。</p>
<p>然后在右边的<strong><em>Size Inspector</em></strong>中，设置X=93, Y=93, Width=44, 还有Height=44：</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/12/1-LabelCoords.png" alt="1-LabelCoords"></p>
<p>在右边的<strong><em>Attributes Inspector</em></strong>，改变Alignment参数为center,font size为36并且默认的Label title为8.</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/12/1-LabelAttributes.png" alt="1-LabelAttributes"></p>
<p>打开ViewController.swift然后添加下面的属性到这个类的顶部：</p>
<pre><code><span class="comment">//Counter outlets</span>
<span class="variable">@IBOutlet</span> weak var <span class="attribute">counterView</span>: CounterView!
<span class="variable">@IBOutlet</span> weak var <span class="attribute">counterLabel</span>: UILabel!
</code></pre><p>还是在ViewController.swift里，添加下面的方法到这个类的最下面。</p>
<pre><code><span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">btnPushButton</span><span class="params">(button: PushButtonView)</span></span> {
<span class="keyword">if</span> button.isAddButton {
 counterView.counter++
} <span class="keyword">else</span> {
 <span class="keyword">if</span> counterView.counter &gt; <span class="number">0</span> {
   counterView.counter--
 }
}
counterLabel.text = <span class="type">String</span>(counterView.counter)
}
</code></pre><p>现在，你对计数器的增加或者减少都依赖于按钮的<strong><em>isAddButton</em></strong>属性，确保计数器不会降到0以下-没人会喝负数杯数的水。:] 同时你也要在更新label上面的计数器数值。</p>
<p>把下面这段代码也加入到<code>viewDidLoad()</code>的底部，确保这个counterLabel的初始数值也被赋值到。</p>
<pre><code>counterLabel<span class="class">.text</span> = <span class="function"><span class="title">String</span><span class="params">(counterView.counter)</span></span>
</code></pre><p>在<strong><em>Main.storyboard</em></strong>中，连接<strong><em>CounterView</em></strong> outlet和<strong><em>UILabel</em></strong> outlet到ViewController中，同时连接两个按钮的<strong><em>Touch Up Inside</em></strong>事件到ViewController里面的相关方法上。</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/1-ConnectingOutlets2.gif" alt="1-ConnectingOutlets2"></p>
<p>运行这个应用，然后看看是否你的按钮能够更新这个label上面的数字，他们应该能行的。</p>
<p>等等！为什么这个CounterView上面的进度没有更新？</p>
<p>回想一下在这个教程的开始，<code>drawRect(_:)</code>方法只有在某些情况下会被调用，比如：遮住它的view被移开的时候，或者是它的hidden属性被改变的时候，或者是这个view第一次出现在屏幕上，或者是你的app调用了<code>setNeedsDisplay()</code>或者<code>setNeedsDisplayInRect()</code>方法。</p>
<p>然而，一旦counter属性改变的时候，CounterView也必须改变它的进度条。否则，用户就会认为你的app毫无用处。</p>
<p>打开CounterView.swift 然后改变这个counter属性声明为下面的代码：</p>
<pre><code><span class="preprocessor">@IBInspectable</span> <span class="keyword">var</span> counter: <span class="type">Int</span> = <span class="number">5</span> {
    <span class="keyword">didSet</span> {
        <span class="keyword">if</span> counter &lt;=  <span class="type">NoOfGlasses</span> {
        <span class="comment">//the view needs to be refreshed</span>
        setNeedsDisplay()
        }
    }
}
</code></pre><p>这段代码使CounterView仅仅在counter的数值小于或者等于用户的每天目标杯数的时候才会刷新，因为外面的轮廓只会最高到8.</p>
<p>再一次运行你的app，一切都正常工作起来。</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/1-Part1Finished.png" alt="1-Part1Finished"></p>
<h2 id="接下来何去何从？">接下来何去何从？</h2><p>在这个教程你已经学习到了基本的绘图，现在你应该能够在你的UI里改变你的view的形状。但是等等，还有很多需要学习！在这篇教程的<a href="http://www.raywenderlich.com/?p=90693" target="_blank" rel="external">第二部分</a>，你将会尝试更深层次探索Core Graphics context并且创造一个记录你的喝水杯数的图表。</p>
<p>你可以<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2015/02/Flo-Part1-6.31.zip" target="_blank" rel="external">下载</a>这个项目的所有代码，如果你有任何问题和评论，在下面的讨论中提出来。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Core_Graphics教程第一部分(Swift)_-_起步">Core Graphics教程第一部分(Swift) - 起步</h2><blockquote>
<ul>
<li>原文链接 : <a href="http://www.raywenderlich.com/90690/modern-core-graphics-with-swift-part-1">Core Graphics Tutorial Part 1: Getting Started</a></li>
<li>原文作者 : <a href="http://www.raywenderlich.com/u/caroline">Caroline Begbie </a></li>
<li>译文出自 :  <a href="www.devtf.cn">开发技术前线</a></li>
<li>译者 : <a href="https://github.com/sdq/">sdq</a>  <a href="https://github.com/StormXX/">StormXX</a></li>
<li>校对者:  <a href="https://github.com/StormXX/">StormXX</a></li>
</ul>
</blockquote>
<p>想象一下…当你完成了你的应用，它能够很好地运行，但是界面还缺少个人的风格。这时，你可以选择用PS画出一系列尺寸的图片，并希望Apple不会再推出一个<strong>@4x</strong>的retina显示尺寸…   </p>
<p>或者，你可以领先一步，采用Core Graphics进行绘图，保证一个图片可以适应各种尺寸的屏幕。   </p>
<p>Core Graphics是苹果的一个矢量图绘制框架 - 它是一个大型且给力的API、有很多需要去学习。不过别慌，这个系列的文章会带你由简入深地学习Core Graphics，最后你将可以在你的应用中创作令人惊叹的图片。   </p>
<p>这是一个全新的系列，采用最新的方式来学习Core Graphics。这个系列完全和Xcode6与Swift保持同步，并且包含了一些很酷的新特性，比如<strong>@IBDesignable</strong>和<strong>@IBInspectable</strong>，这让学习Core Graphics变得更有趣也更容易。</p>
<p>拿起可乐，让我们开始吧！</p>
<h2 id="介绍Flo_-_一款记录喝水杯数的App">介绍Flo - 一款记录喝水杯数的App</h2><p>你将会完成一个追踪你喝水习惯的app。   </p>
<p>Flo可以让你很轻松地追踪到你喝了多少水。人们说一天喝8杯水才是健康的，但是往往喝了几杯水之后我们就忘了记录了。这就是Flo使用的时候了，每当你喝完一杯水以后，你就可以在Flo上点击计数，Flo会为你记录喝水情况。你也可以在Flo上查看到过去7天的喝水状况。</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/12/1-CompletedApp.gif" alt="demo"></p>
<p>在这个系列的第一部分，你将会通过UIKit的画图方法创建三个控件。<br>第二部分中，你将会深入了解Core Graphics的内容并且学习绘图。<br>最后第三部分，你将会制作一个样式背景，并且获得自制的Core Graphics奖牌 ：）</p>]]>
    
    </summary>
    
      <category term="Core Graphics" scheme="http://ytlvy.com/tags/Core-Graphics/"/>
    
      <category term="Swift" scheme="http://ytlvy.com/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift Core Graphics Tutorial Part 3: Patterns and Playgrounds]]></title>
    <link href="http://ytlvy.com/2015/08/08/Swift-Core-Graphics-Tutorial-Part-3-Patterns-and-Playgrounds/"/>
    <id>http://ytlvy.com/2015/08/08/Swift-Core-Graphics-Tutorial-Part-3-Patterns-and-Playgrounds/</id>
    <published>2015-08-08T13:20:32.000Z</published>
    <updated>2015-08-08T13:21:02.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Core_Graphics_教程第三部分(Swift)_-_Patterns_和_Playgrounds">Core Graphics 教程第三部分(Swift) - Patterns 和 Playgrounds</h2><blockquote>
<ul>
<li>原文链接：<a href="http://www.raywenderlich.com/90695/modern-core-graphics-with-swift-part-3" target="_blank" rel="external">Core Graphics Tutorial Part 3: Patterns and Playgrounds</a></li>
<li>原文作者：<a href="http://www.raywenderlich.com/u/caroline" target="_blank" rel="external"> Caroline Begbie </a></li>
<li>译文出自：<a href="www.devtf.cn">开发者前线</a></li>
<li>译者：<a href="https://github.com/MrLoong" target="_blank" rel="external">MrLoong</a></li>
<li>校对者：<a href="https://github.com/samw00" target="_blank" rel="external">samw00</a></li>
</ul>
</blockquote>
<p>欢迎回到Core Graphics 教学系列的第三也是最后一部分！Flo，你的water drinking tracking app将使用Core Graphics 进行最终的改进。</p>
<p>在<a href="http://www.raywenderlich.com/90690/modern-core-graphics-with-swift-part-1" target="_blank" rel="external">第一部分</a>，你通过UIKit画了三个自定义形状的控件,<a href="http://www.raywenderlich.com/90693/modern-core-graphics-with-swift-part-2" target="_blank" rel="external">在第二部分</a>你创建了一个视图用来显示用户在过去一周的喝水量，并且研究了transforming the context transformation matrix (CTM)</p>
<p>在这第三也是最后一部分，你将使<strong>Flo</strong>升级到它的最终形态，特别的是你将：</p>
<ul>
<li>创建一个重复的背景图案</li>
<li>为成功每天喝掉8杯水的用户从头到尾画一枚奖章</li>
</ul>
<p>如果你还没有这个项目的源代码，从本系列的第二部分下载<a href="http://cdn1.raywenderlich.com/wp-content/uploads/2015/02/Flo-Part2-6.3.zip" target="_blank" rel="external"><strong>Flo工程</strong></a></p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/FinalApp-192x320.png" alt=""></p>
<a id="more"></a>
<h2 id="Background_Repeating_Pattern_背景重复模式">Background Repeating Pattern 背景重复模式</h2><p>你在这部分的任务是使用UIKit的方式创建这个背景图案：</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/12/3-FinalBackground-300x500.png" alt=""></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Note: If you need to <span class="operator"><span class="keyword">optimize</span> <span class="keyword">for</span> speed, <span class="keyword">then</span> <span class="keyword">work</span> through</span><br><span class="line">Core Graphics Tutorial: Patterns which demonstrates a basic </span><br><span class="line">way <span class="keyword">to</span> <span class="keyword">create</span> patterns <span class="keyword">with</span> Objective-C <span class="keyword">and</span> Core Graphics. </span><br><span class="line"><span class="keyword">For</span> most purposes, <span class="keyword">like</span> <span class="keyword">when</span> the background <span class="keyword">is</span> <span class="keyword">only</span> drawn </span><br><span class="line">once, UIKit’s easier wrapper methods should be acceptable.</span></span><br></pre></td></tr></table></figure>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：如果你需要对速度进行优化，可以去看[<span class="link_label">Core Graphics Tutorial:Patters</span>](<span class="link_url">http://www.raywenderlich.com/33496/core-graphics-tutorial-patterns</span>)里面演示一个使用Object－c和Core Graphics的基本方法去创建一个格局.在大多数情况下当背景仅被描绘一次，使用UIKit封装好的简易方法应该是可以接受的。</span><br></pre></td></tr></table></figure>
<p>点击<strong>File\New\File…</strong>并且选择IOS <strong>iOS\Source\Cocoa Touch Class</strong> 模版创建一个类名为<strong>BackgroundView</strong>的UIView。点击下一步然后创建</p>
<p>进入<strong>Main.storyboard</strong>，在 <strong>Identity Inspector</strong>选择ViewController主界面，改变为<strong>BackgroundView</strong></p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/3-BackgroundViewStoryboard3-480x187.png" alt=""></p>
<p>点击<strong>Assistant Editor</strong>，让<strong>BackgroundView.swift</strong>和<strong>Main.storyboard</strong>并排显示。</p>
<p>替换<strong>BackgroundView.swift</strong>的代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">UIKit</span></span><br><span class="line"> </span><br><span class="line"><span class="preprocessor">@IBDesignable</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BackgroundView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//1 </span></span><br><span class="line">  <span class="preprocessor">@IBInspectable</span> <span class="keyword">var</span> lightColor: <span class="type">UIColor</span> = <span class="type">UIColor</span>.orangeColor()</span><br><span class="line">  <span class="preprocessor">@IBInspectable</span> <span class="keyword">var</span> darkColor: <span class="type">UIColor</span> = <span class="type">UIColor</span>.yellowColor()</span><br><span class="line">  <span class="preprocessor">@IBInspectable</span> <span class="keyword">var</span> patternSize:<span class="type">CGFloat</span> = <span class="number">200</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">drawRect</span><span class="params">(rect: CGRect)</span></span> &#123;</span><br><span class="line">    <span class="comment">//2</span></span><br><span class="line">    <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>()</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//3</span></span><br><span class="line">    <span class="type">CGContextSetFillColorWithColor</span>(context, darkColor.<span class="type">CGColor</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//4</span></span><br><span class="line">    <span class="type">CGContextFillRect</span>(context, rect)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在你的storyboard背景应该是黄色的，更多的细节参考上面的代码：</p>
<ol>
<li><strong>lightColor</strong>和<strong>darkColor</strong>拥有<strong>@IBInspectable</strong>属性，所以更容易去配置背景颜色。你使用橙色和黄色作为临时色，这样你就能直到到底在发生什么事。<strong>patternSize</strong>控件控制着重复形式的大小。它的初始值设置为large，所以更容易看清发生了什么。</li>
<li><strong>UIGraphicsGetCurrentContext()</strong>让你了解视图上下文同样也是<strong>drawRect(_:)</strong>将会绘画的区域。</li>
<li>使用Core Graphics的方法<strong>CGContextSetFillColorWithColor()</strong> 去设置当前上下文的填充色。注意当你使用Core Graphics时，需要用到<strong>darkColor</strong>的一个属性<strong>CGColor</strong>。</li>
<li><strong>CGContextFillRect()</strong>使用当前填充色填充当前上下文的整个背景，而不是建立一个矩形路径。</li>
</ol>
<p>你现在需要使用<strong>UIBezierPath()</strong>画这三个橙色的三角形。图中的点对应代码中的数字。</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/12/3-GridPattern.png" alt=""></p>
<p>仍然在<strong>BackgroundView.swift</strong>中操作，在 <strong>drawRect(_:)</strong>末尾添加如下代码：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">let drawSize = <span class="function"><span class="title">CGSize</span><span class="params">(width: patternSize, height: patternSize)</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//insert code here</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">let trianglePath = <span class="function"><span class="title">UIBezierPath</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line">trianglePath.moveToPoint(CGPoint(x:drawSize.<span class="attribute">width</span>/<span class="number">2</span>, </span><br><span class="line">                                 y:<span class="number">0</span>)) </span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">trianglePath.addLineToPoint(CGPoint(x:<span class="number">0</span>, </span><br><span class="line">                                    y:drawSize.<span class="attribute">height</span>/<span class="number">2</span>)) </span><br><span class="line"><span class="comment">//3</span></span><br><span class="line">trianglePath.addLineToPoint(CGPoint(x:drawSize<span class="class">.width</span>, </span><br><span class="line">                                    y:drawSize.<span class="attribute">height</span>/<span class="number">2</span>)) </span><br><span class="line"> </span><br><span class="line"><span class="comment">//4</span></span><br><span class="line">trianglePath.moveToPoint(CGPoint(x: <span class="number">0</span>, </span><br><span class="line">                                 y: drawSize.<span class="attribute">height</span>/<span class="number">2</span>)) </span><br><span class="line"><span class="comment">//5</span></span><br><span class="line">trianglePath.addLineToPoint(CGPoint(x: drawSize.<span class="attribute">width</span>/<span class="number">2</span>, </span><br><span class="line">                                    y: drawSize.<span class="attribute">height</span>)) </span><br><span class="line"><span class="comment">//6</span></span><br><span class="line">trianglePath.addLineToPoint(CGPoint(x: <span class="number">0</span>, </span><br><span class="line">                                    y: drawSize.<span class="attribute">height</span>)) </span><br><span class="line"> </span><br><span class="line"><span class="comment">//7</span></span><br><span class="line">trianglePath.moveToPoint(CGPoint(x: drawSize<span class="class">.width</span>, </span><br><span class="line">                                 y: drawSize.<span class="attribute">height</span>/<span class="number">2</span>)) </span><br><span class="line"><span class="comment">//8</span></span><br><span class="line">trianglePath.addLineToPoint(CGPoint(x:drawSize.<span class="attribute">width</span>/<span class="number">2</span>, </span><br><span class="line">                                    y:drawSize.<span class="attribute">height</span>)) </span><br><span class="line"><span class="comment">//9</span></span><br><span class="line">trianglePath.addLineToPoint(CGPoint(x: drawSize<span class="class">.width</span>, </span><br><span class="line">                                    y: drawSize.<span class="attribute">height</span>)) </span><br><span class="line"> </span><br><span class="line">lightColor.<span class="function"><span class="title">setFill</span><span class="params">()</span></span></span><br><span class="line">trianglePath.<span class="function"><span class="title">fill</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>注意你是如何使用一个路径画三个三角形的，<strong>moveToPoint(_:)</strong>就像在纸上抬起你的笔从一个地方绘制和移动到另一个地方。</p>
<p>你的storyboard现在应该有一个橙色和黄的的图像在你背景的左上方。</p>
<p>到目前为止，你都是直接在一个视图的上下文中直接绘画。为了能重复这个图案，你需要在上下文外创建一个图像，然后用这个图像作为上下文中的背景图案。</p>
<p>找到下面这段代码，在drawRect(_:)的顶部，但是在下面这段代码之后：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">et drawSize = <span class="function"><span class="title">CGSize</span><span class="params">(width: patternSize, height: patternSize)</span></span></span><br></pre></td></tr></table></figure>
<p>然后插入下面的代码</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">UIGraphicsBeginImageContextWithOptions</span><span class="params">(drawSize, true, <span class="number">0.0</span>)</span></span></span><br><span class="line">let drawingContext = <span class="function"><span class="title">UIGraphicsGetCurrentContext</span><span class="params">()</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//set the fill color for the new context</span></span><br><span class="line">darkColor.<span class="function"><span class="title">setFill</span><span class="params">()</span></span></span><br><span class="line">CGContextFillRect(drawingContext,</span><br><span class="line">      <span class="function"><span class="title">CGRectMake</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, drawSize.width, drawSize.height)</span></span>)</span><br></pre></td></tr></table></figure>
<p>嘿！那些橘黄色三角形从面板中消失了，它们去哪了？</p>
<p><strong>UIGraphicsBeginImageContextWithOptions()</strong>创建了一个新的上下文，并且将其设置为当前的绘图上下文，所以你在这个新的上下文中作画。刚才方法的参数为：</p>
<ul>
<li>context的大小</li>
<li>背景是否透明— 如果你需要透明的, 这里设置为false.</li>
<li>context scale的大小. 如果要适应视网膜屏幕, 这里应该设置为2, 如果要适应iPhone 6 Plus, 应该为3.0. 然而这里使用0.0将自动适配屏幕</li>
</ul>
<p>然后你用 <strong>UIGraphicsGetCurrentContext()</strong>得到这个新的上下文的引用。</p>
<p>然后你将这个新的context设置为黄色。你可以通过设这context的属性opacity为false让原来的背景色显示，但是画一个不透明的context比画一个透明的要快得多，凭这一点就应该选opaque。</p>
<p>在<strong>drawRect(_:)</strong>的末尾添加下面的代码：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let image = <span class="function"><span class="title">UIGraphicsGetImageFromCurrentImageContext</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">UIGraphicsEndImageContext</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>在当前的context提取一个UIImage。当你使用<strong>UIGraphicsEndImageContext()</strong>结束当前context时，描绘context还原为视图context，所以任何未来在<strong>drawRect(_:)</strong> 中的的绘图都会反应在viwe中。</p>
<p>为了使图像作为一个可重复的图案，在drawRect(_:)末尾添加代码：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">UIColor</span><span class="params">(patternImage: image)</span></span>.<span class="function"><span class="title">setFill</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">CGContextFillRect</span><span class="params">(context, rect)</span></span></span><br></pre></td></tr></table></figure>
<p>这会让图片当作UIColor中的一个新的颜色来用，而不是一个纯色。</p>
<p>编译并且运行app，你现在的app应该有一个相当亮眼的背景：</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/12/3-BoldBackground2.png" alt=""></p>
<p>去Main.storyboard，选择background view，并且在Attributes Inspector改变IBInspectable属性的值为：</p>
<ul>
<li>Light Color: RGB(255, 255, 242)</li>
<li>Dark Color: RGB(223, 255, 247)</li>
<li>Pattern Size: 30</li>
</ul>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/3-BackgroundColors2-473x320.png" alt=""></p>
<p>尝试去画一些不同的背景图案，看看除了三角形，你能不能把背景图案变成polka dot。</p>
<p>当然，你可以使用自己的非矢量图作为背景图案</p>
<h2 id="Drawing_Images_绘制图像">Drawing Images 绘制图像</h2><p>在本教程的最后阶段，你将为喝够水的人送上一个奖牌，当计数器纪录的数量达到8杯的时候这个奖牌将出现。</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/12/3-MedalFinal.png" alt=""></p>
<p>我知道这肯定比不上博物馆里的一件艺术品，但是请你知道，如果你改进它，我并不会生气，甚至你可以通过画一个奖杯而不是奖牌来升华一下。</p>
<p>你将在<strong>Swift Playground</strong>中绘制这个奖牌，而不是用<strong>@IBDesignable</strong>，然后把代码复制到<strong>UIImageView</strong>的子类中。虽然与storyboards互动通长是很有用的，但他们有局限性。他们仅能描绘简单的代码，当你创建一个复杂的设计时，storyboards通长很耗时间。</p>
<p>在这种情况下，只有当用户喝满八杯水的时候才需要画一个图像。如果用户从来没有到达到过目标，那就根本不需要绘制奖牌。</p>
<p>一旦绘制，他也不需要使用drawRect(_:)和setNeedsDisplay().进行重绘。</p>
<p>是时候作画了。首先点击Standard Editor按钮，让Xcode返回单一界面编辑模式。</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/3-StandardEditor.png" alt=""></p>
<p>点击<strong>File\New\File…</strong>并且选择IOS Playground模版。点击 Next 命名playground为MedalDrawing然后点击Create。</p>
<p>把playground中的代码替换为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line"> </span><br><span class="line">let size = <span class="function"><span class="title">CGSize</span><span class="params">(width: <span class="number">120</span>, height: <span class="number">200</span>)</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="title">UIGraphicsBeginImageContextWithOptions</span><span class="params">(size, false, <span class="number">0.0</span>)</span></span></span><br><span class="line">let context = <span class="function"><span class="title">UIGraphicsGetCurrentContext</span><span class="params">()</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//This code must always be at the end of the playground</span></span><br><span class="line">let image = <span class="function"><span class="title">UIGraphicsGetImageFromCurrentImageContext</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">UIGraphicsEndImageContext</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>这将创建一个绘制上下文，就像你之前刚给重复背景图片做的是一回事。</p>
<p>注意最后两行。你总是需要它们在playground底部，这样你就可以在playground中预览图片。</p>
<p>下一步，在灰色的结果栏中单击代码右边的＋按钮：</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/02/ShowFinishedImage.gif" alt=""></p>
<p>这将在代码的底部预览你的图像。图像将根据你代码的每次更新而更新。</p>
<p>在你作画之前，最好能在你的脑海里先有一张绘制草图，看看我在构造这篇tutorial时所构想的“杰作”：</p>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/12/3-Sketch.png" alt=""></p>
<p>下面是绘制奖牌的顺序:</p>
<ol>
<li>后丝带（红色）</li>
<li>奖章（金色渐变）</li>
<li>扣环（暗金色）</li>
<li>前丝带（蓝色）</li>
<li>数字1（暗金色）</li>
</ol>
<p>记住不要变动playground的最后两行（在你最后提取背景图像的地方），并且在那两行代码前添加描绘代码：</p>
<p>首先设置你要的非标准颜色。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Gold colors</span></span><br><span class="line">let darkGoldColor = UIColor(<span class="string">red:</span> <span class="number">0.6</span>, <span class="string">green:</span> <span class="number">0.5</span>, <span class="string">blue:</span> <span class="number">0.15</span>, <span class="string">alpha:</span> <span class="number">1.0</span>)</span><br><span class="line">let midGoldColor = UIColor(<span class="string">red:</span> <span class="number">0.86</span>, <span class="string">green:</span> <span class="number">0.73</span>, <span class="string">blue:</span> <span class="number">0.3</span>, <span class="string">alpha:</span> <span class="number">1.0</span>)</span><br><span class="line">let lightGoldColor = UIColor(<span class="string">red:</span> <span class="number">1.0</span>, <span class="string">green:</span> <span class="number">0.98</span>, <span class="string">blue:</span> <span class="number">0.9</span>, <span class="string">alpha:</span> <span class="number">1.0</span>)</span><br></pre></td></tr></table></figure>
<p>这些现在应该看起来非常熟悉了。注意当你声明颜色的时候，颜色会出现在palyground的右边。</p>
<p>下面的代码将绘制奖章的红色丝带：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Lower Ribbon</span></span><br><span class="line"><span class="tag">var</span> lowerRibbonPath = <span class="function"><span class="title">UIBezierPath</span><span class="params">()</span></span></span><br><span class="line">lowerRibbonPath.<span class="function"><span class="title">moveToPoint</span><span class="params">(CGPointMake(<span class="number">0</span>, <span class="number">0</span>)</span></span>)</span><br><span class="line">lowerRibbonPath.<span class="function"><span class="title">addLineToPoint</span><span class="params">(CGPointMake(<span class="number">40</span>,<span class="number">0</span>)</span></span>)</span><br><span class="line">lowerRibbonPath.<span class="function"><span class="title">addLineToPoint</span><span class="params">(CGPointMake(<span class="number">78</span>, <span class="number">70</span>)</span></span>)</span><br><span class="line">lowerRibbonPath.<span class="function"><span class="title">addLineToPoint</span><span class="params">(CGPointMake(<span class="number">38</span>, <span class="number">70</span>)</span></span>)</span><br><span class="line">lowerRibbonPath.<span class="function"><span class="title">closePath</span><span class="params">()</span></span></span><br><span class="line">UIColor.<span class="function"><span class="title">redColor</span><span class="params">()</span></span>.<span class="function"><span class="title">setFill</span><span class="params">()</span></span></span><br><span class="line">lowerRibbonPath.<span class="function"><span class="title">fill</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>没有什么新东西，就是创建一个路径并且填充它。你应该看见红色的路径出现在右侧。</p>
<p>添加描绘扣环的代码：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Clasp</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">var</span> claspPath = UIBezierPath(roundedRect: </span><br><span class="line">                           <span class="function"><span class="title">CGRectMake</span><span class="params">(<span class="number">36</span>, <span class="number">62</span>, <span class="number">43</span>, <span class="number">20</span>)</span></span>, </span><br><span class="line">                           cornerRadius: <span class="number">5</span>)</span><br><span class="line">claspPath<span class="class">.lineWidth</span> = <span class="number">5</span></span><br><span class="line">darkGoldColor.<span class="function"><span class="title">setStroke</span><span class="params">()</span></span></span><br><span class="line">claspPath.<span class="function"><span class="title">stroke</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>这里你将通过<strong>UIBezierPath(roundedRect:)</strong>中的<strong>cornerRadius</strong>这个参数来设置圆角。<br>扣环应该在右侧显示了。</p>
<p>添加绘制奖章的代码：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Medallion</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">var</span> medallionPath = UIBezierPath(ovalInRect: </span><br><span class="line">                    <span class="function"><span class="title">CGRect</span><span class="params">(origin: CGPointMake(<span class="number">8</span>, <span class="number">72</span>)</span></span>, </span><br><span class="line">                             size: <span class="function"><span class="title">CGSizeMake</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>))</span><br><span class="line"><span class="comment">//CGContextSaveGState(context)</span></span><br><span class="line"><span class="comment">//medallionPath.addClip()</span></span><br><span class="line">let gradient = CGGradientCreateWithColors(</span><br><span class="line">                      <span class="function"><span class="title">CGColorSpaceCreateDeviceRGB</span><span class="params">()</span></span>, </span><br><span class="line">                      [darkGoldColor<span class="class">.CGColor</span>, </span><br><span class="line">                       midGoldColor<span class="class">.CGColor</span>, </span><br><span class="line">                       lightGoldColor.CGColor],</span><br><span class="line">                      [<span class="number">0</span>, <span class="number">0.51</span>, <span class="number">1</span>])</span><br><span class="line">CGContextDrawLinearGradient(context,</span><br><span class="line">                            gradient, </span><br><span class="line">                            <span class="function"><span class="title">CGPointMake</span><span class="params">(<span class="number">40</span>, <span class="number">40</span>)</span></span>, </span><br><span class="line">                            <span class="function"><span class="title">CGPointMake</span><span class="params">(<span class="number">40</span>,<span class="number">162</span>)</span></span>, </span><br><span class="line">                             <span class="number">0</span>)</span><br><span class="line"><span class="comment">//CGContextRestoreGState(context)</span></span><br></pre></td></tr></table></figure>
<p>注意注释部分，这些都是暂时显示颜色渐变是如何写的：</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/3-SquareGradient.png" alt=""></p>
<p>为了使颜色从左上角至右下角渐变，改变渐变最终点的x坐标，修改<strong>CGContextDrawLinearGradient()</strong>中的代码：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CGContextDrawLinearGradient(context,</span><br><span class="line">                            gradient, </span><br><span class="line">                            <span class="function"><span class="title">CGPointMake</span><span class="params">(<span class="number">40</span>, <span class="number">40</span>)</span></span>, </span><br><span class="line">                            <span class="function"><span class="title">CGPointMake</span><span class="params">(<span class="number">100</span>,<span class="number">160</span>)</span></span>, </span><br><span class="line">                             <span class="number">0</span>)</span><br><span class="line">``` </span><br><span class="line">![](http:<span class="comment">//cdn3.raywenderlich.com/wp-content/uploads/2014/12/3-SkewedGradient.png)</span></span><br><span class="line"></span><br><span class="line">现在取消奖章那部分代码中的三行注释从而创建了一个剪切路径把渐变图案约束在奖章的圈圈内。</span><br><span class="line"></span><br><span class="line">就像你在第二部分绘制图形是一样，你在添加剪切路径前保存了绘画上下文，在渐变画好自后你有将上下文恢复了回去，所以上下文不再是被剪切的状态了。</span><br><span class="line"></span><br><span class="line">![](http:<span class="comment">//cdn5.raywenderlich.com/wp-content/uploads/2014/12/3-ClippedGradient.png)</span></span><br><span class="line"></span><br><span class="line">用奖牌的圆圈路径来绘制奖牌上的实线，但绘制前要改变比例。你只将改变应用到一个路径上而不是转变整个context。</span><br><span class="line"></span><br><span class="line">在绘制奖章的代码下添加：</span><br></pre></td></tr></table></figure>
<p>//Create a transform<br>//Scale it, and translate it right and down<br>var transform = CGAffineTransformMakeScale(0.8, 0.8)<br>transform = CGAffineTransformTranslate(transform, 15, 30)</p>
<p>medallionPath.lineWidth = 2.0</p>
<p>//apply the transform to the path<br>medallionPath.applyTransform(transform)<br>medallionPath.stroke()<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">!<span class="attr_selector">[]</span>(<span class="attribute">http</span>:<span class="comment">//cdn5.raywenderlich.com/wp-content/uploads/2014/12/3-MedalOutline.png)</span></span><br><span class="line"></span><br><span class="line">这将路径的尺寸缩小至原始尺寸的<span class="number">80%</span>，并转换路径使其人在渐变视图中居中。</span><br><span class="line"></span><br><span class="line">之后添加前丝带的绘制代码：</span><br></pre></td></tr></table></figure></p>
<p>//Upper Ribbon</p>
<p>var upperRibbonPath = UIBezierPath()<br>upperRibbonPath.moveToPoint(CGPointMake(68, 0))<br>upperRibbonPath.addLineToPoint(CGPointMake(108, 0))<br>upperRibbonPath.addLineToPoint(CGPointMake(78, 70))<br>upperRibbonPath.addLineToPoint(CGPointMake(38, 70))<br>upperRibbonPath.closePath()</p>
<p>UIColor.blueColor().setFill()<br>upperRibbonPath.fill()<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这和你之前给后丝带添加的代码非常相似，创建一个<span class="tag">bezier</span>路径并且填充。</span><br><span class="line"></span><br><span class="line">!<span class="attr_selector">[]</span>(<span class="rule"><span class="attribute">http</span>:<span class="value">//cdn4.raywenderlich.com/wp-content/uploads/<span class="number">2014</span>/<span class="number">12</span>/<span class="number">3</span>-UpperRibbon.png)</span><br><span class="line"></span><br><span class="line">最后一步是在奖章上画数字<span class="number">1</span>，代码如下：</span></span></span><br></pre></td></tr></table></figure></p>
<p>//Number One</p>
<p>//Must be NSString to be able to use drawInRect()<br>let numberOne = “1”<br>let numberOneRect = CGRectMake(47, 100, 50, 50)<br>let font = UIFont(name: “Academy Engraved LET”, size: 60)<br>let textStyle = NSMutableParagraphStyle.defaultParagraphStyle()<br>let numberOneAttributes = [<br>  NSFontAttributeName: font!,<br>  NSForegroundColorAttributeName: darkGoldColor]<br>numberOne.drawInRect(numberOneRect,<br>                     withAttributes:numberOneAttributes)<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在这里你定义了一个字符串并设置了字体属性，然后使用**<span class="function"><span class="title">drawInRect</span><span class="params">(_:)</span></span>.**在context进行了重绘</span><br><span class="line"></span><br><span class="line">![](http:<span class="comment">//cdn3.raywenderlich.com/wp-content/uploads/2014/12/3-NumberOne.png)</span></span><br><span class="line"></span><br><span class="line">看上去不错</span><br><span class="line"></span><br><span class="line">你已经很接近成功了，但它看起来有一些二维 － 如果加上一些阴影会更好。</span><br><span class="line"></span><br><span class="line">#<span class="id">#Shadows</span> 阴影</span><br><span class="line"></span><br><span class="line">创建一个阴影需要三个要素：颜色，偏移（阴影的距离和方向）和模糊</span><br><span class="line"></span><br><span class="line">在 playground 顶部，位于自定义颜色之后但在<span class="comment">//Lower Ribbon之前，插入实现阴影的代码：</span></span><br></pre></td></tr></table></figure></p>
<p>//Add Shadow<br>let shadow:UIColor = UIColor.blackColor().colorWithAlphaComponent(0.80)<br>let shadowOffset = CGSizeMake(2.0, 2.0)<br>let shadowBlurRadius: CGFloat = 5</p>
<p>CGContextSetShadowWithColor(context,<br>                            shadowOffset,<br>                            shadowBlurRadius,<br>                            shadow.CGColor)<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Okay，这能给我们一个阴影，但结果并不是我们所想象的那样。为什么呢？</span><br><span class="line"></span><br><span class="line">![](<span class="string">http:</span><span class="comment">//cdn5.raywenderlich.com/wp-content/uploads/2014/12/3-MessyShadows.png)</span></span><br><span class="line"></span><br><span class="line">当你在上下文中绘制一个对象时，该代码会给所有的对象都创建阴影。</span><br><span class="line"></span><br><span class="line">![](<span class="string">http:</span><span class="comment">//cdn4.raywenderlich.com/wp-content/uploads/2014/12/3-IndividualShadows.png)</span></span><br><span class="line"></span><br><span class="line">啊！你的奖章由五个对象所组成。难怪看起来有点模糊。幸运的是这改起来比较容易。就是简单的把所有的对象通过一个透明的layer组起来，然后你只需要对整个对象组绘制一个阴影就可以。</span><br><span class="line"></span><br><span class="line">![](<span class="string">http:</span><span class="comment">//cdn5.raywenderlich.com/wp-content/uploads/2014/12/3-GroupedShadow.png)</span></span><br><span class="line"></span><br><span class="line">在阴影代码后添加组合对象的代码。以这段开头：</span><br></pre></td></tr></table></figure></p>
<p>CGContextBeginTransparencyLayer(context, nil)<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">当你开启一组，你也需要结束它。所以在playground末端添加这一段代码，但仍然在截取最后的图像之前：</span><br></pre></td></tr></table></figure></p>
<p>CGContextEndTransparencyLayer(context)<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">现在你将有一个完整的奖牌图像，整洁的阴影。</span><br><span class="line"></span><br><span class="line">![](http://cdn1.raywenderlich.com/wp-content/uploads/2014/12/3-MedalFinal.png)</span><br><span class="line"></span><br><span class="line"><span class="comment">##Image View Using Core Graphics Image创建一个新的图像视图</span></span><br><span class="line"></span><br><span class="line">给这个图像视图创建一个新的文件。</span><br><span class="line"></span><br><span class="line">单击<span class="keyword">*</span><span class="keyword">*</span>File\New\File…<span class="keyword">*</span><span class="keyword">*</span> ,并且选择 <span class="keyword">*</span><span class="keyword">*</span>Cocoa Touch Class<span class="keyword">*</span><span class="keyword">*</span> 模版，单击Next，并且将类命名为<span class="keyword">*</span><span class="keyword">*</span>MedalView<span class="keyword">*</span><span class="keyword">*</span>，父类为<span class="keyword">*</span><span class="keyword">*</span>UIImageView<span class="keyword">*</span><span class="keyword">*</span>，然后点击Next，点击Creat</span><br><span class="line"></span><br><span class="line">进入<span class="keyword">*</span><span class="keyword">*</span>Main.storyboard<span class="keyword">*</span><span class="keyword">*</span>，把<span class="keyword">*</span><span class="keyword">*</span>UIImageView<span class="keyword">*</span><span class="keyword">*</span> 添加为<span class="keyword">*</span><span class="keyword">*</span>Counter View<span class="keyword">*</span><span class="keyword">*</span>的一个子视图。然后选择UIImageView，在<span class="keyword">*</span><span class="keyword">*</span>Identity Inspector<span class="keyword">*</span><span class="keyword">*</span>把类改为 <span class="keyword">*</span><span class="keyword">*</span>MedalView<span class="keyword">*</span><span class="keyword">*</span>。</span><br><span class="line"></span><br><span class="line">![](http://cdn5.raywenderlich.com/wp-content/uploads/2014/12/3-MedalViewClass.png)</span><br><span class="line"></span><br><span class="line">在<span class="keyword">*</span><span class="keyword">*</span>Size Inspector<span class="keyword">*</span><span class="keyword">*</span>给视图设置坐标为x=76,y=147,宽度为80,高度为80：</span><br><span class="line"></span><br><span class="line">![](http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/3-MedalViewCoordinates.png)</span><br><span class="line"></span><br><span class="line">在<span class="keyword">*</span><span class="keyword">*</span>Attributes Inspector<span class="keyword">*</span><span class="keyword">*</span>中改变<span class="keyword">*</span><span class="keyword">*</span>Image Mode<span class="keyword">*</span><span class="keyword">*</span>为<span class="keyword">*</span><span class="keyword">*</span>Aspect Fit<span class="keyword">*</span><span class="keyword">*</span>，这样图像可以自动调整大小适应视图。</span><br><span class="line"></span><br><span class="line">![](http://cdn4.raywenderlich.com/wp-content/uploads/2014/12/3-MedalAspectFit.png)</span><br><span class="line"></span><br><span class="line">去medalview.swift并添加一个方法用来创建奖章：</span><br></pre></td></tr></table></figure></p>
<p>func createMedalImage() -&gt; UIImage {<br>  println(“creating Medal Image”)</p>
<p>}<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这会打印一句话，这样你就能直到图像什么时候被创建。</span><br><span class="line"></span><br><span class="line">进入<span class="keyword">*</span><span class="keyword">*</span>MedalDrawing<span class="keyword">*</span><span class="keyword">*</span> playground，复制整个代码除了开始的 import UIKit。</span><br><span class="line"></span><br><span class="line">返回<span class="keyword">*</span><span class="keyword">*</span>MedalView.swift<span class="keyword">*</span><span class="keyword">*</span>把playground中的代码黏贴到<span class="keyword">*</span><span class="keyword">*</span>createMedalImage()<span class="keyword">*</span><span class="keyword">*</span>中去。</span><br><span class="line"></span><br><span class="line">在<span class="keyword">*</span><span class="keyword">*</span>createMedalImage()<span class="keyword">*</span><span class="keyword">*</span>尾部添加：</span><br></pre></td></tr></table></figure></p>
<p>return image<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">应该会编译错误。</span><br><span class="line">在类的顶部添加一个属性来持有奖牌图像：</span><br></pre></td></tr></table></figure></p>
<p>lazy var medalImage:UIImage = self.createMedalImage()<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">添加一个方法去显示奖牌：</span><br></pre></td></tr></table></figure></p>
<p>func showMedal(show:Bool) {<br>  if show {<br>    image = medalImage<br>  } else {<br>    image = nil<br>  }<br>}<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在<span class="keyword">*</span><span class="keyword">*</span>ViewController.swift<span class="keyword">*</span><span class="keyword">*</span>类顶部添加一个外部应用：</span><br></pre></td></tr></table></figure></p>
<p>@IBOutlet weak var medalView: MedalView!<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">去Main.storyboard将new MedalView和这个外部引用相连。</span><br><span class="line"></span><br><span class="line">返回<span class="keyword">*</span><span class="keyword">*</span>ViewController.swift<span class="keyword">*</span><span class="keyword">*</span>并且添加这个方法：</span><br></pre></td></tr></table></figure></p>
<p>func checkTotal() {<br>  if counterView.counter &gt;= 8 {<br>    medalView.showMedal(true)<br>  } else {<br>    medalView.showMedal(false)<br>  }<br>}<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果你今天喝了足够的水，这个奖牌将显示。</span><br><span class="line"></span><br><span class="line">在<span class="keyword">*</span><span class="keyword">*</span>viewDidLoad()<span class="keyword">*</span><span class="keyword">*</span> 和 <span class="keyword">*</span><span class="keyword">*</span>btnPushButton(_:)<span class="keyword">*</span><span class="keyword">*</span>这两个方法的底部调用:</span><br></pre></td></tr></table></figure></p>
<p>checkTotal()<br>```</p>
<p>编译并运行应用，它应该像这样：</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2014/12/3-CompletedApp.png" alt=""></p>
<p>在调试控制台中，只有当计数器达到8时，你才会看到创建奖章的那句log，这是因为medalImage使用了一个延迟声明lazy declaration。</p>
<h2 id="Where_to_Go_From_Here?_何去何从">Where to Go From Here? 何去何从</h2><p>你已经在这部系列教程中走了很长的路。你应该已经掌握了Core Graphics的基本知识，创建图案和渐变还有转换context，最为重要的是，你学会了如何在app中融汇地使用它们。</p>
<p>在这<a href="http://cdn1.raywenderlich.com/wp-content/uploads/2015/02/Flo-Part3-6.31.zip" target="_blank" rel="external">Flo right here</a>下载完整的版本。这个版本还包括一些额外地数据和辐射渐变让按钮在被按下的时候能给用户一个更好的UI体验。</p>
<p>我希望在制作Flo时你乐在其中，并且你能只用Core Graphics和UIKit做一些惊叹漂亮的UI！如果你有任何问题，意见，或者你想讨论如何绘制一个奖杯，而不是一个奖章，请加入论坛讨论下。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Core_Graphics_教程第三部分(Swift)_-_Patterns_和_Playgrounds">Core Graphics 教程第三部分(Swift) - Patterns 和 Playgrounds</h2><blockquote>
<ul>
<li>原文链接：<a href="http://www.raywenderlich.com/90695/modern-core-graphics-with-swift-part-3">Core Graphics Tutorial Part 3: Patterns and Playgrounds</a></li>
<li>原文作者：<a href="http://www.raywenderlich.com/u/caroline"> Caroline Begbie </a></li>
<li>译文出自：<a href="www.devtf.cn">开发者前线</a></li>
<li>译者：<a href="https://github.com/MrLoong">MrLoong</a></li>
<li>校对者：<a href="https://github.com/samw00">samw00</a></li>
</ul>
</blockquote>
<p>欢迎回到Core Graphics 教学系列的第三也是最后一部分！Flo，你的water drinking tracking app将使用Core Graphics 进行最终的改进。</p>
<p>在<a href="http://www.raywenderlich.com/90690/modern-core-graphics-with-swift-part-1">第一部分</a>，你通过UIKit画了三个自定义形状的控件,<a href="http://www.raywenderlich.com/90693/modern-core-graphics-with-swift-part-2">在第二部分</a>你创建了一个视图用来显示用户在过去一周的喝水量，并且研究了transforming the context transformation matrix (CTM)</p>
<p>在这第三也是最后一部分，你将使<strong>Flo</strong>升级到它的最终形态，特别的是你将：</p>
<ul>
<li>创建一个重复的背景图案</li>
<li>为成功每天喝掉8杯水的用户从头到尾画一枚奖章</li>
</ul>
<p>如果你还没有这个项目的源代码，从本系列的第二部分下载<a href="http://cdn1.raywenderlich.com/wp-content/uploads/2015/02/Flo-Part2-6.3.zip"><strong>Flo工程</strong></a></p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/FinalApp-192x320.png" alt=""></p>]]>
    
    </summary>
    
      <category term="Core Graphics" scheme="http://ytlvy.com/tags/Core-Graphics/"/>
    
      <category term="Swift" scheme="http://ytlvy.com/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift Core Graphics Tutorial Part 2: Gradients and Contexts]]></title>
    <link href="http://ytlvy.com/2015/08/08/Swift-Core-Graphics-Tutorial-Part-2-Gradients-and-Contexts/"/>
    <id>http://ytlvy.com/2015/08/08/Swift-Core-Graphics-Tutorial-Part-2-Gradients-and-Contexts/</id>
    <published>2015-08-08T13:19:24.000Z</published>
    <updated>2015-08-08T13:20:10.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Core_Graphics教程第二部分(Swift)_-_Gradients_与_Context">Core Graphics教程第二部分(Swift) - Gradients 与 Context</h2><blockquote>
<ul>
<li>原文链接 : <a href="http://www.raywenderlich.com/90693/modern-core-graphics-with-swift-part-2" target="_blank" rel="external">Core Graphics Tutorial Part 2: Gradients and Contexts</a></li>
<li>原文作者 : <a href="http://www.raywenderlich.com/u/caroline" target="_blank" rel="external">caroline</a></li>
<li>译文出自 :  <a href="http://www.devtf.cn" target="_blank" rel="external">开发技术前线</a></li>
<li>译者 : <a href="https://github.com/mrchenhao" target="_blank" rel="external">HarriesChen</a> </li>
<li>校对者: <a href="https://github.com/mrchenhao" target="_blank" rel="external">HarriesChen</a></li>
</ul>
</blockquote>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/FinalApp-192x320.png" alt="FinalApp"></p>
<p><em>更新时间  04/15/2015</em> 为Xcode 6.3 和 Swift1.2更新</p>
<p>欢迎回到我们的Swift核心绘图教程系列！</p>
<p>在<a href="http://www.raywenderlich.com/?p=90690" target="_blank" rel="external">第一部分</a>中,你学习到了使用storyboard绘制线条和矩形.</p>
<p>在第二部部分中，你将深入核心绘图，使用CGContext实现渐变效果</p>
<h2 id="核心绘图">核心绘图</h2><p>你现在已经从简单的UIKit深入到核心绘图。</p>
<p>下图是各个框架的关系图：</p>
<p><a href="http://cdn2.raywenderlich.com/wp-content/uploads/2014/12/2-Architecture.png" target="_blank" rel="external"><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/2-Architecture-433x320.png" alt="2-Architecture"></a></p>
<p>UIKit是在最顶层，使用最友好的框架。你使用过UIBezierPath的就是在UIKit层中对Core Graphics层中CGPath的封装。</p>
<p>你可以看到 Core Graphics 的对象和方法都是CG开头的，非常容易辨认。</p>
<p>另外CG方法都是C方法，在调用的时候不需要明确的指定参数名，和一般Swift调用方法不一样。</p>
<h2 id="从Graph_View开始">从Graph View开始</h2><a id="more"></a>
<p>本次的目标就是使用历史数据创建一个图表。</p>
<p><a href="http://cdn2.raywenderlich.com/wp-content/uploads/2014/12/2-ResultGraphView.png" target="_blank" rel="external"><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/12/2-ResultGraphView-383x320.png" alt="2-ResultGraphView"></a></p>
<p>在绘图之前，你需要创建一个storyboard，写一些显示图表的代码。</p>
<p>完成后的视图结构如下图：</p>
<p><a href="http://cdn2.raywenderlich.com/wp-content/uploads/2014/12/2-ViewHierarchy.png" target="_blank" rel="external"><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/12/2-ViewHierarchy-547x500.png" alt="2-ViewHierarchy"></a></p>
<p>如果你还没有完成，从<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2015/02/Flo-Part1-6.31.zip" target="_blank" rel="external">这里</a>下载开始的项目。</p>
<p>打开 <em>File\New\File…</em>, 选择 <em>iOS\Source\Cocoa Touch Class</em><br>模板然后点击 <em>Next</em>. 输入名称 <em>GraphView</em>,选择成为 <em>UIView</em> 的子类，选择语言 <em>Swift</em>。 点击 <em>Next</em> 和 <em>Create</em>.</p>
<p>打开 <em>Main.storyboard</em> 拖一个 <em>UIView</em> 到控制器的视图。</p>
<p>视图将包含一个<code>Graph</code>和<code>Counter Views</code>，确定他们是视图控制器的主视图的子视图，并且<code>Graph</code>在<code>Counter Views</code>之上。</p>
<p>此时目录结构应该是这样的：</p>
<p><a href="http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/2-DocumentOutline.png" target="_blank" rel="external"><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/2-DocumentOutline.png" alt="2-DocumentOutline"></a></p>
<p>在 <em>Size Inspector</em>, 设置 <em>X</em>=<em>150</em>, <em>Y</em>=<em>50</em>, <em>Width</em>=<em>300</em>,<br><em>Height</em>=<em>300</em>:</p>
<p><a href="http://cdn5.raywenderlich.com/wp-content/uploads/2014/12/2-ContainerCoordinates.png" target="_blank" rel="external"><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/12/2-ContainerCoordinates.png" alt="2-ContainerCoordinates"></a></p>
<p>创建自动布局约束非常简单，在第一部分中有讲到。</p>
<ul>
<li>选中视图, 按住Control轻轻的向左拖动，在弹出的菜单中选择<em>Width</em>.</li>
<li>选中视图, 按住Control轻轻的向上拖动，在弹出的菜单中选择<em>Height</em>.</li>
<li>选中视图, 按住Control从里向外拖动，在弹出的菜单中选择 <em>Center Vertically in Container</em>.</li>
<li>选中视图, 按住Control从里向外拖动，在弹出的菜单中选择 <em>Center Horizontally in Container</em>.</li>
</ul>
<p>当创建了视图，通常我们我们会设置一个临时的背景颜色，这样做非常有用，可以让我们清楚的看到我们做了什么。</p>
<p>在 <em>Attributes Inspector</em>, 将背景颜色设置为黄色.</p>
<p><a href="http://cdn4.raywenderlich.com/wp-content/uploads/2014/12/2-ContainerViewBackground.png" target="_blank" rel="external"><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/12/2-ContainerViewBackground.png" alt="2-ContainerViewBackground"></a></p>
<p>再拖一个 <em>UIView</em> 到黄色的视图作为它的子视图.</p>
<p>在 <em>Identity Inspector</em>, 将新创建的视图的class设置为<em>GraphView</em>.</p>
<p><a href="http://cdn5.raywenderlich.com/wp-content/uploads/2014/12/2-GraphViewClass.png" target="_blank" rel="external"><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/12/2-GraphViewClass.png" alt="2-GraphViewClass"></a></p>
<p>在 <em>Size Inspector</em>, 设置 <em>X</em>=<em>0</em>, <em>Y</em>=<em>25</em>, <em>Width</em>=<em>300</em>,<br><em>Height</em>=<em>250</em>:</p>
<p><a href="http://cdn4.raywenderlich.com/wp-content/uploads/2014/12/2-GraphViewCoordinates.png" target="_blank" rel="external"><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/12/2-GraphViewCoordinates.png" alt="2-GraphViewCoordinates"></a></p>
<p>在<em>Document Outline</em>，将 <em>Counter View</em>拖到黄色的视图中作为它的子视图，这里需要注意需要放置在<em>Graph View</em>的后方。</p>
<p>在移动 <em>Counter View</em>之后, 自动布局约束会变红. 选择 <em>Counter View</em>, 在storyboard 右下方找到并点击 <em>Resolve Auto Layout Issues</em>, 选择<br><em>Selected Views: Clear Constraints</em>.</p>
<p><a href="http://cdn2.raywenderlich.com/wp-content/uploads/2014/12/2-ClearAutoLayout.png" target="_blank" rel="external"><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2014/12/2-ClearAutoLayout.png" alt="2-ClearAutoLayout"></a></p>
<p>你可以重置为默认的约束，因为现在<code>Counter View</code>充满了整个<code>Container View</code></p>
<p>在 <em>Document Outline</em> 双击黄色视图来重命名为 <em>Container View</em>. 现在 <em>Document Outline</em> 是这样子的:</p>
<p><a href="http://cdn4.raywenderlich.com/wp-content/uploads/2014/12/Flo2-Outline.png" target="_blank" rel="external"><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/Flo2-Outline-303x320.png" alt="Flo2-Outline"></a></p>
<p>你需要一个<code>Container View</code>是因为在 <code>Counter View</code> 和 <code>Graph View</code>的渐变动画中需要用到。</p>
<p>打开 <em>ViewController.swift</em> ,为<code>Container</code> 和 <code>Graph Views</code> 添加<code>outloets</code>:</p>
 <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"> @IBOutlet weak var containerView: UIView!                                </span><br><span class="line"> @IBOutlet weak var graphView: GraphView!                                 </span><br><span class="line"> <span class="code">```</span>                                                                      </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这一步为<span class="code">`container view`</span> 和 <span class="code">`graph view`</span>创建outlet，现在我们将他们和<span class="code">`storyboard`</span>的视图关联起来。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">打开 <span class="emphasis">*Main.storyboard*</span>， 将 <span class="emphasis">*Graph View*</span> <span class="emphasis">*Container View*</span> 和 outlets关联起来:</span><br><span class="line"></span><br><span class="line">![<span class="link_label">Flo2-ConnectGraphViewOutlet</span>](<span class="link_url">http://cdn4.raywenderlich.com/wp-content/uploads/2014/12/Flo2-ConnectGraphViewOutlet.gif</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="header">设置渐变动画</span><br><span class="line">----------</span></span><br><span class="line"></span><br><span class="line">仍然在 <span class="emphasis">*Main.storyboard*</span>中, 从<span class="emphasis">*Object Library*</span> 拖一个<span class="emphasis">*UITapGestureRecognizer*</span> 到 <span class="emphasis">*Container View*</span>:</span><br><span class="line"></span><br><span class="line">![<span class="link_label">Flo2-AddTapGesture</span>](<span class="link_url">http://cdn5.raywenderlich.com/wp-content/uploads/2014/12/Flo2-AddTapGesture.gif</span>)</span><br><span class="line"></span><br><span class="line">打开 <span class="emphasis">*ViewController.swift*</span> 在开头添加属性：</span><br><span class="line"></span><br><span class="line"> <span class="code">```</span>                               </span><br><span class="line"> var isGraphViewShowing = false                                           </span><br><span class="line"> <span class="code">```</span>                                                                      </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这个将简单的标记用于判断当前<span class="code">`graph view`</span>是否正在显示；</span><br><span class="line"></span><br><span class="line">为点击事件添加过渡效果的方法：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="code">```</span>                               </span><br><span class="line"> @IBAction func counterViewTap(gesture:UITapGestureRecognizer?) &#123;         </span><br><span class="line">   if (isGraphViewShowing) &#123;                                              </span><br><span class="line">                                                                          </span><br><span class="line"><span class="code">     //hide Graph                                                         </span></span><br><span class="line"><span class="code">     UIView.transitionFromView(graphView,                                 </span></span><br><span class="line"><span class="code">         toView: counterView,                                             </span></span><br><span class="line"><span class="code">         duration: 1.0,                                                   </span></span><br><span class="line"><span class="code">         options: UIViewAnimationOptions.TransitionFlipFromLeft           </span></span><br><span class="line"><span class="code">            UIViewAnimationOptions.ShowHideTransitionViews,              </span></span><br><span class="line"><span class="code">         completion:nil)                                                  </span></span><br><span class="line">   &#125; else &#123;                                                               </span><br><span class="line">                                                                          </span><br><span class="line"><span class="code">     //show Graph                                                         </span></span><br><span class="line"><span class="code">     UIView.transitionFromView(counterView,                               </span></span><br><span class="line"><span class="code">       toView: graphView,                                                 </span></span><br><span class="line"><span class="code">       duration: 1.0,                                                     </span></span><br><span class="line"><span class="code">       options: UIViewAnimationOptions.TransitionFlipFromRight            </span></span><br><span class="line"><span class="code">          UIViewAnimationOptions.ShowHideTransitionViews,                </span></span><br><span class="line"><span class="code">       completion: nil)                                                   </span></span><br><span class="line">   &#125;                                                                      </span><br><span class="line">   isGraphViewShowing = !isGraphViewShowing                               </span><br><span class="line"> &#125;                                                                        </span><br><span class="line"> <span class="code">```</span>                                                                      </span><br><span class="line"></span><br><span class="line"><span class="code">`UIView.transitionFromView(_:toView:duration:options:completion:)`</span></span><br><span class="line">设置了一个水平翻动的效果. 另外还有扩散，溶解，竖直翻动，弯曲和下降等效果。 过渡效果使用<span class="emphasis">*ShowHideTransitionViews*</span> 系数, 你不必通过移除视图来使它消失。</span><br><span class="line"></span><br><span class="line">在<span class="emphasis">*btnPushButton(\_:)*</span>的最后添加以下代码：</span><br><span class="line"></span><br><span class="line"> <span class="code">```</span>                               </span><br><span class="line"> if isGraphViewShowing &#123;                                                  </span><br><span class="line">   counterViewTap(nil)                                                    </span><br><span class="line"> &#125;                                                                        </span><br><span class="line"> <span class="code">```</span>                                                                      </span><br><span class="line"></span><br><span class="line">这是为了防止在图标正在显示的过程中点击，将闪回计数器视图。</span><br><span class="line"></span><br><span class="line">最后，为了让这个效果生效，打开 <span class="emphasis">*Main.storyboard*</span>，将点击手势与<span class="code">`counterViewTap(gesture:)`</span>关联起来。</span><br><span class="line"></span><br><span class="line">![<span class="link_label">Flo2-TapGestureConnection</span>](<span class="link_url">http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/Flo2-TapGestureConnection.gif</span>)</span><br><span class="line"></span><br><span class="line">构建并运行程序，你可以看到<span class="code">` graph view `</span>在你打开程序的时候。点击它，<span class="code">`graph view`</span>会消失，<span class="code">`counter view`</span>现实，中间有过渡动画。</span><br><span class="line"></span><br><span class="line">[<span class="link_label">![2-ViewTransition</span>](<span class="link_url">http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/2-ViewTransition-270x500.png</span>)](<span class="link_url">http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/2-ViewTransition.png</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="header">分析Graph View</span><br><span class="line">-------------</span></span><br><span class="line"></span><br><span class="line">[<span class="link_label">![2-AnalysisGraphView</span>](<span class="link_url">http://cdn4.raywenderlich.com/wp-content/uploads/2014/12/2-AnalysisGraphView-383x320.png</span>)](<span class="link_url">http://cdn2.raywenderlich.com/wp-content/uploads/2014/12/2-AnalysisGraphView.png</span>)</span><br><span class="line"></span><br><span class="line">还记得第一部分的绘图模型嘛？它描述了用Core Graphics绘图从里到外的过程，你需要明白这里的顺序在你写代码之前：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="bullet">1.  </span>渐变的背景</span><br><span class="line"><span class="bullet">2.  </span>在图表中进行裁剪</span><br><span class="line"><span class="bullet">3.  </span>折线</span><br><span class="line"><span class="bullet">4.  </span>折线点</span><br><span class="line"><span class="bullet">5.  </span>横线</span><br><span class="line"><span class="bullet">6.  </span>标签</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="header">绘制渐变</span><br><span class="line">------</span></span><br><span class="line"></span><br><span class="line">现在我们在<span class="code">`Graph View`</span> 的 <span class="code">`context`</span>中绘制渐变效果。</span><br><span class="line"></span><br><span class="line">打开 <span class="emphasis">*GraphView.swift*</span> 将里面带代码替换为以下:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="code">```</span>                               </span><br><span class="line"> import UIKit                                                             </span><br><span class="line">                                                                          </span><br><span class="line"> @IBDesignable class GraphView: UIView &#123;                                  </span><br><span class="line">                                                                          </span><br><span class="line">   //1 - the properties for the gradient                                  </span><br><span class="line">   @IBInspectable var startColor: UIColor = UIColor.redColor()            </span><br><span class="line">   @IBInspectable var endColor: UIColor = UIColor.greenColor()            </span><br><span class="line">                                                                          </span><br><span class="line"><span class="code">     override func drawRect(rect: CGRect) &#123;                               </span></span><br><span class="line">                                                                          </span><br><span class="line"><span class="code">       //2 - get the current context                                      </span></span><br><span class="line"><span class="code">       let context = UIGraphicsGetCurrentContext()                        </span></span><br><span class="line"><span class="code">       let colors = [startColor.CGColor, endColor.CGColor]                </span></span><br><span class="line">                                                                          </span><br><span class="line"><span class="code">       //3 - set up the color space                                       </span></span><br><span class="line"><span class="code">       let colorSpace = CGColorSpaceCreateDeviceRGB()                     </span></span><br><span class="line">                                                                          </span><br><span class="line"><span class="code">       //4 - set up the color stops                                       </span></span><br><span class="line"><span class="code">       let colorLocations:[CGFloat] = [0.0, 1.0]                          </span></span><br><span class="line">                                                                          </span><br><span class="line"><span class="code">       //5 - create the gradient                                          </span></span><br><span class="line"><span class="code">       let gradient = CGGradientCreateWithColors(colorSpace,              </span></span><br><span class="line"><span class="code">                                                 colors,                  </span></span><br><span class="line"><span class="code">                                                 colorLocations)          </span></span><br><span class="line">                                                                          </span><br><span class="line"><span class="code">       //6 - draw the gradient                                            </span></span><br><span class="line"><span class="code">       var startPoint = CGPoint.zeroPoint                                 </span></span><br><span class="line"><span class="code">       var endPoint = CGPoint(x:0, y:self.bounds.height)                  </span></span><br><span class="line"><span class="code">       CGContextDrawLinearGradient(context,                               </span></span><br><span class="line"><span class="code">                                   gradient,                              </span></span><br><span class="line"><span class="code">                                   startPoint,                            </span></span><br><span class="line"><span class="code">                                   endPoint,                              </span></span><br><span class="line"><span class="code">                                   0)                                     </span></span><br><span class="line"><span class="code">     &#125;                                                                    </span></span><br><span class="line"> &#125;                                                                        </span><br><span class="line"> <span class="code">```</span>                                                                      </span><br><span class="line"></span><br><span class="line">这里有以下步骤</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.  </span>将渐变的开始和结束颜色设置为<span class="code">`@IBInspectable`</span> 属性,这样就可以在storyboard中实时看到效果.</span><br><span class="line"><span class="bullet">2.  </span>CG 绘图方法需要知道他们在哪个上下文（context）中绘图，,调用 <span class="code">`UIGraphicsGetCurrentContext()`</span> 来获取当前上下文. 那就是 <span class="code">`drawRect(_:)`</span> 绘制的地方.</span><br><span class="line"><span class="bullet">3.  </span>所有的上下文都有一个色域. 可以是 CMYK 也可以是 grayscale,</span><br><span class="line"><span class="code">    这里使用的是RGB色域.</span></span><br><span class="line"><span class="bullet">4.  </span>颜色的起止描述了颜色的变化效果. 在这个例子中, 你只有两种颜色，从红到绿,</span><br><span class="line"><span class="code">    你也可以又一个数组的颜色变化, 颜色从红到蓝在到绿. 每种颜色的起止都是0.33.</span></span><br><span class="line"><span class="bullet">5.  </span>创建渐变效果，定义色域，颜色起止。</span><br><span class="line"><span class="bullet">6.  </span>最后，绘制渐变效果通过方法<span class="code">`CGContextDrawLinearGradient()`</span></span><br><span class="line"><span class="code">    有以下几个参数:</span></span><br><span class="line"><span class="code">    -   `CGContext`表示在哪个上下文</span></span><br><span class="line"><span class="code">    -   `CGGradient` 色域，颜色起止。</span></span><br><span class="line"><span class="code">    -   开始点</span></span><br><span class="line"><span class="code">    -   结束点</span></span><br><span class="line"><span class="code">    -   其他延伸选项</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">通过<span class="code">`drawRect(_:)`</span>渐变效果将充满整个<span class="code">`rect`</span>。</span><br><span class="line"></span><br><span class="line">在Xcode你通过设置代码或者在storyboard的<span class="emphasis">*Assistant Editor*</span>调节，可以直接在<span class="code">`Graph View`</span>看到效果。</span><br><span class="line"></span><br><span class="line">![<span class="link_label">2-InitialGradient</span>](<span class="link_url">http://cdn4.raywenderlich.com/wp-content/uploads/2014/12/2-InitialGradient1.png</span>)</span><br><span class="line"></span><br><span class="line">在storyboard中, 选择 <span class="code">`Graph View`</span>. 在 *Attributes</span><br><span class="line">Inspector<span class="emphasis">*设置 *</span>Start Color<span class="bullet">* 为 RGB(250, 233, 222), 设置 *</span>End Color* 为RGB(252, 79, 8):</span><br><span class="line"></span><br><span class="line">[<span class="link_label">![2-FirstGradient</span>](<span class="link_url">http://cdn1.raywenderlich.com/wp-content/uploads/2014/12/2-FirstGradient.png</span>)](<span class="link_url">http://cdn1.raywenderlich.com/wp-content/uploads/2014/12/2-FirstGradient.png</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在 <span class="emphasis">*Main.storyboard*</span>, 一次选择所有的视图,除了控制器自带的,将他们的<span class="emphasis">*BackgroundColor*</span> 设置为clear color. 现在已经不需要黄色背景了,同样将按钮的背景颜色设置为透明.</span><br><span class="line"></span><br><span class="line">运行程序，你会发现现在变得好看很多。</span><br><span class="line"></span><br><span class="line"><span class="header">裁剪区域</span><br><span class="line">------</span></span><br><span class="line"></span><br><span class="line">你刚才用渐变填充了整个上下文的区域。现在你可以创建路径来裁剪当前的绘图区域。</span><br><span class="line"></span><br><span class="line">打开<span class="emphasis">*GraphView.swift*</span>, 在<span class="code">`drawRect(_:)`</span>的顶部加入以下代码:</span><br><span class="line"></span><br><span class="line"> <span class="code">```</span>                               </span><br><span class="line"> let width = rect.width                                                   </span><br><span class="line"> let height = rect.height                                                 </span><br><span class="line">                                                                          </span><br><span class="line"> //set up background clipping area                                        </span><br><span class="line"> var path = UIBezierPath(roundedRect: rect,                               </span><br><span class="line"><span class="code">     byRoundingCorners: UIRectCorner.AllCorners,                          </span></span><br><span class="line"><span class="code">     cornerRadii: CGSize(width: 8.0, height: 8.0))                        </span></span><br><span class="line"> path.addClip()</span><br></pre></td></tr></table></figure>
<p>这个将创建一个裁剪区域来限制渐变效果，你可以用相同的方式绘制渐变效果在在折线上。</p>
<p>构建运行程序，你会发现有漂亮的圆角效果：</p>
<p><a href="http://cdn1.raywenderlich.com/wp-content/uploads/2014/12/2-RoundedCorners2.png" target="_blank" rel="external"><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/12/2-RoundedCorners2.png" alt="2-RoundedCorners2"></a></p>
<p><em>注意:</em> 绘制静态的图像使用<code>Core Graphics</code>是绰绰有余的，但是当你的图像需要频繁的重绘时，你应当使用<code>Core Animation layers</code>，它充分利用了GPU而不是CPU。CPU是通过调用 <code>drawRect(_:)</code>绘制的。</p>
<p>除了使用裁剪路径，你还可以通过使用CALayer的<code>cornerRadius</code>属性来创建圆角，但是你需要优化。为了更好的理解，可以参考Mikael Konutgan and Sam Davies写的<a href="http://www.raywenderlich.com/82058/custom-control-tutorial-ios-swift-reusable-knob" target="_blank" rel="external">Custom Control Tutorial for iOS and Swift: A Reusable<br>Knob</a>，使用<code>Core Animation</code>来创建自定义控件。</p>
<h2 id="计算坐标点">计算坐标点</h2><p>现在可以短暂了停一下画图，我们需要绘制7个点，横坐标为一周的七天，纵坐标为</p>
<p>首先, 设置几个简单的值。</p>
<p>在 <em>GraphView.swift</em>, 在顶部添加属性:</p>
 <figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Weekly sample data                                                     </span></span><br><span class="line"> var graphPoints:[Int] = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>]                            </span><br><span class="line"> ```                                                                      </span><br><span class="line"></span><br><span class="line">这里简单的数据代表了七天的数据。</span><br><span class="line"></span><br><span class="line">接着，在`drawRect<span class="params">(_:)</span>`的最后添加代码：</span><br><span class="line"></span><br><span class="line"> ```                               </span><br><span class="line"> <span class="comment">//calculate the x point                                                  </span></span><br><span class="line">                                                                          </span><br><span class="line"> <span class="built_in">let</span> margin:CGFloat = <span class="number">20.0</span>                                                </span><br><span class="line"> var columnXPoint = &#123; <span class="params">(column:Int)</span> -&gt; CGFloat in                          </span><br><span class="line">   <span class="comment">//Calculate gap between points                                         </span></span><br><span class="line">   <span class="built_in">let</span> spacer = <span class="params">(width - margin*<span class="number">2</span> - <span class="number">4</span>)</span> /                                  </span><br><span class="line">         CGFloat<span class="params">(<span class="params">(self.graphPoints.count - <span class="number">1</span>)</span>)</span>                            </span><br><span class="line">   var x:CGFloat = CGFloat<span class="params">(column)</span> <span class="built_in">*</span> spacer                               </span><br><span class="line">   x += margin + <span class="number">2</span>                                                        </span><br><span class="line">   return x                                                               </span><br><span class="line"> &#125;                                                                        </span><br><span class="line"> ```                                                                      </span><br><span class="line"></span><br><span class="line">横坐标点包括了<span class="number">7</span>个等距离的点。上述代码在一个闭包表达式中，应该是要独立的封装成一个方法，但是对于这个小的运算量，是可以内嵌在代码之中。</span><br><span class="line"></span><br><span class="line">`columnXPoint` 接受 column作为参数, 返回点所在的横坐标的值.</span><br><span class="line"></span><br><span class="line">接着，在`drawRect<span class="params">(_:)</span>`的最后添加代码来计算纵坐标的点：</span><br><span class="line"></span><br><span class="line"> ```                               </span><br><span class="line"> <span class="comment">// calculate the y point                                                 </span></span><br><span class="line">                                                                          </span><br><span class="line"> <span class="built_in">let</span> topBorder:CGFloat = <span class="number">60</span>                                               </span><br><span class="line"> <span class="built_in">let</span> bottomBorder:CGFloat = <span class="number">50</span>                                            </span><br><span class="line"> <span class="built_in">let</span> graphHeight = height - topBorder - bottomBorder                      </span><br><span class="line"> <span class="built_in">let</span> maxValue = maxElement<span class="params">(graphPoints)</span>                                   </span><br><span class="line"> var columnYPoint = &#123; <span class="params">(graphPoint:Int)</span> -&gt; CGFloat in                      </span><br><span class="line">   var y:CGFloat = CGFloat<span class="params">(graphPoint)</span> /                                  </span><br><span class="line">           CGFloat<span class="params">(maxValue)</span> <span class="built_in">*</span> graphHeight                                </span><br><span class="line">   y = graphHeight + topBorder - y <span class="comment">// Flip the graph                      </span></span><br><span class="line">   return y                                                               </span><br><span class="line"> &#125;                                                                        </span><br><span class="line"> ```                                                                      </span><br><span class="line"></span><br><span class="line">`columnYPoint` 同样的也在一个闭包表达式中，将数组中得每一天作为参数.返回纵坐标的位置, 在<span class="number">0</span>和最大饮水量之间.</span><br><span class="line"></span><br><span class="line">因为起始点为左上角，但是你是从左下角开始绘制， `columnYPoint`会调整它的返回值来朝向你期望的地方。</span><br><span class="line"></span><br><span class="line">继续在`drawRect<span class="params">(_:)</span>`的底部添加以下代码：</span><br><span class="line"></span><br><span class="line"> ```                               </span><br><span class="line"> <span class="comment">// draw the line graph                                                   </span></span><br><span class="line">                                                                          </span><br><span class="line"> UIColor.whiteColor<span class="params">()</span>.setFill<span class="params">()</span>                                           </span><br><span class="line"> UIColor.whiteColor<span class="params">()</span>.setStroke<span class="params">()</span>                                         </span><br><span class="line">                                                                          </span><br><span class="line"> <span class="comment">//set up the points line                                                 </span></span><br><span class="line"> var graphPath = UIBezierPath<span class="params">()</span>                                           </span><br><span class="line"> <span class="comment">//go to start of line                                                    </span></span><br><span class="line"> graphPath.moveToPoint<span class="params">(CGPoint<span class="params">(x:columnXPoint<span class="params">(<span class="number">0</span>)</span>,                         </span><br><span class="line">                               y:columnYPoint<span class="params">(graphPoints[<span class="number">0</span>])</span>)</span>)</span>           </span><br><span class="line">                                                                          </span><br><span class="line"> <span class="comment">//add points for each item in the graphPoints array                      </span></span><br><span class="line"> <span class="comment">//at the correct (x, y) for the point                                    </span></span><br><span class="line"> <span class="keyword">for</span> i in <span class="number">1</span>..&lt;graphPoints.count &#123;                                         </span><br><span class="line">   <span class="built_in">let</span> nextPoint = CGPoint<span class="params">(x:columnXPoint<span class="params">(i)</span>,                             </span><br><span class="line">                           y:columnYPoint<span class="params">(graphPoints[i])</span>)</span>                </span><br><span class="line">   graphPath.addLineToPoint<span class="params">(nextPoint)</span>                                    </span><br><span class="line"> &#125;                                                                        </span><br><span class="line">                                                                          </span><br><span class="line"> graphPath.stroke<span class="params">()</span>                                                       </span><br><span class="line"> ```                                                                      </span><br><span class="line"></span><br><span class="line">在这个代码快中，你创建了图标的路径， `UIBezierPath`用来连接`graphPoints`种的每一个点。</span><br><span class="line"></span><br><span class="line">现在，storyboard中的图标看起来是这样的：</span><br><span class="line"></span><br><span class="line">[<span class="built_in">!</span>[<span class="number">2</span>-FirstGraphLine]<span class="params">(http://cdn1.raywenderlich.com/wp-content/uploads/<span class="number">2014</span>/<span class="number">12</span>/<span class="number">2</span>-FirstGraphLine.png)</span>]<span class="params">(http://cdn1.raywenderlich.com/wp-content/uploads/<span class="number">2014</span>/<span class="number">12</span>/<span class="number">2</span>-FirstGraphLine.png)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">现在你验证了线已经正确绘制，从`drawRect<span class="params">(_:)</span>`移除最后一行代码</span><br><span class="line"></span><br><span class="line"> ```                               </span><br><span class="line"> graphPath.stroke<span class="params">()</span>                                                       </span><br><span class="line"> ```                                                                      </span><br><span class="line"></span><br><span class="line">这行代码让你检查线在`storyboard `是否被正确的绘制，点是否计算正确.</span><br><span class="line"></span><br><span class="line"><span class="built_in">#</span><span class="built_in">#</span><span class="built_in">#</span> 图表渐变</span><br><span class="line"></span><br><span class="line">现在在这个折线的路径之下来绘制渐变效果.</span><br><span class="line"></span><br><span class="line">首先设置裁剪路径在`drawRect<span class="params">(_:)</span>`的最下方:</span><br><span class="line"></span><br><span class="line"> ```                               </span><br><span class="line"> <span class="comment">//Create the clipping path for the graph gradient                        </span></span><br><span class="line">                                                                          </span><br><span class="line"> <span class="comment">//1 - save the state of the context (commented out for now)              </span></span><br><span class="line"> <span class="comment">//CGContextSaveGState(context)                                           </span></span><br><span class="line">                                                                          </span><br><span class="line"> <span class="comment">//2 - make a copy of the path                                            </span></span><br><span class="line"> var clippingPath = graphPath.copy<span class="params">()</span> as<span class="built_in">!</span> UIBezierPath                     </span><br><span class="line">                                                                          </span><br><span class="line"> <span class="comment">//3 - add lines to the copied path to complete the clip area             </span></span><br><span class="line"> clippingPath.addLineToPoint<span class="params">(CGPoint<span class="params">(                                     </span><br><span class="line">        x: columnXPoint<span class="params">(graphPoints.count - <span class="number">1</span>)</span>,                           </span><br><span class="line">        y:height)</span>)</span>                                                        </span><br><span class="line"> clippingPath.addLineToPoint<span class="params">(CGPoint<span class="params">(                                     </span><br><span class="line">        x:columnXPoint<span class="params">(<span class="number">0</span>)</span>,                                                </span><br><span class="line">        y:height)</span>)</span>                                                        </span><br><span class="line"> clippingPath.closePath<span class="params">()</span>                                                 </span><br><span class="line">                                                                          </span><br><span class="line"> <span class="comment">//4 - add the clipping path to the context                               </span></span><br><span class="line"> clippingPath.addClip<span class="params">()</span>                                                   </span><br><span class="line">                                                                          </span><br><span class="line"> <span class="comment">//5 - check clipping path - temporary code                               </span></span><br><span class="line"> UIColor.greenColor<span class="params">()</span>.setFill<span class="params">()</span>                                           </span><br><span class="line"> <span class="built_in">let</span> rectPath = UIBezierPath<span class="params">(rect: self.bounds)</span>                           </span><br><span class="line"> rectPath.fill<span class="params">()</span>                                                          </span><br><span class="line"> <span class="comment">//end temporary code                                                     </span></span><br><span class="line"> ```                                                                      </span><br><span class="line"></span><br><span class="line">通过上述代码让块于块之间分割：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>.  `CGContextSaveGState` 现在先不讨论`CGContextSaveGState`，一会来说它是干嘛的。</span><br><span class="line"><span class="number">2</span>.  复制一个新的路径来定义需要被填充的区域.</span><br><span class="line"><span class="number">3</span>.  完成区域的角点并关闭路径。这增加了右下和左下的点.</span><br><span class="line"><span class="number">4</span>.  添加裁剪区域，当上下文被填充时，只有被裁减的区域会被填充。</span><br><span class="line"><span class="number">5</span>.  填充上下文. 记住 `rect`就是上下文传递给`drawRect<span class="params">(_:)</span>`被填充的区域。</span><br><span class="line"></span><br><span class="line">现在storyboard中的图标看起来应该是这样的：</span><br><span class="line"></span><br><span class="line">[<span class="built_in">!</span>[<span class="number">2</span>-GraphClipping]<span class="params">(http://cdn5.raywenderlich.com/wp-content/uploads/<span class="number">2014</span>/<span class="number">12</span>/<span class="number">2</span>-GraphClipping.png)</span>]<span class="params">(http://cdn5.raywenderlich.com/wp-content/uploads/<span class="number">2014</span>/<span class="number">12</span>/<span class="number">2</span>-GraphClipping.png)</span></span><br><span class="line"></span><br><span class="line">下一步，你会将可爱的绿色换成你为背景创建的渐变的效果</span><br><span class="line"></span><br><span class="line">移除`drawRect<span class="params">(_:)</span>`底部填充绿色的临时代码，换成以下代码：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> ```                               </span><br><span class="line"> <span class="built_in">let</span> highestYPoint = columnYPoint<span class="params">(maxValue)</span>                               </span><br><span class="line"> startPoint = CGPoint<span class="params">(x:margin, y: highestYPoint)</span>                         </span><br><span class="line"> endPoint = CGPoint<span class="params">(x:margin, y:self.bounds.height)</span>                       </span><br><span class="line">                                                                          </span><br><span class="line"> CGContextDrawLinearGradient<span class="params">(context, gradient, startPoint, endPoint, <span class="number">0</span>)</span>  </span><br><span class="line"> <span class="comment">//CGContextRestoreGState(context)                                        </span></span><br><span class="line"> ```                                                                      </span><br><span class="line"></span><br><span class="line">在这里，你将找到最大的数字作为渐变的起点。</span><br><span class="line"></span><br><span class="line">You can’t fill the whole `rect` the same way you did with the green</span><br><span class="line"><span class="built_in">color</span>. The gradient would fill from the top of the context instead of</span><br><span class="line">from the top of the graph, and the desired gradient wouldn’t show up.</span><br><span class="line"></span><br><span class="line">你不能填充这个`rect`就像填充绿色一样，渐变会从上下问得顶部而不是图标的顶部开始进行渐变。</span><br><span class="line"></span><br><span class="line">注意<span class="built_in">*</span>CGContextRestoreState<span class="built_in">*</span>的注释，你在绘制之后需要取消注释。</span><br><span class="line"></span><br><span class="line">在 `drawRect<span class="params">(_:)</span>`之后添加代码：</span><br><span class="line"></span><br><span class="line"> ```                               </span><br><span class="line"> <span class="comment">//draw the line on top of the clipped gradient                           </span></span><br><span class="line"> graphPath.lineWidth = <span class="number">2.0</span>                                                </span><br><span class="line"> graphPath.stroke<span class="params">()</span>                                                       </span><br><span class="line"> ```                                                                      </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这里绘制了原始的路径</span><br><span class="line"></span><br><span class="line">现在图标看起来是这样的：</span><br><span class="line"></span><br><span class="line">[<span class="built_in">!</span>[<span class="number">2</span>-SecondGraphLine]<span class="params">(http://cdn5.raywenderlich.com/wp-content/uploads/<span class="number">2014</span>/<span class="number">12</span>/<span class="number">2</span>-SecondGraphLine.png)</span>]<span class="params">(http://cdn5.raywenderlich.com/wp-content/uploads/<span class="number">2014</span>/<span class="number">12</span>/<span class="number">2</span>-SecondGraphLine.png)</span></span><br><span class="line"></span><br><span class="line">在`drawRect<span class="params">(_:)</span>`的底部添加:</span><br><span class="line"></span><br><span class="line"> ```                               </span><br><span class="line"> <span class="comment">//Draw the circles on top of graph stroke                                </span></span><br><span class="line"> <span class="keyword">for</span> i in <span class="number">0</span>..&lt;graphPoints.count &#123;                                         </span><br><span class="line">   var point = CGPoint<span class="params">(x:columnXPoint<span class="params">(i)</span>, y:columnYPoint<span class="params">(graphPoints[i])</span>)</span> </span><br><span class="line">   point.x -= <span class="number">5.0</span>/<span class="number">2</span>                                                       </span><br><span class="line">   point.y -= <span class="number">5.0</span>/<span class="number">2</span>                                                       </span><br><span class="line">                                                                          </span><br><span class="line">   <span class="built_in">let</span> <span class="built_in">circle</span> = UIBezierPath<span class="params">(ovalInRect:                                  </span><br><span class="line">                CGRect<span class="params">(origin: point,                                     </span><br><span class="line">                         size: CGSize<span class="params">(width: <span class="number">5.0</span>, height: <span class="number">5.0</span>)</span>)</span>)</span>          </span><br><span class="line">   <span class="built_in">circle</span>.fill<span class="params">()</span>                                                          </span><br><span class="line"> &#125;                                                                        </span><br><span class="line"> ```                                                                      </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">绘制小圆点的代码并不是新的。这里将为每一个数组中的元素的位置绘制一个圆点。</span><br><span class="line"></span><br><span class="line">[<span class="built_in">!</span>[<span class="number">2</span>-GraphWithFlatCircles]<span class="params">(http://cdn2.raywenderlich.com/wp-content/uploads/<span class="number">2014</span>/<span class="number">12</span>/<span class="number">2</span>-GraphWithFlatCircles.png)</span>]<span class="params">(http://cdn2.raywenderlich.com/wp-content/uploads/<span class="number">2014</span>/<span class="number">12</span>/<span class="number">2</span>-GraphWithFlatCircles.png)</span></span><br><span class="line"></span><br><span class="line">现在为什么不好看呢，对了，小圆点。没事，我们一会加上去。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">上下文状态</span><br><span class="line">--------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">图形上下文可以保存状态。当你设置了许多上下文属性，如填充颜色，色域,变换矩阵，或裁剪区域，你实际上设置为当前图形状态。</span><br><span class="line"></span><br><span class="line">你可以使用`CGContextSaveGState<span class="params">()</span>`保存状态，这会就将当前状态的拷贝压进状态栈。你可以改变上下文的属性，但是当你调用`CGContextRestoreGState<span class="params">()</span>`原来的状态将会出栈，还原当前的状态。</span><br><span class="line"></span><br><span class="line">在 <span class="built_in">*</span>GraphView.swift<span class="built_in">*</span>的`drawRect<span class="params">(_:)</span>`方法中，注意`CGContextSaveGState<span class="params">()</span>` 发生在创建裁剪路径之前， `CGContextRestoreGState<span class="params">()</span>`发生在裁剪路径之后。</span><br><span class="line">这里我们做了一下几点：</span><br><span class="line"><span class="number">1</span>.  通过`CGContextSaveGState<span class="params">()</span>`将原始状态压入栈.</span><br><span class="line"><span class="number">2</span>.  添加裁剪路径到新的状态.</span><br><span class="line"><span class="number">3</span>.  在裁剪路径中绘图.</span><br><span class="line"><span class="number">4</span>.  通过`CGContextRestoreGState<span class="params">()</span>`还原状态，这是在添加裁剪路径前的状态。</span><br><span class="line"></span><br><span class="line">现在的图标和圆点看起来更加的清晰：</span><br><span class="line"></span><br><span class="line">[<span class="built_in">!</span>[<span class="number">2</span>-GraphWithCircles]<span class="params">(http://cdn1.raywenderlich.com/wp-content/uploads/<span class="number">2014</span>/<span class="number">12</span>/<span class="number">2</span>-GraphWithCircles.png)</span>]<span class="params">(http://cdn1.raywenderlich.com/wp-content/uploads/<span class="number">2014</span>/<span class="number">12</span>/<span class="number">2</span>-GraphWithCircles.png)</span></span><br><span class="line"></span><br><span class="line">在 `drawRect<span class="params">(_:)</span>`后添加代码来添加三条横线：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> ```                               </span><br><span class="line"> <span class="comment">//Draw horizontal graph lines on the top of everything                   </span></span><br><span class="line"> var linePath = UIBezierPath<span class="params">()</span>                                            </span><br><span class="line">                                                                          </span><br><span class="line"> <span class="comment">//top line                                                               </span></span><br><span class="line"> linePath.moveToPoint<span class="params">(CGPoint<span class="params">(x:margin, y: topBorder)</span>)</span>                    </span><br><span class="line"> linePath.addLineToPoint<span class="params">(CGPoint<span class="params">(x: width - margin,                       </span><br><span class="line">                                 y:topBorder)</span>)</span>                            </span><br><span class="line">                                                                          </span><br><span class="line"> <span class="comment">//center line                                                            </span></span><br><span class="line"> linePath.moveToPoint<span class="params">(CGPoint<span class="params">(x:margin,                                   </span><br><span class="line">                              y: graphHeight/<span class="number">2</span> + topBorder)</span>)</span>              </span><br><span class="line"> linePath.addLineToPoint<span class="params">(CGPoint<span class="params">(x:width - margin,                        </span><br><span class="line">                                 y:graphHeight/<span class="number">2</span> + topBorder)</span>)</span>            </span><br><span class="line">                                                                          </span><br><span class="line"> <span class="comment">//bottom line                                                            </span></span><br><span class="line"> linePath.moveToPoint<span class="params">(CGPoint<span class="params">(x:margin,                                   </span><br><span class="line">                              y:height - bottomBorder)</span>)</span>                   </span><br><span class="line"> linePath.addLineToPoint<span class="params">(CGPoint<span class="params">(x:width - margin,                        </span><br><span class="line">                                 y:height - bottomBorder)</span>)</span>                </span><br><span class="line"> <span class="built_in">let</span> <span class="built_in">color</span> = UIColor<span class="params">(white: <span class="number">1.0</span>, alpha: <span class="number">0.3</span>)</span>                              </span><br><span class="line"> <span class="built_in">color</span>.setStroke<span class="params">()</span>                                                        </span><br><span class="line">                                                                          </span><br><span class="line"> linePath.lineWidth = <span class="number">1.0</span>                                                 </span><br><span class="line"> linePath.stroke<span class="params">()</span>                                                        </span><br><span class="line"> ```                                                                      </span><br><span class="line"></span><br><span class="line">没有新的代码，你需要做的只是移动到一个点然后水平画线。</span><br><span class="line"></span><br><span class="line">[<span class="built_in">!</span>[<span class="number">2</span>-GraphWithAxisLines]<span class="params">(http://cdn5.raywenderlich.com/wp-content/uploads/<span class="number">2014</span>/<span class="number">12</span>/<span class="number">2</span>-GraphWithAxisLines.png)</span>]<span class="params">(http://cdn5.raywenderlich.com/wp-content/uploads/<span class="number">2014</span>/<span class="number">12</span>/<span class="number">2</span>-GraphWithAxisLines.png)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">添加图标的标签</span><br><span class="line">-----------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">现在你可以添加标签来让图标的用户体验更好。</span><br><span class="line">在<span class="built_in">*</span>ViewController.swift<span class="built_in">*</span>添加 outlets 属性：</span><br><span class="line"></span><br><span class="line"> ```                               </span><br><span class="line"> <span class="comment">//Label outlets                                                          </span></span><br><span class="line"> @IBOutlet weak var averageWaterDrunk: UILabel<span class="built_in">!</span>                           </span><br><span class="line"> @IBOutlet weak var maxLabel: UILabel<span class="built_in">!</span>                                    </span><br><span class="line"> ```                                                                      </span><br><span class="line"></span><br><span class="line">这两个标签将会动态的改变内容（饮水量的平均值和最大值）。</span><br><span class="line"></span><br><span class="line">在 <span class="built_in">*</span>Main.storyboard<span class="built_in">*</span> 添加以下的 <span class="built_in">*</span>UILabels<span class="built_in">*</span> 作为 <span class="built_in">*</span>Graph View<span class="built_in">*</span>的子视图:</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>.  <span class="built_in">*</span><span class="built_in">*</span>“Water Drunk”<span class="built_in">*</span><span class="built_in">*</span></span><br><span class="line"><span class="number">2</span>.  <span class="built_in">*</span><span class="built_in">*</span>“Average:”<span class="built_in">*</span><span class="built_in">*</span></span><br><span class="line"><span class="number">3</span>.  <span class="built_in">*</span><span class="built_in">*</span>“<span class="number">2</span>”<span class="built_in">*</span><span class="built_in">*</span> <span class="params">(平均饮水量)</span></span><br><span class="line"><span class="number">4</span>.  <span class="built_in">*</span><span class="built_in">*</span>“<span class="number">99</span>”<span class="built_in">*</span><span class="built_in">*</span> <span class="params">(最大饮水量)</span>. 右对齐</span><br><span class="line"><span class="number">5</span>.  <span class="built_in">*</span><span class="built_in">*</span>“<span class="number">0</span>”<span class="built_in">*</span><span class="built_in">*</span>. 右对齐</span><br><span class="line"><span class="number">6</span>.  每一天的标签，居中对齐.</span><br><span class="line"></span><br><span class="line">通过Shift全选所有标签，改变字体为<span class="built_in">*</span>Avenir Next Condensed, Medium style<span class="built_in">*</span>.</span><br><span class="line"></span><br><span class="line">[<span class="built_in">!</span>[<span class="number">2</span>-LabelledGraph]<span class="params">(http://cdn4.raywenderlich.com/wp-content/uploads/<span class="number">2014</span>/<span class="number">12</span>/<span class="number">2</span>-LabelledGraph.png)</span>]<span class="params">(http://cdn4.raywenderlich.com/wp-content/uploads/<span class="number">2014</span>/<span class="number">12</span>/<span class="number">2</span>-LabelledGraph.png)</span></span><br><span class="line"></span><br><span class="line">在<span class="built_in">*</span>Main.storyboard<span class="built_in">*</span>关联`averageWaterDrunk` 和 `maxLabel` .按住Control从View Controller拖分别拖到相应的标签。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[<span class="built_in">!</span>[<span class="number">2</span>-ConnectLabels]<span class="params">(http://cdn4.raywenderlich.com/wp-content/uploads/<span class="number">2014</span>/<span class="number">12</span>/<span class="number">2</span>-ConnectLabels.gif)</span>]<span class="params">(http://cdn4.raywenderlich.com/wp-content/uploads/<span class="number">2014</span>/<span class="number">12</span>/<span class="number">2</span>-ConnectLabels.gif)</span></span><br><span class="line"></span><br><span class="line">对于每天得标签来说，在<span class="built_in">*</span>Attributes Inspector<span class="built_in">*</span> 改变 <span class="built_in">*</span>View’s Tag<span class="built_in">*</span> 属性，分别食从<span class="number">1</span>到<span class="number">7</span></span><br><span class="line"></span><br><span class="line">[<span class="built_in">!</span>[<span class="number">2</span>-LabelViewTag]<span class="params">(http://cdn1.raywenderlich.com/wp-content/uploads/<span class="number">2014</span>/<span class="number">12</span>/<span class="number">2</span>-LabelViewTag.png)</span>]<span class="params">(http://cdn1.raywenderlich.com/wp-content/uploads/<span class="number">2014</span>/<span class="number">12</span>/<span class="number">2</span>-LabelViewTag.png)</span></span><br><span class="line"></span><br><span class="line">现在已经完成了图标的设置，在<span class="built_in">*</span>Main.storyboard<span class="built_in">*</span> 选择 <span class="built_in">*</span>Graph View<span class="built_in">*</span>并选择<span class="built_in">*</span>Hidden<span class="built_in">*</span>，让程序第一次出现的时候不显示图标。</span><br><span class="line"></span><br><span class="line">[<span class="built_in">!</span>[<span class="number">2</span>-GraphHidden]<span class="params">(http://cdn1.raywenderlich.com/wp-content/uploads/<span class="number">2014</span>/<span class="number">12</span>/<span class="number">2</span>-GraphHidden.png)</span>]<span class="params">(http://cdn1.raywenderlich.com/wp-content/uploads/<span class="number">2014</span>/<span class="number">12</span>/<span class="number">2</span>-GraphHidden.png)</span></span><br><span class="line"></span><br><span class="line">在 <span class="built_in">*</span>ViewController.swift<span class="built_in">*</span> 添加以下方法来设置标签:</span><br></pre></td></tr></table></figure>
<p> func setupGraphDisplay() {                                               </p>
<p>   //Use 7 days for graph - can use any number,<br>   //but labels and sample data are set up for 7 days<br>   let noOfDays:Int = 7                                                   </p>
<p>   //1 - replace last day with today’s actual data<br>   graphView.graphPoints[graphView.graphPoints.count-1] = counterView.cou<br> nter                                                                     </p>
<p>   //2 - indicate that the graph needs to be redrawn<br>   graphView.setNeedsDisplay()                                            </p>
<p>   maxLabel.text = “(maxElement(graphView.graphPoints))”                 </p>
<p>   //3 - calculate average from graphPoints<br>   let average = graphView.graphPoints.reduce(0, combine: +)<br>             / graphView.graphPoints.count<br>   averageWaterDrunk.text = “(average)”                                  </p>
<p>   //set up labels<br>   //day of week labels are set up in storyboard with tags<br>   //today is last day of the array need to go backwards                  </p>
<p>   //4 - get today’s day number<br>   let dateFormatter = NSDateFormatter()<br>   let calendar = NSCalendar.currentCalendar()<br>   let componentOptions:NSCalendarUnit = .CalendarUnitWeekday<br>   let components = calendar.components(componentOptions,<br>                                        fromDate: NSDate())<br>   var weekday = components.weekday                                       </p>
<p>   let days = [“S”, “S”, “M”, “T”, “W”, “T”, “F”]                         </p>
<p>   //5 - set up the day name labels with correct day<br>   for i in reverse(1…days.count) {<br>     if let labelView = graphView.viewWithTag(i) as? UILabel {<br>       if weekday == 7 {<br>         weekday = 0<br>       }<br>       labelView.text = days[weekday—]<br>       if weekday &lt; 0 {<br>         weekday = days.count - 1<br>       }<br>     }<br>   }<br> }</p>
<pre><code>

<span class="livecodeserver">This looks <span class="operator">a</span> little burly, but <span class="keyword">it</span>’s required <span class="built_in">to</span> <span class="built_in">set</span> up <span class="operator">the</span> calendar <span class="operator">and</span> retrieve <span class="operator">the</span> current day <span class="operator">of</span> <span class="operator">the</span> week. Take <span class="keyword">it</span> <span class="operator">in</span> sections:

这看起来有点粗鲁的，但它需要设置日历和知道今天是星期几：

<span class="number">1.</span>  你设置今天的数据将会作为数组的最后一个元素插入. 在最后的项目中,[Part
    <span class="number">3</span>](<span class="keyword">http</span>://www.raywenderlich.com/?p=<span class="number">90695</span>),你可以扩展到<span class="number">60</span>天的数据, 将会有一个方法来选取起止时间,但是这超出了本章的讲解内容 :]
<span class="number">2.</span>  如果今天有变化，重绘数据.
<span class="number">3.</span>  这里你使用 Swift的 `reduce` 来计算一周的平局饮水量; 这个在计算数组的总和的时候非常有用。
<span class="number">4.</span>  这一部分将当前的日期作为iOS的日历一周的结束.
<span class="number">5.</span>  这个循环从<span class="number">7</span>到<span class="number">1</span>，通过tag来获取相应的视图，这是正确的标题从*days*数组中。

还是在*ViewController.swift*，在`counterViewTap(_:)`方法的`<span class="keyword">else</span>`分支中调用新方法来显示图表:</span>
</code></pre><p> setupGraphDisplay()</p>
<pre><code>
运行程序，点击计数器，万岁，图表将显示所有的数据。


[<span class="link_label">![2-GraphFinished</span>](<span class="link_url">http://cdn2.raywenderlich.com/wp-content/uploads/2014/12/2-GraphFinished.gif</span>)](<span class="link_url">http://cdn2.raywenderlich.com/wp-content/uploads/2014/12/2-GraphFinished.gif</span>)

<span class="header">掌握矩阵
------</span>

现在程序看起来有点突兀，我们子啊第一部分创建的计数器还需要提升一下，在饮水量上添加指示。

[<span class="link_label">![2-Result</span>](<span class="link_url">http://cdn4.raywenderlich.com/wp-content/uploads/2014/12/2-Result.png</span>)](<span class="link_url">http://cdn4.raywenderlich.com/wp-content/uploads/2014/12/2-Result.png</span>)

现在已经有CG方法绘图的一些经验了，你将会使用旋转和平移。
可以看出这个标志都是从中心辐射的:

[<span class="link_label">![2-LinesExpanded</span>](<span class="link_url">http://cdn4.raywenderlich.com/wp-content/uploads/2014/12/2-LinesExpanded.png</span>)](<span class="link_url">http://cdn4.raywenderlich.com/wp-content/uploads/2014/12/2-LinesExpanded.png</span>)

和在上下文绘图一样，你可以通过旋转，缩放，和平移来进行矩阵变幻。

一开始这可能是令你费解的，但是在经过一些练习之后，将会变得更有意义，变换的顺序非常重要，我先说画出你需要做的示意图。
下面的示意图就是通过旋转然后在中间绘制矩形的结果。

[<span class="link_label">![2-RotatedContext</span>](<span class="link_url">http://cdn1.raywenderlich.com/wp-content/uploads/2014/12/2-RotatedContext.png</span>)](<span class="link_url">http://cdn1.raywenderlich.com/wp-content/uploads/2014/12/2-RotatedContext.png</span>)

黑色的矩形食旋转前的上下文。然后是绿的，再是红得。有两件事需要注意。

<span class="bullet">1.  </span>上下文根据左上角进行旋转。
<span class="bullet">2.  </span>矩形依然绘制在中心在旋转之后.

当你绘制计数器的标志的时候，你需要先旋转上下文，然后再绘制它。

[<span class="link_label">![2-RotatedTranslatedContext</span>](<span class="link_url">http://cdn5.raywenderlich.com/wp-content/uploads/2014/12/2-RotatedTranslatedContext.png</span>)](<span class="link_url">http://cdn5.raywenderlich.com/wp-content/uploads/2014/12/2-RotatedTranslatedContext.png</span>)


在这个示意图中，矩形的标记在左上方，蓝色轮廓就是变换的上下文，然后上下文旋转（红色虚线），然后再次旋转。

最后当红色的标识被绘制完之后，它的角度如图所示:

在上下文旋转和平移得到红色标记之后，它需要回到中心来进行下一次的变换得到绿的标志。

就像你在裁剪的时候保存上下文一样，你需要保存和恢复上下文状态在每次矩阵变换的时候。

打开<span class="emphasis">*CounterView.swift*</span> 在<span class="code">`drawRect(_:)`</span>的最后添加代码来增加标记:
</code></pre><p> //Counter View markers                                                   </p>
<p> let context = UIGraphicsGetCurrentContext()                              </p>
<p> //1 - save original state<br> CGContextSaveGState(context)<br> outlineColor.setFill()                                                   </p>
<p> let markerWidth:CGFloat = 5.0<br> let markerSize:CGFloat = 10.0                                            </p>
<p> //2 - the marker rectangle positioned at the top left<br> var markerPath = UIBezierPath(rect:<br>        CGRect(x: -markerWidth/2,<br>        y: 0,<br>        width: markerWidth,<br>        height: markerSize))                                              </p>
<p> //3 - move top left of context to the previous center position<br> CGContextTranslateCTM(context,<br>                       rect.width/2,<br>                       rect.height/2)                                     </p>
<p> for i in 1…NoOfGlasses {<br>   //4 - save the centred context<br>   CGContextSaveGState(context)                                           </p>
<p>   //5 - calculate the rotation angle<br>   var angle = arcLengthPerGlass * CGFloat(i) + startAngle - π/2          </p>
<p>   //rotate and translate<br>   CGContextRotateCTM(context, angle)<br>   CGContextTranslateCTM(context,<br>                         0,<br>                         rect.height/2 - markerSize)                      </p>
<p>   //6 - fill the marker rectangle<br>   markerPath.fill()                                                      </p>
<p>   //7 - restore the centred context for the next rotate<br>   CGContextRestoreGState(context)<br> }                                                                        </p>
<p> //8 - restore the original state in case of more painting<br> CGContextRestoreGState(context) </p>
<p>```                                                                      </p>
<p>这里你做了下面几点：</p>
<ol>
<li>矩阵变换之前，保存上下文状态.</li>
<li>得到位路劲的位置和形状，但是现在还不绘制.</li>
<li>旋转能够围绕原始的中心点(上面的蓝色线)</li>
<li>对于每个标志, 首先保存居中上下文状态.</li>
<li>根据先前计算的值来进行旋转和平移上下文.</li>
<li>在旋转后的左上角绘制矩形并平移.</li>
<li>读取居中上下文状态</li>
<li>读取最原始的上下文状态.</li>
</ol>
<p>喔，干的不错，现在来运行程序，欣赏这个漂亮的界面。<br><a href="http://cdn1.raywenderlich.com/wp-content/uploads/2014/12/2-FinalPart2.gif" target="_blank" rel="external"><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/12/2-FinalPart2-270x500.gif" alt="2-FinalPart2"></a></p>
<h2 id="接下来该做什么？">接下来该做什么？</h2><p><a href="http://cdn1.raywenderlich.com/wp-content/uploads/2015/02/Flo-Part2-6.3.zip" target="_blank" rel="external">这里</a>,<br>是到现在为止为止所有的代码.</p>
<p>现在你已经学会了绘制路径，渐变效果和通过上下文的矩阵变化</p>
<p><a href="http://www.raywenderlich.com/?p=90695" target="_blank" rel="external">在第三部分</a>的核心绘图教程中,<br>你将创建图案的背景和绘制矢量图。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Core_Graphics教程第二部分(Swift)_-_Gradients_与_Context">Core Graphics教程第二部分(Swift) - Gradients 与 Context</h2><blockquote>
<ul>
<li>原文链接 : <a href="http://www.raywenderlich.com/90693/modern-core-graphics-with-swift-part-2">Core Graphics Tutorial Part 2: Gradients and Contexts</a></li>
<li>原文作者 : <a href="http://www.raywenderlich.com/u/caroline">caroline</a></li>
<li>译文出自 :  <a href="http://www.devtf.cn">开发技术前线</a></li>
<li>译者 : <a href="https://github.com/mrchenhao">HarriesChen</a> </li>
<li>校对者: <a href="https://github.com/mrchenhao">HarriesChen</a></li>
</ul>
</blockquote>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/FinalApp-192x320.png" alt="FinalApp"></p>
<p><em>更新时间  04/15/2015</em> 为Xcode 6.3 和 Swift1.2更新</p>
<p>欢迎回到我们的Swift核心绘图教程系列！</p>
<p>在<a href="http://www.raywenderlich.com/?p=90690">第一部分</a>中,你学习到了使用storyboard绘制线条和矩形.</p>
<p>在第二部部分中，你将深入核心绘图，使用CGContext实现渐变效果</p>
<h2 id="核心绘图">核心绘图</h2><p>你现在已经从简单的UIKit深入到核心绘图。</p>
<p>下图是各个框架的关系图：</p>
<p><a href="http://cdn2.raywenderlich.com/wp-content/uploads/2014/12/2-Architecture.png"><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/12/2-Architecture-433x320.png" alt="2-Architecture"></a></p>
<p>UIKit是在最顶层，使用最友好的框架。你使用过UIBezierPath的就是在UIKit层中对Core Graphics层中CGPath的封装。</p>
<p>你可以看到 Core Graphics 的对象和方法都是CG开头的，非常容易辨认。</p>
<p>另外CG方法都是C方法，在调用的时候不需要明确的指定参数名，和一般Swift调用方法不一样。</p>
<h2 id="从Graph_View开始">从Graph View开始</h2>]]>
    
    </summary>
    
      <category term="Core Graphics" scheme="http://ytlvy.com/tags/Core-Graphics/"/>
    
      <category term="Swift" scheme="http://ytlvy.com/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift Memory management]]></title>
    <link href="http://ytlvy.com/2015/08/08/Swift-Memory-management/"/>
    <id>http://ytlvy.com/2015/08/08/Swift-Memory-management/</id>
    <published>2015-08-08T13:18:21.000Z</published>
    <updated>2015-08-08T13:18:50.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Swift和自动引用计数(ARC)整理之强，弱和无主引用">Swift和自动引用计数(ARC)整理之强，弱和无主引用</h2><blockquote>
<ul>
<li>原文链接 : <a href="http://www.andrewcbancroft.com/2015/05/08/strong-weak-and-unowned-sorting-out-arc-and-swift/" target="_blank" rel="external">Strong, Weak, and Unowned - Sorting out ARC and Swift</a></li>
<li>原文作者 : <a href="http://www.andrewcbancroft.com/" target="_blank" rel="external">Andrew Bancroft</a></li>
<li>译文出自 : <a href="www.devtf.cn">开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/samw00/" target="_blank" rel="external">samw00</a> </li>
<li>校对者:  <a href="https://github.com/bboyfeiyu/" target="_blank" rel="external">MrSimple</a> </li>
<li>状态 :  完成</li>
</ul>
</blockquote>
<p>我敢打赌有相当一部分的Swfit开发者纠结于<code>strong</code>（强引用），<code>weak</code>（弱引用)和<code>unowned</code>（无主引用）这几种不同类型的引用方式对他们的代码在运行时所造成的影响。如果我的日子依赖于自动引用计数（ARC）,我想我是不会费神来尝试解释其中的奥妙的。</p>
<p>在我每次声明变量或是常量时，我都不是特别确定到底应该用哪种类型的引用，为了让自己不再纠结，我最终决定把<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html" target="_blank" rel="external">苹果官方关于ARC的文档</a>拿出来拜读，试着去理解和消化里面的每一句话。这篇文章尝试着把我脑里关于Swift和自动引用计数（ARC）的整理分享给大家。</p>
<p>这篇文章稍微有点长所以我想：“为何不先把总结直接抛出来让小伙伴们先睹为快呢？然后如果实好奇再继续看我是如何得出这总结的”。所以下面献上我的总结！</p>
<a id="more"></a>
<h2 id="总结">总结</h2><ul>
<li>在你开始担心应该是用<code>strong</code>，<code>weak</code>还是<code>unowned</code>之前，先问自己一个问题：“我是在和引用类型打交道吗？”。如果是在和结构体或是枚举类型打交道，你就压根不用管是用<code>weak</code>还是<code>unowned</code>来修饰这些常量或变量，因为ARC就没做这些类型的内存管理。</li>
<li><code>strong</code>强引用适用于父对象指向子对象，但反过来不能用强引用，听说过父亲拥有儿子的，可没听说过儿子拥有父亲的。事实上，在大多数情况下，<code>strong</code>都是默认引用类型。</li>
<li>当两个实例是<em>optionally</em>关联在一起的，确保其中一个实例是用<code>weak</code>弱引用指向另一个实例。</li>
<li>两个实例A和B，如果实例A必须在实例B存在的前提下才能存在，那么实例A必须用<code>unowned</code>无主引用指向实例B。也就是说，有强制依赖性的那个实例必须对另一个实例持有无主引用。</li>
</ul>
<p>想具体了解我是如何得出这些结论的，就要看接下来的详细解说了，你可以直接跳到你感兴趣的部分也可以顺序读下去。</p>
<h2 id="ARC和内存管理">ARC和内存管理</h2><p>对很多人来说，一提到“内存管理”就云里雾里的。</p>
<p>内存管理的本质之所以被蒙上各种神奇的面纱，是因为大多数我们熟悉的编程语言都把这一块给提炼了出去。大多数时候，我们只要简单的敲我们的代码而不用管我们的实例对象占用了内存的几个字节以及当我们不需要这些对象的时候，它们是如何被清除的。总之程序就是能正常运行。</p>
<p>自动引用计数（ARC）就是对内存管理的一种提炼。这是苹果通过清除内存中不用的类实例来释放内存空间所采用的一种方法。</p>
<p>ARC只对类起作用（所以没结构体和枚举什么事），因为自动引用计数只对<strong>引用类型</strong>有效。结构体和枚举属于值类型，所以ARC不会对值类型的实例做任何内存管理。</p>
<p>引起我们关于引用类型关键字讨论的问题是这：“ARC是如何知道某个实例已经“用完”它所占据的内存空间呢？”。</p>
<h2 id="strong_强引用">strong 强引用</h2><p>在ARC的世界里，<code>strong</code>，<code>weak</code>和<code>unowned</code>就是修饰引用本质的关键字。</p>
<p>所有的引用在没有特殊说明之前都是<code>strong</code>强引用。大多数情况下，这就是对的。在Swift中，当你声明一个变量或是常量时，默认就是<code>strong</code>强引用，所以不用在前面添加<code>strong</code>。</p>
<p>那么，一个引用是强是弱和ARC的内存管理有什么关系吗？</p>
<p>在ARC中，只有当指向一个类实例的<strong>所有</strong><code>strong</code>强引用都被断开了，那么这个类实例才会被清除，内存才会被释放。那么问题来了，<code>strong</code>强引用在什么情况下才会断开呢？</p>
<p><code>strong</code>强引用在下列情况下会被断开…</p>
<ul>
<li>当指向某一实例的变量被设为<code>nil</code></li>
<li>当持有一个子类实例引用的父类变量被设为<code>nil</code>，这样会同时断开父类和子类之间的相互引用</li>
<li>当变量或常量离开了自己的作用域，比如在<code>if/else</code>或者<code>for</code>循环中初始化了某些变量，当程序执行完这些控制流语句时，相关引用就断开了，同时ARC会释放内存。</li>
</ul>
<p>ARC中内存管理的所有事情都取决于到底有<strong>几个</strong><code>strong</code>强引用指向实例。当指向一个实例的<code>strong</code>强引用为零的时候，那么就是这个实例被清除，所占据内存空间被释放的时候。</p>
<p>那么<code>weak</code>弱引用和<code>unowned</code>无主引用又是怎么一回事？</p>
<h2 id="weak弱引用和unowned无主引用">weak弱引用和unowned无主引用</h2><p>当我们谈到类实例与类实例之间的关系时，就应该要想到<code>weak</code>弱引用和<code>unowned</code>无主引用。</p>
<h3 id="实例之间的关系">实例之间的关系</h3><p>类与类之间的关系是面对对象编程的一个核心。不管你对类之间的关系有什么规划，总之这些关系是存在的，而且这些关系又对ARC如何做内存管理有影响。</p>
<p>那么类与类之间到底有哪些关系类型呢？哪些关系类型需要我们用到<code>weak</code>弱引用，哪些需要<code>unowned</code>无主引用呢？</p>
<h4 id="层级类关系类型_Hierarchical_Relationships">层级类关系类型 Hierarchical Relationships</h4><p>在Swift中，能经常看到这些层级关系的身影。经常是某一个类的实例对一个或多个子类实例拥有<code>strong</code>强引用，而这些子类实例又对自己的一个或多个子类实例持有<code>strong</code>强引用。在这种情况下，<code>strong</code>强引用方向都一致：从父类指向子类。</p>
<p>在这种层级结构中，用<code>strong</code>强引用是没问题的。但是，如果某一个子类要反向持有一个父类的引用怎么办呢？如果没考虑好，在ARC中就会遇到麻烦。</p>
<h4 id="可选，相互依赖关系类型_Optional,_mutually_dependent_relationships">可选，相互依赖关系类型 Optional, mutually dependent relationships</h4><p>在这一部分，我的目的是讲明<code>weak</code>弱引用所扮演的角色。</p>
<p>当类实例互相依赖时，它们之间需要相互持有引用。但有时候，依赖性不是强制的，在这种情况下，就允许某一个实例在不持有其他实例引用的情况下也能够存在。</p>
<p>如果用<code>database cardinality</code>来打个比方，我们可以说双方的关系是0：1。</p>
<p>如果我们面前有个例子那是最好不过的了 - 在这过去的一周，Oklahoma州的一个动物园被龙卷风袭击了，有几头珍奇异兽逃脱了，这事给了我灵感!</p>
<p>在动物园里，一个<code>Animal</code>生活在一个<code>Exhibit</code>（展区）里。有时<code>Exhibits</code>可能是空的，可能正在被清理，或者原本生活在这里的<code>Animal</code>生病了或被转移了，又或者一个龙卷风来袭了，等等…</p>
<p>同样的，一个<code>Animal</code>可能不住在<code>Exhibit</code>中。它可能被临时放在某个地方等<code>Exhibit</code>被打扫干净后再回去，或者是在接受治疗也可能是被转移去另一个动物园，也有可能是趁龙卷风来袭逃走了…</p>
<p>这动物园的例子可以用代码这样来表示:</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class <span class="keyword">Animal</span> &#123;</span><br><span class="line">    let name: String</span><br><span class="line">    let species: String</span><br><span class="line">    init(name: String, species: String) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">        self.species = species</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var exhibit: Exhibit? // 注意这是个可选类型变量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Exhibit &#123;</span><br><span class="line">    let title: String</span><br><span class="line">    init(title: String) &#123; self.title = title&#125;</span><br><span class="line"></span><br><span class="line">    var <span class="keyword">animal</span>: <span class="keyword">Animal</span>? // 注意这也是个可选类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在有一个<code>Animal</code>生活在一个<code>Exhibit</code>里。如果我们给这两者建立某种联系，让它们互相拥有对方的信息这样可能会更好。所以我们先实例化一个<code>Animal</code>和一个<code>Exhibit</code>，然后紧接着把实例赋给对方中相对应的属性。</p>
<p>现在我们考虑龙卷风袭击了动物园，然后<code>Animal</code>逃离了它的<code>Exhibit</code>这事。假设，这个<code>Animal</code>没有被找回（实际上他们已经找到那些逃走的动物），再假设这只逃跑的<code>Animal</code>正在Oklahoma的平原上自由的奔跑。而动物园，却不得不关闭它的<code>Exhibit</code>。在代码要体现这的话，我们只要把<code>Animal</code>的实例设为nil，同时把<code>Exhibit</code>的实例也设为nil。</p>
<h4 id="内存泄漏">内存泄漏</h4><p>刚刚给出的这个动物园例子正好说明了在你的应用中造成内存泄漏是可能的。这如何说起?</p>
<p>这一切都和ARC有关，只有当指向某个类实例的引用计数为<strong>零</strong>时，ARC才会释放内存。</p>
<p>在我们的<code>Animal</code> - <code>Exhibit</code>例子中，两个实例互相拥有指向对方的引用。当我们把<code>Animal</code>设为nil时，<code>Exhibit</code>实例仍然会通过自己的<code>animal</code>属性持有对<code>Animal</code>的引用。</p>
<p>反过来说，既然<code>Animal</code>实例仍然存在，那么它也通过自己的<code>exhibit</code>属性持有一个指向<code>Exhibit</code>的引用。所以当我们把<code>Exhibit</code>设为nil时，<code>Animal</code>还是会指向它不放手。</p>
<p>那么现在我们就处在一个尴尬的境地。 <code>Animal</code>和<code>Exhibit</code>就这么一直互相持有对方的引用（所以谁的内存空间也不会被释放）而除此之外再没其他东西再指向它们了，那么就没办法再访问这两个实例了，它们就永远存在于内存中，内存就这么泄漏了。</p>
<p>但是解决的办法总是有的！在这种“可选，相互依赖的关系”中，<code>weak</code>弱引用将起着至关重要的作用。</p>
<h4 id="打破强引用循环">打破强引用循环</h4><p>刚刚提到的尴尬场面就是“强引用循环”。</p>
<p>好在我们有方法破除这类循环从而避免导致内存泄漏。</p>
<p>在互相依赖的关系中，就像上文提到的<code>Animal</code>和<code>Exhibit</code>这种，只要将其中的一个引用从<code>strong</code>强引用转为<code>weak</code>弱引用就能破除强引用循环。</p>
<p>至于哪个类持有<code>weak</code>弱引用不是重点，只要有其中一个类持有。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class <span class="keyword">Animal</span> &#123;</span><br><span class="line">    let name: String</span><br><span class="line">    let species: String</span><br><span class="line">    init(name: String, species: String) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">        self.species = species</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var exhibit: Exhibit? // 用强引用指向exhibit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Exhibit &#123;</span><br><span class="line">    let title: String</span><br><span class="line">    init(title: String) &#123;self.title = title&#125;</span><br><span class="line"></span><br><span class="line">    weak var <span class="keyword">animal</span>: <span class="keyword">Animal</span>? // 这里用到_weak_弱引用来指向<span class="keyword">animal</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让<code>Exhibit</code>中的<code>animal</code>属性拥有一个对<code>Animal</code>实例的<code>weak</code>弱引用会消除形成强引用循环的可能性。</p>
<p>那么<code>unowned</code>无主引用又是怎么一回事?</p>
<h4 id="强制，单向依赖关系">强制，单向依赖关系</h4><p>这一部分，我的目标是讲明<code>unowned</code>无主引用所扮演的角色。</p>
<p>还有最后一类关系类型是直接涉及到ARC这个主题。在有些情况下，两个类实例是相互有联系的，但是其中一个实例必须要在另一个实例存在的前提下才能存在。</p>
<p>让我们继续刚才动物的那个例子。假设我们的动物园向<code>Visitors</code>游客发行<code>AnnualPasses</code>年票。一个<code>Visitor</code>游客可以不用<code>AnnualPass</code>年票就能进动物园，就光他自己存在就足够欣赏各种展厅了。但是，一个<code>AnnualPass</code>年票，却必须需要有一个<code>Visitor</code>来持有才有存在的意义。</p>
<p>在代码中，我们这样来写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> annualPass: <span class="type">AnnualPass</span>?</span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnualPass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> number: <span class="type">UInt64</span></span><br><span class="line">    <span class="keyword">unowned</span> <span class="keyword">let</span> passholder: <span class="type">Visitor</span> <span class="comment">// 注意这里我们用了_unowned_无主引用</span></span><br><span class="line">    <span class="keyword">init</span>(number: <span class="type">UInt64</span>, passholder: <span class="type">Visitor</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = number</span><br><span class="line">        <span class="keyword">self</span>.passholder = passholder</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意下面几点：</p>
<ol>
<li>游客<code>Visitor</code>对<code>AnnualPass</code>年票实例有一个可选的<code>strong</code>强引用</li>
<li>年票<code>AnnualPass</code>对<code>Visitor</code>实例持有一个不可选的<code>unowned</code>无主引用</li>
</ol>
<p>这样做的目的在于，当<code>Visitor</code>变量被设为nil时，<code>strong</code>强引用计数能为零，从而也能够避免因强引用循环而导致的内存泄漏。</p>
<h2 id="总结-1">总结</h2><p>我知道我在一开始就写了总结，但为了文章的完整性，我在下面再总结一次…</p>
<ul>
<li>在你开始担心应该是用<code>strong</code>，<code>weak</code>还是<code>unowned</code>之前，先问自己一个问题：“我是在和引用类型打交道吗？”。如果是在和结构体或是枚举类型打交道，你就压根不用管是用<code>weak</code>还是<code>unowned</code>来修饰这些常量或变量，因为ARC就没做这些类型的内存管理。</li>
<li><code>strong</code>强引用适用于父对象指向子对象，但反过来不能用强引用，听说过父亲拥有儿子的，可没听说过儿子拥有父亲的。事实上，在大多数情况下，<code>strong</code>都是默认引用类型。</li>
<li>当两个实例是<em>optionally</em>关联在一起的，确保其中一个实例是用<code>weak</code>弱引用指向另一个实例。</li>
<li>两个实例A和B，如果实例A必须在实例B存在的前提下才能存在，那么实例A必须用<code>unowned</code>无主引用指向实例B。也就是说，有强制依赖性的那个实例必须对另一个实例持有无主引用。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Swift和自动引用计数(ARC)整理之强，弱和无主引用">Swift和自动引用计数(ARC)整理之强，弱和无主引用</h2><blockquote>
<ul>
<li>原文链接 : <a href="http://www.andrewcbancroft.com/2015/05/08/strong-weak-and-unowned-sorting-out-arc-and-swift/">Strong, Weak, and Unowned - Sorting out ARC and Swift</a></li>
<li>原文作者 : <a href="http://www.andrewcbancroft.com/">Andrew Bancroft</a></li>
<li>译文出自 : <a href="www.devtf.cn">开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/samw00/">samw00</a> </li>
<li>校对者:  <a href="https://github.com/bboyfeiyu/">MrSimple</a> </li>
<li>状态 :  完成</li>
</ul>
</blockquote>
<p>我敢打赌有相当一部分的Swfit开发者纠结于<code>strong</code>（强引用），<code>weak</code>（弱引用)和<code>unowned</code>（无主引用）这几种不同类型的引用方式对他们的代码在运行时所造成的影响。如果我的日子依赖于自动引用计数（ARC）,我想我是不会费神来尝试解释其中的奥妙的。</p>
<p>在我每次声明变量或是常量时，我都不是特别确定到底应该用哪种类型的引用，为了让自己不再纠结，我最终决定把<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html">苹果官方关于ARC的文档</a>拿出来拜读，试着去理解和消化里面的每一句话。这篇文章尝试着把我脑里关于Swift和自动引用计数（ARC）的整理分享给大家。</p>
<p>这篇文章稍微有点长所以我想：“为何不先把总结直接抛出来让小伙伴们先睹为快呢？然后如果实好奇再继续看我是如何得出这总结的”。所以下面献上我的总结！</p>]]>
    
    </summary>
    
      <category term="ARC" scheme="http://ytlvy.com/tags/ARC/"/>
    
      <category term="Swift" scheme="http://ytlvy.com/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift custom-view-controller-transitions-tutorial]]></title>
    <link href="http://ytlvy.com/2015/08/08/Swift-custom-view-controller-transitions-tutorial/"/>
    <id>http://ytlvy.com/2015/08/08/Swift-custom-view-controller-transitions-tutorial/</id>
    <published>2015-08-08T13:08:48.000Z</published>
    <updated>2015-08-08T13:09:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="使用Swift自定义ViewController切换效果与动画">使用Swift自定义ViewController切换效果与动画</h1><blockquote>
<ul>
<li>原文链接 : <a href="http://www.appcoda.com/custom-view-controller-transitions-tutorial/" target="_blank" rel="external">custom-view-controller-transitions-tutorial</a></li>
<li>原文作者 : <a href="http://www.appcoda.com/custom-view-controller-transitions-tutorial/" target="_blank" rel="external">joyce echessa</a></li>
<li><a href="www.devtf.cn">译文出自 :  开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https:www.devtd.cn" target="_blank" rel="external">Shopie</a>  </li>
</ul>
</blockquote>
<p>当我们把从Apple iOS设备上内置的app从一个view切换到另一个的时候，我们可以看到各种不同的动态切换。比如，把详细view controller滑动到主view controller时呈现出的切换动画（通常在短信app或设置app中可以看到），以及代表了不同view controller之间切换的各种不间断过渡。</p>
<p>iOS 7引入了自定义view controller切换，使得开发人员能够在他们的app中实现不同 view controller之间的自定义切换动画。我们通过本教程来看看如何自定义切换动画。本教程还会讲到如何创建手势切换，也就是交互式切换。首先，大家需要下载starter项目，我们在后续的整个教程中将会用到。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/03/custom-view-transition.jpg" alt="pic-1"></p>
<h2 id="开始着手">开始着手</h2><p>我们需要按照以下步骤来创建自定义切换：</p>
<ul>
<li><p>创建一个实现了<code>UIViewControllerAnimatedTransitioning</code>协议的类。这里我们需要写执行动画的代码。我们把这个类叫做animation controller。</p>
</li>
<li><p>在展示view controller之前，我们需要建立一个类作为其transitioning delegate。这个delegate会从animation controller得到一个回调信号用于展示view controller。</p>
</li>
<li><p>实现回调方法返回步骤一的animation controller实例。</p>
</li>
</ul>
<p>运行starter项目后我们可以看到关于条目列表的表格视图。导航条上有一个Action按钮，点击这个按钮我们可以看到一个从底部上滑的以普通模态呈现的view。我们接下来就要为这个view写一个自定义切换程序。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/03/vid01.gif" alt="pic-2"></p>
<h2 id="自定义Present_Transition">自定义Present Transition</h2><p>上文提到，我们首先要做的是创建一个animation controller。创建一个继承自NSObject的<code>CustomPresentAnimationController</code>类。根据图示更改其定义。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomPresentAnimationController</span>: <span class="typename">NSObject</span>, <span class="typename">UIViewControllerAnimatedTransitioning &#123;</span></span></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>UIViewControllerAnimatedTransitioning</code>协议中有两个我们接下来需要添加的方法。将以下方法添加到类中。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func transitionDuration<span class="params">(transitionContext: UIViewControllerContextTransitioning)</span> -&amp;gt; NSTimeInterval &#123;</span><br><span class="line">    return <span class="number">2.5</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">func animateTransition<span class="params">(transitionContext: UIViewControllerContextTransitioning)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">let</span> fromViewController = transitionContext.viewControllerForKey<span class="params">(UITransitionContextFromViewControllerKey)</span><span class="built_in">!</span></span><br><span class="line">    <span class="built_in">let</span> toViewController = transitionContext.viewControllerForKey<span class="params">(UITransitionContextToViewControllerKey)</span><span class="built_in">!</span></span><br><span class="line">    <span class="built_in">let</span> finalFrameForVC = transitionContext.finalFrameForViewController<span class="params">(toViewController)</span></span><br><span class="line">    <span class="built_in">let</span> containerView = transitionContext.containerView<span class="params">()</span></span><br><span class="line">    <span class="built_in">let</span> bounds = UIScreen.mainScreen<span class="params">()</span>.bounds</span><br><span class="line">    toViewController.view.frame = CGRectOffset<span class="params">(finalFrameForVC, <span class="number">0</span>, bounds.size.height)</span></span><br><span class="line">    containerView.addSubview<span class="params">(toViewController.view)</span></span><br><span class="line">        </span><br><span class="line">    UIView.animateWithDuration<span class="params">(transitionDuration<span class="params">(transitionContext)</span>, delay: <span class="number">0.0</span>, usingSpringWithDamping: <span class="number">0.5</span>, initialSpringVelocity: <span class="number">0.0</span>, options: .CurveLinear, animations: &#123;</span><br><span class="line">        fromViewController.view.alpha = <span class="number">0.5</span></span><br><span class="line">        toViewController.view.frame = finalFrameForVC</span><br><span class="line">        &#125;, completion: &#123;</span><br><span class="line">            finished in</span><br><span class="line">            transitionContext.completeTransition<span class="params">(<span class="literal">true</span>)</span></span><br><span class="line">            fromViewController.view.alpha = <span class="number">1.0</span></span><br><span class="line">    &#125;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个方法指定了切换动画的时长。在demo app中我们将其设置为2.5秒，但在实际情况中的app大家将这个值设置为更短一些可能会更好。</p>
<p>在第二个方法中我们使用transitionContext来获得我们从…导航、导航到的view controller，动画完成后transition context应得到的最终框架，以及存储与to view controller和from view controller相关的view的container view。</p>
<p>然后我们把<code>to view</code>放在屏幕正下方。之后把它添加到container view和animate closure中，通过将其最终框架设置在transition context给出的位置来实现<code>to view</code>的动画效果。我们还会实现<code>from view</code>的alpha值的动画效果，以便<code>to view</code>往屏幕上方<code>from view</code>滑动时，<code>from view</code>会淡出。该动画效果设置的时长根据<code>transitionDuration(transitionContext:)</code>中的设置而定。在completion closure中，当动画完成时transition context会收到通知，然后将<code>from view</code>的alpha值恢复正常。之后框架会将<code>from view</code>从container中移出。</p>
<p>animation controller完成之后，我们需要将其链接到storyboard segue。</p>
<p>打开ItemsTableViewController.swift文件，按图所示更改类定义。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ItemsTableViewController</span>: <span class="typename">UITableViewController</span>, <span class="typename">UIViewControllerTransitioningDelegate &#123;</span></span></span><br></pre></td></tr></table></figure>
<p>UIViewController有一个叫做<code>transitionDelegate</code>的属性，这个属性用于支持自定义切换。当切换到一个view controller时，框架会检查这个属性以便确定是否需要使用自定义切换。</p>
<p>打开Main.storyboard并选择<code>Present modally segue to Action View Controller</code>，在Attributes Inspector中将其Identifier设置为<code>showAction</code>。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/03/pic02.png" alt="pic-3"></p>
<p>返回ItemsTableViewController并将下列代码添加到类中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> customPresentAnimationController = <span class="type">CustomPresentAnimationController</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">prepareForSegue</span><span class="params">(segue: UIStoryboardSegue, sender: AnyObject?)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> segue.identifier == <span class="string">"showAction"</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> toViewController = segue.destinationViewController <span class="keyword">as</span> <span class="type">UIViewController</span></span><br><span class="line">        toViewController.transitioningDelegate = <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们将创建一个animation controller的实例，之后我们在<code>prepareForSegue()</code>功能中发现Action屏幕的segue，并设置destination view controller的<code>transitionDelegate</code>属性。</p>
<p>将下列<code>UIViewControllerTransitioningDelegate</code>方法添加到类中。这一步会返回我们的自定义animation controller实例。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">animationControllerForPresentedController</span><span class="params">(presented: UIViewController, presentingController presenting: UIViewController, sourceController source: UIViewController)</span></span> -&amp;gt; <span class="type">UIViewControllerAnimatedTransitioning</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> customPresentAnimationController</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行app后我们可以看到屏幕中的Action view缓慢往上滑动，最后稳定下来之前出现些许弹跳。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/03/vid02.gif" alt="pic-4"></p>
<p>如果大家想看到一个稍微不同的结果，那么我们可以在CustomPresentAnimationController.swift稍作改变：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toViewController<span class="class">.view</span><span class="class">.frame</span> = <span class="function"><span class="title">CGRectOffset</span><span class="params">(finalFrameForVC, <span class="number">0</span>, bounds.size.height)</span></span></span><br></pre></td></tr></table></figure>
<p>改变后如下所示，其中我们将to view controller的原始位置放到了屏幕上方。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toViewController<span class="class">.view</span><span class="class">.frame</span> = <span class="function"><span class="title">CGRectOffset</span><span class="params">(finalFrameForVC, <span class="number">0</span>, -bounds.size.height)</span></span></span><br></pre></td></tr></table></figure>
<p>运行app，Action view会从上往下落。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/03/vid03.gif" alt="pic-5"></p>
<h2 id="自定义消隐(Dismiss)转场效果">自定义消隐(Dismiss)转场效果</h2><p>我们之前为了呈现view设置了一个自定义切换效果，但当View消隐时，view会使用Apple设定的默认切换。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/03/vid04.gif" alt="pic-6"></p>
<p><code>UIViewControllerTransitioningDelegate</code>也可以使我们在解散以及呈现view controller时指定一个animation controller来使用。下面我们就来创建。</p>
<p>创建一个名为 <code>CustomDismissAnimationController</code> 的类，作为<code>NSObject</code>的子类。按照以下代码更改其定义。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomDismissAnimationController</span>: <span class="typename">NSObject</span>, <span class="typename">UIViewControllerAnimatedTransitioning &#123;</span></span></span><br></pre></td></tr></table></figure>
<p>将以下代码添加到类中。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func transitionDuration<span class="params">(transitionContext: UIViewControllerContextTransitioning)</span> -&amp;gt; NSTimeInterval &#123;</span><br><span class="line">    return <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func animateTransition<span class="params">(transitionContext: UIViewControllerContextTransitioning)</span> &#123;</span><br><span class="line">    <span class="built_in">let</span> fromViewController = transitionContext.viewControllerForKey<span class="params">(UITransitionContextFromViewControllerKey)</span><span class="built_in">!</span></span><br><span class="line">    <span class="built_in">let</span> toViewController = transitionContext.viewControllerForKey<span class="params">(UITransitionContextToViewControllerKey)</span><span class="built_in">!</span></span><br><span class="line">    <span class="built_in">let</span> finalFrameForVC = transitionContext.finalFrameForViewController<span class="params">(toViewController)</span></span><br><span class="line">    <span class="built_in">let</span> containerView = transitionContext.containerView<span class="params">()</span></span><br><span class="line">    toViewController.view.frame = finalFrameForVC</span><br><span class="line">    toViewController.view.alpha = <span class="number">0.5</span></span><br><span class="line">    containerView.addSubview<span class="params">(toViewController.view)</span></span><br><span class="line">    containerView.sendSubviewToBack<span class="params">(toViewController.view)</span></span><br><span class="line">    </span><br><span class="line">    UIView.animateWithDuration<span class="params">(transitionDuration<span class="params">(transitionContext)</span>, animations: &#123;</span><br><span class="line">        fromViewController.view.frame = CGRectInset<span class="params">(fromViewController.view.frame, fromViewController.view.frame.size.width / <span class="number">2</span>, fromViewController.view.frame.size.height / <span class="number">2</span>)</span></span><br><span class="line">        toViewController.view.alpha = <span class="number">1.0</span></span><br><span class="line">    &#125;, completion: &#123;</span><br><span class="line">        finished in</span><br><span class="line">        transitionContext.completeTransition<span class="params">(<span class="literal">true</span>)</span></span><br><span class="line">    &#125;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这与实现presentation transition非常相似。在<code>animateTransition()</code>功能中，我们得到to view controller和from view controller。这里的 <code>to view controller</code>作为table view controller。我们改变其view的alpha值，以便我们开始制作动画效果时它会在淡出时迅速消失。之后我们把view添加到container并把它放置在from view controller的view后面以保证其不可视。</p>
<p>在动画块中，我们为<code>from view</code>的尺寸制作动画效果，使其宽和高为0并保持居中。这样我们就可以得到一个将<code>from view</code>缩减至无的效果。我们还会把<code>to view</code>的alpha进行动态化以便使其完全可视。</p>
<p>添加以下属性至ItemsTableViewController中。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let customDismissAnimationController = <span class="function"><span class="title">CustomDismissAnimationController</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>添加以下功能至类中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">animationControllerForDismissedController</span><span class="params">(dismissed: UIViewController)</span></span> -&amp;gt; <span class="type">UIViewControllerAnimatedTransitioning</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> customDismissAnimationController</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>UIViewControllerTransitioningDelegate</code>协议提供了以上功能，把一个解散的view controller中的animation controller收回。</p>
<p>运行app我们可以看到以下效果。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/03/vid05.gif" alt="pic-7"></p>
<p>这个动画效果并不是我们预期的。大家可以看到，from view的白色框架如我们所预期的缩小了，但是view中的image的尺寸并没有变化。这是因为view的边框改变并不影响其子框架。那么我们将使用UIView snapshotting来修复。</p>
<p>UIView snapshotting的工作原理是通过给现有的UIView生成快照并将其放入一个轻量级UIView。之后我们会在淡出动画，而不是实际view中使用这张快照。</p>
<p>用以下代码替换<code>animateTransition()</code>功能。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">func animateTransition<span class="params">(transitionContext: UIViewControllerContextTransitioning)</span> &#123;</span><br><span class="line">    <span class="built_in">let</span> fromViewController = transitionContext.viewControllerForKey<span class="params">(UITransitionContextFromViewControllerKey)</span><span class="built_in">!</span></span><br><span class="line">    <span class="built_in">let</span> toViewController = transitionContext.viewControllerForKey<span class="params">(UITransitionContextToViewControllerKey)</span><span class="built_in">!</span></span><br><span class="line">    <span class="built_in">let</span> finalFrameForVC = transitionContext.finalFrameForViewController<span class="params">(toViewController)</span></span><br><span class="line">    <span class="built_in">let</span> containerView = transitionContext.containerView<span class="params">()</span></span><br><span class="line">    toViewController.view.frame = finalFrameForVC</span><br><span class="line">    toViewController.view.alpha = <span class="number">0.5</span></span><br><span class="line">    containerView.addSubview<span class="params">(toViewController.view)</span></span><br><span class="line">    containerView.sendSubviewToBack<span class="params">(toViewController.view)</span></span><br><span class="line">        </span><br><span class="line">    <span class="built_in">let</span> snapshotView = fromViewController.view.snapshotViewAfterScreenUpdates<span class="params">(<span class="literal">false</span>)</span></span><br><span class="line">    snapshotView.frame = fromViewController.view.frame</span><br><span class="line">    containerView.addSubview<span class="params">(snapshotView)</span></span><br><span class="line">        </span><br><span class="line">    fromViewController.view.removeFromSuperview<span class="params">()</span></span><br><span class="line">        </span><br><span class="line">    UIView.animateWithDuration<span class="params">(transitionDuration<span class="params">(transitionContext)</span>, animations: &#123;</span><br><span class="line">        snapshotView.frame = CGRectInset<span class="params">(fromViewController.view.frame, fromViewController.view.frame.size.width / <span class="number">2</span>, fromViewController.view.frame.size.height / <span class="number">2</span>)</span></span><br><span class="line">        toViewController.view.alpha = <span class="number">1.0</span></span><br><span class="line">    &#125;, completion: &#123;</span><br><span class="line">        finished in</span><br><span class="line">        snapshotView.removeFromSuperview<span class="params">()</span></span><br><span class="line">        transitionContext.completeTransition<span class="params">(<span class="literal">true</span>)</span></span><br><span class="line">    &#125;)</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们会创建一个<code>from view controller</code>的view的快照，将其添加到container并把container中的<code>from view</code>移出。之后我们在动画中缩小这张快照，动画完成后，将snapshot view从container中移出。</p>
<p>再次运行时动画应该会很顺畅了。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/03/vid06.gif" alt="pic-8"></p>
<h2 id="Navigation_controller_transitions">Navigation controller transitions</h2><p>我们已经在modal view controller presentation中添加了一个自定义切换，这个自定义切换中的presenting view controller添加了transitioning delegate。但是，当我们使用<code>UITabBarController</code>或<code>UINavigationController</code>来工作时，每个view controller都设置一个delegate就显得非常麻烦。</p>
<p>这些controller提供了一个更简单的方法，通过这个方法transition的animationcontroller会通过<code>UITabBarControllerDelegate</code> 或 <code>UINavigationControllerDelegate</code>来提供。</p>
<p>在navigation controller中添加一个自定义切换后我们可以看到其运转状态。</p>
<p>首先，创建一个animation controller。创建一个名为<code>CustomNavigationAnimationController</code>的类，将其作为<code>NSObject</code>的子类并按下列方式更改其定义。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomNavigationAnimationController</span>: <span class="typename">NSObject</span>, <span class="typename">UIViewControllerAnimatedTransitioning &#123;</span></span></span><br></pre></td></tr></table></figure>
<p>将以下代码添加到类中。对于这个animation controller，我本人使用的是一个简版的<a href="https://github.com/andresbrun/ABCustomUINavigationController#cube" target="_blank" rel="external">this cube animation</a>。我们只需要像前面提到的两个animation controller一样建立这个animation controller。需要注意逆类变量。我们要用它来决定动画的方向，取决于我们是否从主视图过渡到详细视图或从详细视图过渡到主视图。</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">var reverse: Bool = false</span><br><span class="line">    </span><br><span class="line">func transitionDuration(transitionContext: UIViewControllerContextTransitioning) -&amp;gt; NSTimeInterval &#123;</span><br><span class="line">    return <span class="number">1.5</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">func animateTransition(transitionContext: UIViewControllerContextTransitioning) &#123;</span><br><span class="line">    let containerView = transitionContext.containerView()</span><br><span class="line">    let <span class="keyword">to</span>ViewController = transitionContext.viewControllerForKey(UITransitionContextToViewControllerKey)!</span><br><span class="line">    let <span class="keyword">from</span>ViewController = transitionContext.viewControllerForKey(UITransitionContextFromViewControllerKey)!</span><br><span class="line">    let <span class="keyword">to</span>View = <span class="keyword">to</span>ViewController.view</span><br><span class="line">    let <span class="keyword">from</span>View = <span class="keyword">from</span>ViewController.view</span><br><span class="line">    let direction: CGFloat = reverse ? -<span class="number">1</span> : <span class="number">1</span></span><br><span class="line">    let const: CGFloat = -<span class="number">0.005</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">to</span>View.layer.<span class="built_in">anchor</span>Point = CGPointMake(direction == <span class="number">1</span> ? <span class="number">0</span> : <span class="number">1</span>, <span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">from</span>View.layer.<span class="built_in">anchor</span>Point = CGPointMake(direction == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>, <span class="number">0.5</span>)</span><br><span class="line">        </span><br><span class="line">    var viewFromTransform: CATransform3D = CATransform3DMakeRotation(direction * CGFloat(M_PI_2), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>)</span><br><span class="line">    var viewToTransform: CATransform3D = CATransform3DMakeRotation(-direction * CGFloat(M_PI_2), <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>)</span><br><span class="line">    viewFromTransform.m34 = const</span><br><span class="line">    viewToTransform.m34 = const</span><br><span class="line">        </span><br><span class="line">    containerView.transform = CGAffineTransformMakeTranslation(direction * containerView.frame.size.width / <span class="number">2.0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">to</span>View.layer.transform = viewToTransform</span><br><span class="line">    containerView.addSubview(<span class="keyword">to</span>View)</span><br><span class="line">        </span><br><span class="line">    UIView.animateWithDuration(transitionDuration(transitionContext), animations: &#123;</span><br><span class="line">        containerView.transform = CGAffineTransformMakeTranslation(-direction * containerView.frame.size.width / <span class="number">2.0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">from</span>View.layer.transform = viewFromTransform</span><br><span class="line">        <span class="keyword">to</span>View.layer.transform = CATransform3DIdentity</span><br><span class="line">    &#125;, completion: &#123;</span><br><span class="line">        finished <span class="keyword">in</span></span><br><span class="line">        containerView.transform = CGAffineTransformIdentity</span><br><span class="line">        <span class="keyword">from</span>View.layer.transform = CATransform3DIdentity</span><br><span class="line">        <span class="keyword">to</span>View.layer.transform = CATransform3DIdentity</span><br><span class="line">        <span class="keyword">from</span>View.layer.<span class="built_in">anchor</span>Point = CGPointMake(<span class="number">0.5</span>, <span class="number">0.5</span>)</span><br><span class="line">        <span class="keyword">to</span>View.layer.<span class="built_in">anchor</span>Point = CGPointMake(<span class="number">0.5</span>, <span class="number">0.5</span>)</span><br><span class="line">    </span><br><span class="line">        if (transitionContext.transitionWasCancelled()) &#123;</span><br><span class="line">            <span class="keyword">to</span>View.removeFromSuperview()</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            <span class="keyword">from</span>View.removeFromSuperview()</span><br><span class="line">        &#125;</span><br><span class="line">        transitionContext.completeTransition(!transitionContext.transitionWasCancelled())</span><br><span class="line">    &#125;)        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打开ItemsTableViewController并按照以下内容修改类定义。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ItemsTableViewController</span>: <span class="typename">UITableViewController</span>, <span class="typename">UIViewControllerTransitioningDelegate</span>, <span class="typename">UINavigationControllerDelegate &#123;</span></span></span><br></pre></td></tr></table></figure>
<p><code>UINavigationControllerDelegate</code>提供animation controller。</p>
<p>将以下属性添加到类中。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let customNavigationAnimationController = <span class="function"><span class="title">CustomNavigationAnimationController</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>在<code>viewDidLoad()</code>末尾添加以下代码。</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navigationController?.<span class="keyword">delegate</span> = <span class="keyword">self</span></span><br></pre></td></tr></table></figure>
<p>以上步骤设置了host navigation controller的delegate以便新的transition delegate方法能够被收到。</p>
<p>然后将以下代码添加到类中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">navigationController</span><span class="params">(navigationController: UINavigationController, animationControllerForOperation operation: UINavigationControllerOperation, fromViewController fromVC: UIViewController, toViewController toVC: UIViewController)</span></span> -&amp;gt; <span class="type">UIViewControllerAnimatedTransitioning</span>? &#123;</span><br><span class="line">    customNavigationAnimationController.<span class="built_in">reverse</span> = operation == .<span class="type">Pop</span></span><br><span class="line">    <span class="keyword">return</span> customNavigationAnimationController</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上功能称之为请求animation controller在from view controller和to view controller之间进行导航，它会返回animation controller的实例。切换的方向取决于这是一个push navigation还是一个pop navigation操作。</p>
<p>运行app。选择一个table view cell后大家看到的动画效果如下。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/03/vid07.gif" alt="pic-9"></p>
<h2 id="使其更具交互式特点">使其更具交互式特点</h2><p>接下来我们将使以上切换更具交互式特点，也就是说，用户能够通过手势控制切换。</p>
<p>iOS内置app具有这个特点。我们可以从屏幕左侧滑动来发起切换，代替后退按钮的功能。大家可以进行短暂滑动以下来简单查看主视图，然后取消切换。滑动距离稍长就会触发pop navigation操作。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/03/vid08.gif" alt="pic-10"></p>
<p>首先，我们需要一个interaction controller。交互式controller使用<code>UIViewControllerInteractiveTransitioning</code>协议。navigation controller delegate 或 transitioning delegate在请求animation controller后会要求一个可选的interaction controller。</p>
<p>我们来创建一个interaction controller。创建一个新的类，取名为<code>CustomInteractionController</code>并使其作为<code>UIPercentDrivenInteractiveTransition</code>的子类。</p>
<p><code>UIPercentDrivenInteractiveTransition</code> implements the <code>UIViewControllerInteractiveTransitioning</code> protocol so we wont have to add that to our class.</p>
<p>由于<code>UIPercentDrivenInteractiveTransition</code> 实现 <code>UIViewControllerInteractiveTransitioning</code>协议，所以我们不需要添加到类中。</p>
<p>要想使用<code>UIPercentDrivenInteractiveTransition</code>，animation controller必须使用单个UIView动画，以便动画能够被停止、翻转及使用。</p>
<p>把以下代码添加到类中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> navigationController: <span class="type">UINavigationController</span>!</span><br><span class="line"><span class="keyword">var</span> shouldCompleteTransition = <span class="literal">false</span></span><br><span class="line"><span class="keyword">var</span> transitionInProgress = <span class="literal">false</span></span><br><span class="line"><span class="keyword">var</span> completionSeed: <span class="type">CGFloat</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> - percentComplete</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">attachToViewController</span><span class="params">(viewController: UIViewController)</span></span> &#123;</span><br><span class="line">    navigationController = viewController.navigationController</span><br><span class="line">    setupGestureRecognizer(viewController.view)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">private <span class="func"><span class="keyword">func</span> <span class="title">setupGestureRecognizer</span><span class="params">(view: UIView)</span></span> &#123;</span><br><span class="line">        view.addGestureRecognizer(<span class="type">UIPanGestureRecognizer</span>(target: <span class="keyword">self</span>, action: <span class="string">"handlePanGesture:"</span>))</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">handlePanGesture</span><span class="params">(gestureRecognizer: UIPanGestureRecognizer)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> viewTranslation = gestureRecognizer.translationInView(gestureRecognizer.view!.superview!)</span><br><span class="line">    <span class="keyword">switch</span> gestureRecognizer.state &#123;</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Began</span>:</span><br><span class="line">        transitionInProgress = <span class="literal">true</span></span><br><span class="line">        navigationController.popViewControllerAnimated(<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Changed</span>:</span><br><span class="line">        <span class="keyword">var</span> const = <span class="type">CGFloat</span>(fminf(fmaxf(<span class="type">Float</span>(viewTranslation.x / <span class="number">200.0</span>), <span class="number">0.0</span>), <span class="number">1.0</span>))</span><br><span class="line">        shouldCompleteTransition = const &amp;gt; <span class="number">0.5</span></span><br><span class="line">        updateInteractiveTransition(const)</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Cancelled</span>, .<span class="type">Ended</span>:</span><br><span class="line">        transitionInProgress = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> !shouldCompleteTransition || gestureRecognizer.state == .<span class="type">Cancelled</span> &#123;</span><br><span class="line">            cancelInteractiveTransition()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            finishInteractiveTransition()</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"Swift switch must be exhaustive, thus the default"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>attachToViewController()</code>方法获得navigation controller在发生手势操作时用来发起pop transition的引用。下一步，我们设立一个手势识别器，滑动操作时识别器会调用<code>handlePanGesture()</code>方法。这检查了手势识别器的状态并在每一个阶段执行下列操作：</p>
<ul>
<li>开始：把<code>transitionInProgress</code> 设为真，并发起pop navigation。</li>
<li>更改：此时手势正在进行，所以它决定了切换的百分比。一个200点滑动会是切换达到100%。之后它将通过手势停止的地方来判断切换是否完成。此时我们要确定用户是否在释放前滑到了屏幕的一半处。</li>
<li>取消/结束：如果<code>shouldCompleteTransition</code>被设为假或者手势被取消，把<code>transitionInProgress</code>设为假，并取消切换。否则，切换完成。</li>
</ul>
<p>我们使用计算属性来确定完成速度。<code>completionSeed</code>具有<code>UIPercentDrivenInteractiveTransition</code>属性，它会在手势完成时通知框架还剩多少动画。如果互动取消，数字更大会使view controller更迅速返回。</p>
<p>打开ItemsTableViewController.swift 并把下列代码添加到类中之后，大家就可以使用我们的interaction controller了。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let customInteractionController = <span class="function"><span class="title">CustomInteractionController</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>在<code>navigationController(_:animationControllerForOperation:
fromViewController:toViewController:)</code>功能起始处添加以下代码。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> operation == .<span class="keyword">Push</span> &#123;</span><br><span class="line">    customInteractionController.attachToViewController(toVC)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它会调用CustomInteractionController的<code>attachToViewController()</code>方法并在发现push navigation操作时给这个方法传递to view controller的一个引用。</p>
<p>然后添加以下代码到类中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">navigationController</span><span class="params">(navigationController: UINavigationController, interactionControllerForAnimationController animationController: UIViewControllerAnimatedTransitioning)</span></span> -&amp;gt; <span class="type">UIViewControllerInteractiveTransitioning</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> customInteractionController.transitionInProgress ? customInteractionController : <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>框架请求并获得animation controller后，它会使用以上方法请求interaction controller。如果切换正在进行，那么将会返回interaction controller的一个实例。</p>
<p>运行app后我们将看到如图所示的切换。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/03/vid09.gif" alt="pic-11"></p>
<h2 id="总结">总结</h2><p>大家已经知道如何创建自定义view controller切换以及如何使切换具有交互性。有了这些特性之后，开发者可以完全掌控app中从一个view切换到另一个view时使用的动画，由此带给用户更好的体验。大家可以在<a href="https://github.com/appcoda/CustomViewTransitionDemo" target="_blank" rel="external">此处下载项目</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="使用Swift自定义ViewController切换效果与动画">使用Swift自定义ViewController切换效果与动画</h1><blockquote>
<ul>
<li>原文链接 : <a href="http://www.appcoda.com/cu]]>
    </summary>
    
      <category term="Animation" scheme="http://ytlvy.com/tags/Animation/"/>
    
      <category term="Swift" scheme="http://ytlvy.com/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift Back to the Future]]></title>
    <link href="http://ytlvy.com/2015/08/08/Swift-Back-to-the-Future/"/>
    <id>http://ytlvy.com/2015/08/08/Swift-Back-to-the-Future/</id>
    <published>2015-08-08T13:07:52.000Z</published>
    <updated>2015-08-08T13:08:22.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Swift的异步机制-Future">Swift的异步机制-Future</h1><hr>
<blockquote>
<ul>
<li>原文链接 : <a href="https://realm.io/news/swift-summit-javier-soto-futures/" target="_blank" rel="external">Back to the Future</a></li>
<li>原文作者 : <a href="https://twitter.com/Javi" target="_blank" rel="external">Javier Soto</a></li>
<li><a href="http://www.devtf.cn" target="_blank" rel="external">译文出自 :  开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="http://shidanqing.net" target="_blank" rel="external">sdq</a> </li>
</ul>
</blockquote>
<p>我们在使用Objective-C写异步代码时常常会出现许多问题。它没有很好的错误处理机制，当你发现你需要在你的异步函数中创建新的异步函数它也没有一个很好的可伸缩实现。在这次演讲中，Javier Soto将演示实现一个能够简化异步API的Swift Future类型。并且创建一个Resule类型,我们可以在这个类型上调用map和andThen等操作。对于Swift来说，Futures的未来可能很会基于信号和eactiveCocoa 3。</p>
<p>你可以在<a href="https://github.com/JaviSoto/Talks#swift-summit-2015-back-to-the-futures" target="_blank" rel="external">这里</a>看到这次演讲中的代码。</p>
<h2 id="更优雅地使用Swift">更优雅地使用Swift</h2><p>谢谢各位，很高兴和大家一起来聊一聊Swift，感谢组织者把我们聚集在一起并让我在这里演讲。我的名字叫Javi，是来自Twitter的iOS工程师。</p>
<p>相比于Objective-C，我们在Swift里可以把很多事做得更好。我们已经在之前的演讲中看了不少例子，我想紧接着着他们，和大家谈论一下一种我想引入Swift的设计模式。这种设计模式会使我们的代码更为优雅。</p>
<a id="more"></a>
<h2 id="如今的异步API">如今的异步API</h2><p>今天我不会讲一些很空理论，而是通过实践和大家一起讨论。接下来会看到，在传统情况下我们是如何使用异步API的，并且在使用过程中存在的一些问题，尤其是对错误的处理。然后我会介绍一个简单的Future API，我们会看到它使如何提升我们的异步代码的。</p>
<p>让我们看看如今的问题在哪里？</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span> </span>&#123; <span class="keyword">let</span> avatarURL: <span class="type">NSURL</span> &#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">requestUserInfo</span><span class="params">(userID: String, completion: <span class="params">(User?, NSError?)</span></span></span> -&gt; ())</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">downloadImage</span><span class="params">(URL: NSURL, completion: <span class="params">(UIImage?, NSError?)</span></span></span> -&gt; ())</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">loadAvatar</span><span class="params">(userID: String, completion: <span class="params">(UIImage?, NSError?)</span></span></span> -&gt; ()) &#123;</span><br><span class="line">    requestUserInfo(userID) &#123; user, error <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> user = user &#123;</span><br><span class="line">            downloadImage(user.avatarURL) &#123; avatar, error <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> avatar = avatar &#123; completion(avatar, <span class="literal">nil</span>) &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; completion(<span class="literal">nil</span>, error!) &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; completion(<span class="literal">nil</span>, error!) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是我们参照Objective-C异步API的方法写的Swift代码，其中包含大量的嵌套回调函数。我们可以看到loadAvatar方法，该方法的输入为用户ID，函数体完成对该用户头像的下载。其中，complete block需要传入一个image及一个error，但其实这个方法没有任何逻辑可言。方法本身不知道该如何进一步处理，其内部包含了一些异步方法来完成整个操作，包括采用requestUserInfo方法异步获取用户信息，以及一个下载图片的方法downloadImage。每一次我们都需要检查错误，执行完以后再调用completion block。</p>
<p>你们中的大部分可能已经习惯了这样的代码，但这样的模式非常不容易扩展。即使你没有使用过PHP，你也肯定看到过这样的场景（演讲者展示了一张异步代码层层嵌套的图）。所以让我们避免这样的情况发生吧，我们可以做的更好。此外，这段代码还有一些其它特殊的问题。其中的一个异步API将会查看参数类型。completion block需要传入的一个元祖或者两个数值；它们都是optional型的，因为下载失败的话image会返回nil，而下载成功没有错误的话error会返回nil。</p>
<p>这些问题会让你不爽，但你要知道问题其实一直存在，只是你从没有发现而已。在Objective-C中它们比较隐晦，因为任何类型都可以产生nil值。</p>
<p>如果我们看一下所有可能发生的情况，我们会发现总共有两种：一种是图片下载成功没有error，另一种是图片下载失败发生error。有趣的是其实还存在其余两种可能的情况，但完全没有任何意义。我的app该如何处理即有图片又有错误的状况呢？又或者当既没有图片又没有错误时，会发生什么？</p>
<h2 id="错误处理的重要性">错误处理的重要性</h2><p>我常常喜欢说我认为的计算机是不会犯错的完美机器，每当我们遇到了bug，那都是因为攻城狮所希望的与实际要求计算机去做的产生了冲突。如果我们没有一个很好地方式来表达如何能完成我们的设想，那很可能导致我们对计算机下达了错误的命令。</p>
<p>我认为错误处理非常重要，我们需要用合适的方式在应用程序中处理错误。上述这类API会令你在很多情况下用错，举个例子，你可能会首先检查error而不是先查看数值，虽然已经执行成功了，但你仍然会担心产生错误。</p>
<h2 id="我讨厌NSError">我讨厌NSError</h2><p>然后是NSError，我非常讨厌NSError,但我不能责怪Apple，因为老实说这的确是Objective-C中针对error最好的做法了。让我们再看一个例子看一下为什么NSError容易产生问题。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> error: <span class="type">NSError</span>?</span><br><span class="line"><span class="keyword">let</span> string = <span class="type">NSString</span>(contentsOfFile:path encoding:<span class="type">NSUTF8Encoding</span> error:&amp;error)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> string == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// Oops:</span></span><br><span class="line">    <span class="keyword">if</span> error.code == <span class="type">NSFileReadNoSuchFileError</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码有错误，但是并不是非常明显。我们调用了Foundation API，如果查看文档，会发现我们完全不知道返回的是什么类型的错误，既没有提到领域，也没有提及错误代码。这段代码首先查看错误代码而不是先查看领域，这是没有任何意义的，因为在完全不同的领域可能产生相同的错误代码，非常容易误导开发者。另一种情况是，我们可以传nil给error，告诉Foundation“我不在乎error”，但是我认为鲁棒性强的软件应该认真处理错误。</p>
<p>我们每天都会遇到这样令人抓狂的情况，但我们无法责备开发者。如果我们的工具不能让这一切变得简单、让错误处理更方便，那我们只会变得更懒，我们将会向方法里传nil值，然后忽略这些error。我们不会去了解那些错误是什么，而是让它们显示在控制台然后继续。</p>
<h2 id="一个提议">一个提议</h2><p>这里我有一个提议：我们可以用自己定义的类型来封装我们API中可能产生的错误，而不是使用NSError。我们可以写一个protocol包含所有可能发生的错误类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ErrorType</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UserInfoErrorDomain</span>: <span class="title">ErrorType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">UserDoesNotExist</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">UserRequestFailure</span>(reason: <span class="type">String</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">NetworkRequestFailure</span>(reason: <span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSError</span>: <span class="title">ErrorType</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>举个例子，如果我们有一个API，我们可以声明一个遵循此protocol的枚举类型，包含了三种清楚的错误情况。这里甚至可以提供原因的信息，之后可以看到我们如何进行使用。如果确实想用NSError，我们也可以将其包含在内。</p>
<p>另一件看似矛盾但是却很酷的事情是，我们甚至可以创建一个NoError类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">NoError</span>: <span class="title">ErrorType</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> error = <span class="type">NoError</span>(?)</span><br></pre></td></tr></table></figure>
<p>很奇怪是吧？由于它是空的枚举，我们实际上不能创建这种类型，因为它不存在任何构造函数。虽然没有意义，但是我们知道null类型是可以被构造的。如果API返回的error值是NOError类型，那API就会报错，我们不再需要通过单元测试进行检验，编译器就会替我们发现。</p>
<h2 id="采用Future建立Result类型">采用Future建立Result类型</h2><p>如Brian在之前的演讲里所叙述的那样，这里我们会在Result类型的基础上展开一些工作，Result无论成功或者失败都可以产生一个值。在这页slide里我做了点手脚，因为由于编译器的限制，目前这个代码在Swift里是无法实现的，你必须用class的形式来想办法实现，但我还是先用简单的形式在这里展示以免影响理解。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span>&lt;<span class="title">T</span>, <span class="title">E</span>: <span class="title">ErrorType</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Success</span>(<span class="type">T</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Error</span>(<span class="type">E</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在让我们来看一下Future，我们如何来实现呢？希望通过研究其实现的过程，我们能够更加理解其价值，这会很有趣！那什么是Future呢？你可能在其它语言或者框架里听到过它的另外一个名字——Promise。它们的概念是完全相同的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Future</span>&lt;<span class="title">T</span>, <span class="title">E</span>: <span class="title">ErrorType</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">ResultType</span> = <span class="type">Result</span>&lt;<span class="type">T</span>, <span class="type">E</span>&gt;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Completion</span> = <span class="type">ResultType</span> -&gt; ()</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">AsyncOperation</span> = <span class="type">Completion</span> -&gt; ()</span><br><span class="line"></span><br><span class="line">    private <span class="keyword">let</span> operation: <span class="type">AsyncOperation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Future包含了不一样的处理方式，可以对一段时间后才能获取数据先进行抽象的处理，比如网络延迟的情况。或许有人会说 “那是不是像闭包？”或者 “这不就是回调函数！” 不过Future的优势在于，我们可以像已经获取了数据那样进行操作，并且不用关心那些无关的异步操作，使我们的代码变得更简洁。</p>
<h2 id="实施Future">实施Future</h2><p>让我们开始实践吧。我们创建一个struct，类似Result它具有T和E的泛型，因为我们需要使用Result。我定义了一些别名用来帮助我们处理这些类型。我们之前看到过Result，同时需要一个可以触发的completion用于当你向Future要求，“现在给我值吧！”。你将会进到completion block里，它会获取到result并且不会返回任何东西。异步合并是一个闭包，当需要一个函数返回值的时候被调用。这时候completion块被调用，并且告知其函数工作的完成，并且不会返回任何值。Future封装了一些操作处理，我们可以在实例化中直接传入这些操作符。最重要的共有API是start方法，API的使用者可以通过此方法来告诉Future，“Ok，你现在可以去获取数据了，获取完之后交给我”。但是到现在为止用处不大，除了使用Result的方法不同外，它看起来完全和completion block一样。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Future</span>&lt;<span class="title">T</span>, <span class="title">E</span>: <span class="title">ErrorType</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>(operation: <span class="type">AsyncOperation</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.operation = operation</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">start</span><span class="params">(completion: Completion)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.operation() &#123; result <span class="keyword">in</span></span><br><span class="line">            completion(result)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="map_&amp;_andThen">map &amp; andThen</h3><p>Future真正酷的是在我们实现一些操作的时候。我想要实现map和andThen，让我们先从map开始吧。我们可以用map方法实现的一些功能。比如我们有了用户的ID，然后我们想取得用户头像的链接地址。我们创建一个方法来完成这个功能，另外我们还有一个已经创建出的方法用以下载用户信息并给我们一个基本的用户信息的结构体，也就是URL。如果我们想不用一堆回调来将其中一个转换为另一个，那可以先map，然后通过返回user内部的其它数据进行转换。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span> </span>&#123; <span class="keyword">let</span> avatarURL: <span class="type">NSURL</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">requestUserInfo</span><span class="params">(userID: String)</span></span> -&gt; <span class="type">Future</span>&lt;<span class="type">User</span>, <span class="type">ErrorDomain</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">requestUserAvatarURL</span><span class="params">(userID: String)</span></span> -&gt; <span class="type">Future</span>&lt;<span class="type">NSURL</span>, <span class="type">ErrorDomain</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> requestUserInfo(userID)</span><br><span class="line">    .<span class="built_in">map</span> &#123; $<span class="number">0</span>.avatarURL &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是函数签名的样子。比较一下它与map的函数签名你会发现很有意思，举个例子，两种类型都是出自swift标准库，Array和Optional。如果我们看一下类型，它们是完全一样的。他们会用函数来将获取的T类型值生成U类型的结果，其中T是容器内部的类型，而U将是新容器的类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">map</span><span class="generics">&lt;U&gt;</span><span class="params">(f: T -&gt; U)</span></span> -&gt; [<span class="type">U</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Optional</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">map</span><span class="generics">&lt;U&gt;</span><span class="params">(f: T -&gt; U)</span></span> -&gt; <span class="type">U</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Future</span>&lt;<span class="title">T</span>, <span class="title">E</span>: <span class="title">ErrorType</span>&gt; </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">map</span><span class="generics">&lt;U&gt;</span><span class="params">(f: T -&gt; U)</span></span> -&gt; <span class="type">Future</span>&lt;<span class="type">U</span>, <span class="type">E</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现map">实现map</h2><p>那么让我们实现它吧。我们需要创建一个新的Future，因为它必须是U型的。我们用下列的方法来验证Future模式的机制。就像我们看到的，方法传给Future一个运算操作。为了转变数值，我们首先需要获得数值，所以我们调用开始方法从而得到结果。该结果可以是成功或失败，因此我们需要根据其情况处理。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">map</span><span class="generics">&lt;U&gt;</span><span class="params">(f: T -&gt; U)</span></span> -&gt; <span class="type">Future</span>&lt;<span class="type">U</span>, <span class="type">E</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Future</span>&lt;<span class="type">U</span>, <span class="type">E</span>&gt;(operation: &#123; completion <span class="keyword">in</span></span><br><span class="line">        <span class="comment">// Retrieve the value from self...</span></span><br><span class="line">        <span class="keyword">self</span>.start &#123; result <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先让我们看一下成功的情况。成功的情况下，如同类型签名那样，告诉我们需要通过F函数转化得到想要的数值 - 我们将再次在成功条件下运行它，然后会调用completion block。错误的情况下就更简单了。我们没有value，我们不能进行转换，只需要调用completion block。这就和幻灯片里显示的一样。</p>
<p>在错误情况下发生的短路情况和Brain之前展示的面向铁路对象编程概念基本一样。但是现在我们想要用最初Future给我们的value做一些事，但我们希望获取一个新的value。获取该value不像调用头像URL一样简单。获取该value会导致一些延迟，比如当我们需要另一个网络请求。</p>
<h2 id="声明andThen">声明andThen</h2><p>这是行不通的，因为我们需要通过一个函数来返回另一个Future。因此，我们想要再Future API上声明一个Future和一个andThen函数。我们会这样使用，例如：如果我们有一个像刚才看到的请求头像URL，可以在之前的操作后紧接着下载图片，返回头像图片的Future。我们只需要调用andThen函数并传其它的函数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">requestUserAvatarURL</span><span class="params">(userID: String)</span></span> -&gt; <span class="type">Future</span>&lt;<span class="type">NSURL</span>, <span class="type">ErrorDomain</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">downloadImage</span><span class="params">(URL: NSURL)</span></span> -&gt; <span class="type">Future</span>&lt;<span class="type">UIImage</span>, <span class="type">ErrorDomain</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">downloadUserAvatar</span><span class="params">(userID: String)</span></span> -&gt; <span class="type">Future</span>&lt;<span class="type">UIImage</span>, <span class="type">ErrorDomain</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> requestUserAvatarURL(userID)</span><br><span class="line">    .andThen(downloadImage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是签名的样子，类似map，就像我说的重要的区别是，F函数不返回U，它返回的是一个新的Future。实现它非常非常相似。我们重新建立一个Future，初始化并取得value，然后选择Result。在成功的情况下，当我们在value上调用F，我们没有可以返回的value。现在我们有了另一个Future，我们需要启动它，当我们完成得到最后的Result。</p>
<p>在错误的情况下，我们需要对其短路。如果我们没有一个value，就不能转换它，以便继续做更多的操作。我们需要马上调用completion block。这就是整个的实现过程，你会意识到它看起来很像map。事实上，有趣的是你可以在其他情况下实现它，但我选择了单独实现来看看他们会做些什么。</p>
<p>让我们来看看已经完成的工作。我们从嵌套混乱复杂的回调函数以及每次单独调用都会涉及错误处理的情形，转变为通过一个声明方法来告诉我们需要获取头像：我们需要请求用户信息，将它map到头像的URL，然后下载图像。这不是关于代码的能力，它是关于我们在代码中要表达我们的意图的能力。不过其最大的优势在于，代码中不再有错误处理的内容，所有的error都会在运行中自动被识别。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">andThen</span><span class="generics">&lt;U&gt;</span><span class="params">(f: T -&gt; Future&lt;U, E&gt;)</span></span> -&gt; <span class="type">Future</span>&lt;<span class="type">U</span>, <span class="type">E</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Future</span>&lt;<span class="type">U</span>, <span class="type">E</span>&gt;(operation: &#123; completion <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">self</span>.start &#123; firstFutureResult <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">switch</span> firstFutureResult &#123;</span><br><span class="line">                <span class="keyword">case</span> .<span class="type">Success</span>(<span class="keyword">let</span> value): <span class="comment">// ...</span></span><br><span class="line">                <span class="keyword">case</span> .<span class="type">Error</span>(<span class="keyword">let</span> error): <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Future的局限性">Future的局限性</h2><p>我希望你们会和我一样喜欢Future，Future也的确和我想的一样具有实用价值。但是，了解Future的缺陷也同样重要。文中的例子在我们的移动应用中很常见，会存在网络请求，会存在异步请求等等，但是问题是我们不仅仅只处理异步事件；另外，当返回值不只有一个值时Future就会失效，Future只能处理一个值，而当我们处理用户交互的时候，像手势识别，往往会存在多个值的情况。</p>
<p>另一个问题是我们在上文处理的情景并不是用户驱动的，就像交互时你不会告诉app “我现在准备触碰手机了”。 这些行为完全是用户决定的，程序无法预测。</p>
<h2 id="Signals">Signals</h2><p>好消息是Future正在变得更好。Signals将会解决以上遇到的问题。Signals是一个非常有效的工具。</p>
<p>另一件令人兴奋得事情是我们不必自己去实现它。你可能已经听过了ReactiveCocoa可以用来实现signals并允许你的app使用这些概念。ReactiveCocoa 3是用swift写的，可以在Github上找到。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Swift的异步机制-Future">Swift的异步机制-Future</h1><hr>
<blockquote>
<ul>
<li>原文链接 : <a href="https://realm.io/news/swift-summit-javier-soto-futures/">Back to the Future</a></li>
<li>原文作者 : <a href="https://twitter.com/Javi">Javier Soto</a></li>
<li><a href="http://www.devtf.cn">译文出自 :  开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="http://shidanqing.net">sdq</a> </li>
</ul>
</blockquote>
<p>我们在使用Objective-C写异步代码时常常会出现许多问题。它没有很好的错误处理机制，当你发现你需要在你的异步函数中创建新的异步函数它也没有一个很好的可伸缩实现。在这次演讲中，Javier Soto将演示实现一个能够简化异步API的Swift Future类型。并且创建一个Resule类型,我们可以在这个类型上调用map和andThen等操作。对于Swift来说，Futures的未来可能很会基于信号和eactiveCocoa 3。</p>
<p>你可以在<a href="https://github.com/JaviSoto/Talks#swift-summit-2015-back-to-the-futures">这里</a>看到这次演讲中的代码。</p>
<h2 id="更优雅地使用Swift">更优雅地使用Swift</h2><p>谢谢各位，很高兴和大家一起来聊一聊Swift，感谢组织者把我们聚集在一起并让我在这里演讲。我的名字叫Javi，是来自Twitter的iOS工程师。</p>
<p>相比于Objective-C，我们在Swift里可以把很多事做得更好。我们已经在之前的演讲中看了不少例子，我想紧接着着他们，和大家谈论一下一种我想引入Swift的设计模式。这种设计模式会使我们的代码更为优雅。</p>]]>
    
    </summary>
    
      <category term="Future" scheme="http://ytlvy.com/tags/Future/"/>
    
      <category term="Swift" scheme="http://ytlvy.com/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift Reactive]]></title>
    <link href="http://ytlvy.com/2015/08/08/Swift-Reactive/"/>
    <id>http://ytlvy.com/2015/08/08/Swift-Reactive/</id>
    <published>2015-08-08T13:06:45.000Z</published>
    <updated>2015-08-08T13:07:16.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Swift的响应式编程">Swift的响应式编程</h1><hr>
<blockquote>
<ul>
<li>原文链接 : <a href="https://medium.com/swift-programming/reactive-swift-3b6050375534" target="_blank" rel="external">Reactive Swift</a></li>
<li>原文作者 : <a href="https://medium.com/@vasarhelyia" target="_blank" rel="external">Agnes Vasarhelyi</a></li>
<li><a href="http://www.devtf.cn" target="_blank" rel="external">译文出自 :  开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/bboyefiyu" target="_blank" rel="external">Mr.Simple</a> </li>
<li>校对者: <a href="https://github.com/Lollypo" target="_blank" rel="external">Lollypo</a>  </li>
<li>状态 :  完成</li>
</ul>
</blockquote>
<p>让我们首先回到Apple刚推出Objective-C的继任者-Swift的时候，那真是一个非比寻常的时刻。<br>Siri还没有开启地狱之门，Prezi还没有支持订阅，那时的朝鲜也还没有hack任何人的email。一种新语言的出现让我个人非常兴奋，尤其是这是一种类型安全的脚本语言。虽然Swift还在快速的发展中，但是我们不必担心它是否已经稳定。当那一刻到来之时，我应该已经知道如何交付整洁的、可测试的代码。还要有非常灵活、流畅的UI？如果你对Objective-C 和 MVC之外的东西感兴趣，那么就请继续读下去吧。</p>
<h2 id="MVC_与_MVVM">MVC 与 MVVM</h2><p>让我们从零开始，当我们设计一个应用时，你可能会先考虑应用的架构。Cocoa框架以<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html" target="_blank" rel="external">Model-View-Controller</a> (也称为 MVC)为基础架构，它的结构如下图所示。</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/1600/0*pEvMKHBK9HeAgrYC." alt=""></p>
<a id="more"></a>
<p>虽然，你可能发现这个架构并没有让你的设计更有效，从上图中我们可以看到Controller角色的职责太过复杂。如果你有在iOS或者Mac上使用MVC的经验，我打赌你已经领略到了View Controller承担了过多的职责。你使用MVC的经验越多，你就越会想找到另一个方法来解决掉MVC存在的这些问题。当使用MVC处理网络请求时，你会发现这会使得Controller变得极为臃肿，它不仅要处理获取数据的请求，同时也要负责将这些数据渲染到UI上。更蛋疼的是你有尝试过对一个ViewController进行单元测试吗？不堪回首啊！这涉及到View、业务逻辑的测试。随着View的复杂度的增长，它变得越来越难以维护。这就是为什么人们不对MVC进行测试的原因。</p>
<p><a href="http://www.objc.io/issue-13/mvvm.html" target="_blank" rel="external">Model-View-ViewModel</a> (也叫MVVM)对于你的应用来说是一个更好的选择。这是微软发布的一个针对事件驱动实现的、非常强大的架构模式。正如你看到的，与MVC不同的是这里的View持有ViewModel角色。</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/1600/0*SUaY1aSgIcvDys9j." alt=""></p>
<p>当然，这些都依赖于你想如何实现这个模式，不管如何，最终MVVM模式都会给你带来更低的复杂性、更好的可测试性。同时能达到这些效果吗？怎么可能？反正我相信了！它把所有的逻辑移到ViewModel角色中，以此来减少View Controller的职责。( 译者注: 关于MVC、MVP、MVVM的区别请参考<a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="external">这篇文章</a>。)</p>
<p><img src="http://img.blog.csdn.net/20150507120115027" alt="">       </p>
<p>闪开，让哥用一个项目来演示MVVM模式的使用，这是一个用来控制酒窖气温的半自动iOS客户端项目。如何你想了解更多关于这个项目的细节，可以参考<a href="http://blog.risingstack.com/brewfactory-full-stack-homebrew-with-iot/" target="_blank" rel="external">这篇文章</a>。这个项目的关键在于我们能够通过这个App看到酒窖中各个时间段的温度。</p>
<p>让我们回到MVVM与酒窖的温度上。为了能够读取到温度值，我们需要在我们的服务器上使用WebSocket，使得我们基于MVC架构的应用能够读取它，并且将它显示到iPhone上。首先我们需要建立一个Brew 模型类，这个类中有一个温度字段（ temp ）.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brew</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temp = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还需要建立一个将酒窖温度显示到UI上的ViewController。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BrewViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="preprocessor">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> tempLabel: <span class="type">UILabel</span>!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过MVC的方式，我们需要在ViewController中实现网络请求逻辑、更新UI的操作。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">socket.on(<span class="string">"temperature_changed"</span>, callback: &#123;(<span class="type">AnyObject</span> data) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>.brew.temp = data[<span class="number">0</span>] <span class="keyword">as</span> <span class="type">Float</span></span><br><span class="line">     dispatch_async(dispatch_get_main_queue(), &#123;</span><br><span class="line">       <span class="keyword">self</span>.updateTempLabel()</span><br><span class="line">     &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>更新UI的函数 : </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">updateTempLabel</span><span class="params">()</span></span> &#123;</span><br><span class="line">       <span class="keyword">self</span>.brewLabel.text =  <span class="type">NSString</span>(format:<span class="string">"%.2f ˚C"</span>, <span class="keyword">self</span>.brew.temp)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>此时，我们成功的把这些代码都放到一个ViewController中了，非常好不是吗？必须不是呐！</p>
<p>想象一下这种场景，当你需要先验证用户的身份、绘制一个实时的图表或者处理出入的字段时你如何实现？MVC架构的完整例子在<a href="https://gist.github.com/vasarhelyia/70b2c3fae2bbe38c4a7a" target="_blank" rel="external">这里</a>。但是现在，先让我们来看看基于MVVM架构的实现:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> brew = <span class="type">Brew</span>()</span><br><span class="line">dynamic <span class="keyword">var</span> temp: <span class="type">Float</span> = <span class="number">0.0</span> &#123;</span><br><span class="line">    <span class="keyword">didSet</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.brew.temp = temp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就是存储在ViewModel中的变量，虽然它们看起来有点陌生，但是我也不知道怎么才能使它们看起来不那么奇怪。不管它啦，我们先来看Socket: </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">socket.on(<span class="string">"temperature_changed"</span>, callback: &#123;(<span class="type">AnyObject</span> data) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">   <span class="keyword">self</span>.temp = data[<span class="number">0</span>] <span class="keyword">as</span> <span class="type">Float</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样，网络请求的逻辑就被移到了ViewModel中。但是我们如何修改UI呢？<a href="http://nshipster.com/key-value-observing/" target="_blank" rel="external">KVO</a>是我们的好朋友，我们就用它来实现，这里是viewDidLoad中的一个代码片段 : </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.brewViewModel.addObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"temp"</span>, options: .<span class="type">New</span>, context: &amp;brewContext)</span><br></pre></td></tr></table></figure>
<p>我们需要观察酒窖中的温度，因此，我为View Model添加了一个单独的字段。你可能会问，为什么我们要关心Brew模型是否在View Model中？我要说的是，Brew模型可能会有不同的字段，而你可能需要将它序列化，通过网络传输它，或者其他的一些什么操作。因此，我们需要它的状态。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">observeValueForKeyPath</span><span class="params">(keyPath: String, ofObject object: AnyObject, change: [NSObject : AnyObject], context: UnsafeMutablePointer&lt;Void&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> context == &amp;brewContext &#123;</span><br><span class="line">            <span class="keyword">self</span>.updateTempLabel((change[<span class="type">NSKeyValueChangeNewKey</span>]) <span class="keyword">as</span> <span class="type">Float</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.observeValueForKeyPath(keyPath, ofObject: object, change: change, context: context)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>哇噢，这代码太多了？KVO实现产生了很多的样板代码，但是它还是比MVC实现更为轻量级，尤其是当我们考虑添加越来越多的功能到我们的应用中时,这些逻辑就会被移到View Model中。<a href="https://gist.github.com/vasarhelyia/e4fa64096517ae966d01" target="_blank" rel="external">这里</a>是MVVM实现的完整代码段。</p>
<p>总之，MVVM实现好了很多，但是我们还有这还能再优化的感觉。现在，我们知道了展示可变数据模型到MVVM的View上的关键是数据绑定，既然这样，那还有什么比响应式编程适合这种情况？</p>
<h2 id="响应式编程">响应式编程</h2><p>“Reactive programming is programming with asynchronous data streams.”<br>“响应式编程就是以异步数据流的形式进行编程。”</p>
<p>如果你对这个概念还不熟悉，我建议你阅读一下<a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754" target="_blank" rel="external">这篇文章</a> （中文版在这里 : <a href="http://www.devtf.cn/?p=174" target="_blank" rel="external">那些年我们错过的响应式编程</a> ），这是一篇非常好的介绍。在响应式编程的世界里，任何东西都是流（ stream ）。下面这幅图就展示了将一个按钮点击或者触摸事件转换为流。</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/1600/0*JyZB_1WzJRNIY7o-." alt="">    </p>
<p>如果运用响应式编程到我们的项目中，那么情况应该是这样的: 将socket数据看成是温度的流，这个流被UILabel监听着。转换它们的流程也就是上图的函数式编程所展示的那样，map、merge、filter等其他的操作，这个过程非常赞！让我们来看看这些概念如何跟Cocoa一起配合。</p>
<h2 id="ReactiveCocoa">ReactiveCocoa</h2><p>当我们计划在Cocoa上使用响应式编程时，最好的选择就是使用<a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="external">ReactiveCocoa</a>。ReactiveCocoa是一个受到<a href="http://en.wikipedia.org/wiki/Functional_reactive_programming" target="_blank" rel="external">函数式编程</a>启发的数据绑定框架。</p>
<p>它通过信号来进行操作，这些信号被定义为push-driven的流。这意味着，一个信号代表了一个在未来会交付数据或者任意结果到它的观察者的异步工作流。除了数据模型变化会产生一个信号之外，ReactiveCocoa也提供了一些内置的UIKit/AppKit绑定，例如rac_textSignal和其他用用的东西。</p>
<p>你可能略微地不确定什么时候才会计划启动你的下一个Swift项目，你可能也会想在这个项目中实现响应式编程。无需这样，github上的开发人员会帮助你实现这些功能。他们正在计划发布名为Great Swiftening的ReactiveCocoa 3.0版本，当然你也可以使用2.4.x版本，因为它们也足够稳定。</p>
<p>Swift在集合类型上也内置了一些函数式操作，它们能很方便的执行某些操作，我们无需对此进行重复地工作。</p>
<p>让我们看看使用ReactiveCocoa作为MVVM模式的数据绑定系统时我们如何创建一个ReactiveViewModel。看如下代码，我们的View Controller看起来是不是更优雅了？</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.brewViewModel.tempChangedSignal.<span class="built_in">map</span> &#123;</span><br><span class="line">            (temp: <span class="type">AnyObject</span>!) -&gt; <span class="type">AnyObject</span>! <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> <span class="type">NSString</span>(format:<span class="string">"%.2f ˚C"</span>, temp <span class="keyword">as</span> <span class="type">Float</span>)</span><br><span class="line">        &#125; ~&gt; <span class="type">RAC</span>(<span class="keyword">self</span>.tempLabel, <span class="string">"text"</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>由于C式的复杂的宏在Swift中不可用，因此用于Objective-C的RAC宏被替换掉了。感谢Yusef Napora提供了一个直截了当的<a href="http://napora.org/a-swift-reaction/" target="_blank" rel="external">解决方法</a>，还有一种解决方法是在ColinEberhardt的这个<a href="https://github.com/ColinEberhardt/ReactiveSwiftFlickrSearch" target="_blank" rel="external">Sample App</a>中。</p>
<p>现在我们回到酒窖气温检测项目中，我们已经准备好了运用响应式编程！我们看看剩下的代码: </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">socket.on(<span class="string">"temperature_changed"</span>, callback: </span><br><span class="line">    &#123;(<span class="type">AnyObject</span> data) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">tempChangedSignal.sendNext(data[<span class="number">0</span>]).deliverOn(<span class="type">RACScheduler</span>.mainThreadScheduler())</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>在这里，我们仅仅创建了一个温度数据信号，并且确保UILabel的更新会被执行在主线程中。我对于ReactiveCocoa简直没有抵抗力了！现在我们来执行http请求、处理当试图在服务端初始化一个Brew对象时引发的错误，代码如下 :    </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSURLConnection</span>.sendAsynchronousRequest(request, queue: <span class="type">NSOperationQueue</span>(), completionHandler: &#123;</span><br><span class="line">                (response:<span class="type">NSURLResponse</span>!, data: <span class="type">NSData</span>!, error: <span class="type">NSError</span>!) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> error == <span class="literal">nil</span> &#123;</span><br><span class="line">                    subscriber.sendNext(<span class="type">JSON</span>(data))</span><br><span class="line">                    subscriber.sendCompleted()</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    subscriber.sendError(error)</span><br><span class="line">                &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果成功我们将接收到的Json数据发送给订阅者，否则调用sendError函数将错误信息发送给订阅者。非常方便，不是吗？</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">syncSignal.subscribeError(&#123; (error: <span class="type">NSError</span>!) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">                <span class="type">UIAlertView</span>(title: <span class="string">"Error creating brew"</span>, message: error.localizedDescription, delegate: <span class="literal">nil</span>, cancelButtonTitle: <span class="string">"OK"</span>).show()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我们仅仅是需要在ViewController中实现错误处理，然后等待着响应式编程的魔法降临到我们身上，例如 丢失连接。</p>
<h2 id="总结">总结</h2><p>酒窖温度监测项目是一个真实的示例,起初我用Objective-C中的MVC实现.这种实现非常简单,却少了份惊喜.后来,Swift出现了,我理所当然地喜欢上这样的创新.因此我决定重写整个App.当我与繁重的控制器以及UI刷新机制斗争了许久之后,这些东西我不是很精通,所以我决定尝试响应式编程.由于我早已知道这与MVVM能够兼容,所以就决定尝试一下.这次经历清除了我一半代码.于是,经过ReactiveCocoa转换的App的价值感觉就像是剩下的代码的价值的两倍.从那时候起,做一些调整(比如根据一些数据改变按钮的状态)仅仅需要编写一行用于发送启用信号到按钮命令的代码,这几乎没有成本.想想使用原来的方式将花费多少时间呐！</p>
<p>有很多其他的因素可能使你想尝试ReactiveCocoa和Swift。如果你想对如何酿造啤酒感兴趣，或者只是对这些代码感兴趣，那么你可以这<a href="https://github.com/brewfactory/BrewMobile" target="_blank" rel="external">这里(BrewMobile)</a>查看到所有的代码。如果你有更好的技术使得这个App变得更好，请让我知道！当然，也欢迎给我们贡献代码。</p>
<p>在结束之前，分享一下我关于BrewMobile的未来的一些思考，我正在打算将React Native引入到BrewMobile。如果搞定了我会再次分享我的经验。</p>
<h2 id="其他资料">其他资料</h2><h3 id="Swift">Swift</h3><ul>
<li><a href="http://www.objc.io/issue-16/power-of-swift.html" target="_blank" rel="external">http://www.objc.io/issue-16/power-of-swift.html</a></li>
<li><a href="https://designcode.io/swift-design" target="_blank" rel="external">https://designcode.io/swift-design</a></li>
<li><a href="http://blog.scottlogic.com/2014/07/24/mvvm-reactivecocoa-swift.html" target="_blank" rel="external">http://blog.scottlogic.com/2014/07/24/mvvm-reactivecocoa-swift.html</a></li>
<li><a href="http://www.objc.io/books/" target="_blank" rel="external">http://www.objc.io/books/</a></li>
</ul>
<h3 id="MVVM模式">MVVM模式</h3><p><a href="http://www.objc.io/issue-13/mvvm.html" target="_blank" rel="external">http://www.objc.io/issue-13/mvvm.html</a><br><a href="http://www.teehanlax.com/blog/model-view-viewmodel-for-ios/" target="_blank" rel="external">http://www.teehanlax.com/blog/model-view-viewmodel-for-ios/</a></p>
<h3 id="响应式编程-1">响应式编程</h3><ul>
<li><a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754" target="_blank" rel="external">https://gist.github.com/staltz/868e7e9bc2a7b8c1f754</a></li>
<li><a href="http://blog.risingstack.com/functional-reactive-programming-with-the-power-of-nodejs-streams/" target="_blank" rel="external">http://blog.risingstack.com/functional-reactive-programming-with-the-power-of-nodejs-streams/</a></li>
<li><a href="http://rxmarbles.com" target="_blank" rel="external">http://rxmarbles.com</a></li>
</ul>
<h3 id="ReactiveCocoa-1">ReactiveCocoa</h3><ul>
<li><a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/Documentation/DesignGuidelines.md" target="_blank" rel="external">https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/Documentation/DesignGuidelines.md</a></li>
<li><a href="http://nshipster.com/reactivecocoa/" target="_blank" rel="external">http://nshipster.com/reactivecocoa/</a></li>
</ul>
<h3 id="Ghostbusters">Ghostbusters</h3><ul>
<li><a href="https://itunes.apple.com/us/movie/ghostbusters/id532285804" target="_blank" rel="external">https://itunes.apple.com/us/movie/ghostbusters/id532285804</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Swift的响应式编程">Swift的响应式编程</h1><hr>
<blockquote>
<ul>
<li>原文链接 : <a href="https://medium.com/swift-programming/reactive-swift-3b6050375534">Reactive Swift</a></li>
<li>原文作者 : <a href="https://medium.com/@vasarhelyia">Agnes Vasarhelyi</a></li>
<li><a href="http://www.devtf.cn">译文出自 :  开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/bboyefiyu">Mr.Simple</a> </li>
<li>校对者: <a href="https://github.com/Lollypo">Lollypo</a>  </li>
<li>状态 :  完成</li>
</ul>
</blockquote>
<p>让我们首先回到Apple刚推出Objective-C的继任者-Swift的时候，那真是一个非比寻常的时刻。<br>Siri还没有开启地狱之门，Prezi还没有支持订阅，那时的朝鲜也还没有hack任何人的email。一种新语言的出现让我个人非常兴奋，尤其是这是一种类型安全的脚本语言。虽然Swift还在快速的发展中，但是我们不必担心它是否已经稳定。当那一刻到来之时，我应该已经知道如何交付整洁的、可测试的代码。还要有非常灵活、流畅的UI？如果你对Objective-C 和 MVC之外的东西感兴趣，那么就请继续读下去吧。</p>
<h2 id="MVC_与_MVVM">MVC 与 MVVM</h2><p>让我们从零开始，当我们设计一个应用时，你可能会先考虑应用的架构。Cocoa框架以<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html">Model-View-Controller</a> (也称为 MVC)为基础架构，它的结构如下图所示。</p>
<p><img src="https://d262ilb51hltx0.cloudfront.net/max/1600/0*pEvMKHBK9HeAgrYC." alt=""></p>]]>
    
    </summary>
    
      <category term="Reactive" scheme="http://ytlvy.com/tags/Reactive/"/>
    
      <category term="Swift" scheme="http://ytlvy.com/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift Access Sub-Controllers from a UINavigationController]]></title>
    <link href="http://ytlvy.com/2015/08/08/Swift-Access-Sub-Controllers-from-a-UINavigationController/"/>
    <id>http://ytlvy.com/2015/08/08/Swift-Access-Sub-Controllers-from-a-UINavigationController/</id>
    <published>2015-08-08T13:05:47.000Z</published>
    <updated>2015-08-08T13:06:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="在Swift开发中通过UINavigationController来访问Sub-Controllers">在Swift开发中通过UINavigationController来访问Sub-Controllers</h1><blockquote>
<ul>
<li>原文链接 : <a href="http://www.andrewcbancroft.com/2015/06/02/access-sub-controllers-from-a-uinavigationcontroller-in-swift/" target="_blank" rel="external">Access Sub-Controllers from a UINavigationController in Swift</a></li>
<li>原文作者 : <a href="http://www.andrewcbancroft.com" target="_blank" rel="external">Andrew Bancroft</a></li>
<li>译文出自 : <a href="http://www.devtf.cn" target="_blank" rel="external">开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="http://www.andrewcbancroft.com/2015/06/02/access-sub-controllers-from-a-uinavigationcontroller-in-swift/" target="_blank" rel="external">samw00</a> </li>
<li>校对者: <a href="https://github.com/mrchenhao" target="_blank" rel="external">mrchenhao</a> </li>
<li>状态 : 完成</li>
</ul>
</blockquote>
<p>通过<code>AppDelegate</code>或者通过<code>prepareForSegue(_:sender:)</code>来访问<code>UINavigationController</code>的第一个子元素的访问顺序总是让我有点纳闷。这篇博文中有几段代码可以帮助你和我迅速的弄清楚如何在我们的Swift应用程序开发中和navigation controllers打交道。</p>
<h2 id="AppDelegate">AppDelegate</h2><p>每一个iOS应用在其启动加载完成后都会显示一个根视图控制器。假设我们要搭建一个以导航控制器(navigation controller)为主的一个app…,也就是说我们这个app的第一（根）视图控制器是一个UINavigationController。在我们的Storyboard中，我们创建了一个简单的场景，给一个视图控制器添加了些UI控件和一些属性，然后我们将这个视图控制器嵌入在一个导航控制器中。</p>
<p>但是如果我想在app启动之后再去设置视图控制器中的某些个属性呢？我们要如何才能做到这点呢？</p>
<p>我一直把我在Storyboard中添加UI要素的第一个场景(first scene)视为“第一视图控制器”。但是，对iOS来说，导航控制器才是实际意义上的第一（根）视图控制器。</p>
<p>当一个app把导航控制器视为其第一（根）视图器时，我们就需要在视图层级结构中“挖”的更深一点才能访问到我们之前所以为的“第一视图控制器“。</p>
<a id="more"></a>
<h3 id="找寻第一视图控制器">找寻第一视图控制器</h3><p>下面的代码段展示了如果在<code>UINavigationController</code>的视图控制器层级中找到第一个控制器并给其设置一些虚构属性，这一次都发生在AppDelegate中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span>: <span class="title">UIResponder</span>, <span class="title">UIApplicationDelegate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> window: <span class="type">UIWindow</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">application</span><span class="params">(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="comment">// Override point for customization after application launch.</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">let</span> navigationController = window?.rootViewController <span class="keyword">as</span>! <span class="type">UINavigationController</span></span><br><span class="line">        <span class="keyword">let</span> firstVC = navigationController.viewControllers[<span class="number">0</span>] <span class="keyword">as</span>! <span class="type">NameofFirstViewController</span></span><br><span class="line">        <span class="comment">// set whatever properties you might want to set</span></span><br><span class="line">        <span class="comment">// such as an NSManagedObjectContext reference</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个流程是这样的：</p>
<ul>
<li>获取window的根视图控制器（在我们的例子中就是导航控制器）</li>
<li>通过导航控制器的视图控制器数组获取其第一个子视图控制器（也就是原先我一直以为的“第一”视图控制器）</li>
<li>设置任何你需要设置的属性</li>
</ul>
<p>在上面这段代码中，你可能担心我用了隐式拆包这方法来看可选值变量是否有值。通常情况下我也是避免用这种方法的，但在这里我用这种方法的理由是我的这个app的根视图控制器就是一个<code>UINavigationController</code>，这点确保了我可以使用隐式拆包这种用法。因为不管如何，只要改变了app的导航模式都会出错。</p>
<p>如果上面的理由没有说服你也别担心 － 你可以把<code>?</code>换成<code>!</code>然后添加一些<code>if-let</code>语句来确保你不会碰到<code>nil</code>。举个例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span>: <span class="title">UIResponder</span>, <span class="title">UIApplicationDelegate</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> navigationController = window?.rootViewController <span class="keyword">as</span>? <span class="type">UINavigationController</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> firstVC = navigationController.viewControllers[<span class="number">0</span>] <span class="keyword">as</span>? <span class="type">NameOfFirstViewController</span> &#123;</span><br><span class="line">            firstVC.someproperty = someValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Prepare_for_segue">Prepare for segue</h2><p>那么<code>prepareForSegue(_:sender:)</code>又是怎么一回事？什么时候不得不走这条路呢？</p>
<p>假设，我们有一个应用跳转进一个导航控制器。我们可能需要给下一个视图控制器传值，但是“下一个视图控制器”严格来说其实是一个导航控制器，并不是我们声明属性的那个控制器。</p>
<p>和通过AppDelegate时的情形一样，我们也需要在视图层级中深挖一点来访问第一视图控制器来，这样才能传递我们的数据。下面是一个实现的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">override</span> public <span class="func"><span class="keyword">func</span> <span class="title">prepareForSegue</span><span class="params">(segue: UIStoryboardSegue, sender: AnyObject?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> destinationVC = segue.destinationViewController <span class="keyword">as</span>! <span class="type">UINavigationController</span></span><br><span class="line">        <span class="keyword">let</span> nextViewController = destinationVC.viewControllers[<span class="number">0</span>] <span class="keyword">as</span>! <span class="type">SecondViewController</span></span><br><span class="line">        </span><br><span class="line">        nextViewController.someProperty = someValue</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>AppDelegate</code>例子和<code>prepareForSegue</code>的例子中唯一改变的就是我们是从哪里如何获取<code>UINavigationController</code>的。在<code>AppDelegate</code>例子中，导航控制器是来自window的根视图控制器。在<code>prepareForSegue</code>中则来自segue的目标视图控制器。</p>
<p>除此之外，获取导航控制器的第一个子元素的步骤都是一样的。</p>
<h2 id="总结">总结</h2><p>如何去访问一个导航控制器的视图控制器层级结构让我觉得有点含糊不清，所以我给我自己写了这篇小博文作为日后的一个参考，但是我希望你也能从这篇博文中受益。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="在Swift开发中通过UINavigationController来访问Sub-Controllers">在Swift开发中通过UINavigationController来访问Sub-Controllers</h1><blockquote>
<ul>
<li>原文链接 : <a href="http://www.andrewcbancroft.com/2015/06/02/access-sub-controllers-from-a-uinavigationcontroller-in-swift/">Access Sub-Controllers from a UINavigationController in Swift</a></li>
<li>原文作者 : <a href="http://www.andrewcbancroft.com">Andrew Bancroft</a></li>
<li>译文出自 : <a href="http://www.devtf.cn">开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="http://www.andrewcbancroft.com/2015/06/02/access-sub-controllers-from-a-uinavigationcontroller-in-swift/">samw00</a> </li>
<li>校对者: <a href="https://github.com/mrchenhao">mrchenhao</a> </li>
<li>状态 : 完成</li>
</ul>
</blockquote>
<p>通过<code>AppDelegate</code>或者通过<code>prepareForSegue(_:sender:)</code>来访问<code>UINavigationController</code>的第一个子元素的访问顺序总是让我有点纳闷。这篇博文中有几段代码可以帮助你和我迅速的弄清楚如何在我们的Swift应用程序开发中和navigation controllers打交道。</p>
<h2 id="AppDelegate">AppDelegate</h2><p>每一个iOS应用在其启动加载完成后都会显示一个根视图控制器。假设我们要搭建一个以导航控制器(navigation controller)为主的一个app…,也就是说我们这个app的第一（根）视图控制器是一个UINavigationController。在我们的Storyboard中，我们创建了一个简单的场景，给一个视图控制器添加了些UI控件和一些属性，然后我们将这个视图控制器嵌入在一个导航控制器中。</p>
<p>但是如果我想在app启动之后再去设置视图控制器中的某些个属性呢？我们要如何才能做到这点呢？</p>
<p>我一直把我在Storyboard中添加UI要素的第一个场景(first scene)视为“第一视图控制器”。但是，对iOS来说，导航控制器才是实际意义上的第一（根）视图控制器。</p>
<p>当一个app把导航控制器视为其第一（根）视图器时，我们就需要在视图层级结构中“挖”的更深一点才能访问到我们之前所以为的“第一视图控制器“。</p>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://ytlvy.com/tags/Swift/"/>
    
      <category term="Swift" scheme="http://ytlvy.com/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift Increasing Performance by Reducing Dynamic Dispatch]]></title>
    <link href="http://ytlvy.com/2015/08/08/Swift-Increasing-Performance-by-Reducing-Dynamic-Dispatch/"/>
    <id>http://ytlvy.com/2015/08/08/Swift-Increasing-Performance-by-Reducing-Dynamic-Dispatch/</id>
    <published>2015-08-08T13:04:40.000Z</published>
    <updated>2015-08-08T13:05:23.000Z</updated>
    <content type="html"><![CDATA[<h2 id="通过减少动态分发来提高Swift的执行效率">通过减少动态分发来提高Swift的执行效率</h2><p>&gt;</p>
<ul>
<li>原文链接 : <a href="https://developer.apple.com/swift/blog/?id=27" target="_blank" rel="external">Increasing Performance by Reducing Dynamic Dispatch</a></li>
<li>原文作者 : <a href="https://developer.apple.com/swift" target="_blank" rel="external">Apple官方博文</a></li>
<li>译文出自 : <a href="www.devtf.cn">开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/samw00/" target="_blank" rel="external">samw00</a> </li>
</ul>
<p>和其他很多编程语言一样，Swift允许一个类重写其父类中声明的方法和属性。这意味着程序在运行时需要先确定要调用的方法和访问的属性是属于哪个类的，确定之后，则会执行间接调用（indirect call）或间接访问（indirect access）。这个运行机制称为<strong>动态分发</strong>（dynamic dispatch）。这个机制能够提高语言的表现力，但其付出的代价是在每次间接调用或间接访问时，会产生一定量的运行时开销（runtime overhead）。在执行敏感代码时，最好能避免产生这样的开销。这篇博客将罗列三种通过消除这动态分发机制来提高程序执行效率的方式：<code>final</code>，<code>private</code>和全模块优化（Whole Module Optimization）。</p>
<p>Consider the following example:</p>
<p>先来看看下面这段代码</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParticleModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> point = ( <span class="number">0.0</span>, <span class="number">0.0</span> )</span><br><span class="line">    <span class="keyword">var</span> velocity = <span class="number">100.0</span></span><br><span class="line"></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">updatePoint</span><span class="params">(newPoint: <span class="params">(Double, Double)</span></span></span>, newVelocity: <span class="type">Double</span>) &#123;</span><br><span class="line">        point = newPoint</span><br><span class="line">        velocity = newVelocity</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">update</span><span class="params">(newP: <span class="params">(Double, Double)</span></span></span>, newV: <span class="type">Double</span>) &#123;</span><br><span class="line">        updatePoint(newP, newVelocity: newV)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="type">ParticalModel</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> stride(from: <span class="number">0.0</span>, through: <span class="number">360</span>, by: <span class="number">1.0</span>) &#123;</span><br><span class="line">    p.update((i * sin(i), i), newV: i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>正如上面代码所写的那样，编译器会通过动态分发机制来：</p>
<ol>
<li>调用<code>p</code>的<code>update()</code>方法。</li>
<li>调用<code>p</code>的<code>updatePoint</code>方法。</li>
<li>获取<code>p</code>中<code>point</code>这个属性元组。</li>
<li>获取<code>p</code>中的<code>velocity</code>属性。</li>
</ol>
<p>这可能和你当初看到代码时所期望的不一样。因为某个<code>PracticalModel</code>的子类可能会通过一个计算过的属性来重写<code>point</code>或<code>velocity</code>属性或者重写<code>updatePoint()</code>或<code>update()</code>中的实现方法，所以通过一个动态分发的机制去调用是有必要的。</p>
<p>在Swift中，动态分发调用既是在一个方法表中找寻要调用的函数，然后执行间接调用，这样的执行效率会低于直接调用。除此之外，间接调用也阻止编译器各种优化，从而使得间接调用的成本更高。在执行某些关键代码时，并不需要动态分发来提高执行效率的时候，你可以使用一些技术来对动态分发调用进行一些限制和约束。</p>
<h2 id="当你确定某个声明不会被重写时，用final关键字修饰">当你确定某个声明不会被重写时，用final关键字修饰</h2><p>加上关键字<code>final</code>就意味着类，方法或者属性的声明不能被重写。这就能让编译器安全的省略动态分发的间接调用。比方说在下面的代码中，属性<code>point</code>和<code>velocity</code>会通过加载对象已存的属性来被直接访问,<code>updatePoint()</code>也会被直接调用。但是<code>update()</code>这个方法还是会通过动态分发来间接调用，这样能允许子类自定义<code>update()</code>中的实现。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParticlModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="variable"><span class="keyword">var</span> point</span> = (x: <span class="number">0.0</span>, y: <span class="number">0.0</span>)</span><br><span class="line">    <span class="keyword">final</span> <span class="variable"><span class="keyword">var</span> velocity</span> = <span class="number">100.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> func updatePoint(newPoint: (<span class="typename">Double</span>, Doulbe), newVelocity: <span class="typename">Double</span>) &#123;</span><br><span class="line">        point = newPoint</span><br><span class="line">        velocity = newVelocity</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func update(newP: (<span class="typename">Double</span>, <span class="typename">Double</span>), newV: <span class="typename">Double</span>) &#123;</span><br><span class="line">        updatePoint(newP, newVelocity: newV)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以给整个类加一个<code>final</code>关键字来修饰。这样就禁止了给当前类添加任何子类也意味着类里所有的方法和属性都是<code>final</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ParticleModel</span> </span>&#123;</span><br><span class="line">    <span class="variable"><span class="keyword">var</span> point</span> = (x: <span class="number">0.0</span>, y:<span class="number">0.0</span>)</span><br><span class="line">    <span class="variable"><span class="keyword">var</span> velocity</span> = <span class="number">100.0</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="用private关键字来暗示在同一文件中的声明为final">用private关键字来暗示在同一文件中的声明为final</h2><p>给声明添加关键字<code>private</code>会把该声明限制在当前文件可见。这允许编译器去寻找所有潜在能被重写的声明。任何没有标明能被重写的声明，编译器都会自动推断为<code>final</code>并去除访问该属性或方法时的间接调用。</p>
<p>假设在当前文件中，没有类会重写<code>ParticleModel</code>，编译器会把所有<code>priavte</code>修饰的声明的动态分发调用替换成直接调用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParticleModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">var</span> point</span> = (x:<span class="number">0.0</span>, y:<span class="number">0.0</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="variable"><span class="keyword">var</span> velocity</span> = <span class="number">100.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">updatePoint</span><span class="params">(newPoint: <span class="typename">(Double, Double</span>)</span>, newVelocity: Double) &#123;</span></span><br><span class="line">        point = newPoint</span><br><span class="line">        velocity = newVelocity</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func update(newP: (<span class="typename">Double</span>, <span class="typename">Double</span>), newV: <span class="typename">Double</span>) &#123;</span><br><span class="line">        updatePoint(newP, newVelocity: newV)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就像上面这个例子，属性<code>point</code>和<code>velocity</code>被直接访问，<code>updatePoint()</code>也是被直接调用。同样的，<code>update()</code>仍会被间接调用，因为没有添加<code>private</code>修饰。</p>
<p>和关键字<code>final</code>一样，同样可以用<code>private</code>来修饰一个类，这会使类成为一个私有类，类中的方法和属性也同样为私有<code>private</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ParticleModel</span> </span>&#123;</span><br><span class="line">    <span class="variable"><span class="keyword">var</span> point</span> = (x:<span class="number">0.0</span>, y:<span class="number">0.0</span>)</span><br><span class="line">    <span class="variable"><span class="keyword">var</span> velocity</span> = <span class="number">100.0</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用全模块优化将internal声明推断为final">使用全模块优化将internal声明推断为final</h2><p>带有<code>internal</code>访问的声明（如果没有特别声明，此为默认）只在当前模块中可见。通常来讲Swift会分开编译同一模块中的不同文件，所以编译器是无法确定某个<code>internal</code>声明是否在另一个文件被重写。但是，如果开启了全模块优化，则所有的模块都会在同一时被一起编译。这就能让编译器来对整个模块进行处理，如果某个<code>internal</code>的声明没有可见重写，则推断为<code>final</code>。</p>
<p>现在我们回过头去看之前的代码段，这次添加一些额外的<code>public</code>关键字。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParticleModel</span> </span>&#123;</span><br><span class="line">    <span class="variable"><span class="keyword">var</span> point</span> = (x:<span class="number">0.0</span>, y:<span class="number">0.0</span>)</span><br><span class="line">    <span class="variable"><span class="keyword">var</span> velocity</span> = <span class="number">100.0</span></span><br><span class="line"></span><br><span class="line">    func updatePoint(newPoint: (<span class="typename">Double</span>, <span class="typename">Double</span>), newVelocity: <span class="typename">Double</span>) &#123;</span><br><span class="line">        point = newPoint</span><br><span class="line">        velocity = newVelocity</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> func update(newP: (<span class="typename">Double</span>, <span class="typename">Double</span>), newV: <span class="typename">Double</span>) &#123;</span><br><span class="line">        updatePoint(newP, newVelocity: newV)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable"><span class="keyword">var</span> p</span> = ParticleModel()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> stride(from: <span class="number">0.0</span>, through: times, by: <span class="number">1.0</span>) &#123;</span><br><span class="line">    p.update((i * sin(i), i), newV: i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当用全局模块优化来编译这段代码时，编译器能够推断<code>point</code>，<code>velocity</code>属性和<code>updatePoint()</code>方法为<code>final</code>。相反的，因为<code>update()</code>方法被public修饰，则不能推断为<code>final</code>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="通过减少动态分发来提高Swift的执行效率">通过减少动态分发来提高Swift的执行效率</h2><p>&gt;</p>
<ul>
<li>原文链接 : <a href="https://developer.apple.com/swift/blog/?id=27">Increasing Performance by Reducing Dynamic Dispatch</a></li>
<li>原文作者 : <a href="https://developer.apple.com/swift">Apple官方博文</a></li>
<li>译文出自 : <a href="www.devtf.cn">开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/samw00/">samw00</a> </li>
</ul>
<p>和其他很多编程语言一样，Swift允许一个类重写其父类中声明的方法和属性。这意味着程序在运行时需要先确定要调用的方法和访问的属性是属于哪个类的，确定之后，则会执行间接调用（indirect call）或间接访问（indirect access）。这个运行机制称为<strong>动态分发</strong>（dynamic dispatch）。这个机制能够提高语言的表现力，但其付出的代价是在每次间接调用或间接访问时，会产生一定量的运行时开销（runtime overhead）。在执行敏感代码时，最好能避免产生这样的开销。这篇博客将罗列三种通过消除这动态分发机制来提高程序执行效率的方式：<code>final</code>，<code>private</code>和全模块优化（Whole Module Optimization）。</p>
<p>Consider the following example:</p>
<p>先来看看下面这段代码</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParticleModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> point = ( <span class="number">0.0</span>, <span class="number">0.0</span> )</span><br><span class="line">    <span class="keyword">var</span> velocity = <span class="number">100.0</span></span><br><span class="line"></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">updatePoint</span><span class="params">(newPoint: <span class="params">(Double, Double)</span></span></span>, newVelocity: <span class="type">Double</span>) &#123;</span><br><span class="line">        point = newPoint</span><br><span class="line">        velocity = newVelocity</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">update</span><span class="params">(newP: <span class="params">(Double, Double)</span></span></span>, newV: <span class="type">Double</span>) &#123;</span><br><span class="line">        updatePoint(newP, newVelocity: newV)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="type">ParticalModel</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> stride(from: <span class="number">0.0</span>, through: <span class="number">360</span>, by: <span class="number">1.0</span>) &#123;</span><br><span class="line">    p.update((i * sin(i), i), newV: i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Performance" scheme="http://ytlvy.com/tags/Performance/"/>
    
      <category term="Swift" scheme="http://ytlvy.com/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[How To Implement A Circular Image Loader Animation with CAShapeLayer]]></title>
    <link href="http://ytlvy.com/2015/08/08/How-To-Implement-A-Circular-Image-Loader-Animation-with-CAShapeLayer/"/>
    <id>http://ytlvy.com/2015/08/08/How-To-Implement-A-Circular-Image-Loader-Animation-with-CAShapeLayer/</id>
    <published>2015-08-08T12:55:46.000Z</published>
    <updated>2015-08-08T12:56:17.000Z</updated>
    <content type="html"><![CDATA[<h2 id="使用CAShapeLayer来实现圆形图片加载动画">使用CAShapeLayer来实现圆形图片加载动画</h2><blockquote>
<ul>
<li>原文链接 : <a href="http://www.raywenderlich.com/94302/implement-circular-image-loader-animation-cashapelayer" target="_blank" rel="external">How To Implement A Circular Image Loader Animation with CAShapeLayer</a></li>
<li>原文作者 : <a href="http://www.raywenderlich.com/u/rounak" target="_blank" rel="external">Rounak Jain</a></li>
<li>译文出自 : <a href="http://www.devtf.cn" target="_blank" rel="external">开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/samlaudev" target="_blank" rel="external">Sam Lau</a> </li>
<li>校对者: <a href="https://github.com/Lollypo" target="_blank" rel="external">Lollypo</a>  </li>
<li>状态 :  校正完</li>
</ul>
</blockquote>
<p>几个星期之前，Michael Villar在Motion试验中创建一个非常有趣的加载动画。</p>
<p>下面的GIF图片展示这个加载动画，它将一个圆形进度指示器和圆形渐现动画结合。这个组合的效果有趣，独一无二和有点迷人。</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/02/Circle.gif" alt=""></p>
<p>这个教程将会教你如何使用Swift和Core Animatoin来重新创建这个效果。让我们开始吧！</p>
<h1 id="基础">基础</h1><p>首先下载这个教程的<a href="http://cdn1.raywenderlich.com/wp-content/uploads/2015/02/ImageLoaderIndicator-Starter.zip" target="_blank" rel="external">启动项目</a>，然后编译和运行。过一会之后，你应该看到一个简单的image显示：</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/02/StarterProject.png" alt=""></p>
<p>这个启动项目已经预先在恰当的位置将views和加载逻辑编写好了。花一分钟来浏览来快速了解这个项目；那里有一个<strong>ViewController</strong>，<strong>ViewController</strong>里有一个命名为<strong>CustomImageView</strong>的<strong>UIImageView</strong>子类, 还有一个<strong>SDWebImage</strong>的方法被调用来加载image。</p>
<p>你可能注意到当你第一次运行这个app的时候，当image下载时这个app似乎会暂停几秒，然后image会显示在屏幕。当然，此刻没有圆形进度指示器 - 你将会在这个教程中创建它！</p>
<p>你会在两个步骤中创建这个动画：</p>
<ol>
<li><strong>圆形进度</strong>。首先，你会画一个圆形进度指示器，然后根据下载进度来更新它。</li>
<li><strong>扩展圆形图片</strong>。第二，你会通过扩展的圆形窗口来揭示下载图片。</li>
</ol>
<p>紧跟着下面步骤来逐步实现！</p>
<a id="more"></a>
<h1 id="创建圆形指示器">创建圆形指示器</h1><p>想一下关于进度指示器的基本设计。这个指示器一开始是空来展示0%进度，然后逐渐填满直到image完成下载。通过设置<strong>CAShapeLayer</strong>的<strong>path</strong>为circle来实现是相当简单。</p>
<blockquote>
<p>注意：如果你不熟悉<strong>CAShapeLayer</strong>(或<strong>CALayers</strong>)的基本概念，可以查看Scott Gardner的<a href="http://www.raywenderlich.com/90488/calayer-in-ios-with-swift-10-examples" target="_blank" rel="external">CALayer in iOS with Swift</a>文章。</p>
</blockquote>
<p>你可以通过<strong>CAShapeLayer</strong>的<strong>strokeStart</strong>和<strong>strokeEnd</strong>属性来控制开始和结束位置的外观。通过改变<strong>strokeEnd</strong>的值在0到1之间，你可以恰当地填充下载进度。</p>
<p>让我们试一下。通过<strong>iOS\Source\Cocoa Touch Class template</strong>来创建一个新的文件，文件名为<strong>CircularLoaderView</strong>。设置它为<strong>UIView</strong>的子类。</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/02/Screenshot-2015-01-25-19.25.43.png" alt=""></p>
<p>点击<strong>Next</strong>和<strong>Create</strong>。新的子类<strong>UIView</strong>将用来保存动画的代码。</p>
<p>打开<strong>CircularLoaderView.swift</strong>和添加以下属性和常量到这个类：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">circlePathLayer =</span> CAShapeLayer()</span><br><span class="line"><span class="keyword">let</span> circleRadius: <span class="variable">CGFloat =</span> <span class="number">20.0</span></span><br></pre></td></tr></table></figure>
<p><strong>circlePathLayer</strong>表示这个圆形路径，而<strong>circleRadius</strong>表示这个圆形路径的半径。</p>
<p>添加以下初始化代码到<strong>CircularLoaderView.swift</strong>来配置这个shape layer:</p>
<figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="component">override init(frame: CGRect) &#123;</span><br><span class="line">  super<span class="string">.init(frame:</span> frame)</span><br><span class="line">  configure()</span><br><span class="line">&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="component">required init(coder aDecoder: NSCoder) &#123;</span><br><span class="line">  super<span class="string">.init(coder:</span> aDecoder)</span><br><span class="line">  configure()</span><br><span class="line">&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="component">func configure() &#123;</span><br><span class="line">  circlePathLayer<span class="string">.frame</span> = bounds</span><br><span class="line">  circlePathLayer<span class="string">.lineWidth</span> = 2</span><br><span class="line">  circlePathLayer<span class="string">.fillColor</span> = UIColor<span class="string">.clearColor().CGColor</span></span><br><span class="line">  circlePathLayer<span class="string">.strokeColor</span> = UIColor<span class="string">.redColor().CGColor</span></span><br><span class="line">  layer<span class="string">.addSublayer(circlePathLayer)</span></span><br><span class="line">  backgroundColor = UIColor<span class="string">.whiteColor()</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>两个初始化方法都调用<strong>configure</strong>方法，<strong>configure</strong>方法设置一个shape layer的line width为2，fill color为clear,stroke color为red。将添加circlePathLayer添加到view’s main layer。然后设置view的 <strong>backgroundColor</strong> 为white，那么当image加载时，屏幕的其余部分就忽略掉。</p>
<h2 id="添加路径">添加路径</h2><p>你会注意到你还没赋值一个path给layer。为了做到这点，添加以下方法(还是在<strong>CircularLoaderView.swift</strong>文件)：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func circleFrame() -&gt; <span class="built_in">CGRect</span> &#123;</span><br><span class="line">  var circleFrame = <span class="built_in">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">2</span>*circleRadius, height: <span class="number">2</span>*circleRadius)</span><br><span class="line">  circleFrame<span class="variable">.origin</span><span class="variable">.x</span> = <span class="built_in">CGRectGetMidX</span>(circlePathLayer<span class="variable">.bounds</span>) - <span class="built_in">CGRectGetMidX</span>(circleFrame)</span><br><span class="line">  circleFrame<span class="variable">.origin</span><span class="variable">.y</span> = <span class="built_in">CGRectGetMidY</span>(circlePathLayer<span class="variable">.bounds</span>) - <span class="built_in">CGRectGetMidY</span>(circleFrame)</span><br><span class="line">  <span class="keyword">return</span> circleFrame</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面那个方法返回一个<strong>CGRect</strong>的实例来界定指示器的路径。这个边框是<strong>2*circleRadius</strong>宽和<strong>2*circleRadius</strong>高，放在这个view的正中心。</p>
<p>每次这个view的size改变时，你会需要都重新计算<strong>circleFrame</strong>，所以你可能将它放在一个独立的方法。</p>
<p>现在添加以下方法来创建你的路径：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func circlePath<span class="function"><span class="params">()</span> -&gt;</span> UIBezierPath &#123;</span><br><span class="line">  <span class="keyword">return</span> UIBezierPath(<span class="attribute">ovalInRect</span>: circleFrame())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这只是根据<strong>circleFrame</strong>限定来返回圆形的<strong>UIBezierPath</strong>。由于<strong>circleFrame()</strong>返回一个正方形，在这种情况下”椭圆“会最终成为一个圆形。</p>
<p>由于layers没有<strong>autoresizingMask</strong>这个属性，你需要在<strong>layoutSubviews</strong>方法更新<strong>circlePathLayer</strong>的frame来恰当地响应view的size变化。</p>
<p>下一步，覆盖<strong>layoutSubviews()</strong>方法：</p>
<figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="component">override func layoutSubviews() &#123;</span><br><span class="line">  super<span class="string">.layoutSubviews()</span></span><br><span class="line">  circlePathLayer<span class="string">.frame</span> = bounds</span><br><span class="line">  circlePathLayer<span class="string">.path</span> = circlePath()<span class="string">.CGPath</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>由于改变了frame，你要在这里调用<strong>circlePath()</strong>方法来触发重新计算路径。</p>
<p>现在打开<strong>CustomImageView.swift</strong>文件和添加以下<strong>CircularLoaderView</strong>实例作为一个属性：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let progressIndicatorView = <span class="function"><span class="title">CircularLoaderView</span><span class="params">(frame: CGRectZero)</span></span></span><br></pre></td></tr></table></figure>
<p>下一步，在之前下载图片的代码添加这几行代码到<strong>init(coder:)</strong>方法：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">addSubview(self.progressIndicatorView)</span><br><span class="line"></span><span class="label">progressIndicatorView.frame</span> = <span class="keyword">bounds</span><br><span class="line"></span><span class="label">progressIndicatorView.autoresizingMask</span> = .FlexibleWidth <span class="title">| .FlexibleHeight</span></span><br></pre></td></tr></table></figure>
<p>上面代码添加进度指示器作为一个subview添加到自定义的image view。<strong>autoresizingMask</strong>确保进度指示器view保持与image view的size一样。</p>
<p>编译和运行你的项目；你会看到一个红的、空心的圆形出现，就像这样：</p>
<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2015/02/Screenshot-2015-01-25-21.44.17.png" alt=""></p>
<p>好的 - 你已经有进度指示器画在屏幕上。你的下一个任务就是根据下载进度变化来stroke。</p>
<h2 id="修改Stroke长度">修改Stroke长度</h2><p>回到<strong>CircularLoaderView.swift</strong>文件和在这个文件的其他属性直接添加以下代码：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">var</span> progress: CGFloat &#123;</span><br><span class="line">  <span class="preprocessor">get</span> &#123;</span><br><span class="line">    return circlePathLayer.<span class="keyword">strokeEnd</span><br><span class="line"></span>  &#125;</span><br><span class="line">  set &#123;</span><br><span class="line">    <span class="preprocessor">if</span> (newValue &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      circlePathLayer.<span class="keyword">strokeEnd </span>= <span class="number">1</span></span><br><span class="line">    &#125; <span class="preprocessor">else</span> <span class="preprocessor">if</span> (newValue &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      circlePathLayer.<span class="keyword">strokeEnd </span>= <span class="number">0</span></span><br><span class="line">    &#125; <span class="preprocessor">else</span> &#123;</span><br><span class="line">      circlePathLayer.<span class="keyword">strokeEnd </span>= newValue</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码创建一个<strong>computed property</strong> - 也就是一个属性没有任何后背的变量 - 它有一个自定义的setter和getter。这个getter只是返回<strong>circlePathLayer.strokeEnd</strong>，setter验证输入值要在0到1之间，然后恰当地设置layer的<strong>strokeEnd</strong>属性。</p>
<p>在第一次运行的时候，添加下面这行代码到<strong>configure()</strong>来初始化进度：</p>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">progress </span>=<span class="string"> 0</span></span><br></pre></td></tr></table></figure>
<p>编译和运行工程；除了一个空白的屏幕，你应该什么也没看到。相信我，这是一个好消息。设置<strong>progress</strong>为0，反过来会设置<strong>strokeEnd</strong>也为0，这就意味着shape layer什么也没画。</p>
<p>唯一剩下要做的就是你的指示器在image下载回调方法中更新<strong>progress</strong>。</p>
<p>回到<strong>CustomImageView.swift</strong>文件和用以下代码来代替注释<strong>Update progress here</strong>：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self!<span class="class">.progressIndicatorView</span><span class="class">.progress</span> = <span class="function"><span class="title">CGFloat</span><span class="params">(receivedSize)</span></span>/<span class="function"><span class="title">CGFloat</span><span class="params">(expectedSize)</span></span></span><br></pre></td></tr></table></figure>
<p>这主要通过<strong>receivedSize</strong>除以<strong>expectedSize</strong>来计算进度。</p>
<blockquote>
<p>注意：你会注意到block使用weak self引用 - 这样能够避免retain cycle。</p>
</blockquote>
<p>编译和运行你的工程；你会看到进度指示器像这样开始移动：</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/02/indicator.gif" alt=""></p>
<p>即使你自己没有添加任何动画代码，<strong>CALayer</strong>在layer轻松地发现任何animatable属性和当属性改变时平滑地animate。</p>
<p>上面已经完成第一个阶段。现在进入第二和最后阶段。</p>
<h1 id="创建Reveal动画">创建Reveal动画</h1><p>reveal阶段在window显示image然后逐渐扩展圆形环的形状。如果你已经读过<a href="http://www.raywenderlich.com/86521/how-to-make-a-view-controller-transition-animation-like-in-the-ping-app" target="_blank" rel="external">前面教程</a>，那个教程主要讲创建一个Ping风格的view controller动画，你就会知道这是一个很好的关于<strong>CALayer</strong>的<strong>mask</strong>属性的使用案例。</p>
<p>添加以下方法到<strong>CircularLoaderView.swift</strong>文件：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func reveal<span class="params">()</span> &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  backgroundColor = UIColor.clearColor<span class="params">()</span></span><br><span class="line">  progress = <span class="number">1</span></span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  circlePathLayer.removeAnimationForKey<span class="params">(<span class="string">"strokeEnd"</span>)</span></span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  circlePathLayer.removeFromSuperlayer<span class="params">()</span></span><br><span class="line">  superview?.layer.mask = circlePathLayer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个很重要的方法需要理解，让我们逐段看一遍：</p>
<ol>
<li><p>设置view的背景色为clear，那么在view后面的image不再隐藏，然后设置<strong>progress</strong>为1或100%。</p>
</li>
<li><p>使用<strong>strokeEnd</strong>属性来移除任何待定的implicit animations，否则干扰reveal animation。关于implicit animations的更多信息，请查看<a href="http://www.raywenderlich.com/store/ios-animations-by-tutorials" target="_blank" rel="external">iOS Animations by Tutorials</a>.</p>
</li>
<li><p>从它的<strong>superLayer</strong>移除<strong>circlePathLayer</strong>，然后赋值给<strong>superView</strong>的layer maks，借助circular mask “hole”，image是可见的。这样让你复用已存在的layer和避免重复代码。</p>
</li>
</ol>
<p>现在你需要在某个地方调用<strong>reveal()</strong>。在<strong>CustomImageView.swift</strong>文件用以下代码替换<strong>Reveal image here</strong>注释：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self!<span class="class">.progressIndicatorView</span><span class="class">.reveal</span>()</span><br></pre></td></tr></table></figure>
<p>编译和运行你的app；一旦image开始下载，你会看见一部分小的ring在显示。</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/02/Screenshot-2015-01-26-02.49.54.png" alt=""></p>
<p>你能在背景看到你的image - 但几乎什么也没有！</p>
<h2 id="扩展环">扩展环</h2><p>你的下一步就是在内外扩展这个环。你可以两个分离的、同轴心的<strong>UIBezierPath</strong>来做到，但你也可以一个更加有效的方法，只是使用一个Bezier path来完成。</p>
<p>怎样做呢？你只是增加圆的半径(<strong>path</strong>属性)来向外扩展，同时增加line的宽度(<strong>lineWidth</strong>属性)来使环更加厚和向内扩展。最终，两个值都增长到足够时就在下面显示整个image。</p>
<p>回到<strong>CircularLoaderView.swift</strong>文件和添加以下代码到reveal()方法的最后：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">let center = <span class="function"><span class="title">CGPoint</span><span class="params">(x: CGRectGetMidX(bounds)</span></span>, y: <span class="function"><span class="title">CGRectGetMidY</span><span class="params">(bounds)</span></span>)</span><br><span class="line">let finalRadius = <span class="function"><span class="title">sqrt</span><span class="params">((center.x*center.x)</span></span> + (center.y*center.y))</span><br><span class="line">let radiusInset = finalRadius - circleRadius</span><br><span class="line">let outerRect = <span class="function"><span class="title">CGRectInset</span><span class="params">(circleFrame()</span></span>, -radiusInset, -radiusInset)</span><br><span class="line">let toPath = <span class="function"><span class="title">UIBezierPath</span><span class="params">(ovalInRect: outerRect)</span></span><span class="class">.CGPath</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">let fromPath = circlePathLayer<span class="class">.path</span></span><br><span class="line">let fromLineWidth = circlePathLayer<span class="class">.lineWidth</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">CATransaction.<span class="function"><span class="title">begin</span><span class="params">()</span></span></span><br><span class="line">CATransaction.<span class="function"><span class="title">setValue</span><span class="params">(kCFBooleanTrue, forKey: kCATransactionDisableActions)</span></span></span><br><span class="line">circlePathLayer<span class="class">.lineWidth</span> = <span class="number">2</span>*finalRadius</span><br><span class="line">circlePathLayer<span class="class">.path</span> = toPath</span><br><span class="line">CATransaction.<span class="function"><span class="title">commit</span><span class="params">()</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line">let lineWidthAnimation = <span class="function"><span class="title">CABasicAnimation</span><span class="params">(keyPath: <span class="string">"lineWidth"</span>)</span></span></span><br><span class="line">lineWidthAnimation<span class="class">.fromValue</span> = fromLineWidth</span><br><span class="line">lineWidthAnimation<span class="class">.toValue</span> = <span class="number">2</span>*finalRadius</span><br><span class="line">let pathAnimation = <span class="function"><span class="title">CABasicAnimation</span><span class="params">(keyPath: <span class="string">"path"</span>)</span></span></span><br><span class="line">pathAnimation<span class="class">.fromValue</span> = fromPath</span><br><span class="line">pathAnimation<span class="class">.toValue</span> = toPath</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line">let groupAnimation = <span class="function"><span class="title">CAAnimationGroup</span><span class="params">()</span></span></span><br><span class="line">groupAnimation<span class="class">.duration</span> = <span class="number">1</span></span><br><span class="line">groupAnimation<span class="class">.timingFunction</span> = <span class="function"><span class="title">CAMediaTimingFunction</span><span class="params">(name: kCAMediaTimingFunctionEaseInEaseOut)</span></span></span><br><span class="line">groupAnimation<span class="class">.animations</span> = [pathAnimation, lineWidthAnimation]</span><br><span class="line">groupAnimation<span class="class">.delegate</span> = self</span><br><span class="line">circlePathLayer.<span class="function"><span class="title">addAnimation</span><span class="params">(groupAnimation, forKey: <span class="string">"strokeWidth"</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>现在逐段解释以上代码是究竟做了什么：</p>
<ol>
<li><p>确定圆形的半径之后就能完全限制image view。然后计算<strong>CGRect</strong>来完全限制这个圆形。<strong>toPath</strong>表示<strong>CAShapeLayer</strong> mask的最终形状。</p>
</li>
<li><p>设置<strong>lineWidth</strong>和<strong>path</strong>初始值来匹配当前layer的值。</p>
</li>
<li><p>设置<strong>lineWidth</strong>和<strong>path</strong>的最终值；这样能防止它们当动画完成时跳回它们的原始值。<strong>CATransaction</strong>设置<strong>kCATransactionDisableActions</strong>键对应的值为<strong>true</strong>来禁用layer的implicit animations。</p>
</li>
<li><p>创建一个两个<strong>CABasicAnimation</strong>的实例，一个是路径动画，一个是<strong>lineWidth</strong>动画，<strong>lineWidth</strong>必须增加到两倍跟半径增长速度一样快，这样圆形向内扩展与向外扩展一样。</p>
</li>
<li><p>将两个animations添加到一个<strong>CAAnimationGroup</strong>，然后添加animation group到layer。将<strong>self</strong>赋值给delegate，等下你会使用到它。</p>
</li>
</ol>
<p>编译和运行你的工程；你会看到一旦image完成下载，reveal animation就会弹出来。但即使reveal animation完成，部分圆形还是会保持在屏幕上。</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/02/StillVisible.png" alt=""></p>
<p>为了修复这种情况，添加以下实现<strong>animationDidStop(_:finished:)</strong> 到 <strong>CircularLoaderView.swift</strong>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">animationDidStop</span><span class="params">(anim: CAAnimation!, finished flag: Bool)</span></span> &#123;</span><br><span class="line">  superview?.layer.mask = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些代码从super layer上移除mask，这会完全地移除圆形。</p>
<p>再次编译和运行你的工程，和你会看到整个动画的效果：</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/02/indicator-final-final.gif" alt=""></p>
<p>恭喜你，你已经完成创建圆形图像加载动画！</p>
<h1 id="下一步">下一步</h1><p>你可以<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2015/02/ImageLoaderIndicator-Final.zip" target="_blank" rel="external">在这里下载整个工程</a>。</p>
<p>基于本教程，你可以进一步来微调动画的时间、曲线和颜色来满足你的需求和个人设计美学。一个可能需要改进就是设置shape layer的<strong>lineCap</strong>属性值为<strong>kCALineCapRound</strong>来四舍五入圆形进度指示器的尾部。你自己思考还有什么可以改进的地方。</p>
<p>如果你喜欢这个教程和愿意学习怎样创建更多像这样的动画，请查看Marin Todorov的书<a href="http://www.raywenderlich.com/store/ios-animations-by-tutorials" target="_blank" rel="external">iOS Animations by Tutorials</a>。它是从基本的动画开始，然后逐步讲解layer animations, animating constraints, view controller transitions和更多</p>
<p>如果你有什么关于这个教程的问题或评论，请在下面参与讨论。我很乐意看到你在你的App中添加这么酷的动画。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="使用CAShapeLayer来实现圆形图片加载动画">使用CAShapeLayer来实现圆形图片加载动画</h2><blockquote>
<ul>
<li>原文链接 : <a href="http://www.raywenderlich.com/94302/implement-circular-image-loader-animation-cashapelayer">How To Implement A Circular Image Loader Animation with CAShapeLayer</a></li>
<li>原文作者 : <a href="http://www.raywenderlich.com/u/rounak">Rounak Jain</a></li>
<li>译文出自 : <a href="http://www.devtf.cn">开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/samlaudev">Sam Lau</a> </li>
<li>校对者: <a href="https://github.com/Lollypo">Lollypo</a>  </li>
<li>状态 :  校正完</li>
</ul>
</blockquote>
<p>几个星期之前，Michael Villar在Motion试验中创建一个非常有趣的加载动画。</p>
<p>下面的GIF图片展示这个加载动画，它将一个圆形进度指示器和圆形渐现动画结合。这个组合的效果有趣，独一无二和有点迷人。</p>
<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2015/02/Circle.gif" alt=""></p>
<p>这个教程将会教你如何使用Swift和Core Animatoin来重新创建这个效果。让我们开始吧！</p>
<h1 id="基础">基础</h1><p>首先下载这个教程的<a href="http://cdn1.raywenderlich.com/wp-content/uploads/2015/02/ImageLoaderIndicator-Starter.zip">启动项目</a>，然后编译和运行。过一会之后，你应该看到一个简单的image显示：</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/02/StarterProject.png" alt=""></p>
<p>这个启动项目已经预先在恰当的位置将views和加载逻辑编写好了。花一分钟来浏览来快速了解这个项目；那里有一个<strong>ViewController</strong>，<strong>ViewController</strong>里有一个命名为<strong>CustomImageView</strong>的<strong>UIImageView</strong>子类, 还有一个<strong>SDWebImage</strong>的方法被调用来加载image。</p>
<p>你可能注意到当你第一次运行这个app的时候，当image下载时这个app似乎会暂停几秒，然后image会显示在屏幕。当然，此刻没有圆形进度指示器 - 你将会在这个教程中创建它！</p>
<p>你会在两个步骤中创建这个动画：</p>
<ol>
<li><strong>圆形进度</strong>。首先，你会画一个圆形进度指示器，然后根据下载进度来更新它。</li>
<li><strong>扩展圆形图片</strong>。第二，你会通过扩展的圆形窗口来揭示下载图片。</li>
</ol>
<p>紧跟着下面步骤来逐步实现！</p>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://ytlvy.com/tags/Swift/"/>
    
      <category term="Swift" scheme="http://ytlvy.com/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift Extensions Nuances]]></title>
    <link href="http://ytlvy.com/2015/08/08/Swift-Extensions-Nuances/"/>
    <id>http://ytlvy.com/2015/08/08/Swift-Extensions-Nuances/</id>
    <published>2015-08-08T12:54:25.000Z</published>
    <updated>2015-08-08T12:55:20.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Swift扩展的三个微妙细节">Swift扩展的三个微妙细节</h2><blockquote>
<ul>
<li>原文链接 : <a href="http://www.andrewcbancroft.com/2015/04/22/3-nuances-of-swift-extensions/" target="_blank" rel="external">3 Nuances of Swift Extensions</a></li>
<li>原文作者 : <a href="http://www.andrewcbancroft.com/" target="_blank" rel="external">Andrew Bancroft</a></li>
<li>译文出自 : <a href="www.devtf.cn">开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/samw00/" target="_blank" rel="external">samw00</a> </li>
<li>校对者:  </li>
<li>状态 :  校对中 </li>
</ul>
</blockquote>
<p>每当我初次翻看某文档时，我都走马观花似的快速阅过，还一边点着头一边喃喃自语说：“好！懂了，就这么回事！”，可是过后当我真正要运用到这些我以为已经理解了的知识点时，却发现实际情况和我想的往往不一样，每当这时我就懵了，心想：“哇哦…怎么回事？这和我想的完全不一样啊！文档里有说这事吗？”。</p>
<p>最近的几次讨论促使我扪心自问是否真正的理解了Swift中的扩展。我阅读过关于扩展的文档，并且我“认为”我自己对这块内容已经是理解的相当透彻了。可是这几次讨论，加上自己私下通过敲代码的验证，让我发现了我原先不曾注意到几个微妙的细节。</p>
<p><strong>更新</strong>：这篇文章刚一发表，Swift社区就出手襄助并帮助我弄明白了我最根本的纠结点在哪。为此，我写了另一篇文章“<a href="http://www.andrewcbancroft.com/2015/04/24/clarifying-swift-access-control-hint-swift-isnt-c-sharp/" target="_blank" rel="external">阐明Swift访问控制</a>”进一步说明我之前的误解。为了避免犯我曾今犯过的错误，我建议大家去读一读。</p>
<h2 id="三个关于扩展的微妙细节">三个关于扩展的微妙细节</h2><p>对下面列出的三个细节的思考严重挑战了我之前对Swift扩展的理解：</p>
<ol>
<li>Swift扩展对它所扩展类型的<strong>visibility</strong>。比如，扩展能访问被<code>private</code>所修饰的内容吗?</li>
<li>定义扩展的位置是否对扩展的<strong>visibility</strong>有影响。比如我这有一个类型我想写个扩展，把扩展写在同一个源文件里和把扩展写在另一个文件里有什么区别吗？</li>
<li>扩展里“成员”的默认访问修饰符以及是否给他们添加修饰对这个扩展作为一个类型的公共接口的影响。</li>
</ol>
<p>在我开始之前，假设我有一个公共结构体<code>Person</code>。这个结构体有一些私有属性，<code>name</code>，<code>gender</code>，和<code>age</code>。用一个枚举把<code>Gender</code>封装了一下。这个结构体看起来如下：</p>
<a id="more"></a>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public struct <span class="keyword">Person</span> &#123;</span><br><span class="line">    private var name: String</span><br><span class="line">    private var <span class="keyword">gender</span>: <span class="keyword">Gender</span></span><br><span class="line">    private var age: Int</span><br><span class="line"></span><br><span class="line">    public init(name: String, <span class="keyword">gender</span>: <span class="keyword">Gender</span>, age: Int) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">        self.<span class="keyword">gender</span> = <span class="keyword">gender</span></span><br><span class="line">        self.age = age</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public func howOldArdYou() -&gt; String &#123;</span><br><span class="line">        return formattedAge()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 私有方法，用于下面分析扩展的`visibility`...</span><br><span class="line">    private func formattedAge() -&gt; String &#123;</span><br><span class="line">        switch self.<span class="keyword">gender</span> &#123;</span><br><span class="line">        case .Male:</span><br><span class="line">            return <span class="string">"I'm \(self.age)."</span></span><br><span class="line">        case .Female:</span><br><span class="line">            return <span class="string">"Not telling."</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public enum <span class="keyword">Gender</span> &#123;</span><br><span class="line">        case Male</span><br><span class="line">        case Female</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，就让我们给<code>Person</code>写个扩展，通过实践来弄清楚刚刚提到的三个小细节…</p>
<h2 id="扩展对类型的访问能力">扩展对类型的访问能力</h2><p>当我提出第一个细节时，关于扩展对被扩展类型的访问能力时，我问了一个问题：“扩展能访问到被<code>private</code>修饰的内容吗?”。答案一开始出乎我的预料：能…扩展能访问到。</p>
<p>然而，这里就要考虑到第二个细节所涉及的问题，那就是：在<strong>哪里</strong>定义这个扩展是绝对有影响的。</p>
<h3 id="定义在同一个文件里">定义在同一个文件里</h3><p>如果扩展和类型是在写同一个源文件里，则扩展<strong>能</strong>访问到在类型中被<code>priavte</code>所修饰的内容。</p>
<p>举个栗子，在Person.swift里定义一个<code>Person</code>的扩展就会允许这个扩展访问被<code>private</code>修饰的变量和方法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">getAge</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age <span class="comment">// 尽管age是 --private--， 但编译成功</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">getFormattedAge</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> formattedAge() <span class="comment">// 尽管 formattedAge是 --private--，但编译成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“这谁知道？！什么？？为啥？”，我当时就没想明白…</p>
<p>至于为什么把扩展写在同一个源文件里头会这样，我自己的推理是其实可以在写类型的时候，就把扩展的implementation当作类型的一部分给写了，这样的最终效果是一样的。</p>
<p>我在我要“扩展”的类型的<strong>源文件</strong>里，所以无论是我把要新添加的功能当作这个类型的扩展写下来，或是就在这个类型里面定义我原本打算写在扩展里的功能是没有区别的，都是一样的效果。</p>
<p>所以，站在编译器的角度来看，编译器可能会说：“好吧，我看到这里写了一个扩展，但是真没这个必要，因为扩展和类型都在同一个源文件里…，所以开发者完全可以把扩展里的这些代码直接写在类型里面…，所以他／她能够访问到被<code>private</code>修饰的代码段。”</p>
<p><strong>更新:</strong>我上面的写的推理恰恰说明了我压根就没搞明白Swift访问控制机制。所以我建议大家读一读我后来写的“<a href="http://www.andrewcbancroft.com/2015/04/24/clarifying-swift-access-control-hint-swift-isnt-c-sharp/" target="_blank" rel="external">阐明Swfit控制机制</a>”这篇文章，里面有更多的细节。</p>
<h3 id="定义在不同文件里">定义在不同文件里</h3><p>把扩展写在另一个文件里，则扩展无法访问类型中那些被<code>private</code>修饰的内容了。</p>
<p>按照上文我自己推理的逻辑来反过来想，定义在不同文件中就访问不了私有属性对我来说也是说的通的。</p>
<p>大多数情况下，你都会给那些你<strong>没有</strong>源代码的类型扩展，在这种情况下，扩展就只能访问那些被<code>public</code>修饰的内容了。<br><img src="http://www.andrewcbancroft.com/wp-content/uploads/2015/04/PersonExtensions_swift.png" alt="pic1"></p>
<h2 id="默认情况下的扩展访问控制">默认情况下的扩展访问控制</h2><p>对最后一个细节的验证也让我更深的体会。<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html#//apple_ref/doc/uid/TP40014097-CH41-ID25" target="_blank" rel="external">苹果官方文档</a>说了，但是直到我动手验证了一番，我才算领会到了默认访问控制修饰符给扩展所造成的微妙的影响。</p>
<h3 id="没有明确声明访问修饰赋时的默认访问">没有明确声明访问修饰赋时的默认访问</h3><p>简单的说，当你声明一个扩展但没有特别明确指明访问修饰符时（默认情况下），这个扩展的默认访问等级取决于被扩展的那个类型的访问等级。</p>
<ul>
<li>如果类型是<code>public</code>或者是<code>internal</code>，那么扩展的implementation的“成员”就默认为<code>internal</code>。这里让我没想到是，除非你特别声明，那么给<code>public</code>类型的扩展的成员变量在默认情况下也是<code>internal</code>。</li>
<li>如果类型是<code>private</code>，那么默认情况下扩展的implementation中的“成员”也是<code>private</code></li>
</ul>
<p>下面就是在我们不明确的声明添加什么访问修饰的前提下，来看扩展会是一个什么反应（为了能访问私有属性变量和方法，我在Person.swift里定义了这个扩展）：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public struct <span class="keyword">Person</span> &#123;</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension <span class="keyword">Person</span> &#123;</span><br><span class="line">    func getAge() -&gt; Int &#123;</span><br><span class="line">        return age</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func getFormattedAge() -&gt; String &#123;</span><br><span class="line">        return formattedAge()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像上面这段代码用默认的访问修饰符时就会允许在同一个模块中的实例访问扩展里的API。但是，如果被扩展的类型的实例是在另一个模块（比如在测试模块）,则无法访问扩展中任何新增的公共API。</p>
<h4 id="同一模块">同一模块</h4><p><img src="http://www.andrewcbancroft.com/wp-content/uploads/2015/04/SameModule.png" alt="pic2"></p>
<h4 id="不同模块（测试）">不同模块（测试）</h4><p><img src="http://www.andrewcbancroft.com/wp-content/uploads/2015/04/DifferentModule.png" alt="pic3"><br>因为某些原因，我一直都以为如果给一个是<code>public</code>的类型添加扩展，那么扩展里的成员也理应是<code>public</code>。我不知道为什么我会这么想，但是幸好我的验证把这点捋清楚了。</p>
<h3 id="正常声明扩展，但给扩展的implementation添加public修饰">正常声明扩展，但给扩展的implementation添加public修饰</h3><p>给扩展的implementation的成员添加了<code>public</code>访问控制修饰，那么不管是在同一模块还是不同模块（test target）都能访问这些成员。</p>
<p>只要成员被<code>public</code>修饰，那么在同一个源文件里声明扩展还是在另一个文件里声明扩展已经无所谓了…但是，正如前文所讲，只有在同一个源文件中声明的扩展才能够访问那些被<code>private</code>修饰的类型成员变量。</p>
<h4 id="在不同（左）和同一个（右）源文件中声明的扩展">在不同（左）和同一个（右）源文件中声明的扩展</h4><p><img src="http://www.andrewcbancroft.com/wp-content/uploads/2015/04/public_extension_members.png" alt="pic4"></p>
<h4 id="在不同模块中也能访问公共的扩展成员变量">在不同模块中也能访问公共的扩展成员变量</h4><p><img src="http://www.andrewcbancroft.com/wp-content/uploads/2015/04/public_member_visibility.png" alt="pic5"><br>这里请注意，在我写<code>extension Person {...}</code>时，我没有给这个扩展添加任何的修饰，我只是给这个扩展的成员添加了<code>public</code>。即便如此，新添加的方法仍然可以在不同的模块中被访问到。</p>
<p>也就是说，没有必要写<code>public extension Person {...}</code>。因为<code>Person</code>已经是<code>public</code>了，所以基于<code>Person</code>的扩展也就很自然的延用了类型本身的访问等级。</p>
<h2 id="总结">总结</h2><p>对我来说，这篇文章所提到的三个关于Swift扩展的细节已足以让我敲敲代码去验证一番了。我希望这里所作的分析能够为那些尝试理解Swfit扩展的朋友扫清一些障碍。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Swift扩展的三个微妙细节">Swift扩展的三个微妙细节</h2><blockquote>
<ul>
<li>原文链接 : <a href="http://www.andrewcbancroft.com/2015/04/22/3-nuances-of-swift-extensions/">3 Nuances of Swift Extensions</a></li>
<li>原文作者 : <a href="http://www.andrewcbancroft.com/">Andrew Bancroft</a></li>
<li>译文出自 : <a href="www.devtf.cn">开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/samw00/">samw00</a> </li>
<li>校对者:  </li>
<li>状态 :  校对中 </li>
</ul>
</blockquote>
<p>每当我初次翻看某文档时，我都走马观花似的快速阅过，还一边点着头一边喃喃自语说：“好！懂了，就这么回事！”，可是过后当我真正要运用到这些我以为已经理解了的知识点时，却发现实际情况和我想的往往不一样，每当这时我就懵了，心想：“哇哦…怎么回事？这和我想的完全不一样啊！文档里有说这事吗？”。</p>
<p>最近的几次讨论促使我扪心自问是否真正的理解了Swift中的扩展。我阅读过关于扩展的文档，并且我“认为”我自己对这块内容已经是理解的相当透彻了。可是这几次讨论，加上自己私下通过敲代码的验证，让我发现了我原先不曾注意到几个微妙的细节。</p>
<p><strong>更新</strong>：这篇文章刚一发表，Swift社区就出手襄助并帮助我弄明白了我最根本的纠结点在哪。为此，我写了另一篇文章“<a href="http://www.andrewcbancroft.com/2015/04/24/clarifying-swift-access-control-hint-swift-isnt-c-sharp/">阐明Swift访问控制</a>”进一步说明我之前的误解。为了避免犯我曾今犯过的错误，我建议大家去读一读。</p>
<h2 id="三个关于扩展的微妙细节">三个关于扩展的微妙细节</h2><p>对下面列出的三个细节的思考严重挑战了我之前对Swift扩展的理解：</p>
<ol>
<li>Swift扩展对它所扩展类型的<strong>visibility</strong>。比如，扩展能访问被<code>private</code>所修饰的内容吗?</li>
<li>定义扩展的位置是否对扩展的<strong>visibility</strong>有影响。比如我这有一个类型我想写个扩展，把扩展写在同一个源文件里和把扩展写在另一个文件里有什么区别吗？</li>
<li>扩展里“成员”的默认访问修饰符以及是否给他们添加修饰对这个扩展作为一个类型的公共接口的影响。</li>
</ol>
<p>在我开始之前，假设我有一个公共结构体<code>Person</code>。这个结构体有一些私有属性，<code>name</code>，<code>gender</code>，和<code>age</code>。用一个枚举把<code>Gender</code>封装了一下。这个结构体看起来如下：</p>]]>
    
    </summary>
    
      <category term="Extensions" scheme="http://ytlvy.com/tags/Extensions/"/>
    
      <category term="Swift" scheme="http://ytlvy.com/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS What’s New in Swift 2]]></title>
    <link href="http://ytlvy.com/2015/08/08/iOS-What%E2%80%99s-New-in-Swift-2/"/>
    <id>http://ytlvy.com/2015/08/08/iOS-What’s-New-in-Swift-2/</id>
    <published>2015-08-08T12:13:45.000Z</published>
    <updated>2015-08-08T12:15:42.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Swift_2_有哪些新特性">Swift 2 有哪些新特性</h2><blockquote>
<ul>
<li>原文链接 : <a href="http://www.raywenderlich.com/108522/whats-new-in-swift-2" target="_blank" rel="external">What’s New in Swift 2</a></li>
<li>原文作者 : <a href="http://www.raywenderlich.com/u/gregheo" target="_blank" rel="external">Greg Heo</a></li>
<li>译文出自 : <a href="http://www.devtf.cn" target="_blank" rel="external">开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/samlaudev" target="_blank" rel="external">Sam Lau</a> </li>
<li>校对者: <a href="https://github.com/bboyfeiyu" target="_blank" rel="external">Mr.Simple</a>  </li>
<li>状态 :  校正完</li>
</ul>
</blockquote>
<p>在WWDC我们发现Swift团队没有浪费时间在无谓的地方，而是致力于改善Swift 2。</p>
<p>我们将会为你编写和录制很多关于Swift 2的教程，但在此期间我想强调Swift最令人兴奋的改变，为你可以在秋天迁移到Swift 2做准备。</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/06/swift-new.jpg" alt=""></p>
<h1 id="错误处理">错误处理</h1><p>正如Ray在<a href="http://www.raywenderlich.com/108379/wwdc-2015-initial-impressions" target="_blank" rel="external">WWDC 2015 Initial Impressions</a>文章中提及，错误处理已经在Swift 2改进了。我们已经迁移到新的系统就像异常处理，而不是<strong>NSError</strong>对象和双指针。</p>
<p>你可能对以下代码比较熟悉：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> drinkWithError(<span class="constant">nil</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Could not drink beer! :["</span>)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般在Cocoa，你传入一个<strong>NSError</strong>对象的引用(一个<strong>inout</strong>参数在Swift)，然后方法会赋值给错误变量。但问题是你可以传入一个nil到这里来完全忽略这个错误；或者，你可以传入<strong>NSError</strong>但从不检查它。</p>
<p>Swift 2 为错误检查添加额外保护层。你可以使用<strong>throws</strong>关键字来指定那个函数和方法能够抛出一个错误。然后当你调用某样东西时，可以用<strong>do</strong>, <strong>try</strong>和<strong>catch</strong>多个关键字来捕捉和处理错误。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DrinkError</span>: <span class="title">ErrorType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">NoBeerRemainingError</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">drinkWithError</span><span class="params">()</span></span> throws &#123;</span><br><span class="line">  <span class="keyword">if</span> beer.isAvailable() &#123;</span><br><span class="line">    <span class="comment">// party!</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    throw <span class="type">DrinkError</span>.<span class="type">NoBeerRemainingError</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tryToDrink</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 4</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    try drinkWithError()</span><br><span class="line">  &#125; catch &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Could not drink beer! :["</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有几样东西需要强调的：</p>
<ol>
<li>为了创建一个错误可以抛出，只是创建一个继承<strong>ErrorType</strong>的<strong>enum</strong>。</li>
<li>你需要使用<strong>throws</strong>关键字来标志任何函数可以抛出一个错误。</li>
<li>这里抛出一个错误，它将会在section 4中被捕捉。</li>
<li>你在一个<strong>do</strong>块中包含任何可以抛出一个错误的代码，而不是其他语言类似的<strong>try</strong>块中。然后，你添加一个<strong>try</strong>关键字到函数被调用的前面，而且这个函数能够抛出一个错误。</li>
</ol>
<p>新语法是非常简洁和易读。任何API当前使用<strong>NSError</strong>以后都会使用这种错误处理方式。</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/06/throw-all-the-things-415x320.jpg" alt=""></p>
<a id="more"></a>
<h1 id="绑定">绑定</h1><p>在Swift 1.2，我们失去了金字塔的厄运和能够在一行代码测试多个绑定的optionals：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">pants =</span> pants, <span class="variable">frog =</span> frog &#123;</span><br><span class="line">  // good stuff here!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样勉强能够工作，但对于有些人需要缩进那个嵌套着很多optionals才能访问的值的“首选”的代码路径是一个问题。这意味着你需要深入查看缩进主线部分的代码块，而错误条件却在外面。</p>
<p>如果有些方式来检查一些没有值的optionals，然后早点退出。这正是Swift 2提供的guard语句：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">guard <span class="reserved">let</span> pants = pants, frog = frog <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="regexp">//</span> sorry, <span class="literal">no</span> frog pants here :[</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="regexp">//</span> at <span class="keyword">this</span> point, frog <span class="keyword">and</span> pants are both unwrapped <span class="keyword">and</span> bound!</span><br></pre></td></tr></table></figure>
<p>使用<strong>guard</strong>意味着你可以执行optional binding (或其他操作)和如果条件失败就提供一个代码块在<strong>else</strong>运行。然后，你可以继续执行。在这种情况下，optionals <strong>frog</strong>和<strong>pants</strong>在作用域内被unwrap。</p>
<p>使用<strong>guard</strong>指定某种你希望得到状态而不是检查错误情况之后，使代码更加简洁。</p>
<blockquote>
<p><strong>注意：</strong> 如果你仍然不明白为什么使用<strong>guard</strong>语句比<strong>if-else</strong>语句更加有用，请查看Swift团队<a href="http://www.raywenderlich.com/u/ecerney" target="_blank" rel="external">Eric Cerney‘s post</a>在<a href="http://ericcerney.com/swift-guard-statement/" target="_blank" rel="external">Swift guard statement</a>。</p>
</blockquote>
<h1 id="协议扩展">协议扩展</h1><p>面向对象编程？函数式编程？Swift其实还是一种面向协议的编程语言！</p>
<p>在Swift 1，协议就像接口一样可以指定一些属性和方法，然后类，结构体或枚举会遵循它。</p>
<p>现在在Swift 2，你可以扩展协议和给属性和方法添加默认实现。你之前已经可以在类或结构体添加新的方法到<strong>String</strong>或<strong>Array</strong>，但现在你可以添加这些到协议，这让你更加广泛地应用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CustomStringConvertible</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> shoutyDescription: <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"<span class="subst">\(<span class="keyword">self</span>.description.uppercaseString)</span>!!!"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> greetings = [<span class="string">"Hello"</span>, <span class="string">"Hi"</span>, <span class="string">"Yo yo yo"</span>]</span><br><span class="line"> </span><br><span class="line"><span class="comment">// prints ["Hello", "Hi", "Yo yo yo"]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(greetings.description)</span>"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// prints [HELLO, HI, YO YO YO]!!!</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(greetings.shoutyDescription)</span>"</span>)</span><br></pre></td></tr></table></figure>
<p>注意<strong>Printable</strong>协议现在被命名为<strong>CustomStringConvertible</strong>，而大多数的Foundation对象都遵循<strong>Printable</strong>协议。有了协议扩展之，你可以用自定义功能来扩展系统。相比于向很多类、结构体和枚举添加少量的自定义代码，你可以编写一个通用实现，然后应用到不同的数据类型。</p>
<p>Swift团队已经忙着做这个了 - 如果你在Swift已经使用<strong>map</strong>或<strong>filter</strong>，你可能也认为以方法的方式比全局函数来使用它们更好。多亏了强大的协议扩展，已经有一些新的方法添加到集合类型，例如：<strong>map</strong>，<strong>filter</strong>，<strong>indexOf</strong>和更多！</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">et numbers = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">16</span>, <span class="number">42</span>, <span class="number">45</span>]</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Swift 1</span></span><br><span class="line">find(<span class="keyword">filter</span>(map(numbers, &#123; <span class="variable">$0</span> * <span class="number">2</span>&#125;), &#123; <span class="variable">$0</span> % <span class="number">3</span> == <span class="number">0</span> &#125;), <span class="number">90</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Swift 2</span></span><br><span class="line">numbers.map &#123; <span class="variable">$0</span> * <span class="number">2</span> &#125;.<span class="keyword">filter</span> &#123; <span class="variable">$0</span> % <span class="number">3</span> == <span class="number">0</span> &#125;.indexOf(<span class="number">90</span>) <span class="comment">// returns 2</span></span><br></pre></td></tr></table></figure>
<p>多亏了协议一致性，你的Swift 2代码会变得更加简洁和易读。在Swift 1版本，你需要查看调用函数内部来理解它的工作原理；在Swfit 2版本，函数链会变得清晰。</p>
<p>如果你打算使用面向协议编程 - 请查看<a href="https://developer.apple.com/videos/wwdc/2015/?id=408" target="_blank" rel="external">WWDC session on this topic</a>和留意这个网站的教程和文章。</p>
<h1 id="汇总">汇总</h1><p>在WWDC大会中发布很多东西，所以我想强调几样重要的东西：</p>
<ul>
<li><p><strong>Objective-C 泛型</strong> - Apple已经开始标注所有的Objective-C代码以便Swift类型能够获取正确类型的optional。使用Objective-C泛型也能正常工作，这样给Swift开发者更好的类型提示。如果你希望出现一些<strong>UITouch</strong>对象或字符串数组，那就会出现你想要的而不是一些<strong>AnyObjects</strong>。</p>
</li>
<li><p><strong>重命名 语法</strong> - <strong>println</strong>已经离开我们一年了；现在它是普通旧的<strong>print</strong>，现在它有第二个参数的默认值设置为<strong>true</strong>来决定是否换行。<strong>do</strong>关键字主要用来错误处理，do-while循环现在是使用<strong>repeat-while</strong>。类似地，有很多协议名都改变了，例如：<strong>Printable</strong>改为<strong>CustomStringConvertible</strong>。</p>
</li>
<li><p><strong>Migrator</strong> - 有很多小的语法改变，你怎样使得你代码变得最新？Swift 1-to-2 migrator会将代码变成最新的标准和改变语法。这个migrator智能到能够更新你的代码使用新的错误处理，和更新块注释到新的格式风格！</p>
</li>
<li><p><strong>开源!</strong> - 对码农有一个重大消息就是在秋天发布Swift 2的时候，Swift将会开源！这意味着不仅可以使用它来iOS开发，更重要的是学习它的源代码。不仅如此，这将是很好的机会来深入源代码，甚至为项目贡献代码，然后在swift编译器提交历史上留下你的名字。</p>
</li>
</ul>
<h1 id="下一步">下一步</h1><p>这只是所有发布特性中的一些简单示例；想了解更多，请查看<a href="https://developer.apple.com/videos/wwdc/2015/" target="_blank" rel="external">WWDC session videos</a>和已更新的<a href="https://itunes.apple.com/us/book/swift-programming-language/id1002622538?mt=11" target="_blank" rel="external">Swift Programming Language book</a></p>
<p>如果还有一些人记得在Swift第一个beta版和发布的1.0之间有很多改变，那么将来肯定会有更多地特性出现。我们团队将会持续关注所有的更新，深入挖掘令人兴奋的改变，所以请密切留意教程，书籍和视频。</p>
<p>Swift 2哪部分最令你兴奋？哪部分你想我们第一时间报道？在下面评论让我们知道！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Swift_2_有哪些新特性">Swift 2 有哪些新特性</h2><blockquote>
<ul>
<li>原文链接 : <a href="http://www.raywenderlich.com/108522/whats-new-in-swift-2">What’s New in Swift 2</a></li>
<li>原文作者 : <a href="http://www.raywenderlich.com/u/gregheo">Greg Heo</a></li>
<li>译文出自 : <a href="http://www.devtf.cn">开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/samlaudev">Sam Lau</a> </li>
<li>校对者: <a href="https://github.com/bboyfeiyu">Mr.Simple</a>  </li>
<li>状态 :  校正完</li>
</ul>
</blockquote>
<p>在WWDC我们发现Swift团队没有浪费时间在无谓的地方，而是致力于改善Swift 2。</p>
<p>我们将会为你编写和录制很多关于Swift 2的教程，但在此期间我想强调Swift最令人兴奋的改变，为你可以在秋天迁移到Swift 2做准备。</p>
<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2015/06/swift-new.jpg" alt=""></p>
<h1 id="错误处理">错误处理</h1><p>正如Ray在<a href="http://www.raywenderlich.com/108379/wwdc-2015-initial-impressions">WWDC 2015 Initial Impressions</a>文章中提及，错误处理已经在Swift 2改进了。我们已经迁移到新的系统就像异常处理，而不是<strong>NSError</strong>对象和双指针。</p>
<p>你可能对以下代码比较熟悉：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> drinkWithError(<span class="constant">nil</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Could not drink beer! :["</span>)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般在Cocoa，你传入一个<strong>NSError</strong>对象的引用(一个<strong>inout</strong>参数在Swift)，然后方法会赋值给错误变量。但问题是你可以传入一个nil到这里来完全忽略这个错误；或者，你可以传入<strong>NSError</strong>但从不检查它。</p>
<p>Swift 2 为错误检查添加额外保护层。你可以使用<strong>throws</strong>关键字来指定那个函数和方法能够抛出一个错误。然后当你调用某样东西时，可以用<strong>do</strong>, <strong>try</strong>和<strong>catch</strong>多个关键字来捕捉和处理错误。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DrinkError</span>: <span class="title">ErrorType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">NoBeerRemainingError</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">drinkWithError</span><span class="params">()</span></span> throws &#123;</span><br><span class="line">  <span class="keyword">if</span> beer.isAvailable() &#123;</span><br><span class="line">    <span class="comment">// party!</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    throw <span class="type">DrinkError</span>.<span class="type">NoBeerRemainingError</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tryToDrink</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 4</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    try drinkWithError()</span><br><span class="line">  &#125; catch &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Could not drink beer! :["</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有几样东西需要强调的：</p>
<ol>
<li>为了创建一个错误可以抛出，只是创建一个继承<strong>ErrorType</strong>的<strong>enum</strong>。</li>
<li>你需要使用<strong>throws</strong>关键字来标志任何函数可以抛出一个错误。</li>
<li>这里抛出一个错误，它将会在section 4中被捕捉。</li>
<li>你在一个<strong>do</strong>块中包含任何可以抛出一个错误的代码，而不是其他语言类似的<strong>try</strong>块中。然后，你添加一个<strong>try</strong>关键字到函数被调用的前面，而且这个函数能够抛出一个错误。</li>
</ol>
<p>新语法是非常简洁和易读。任何API当前使用<strong>NSError</strong>以后都会使用这种错误处理方式。</p>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2015/06/throw-all-the-things-415x320.jpg" alt=""></p>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://ytlvy.com/tags/Swift/"/>
    
      <category term="Swift" scheme="http://ytlvy.com/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[swift Core Image Tutorial]]></title>
    <link href="http://ytlvy.com/2015/08/08/swift-Core-Image-Tutorial/"/>
    <id>http://ytlvy.com/2015/08/08/swift-Core-Image-Tutorial/</id>
    <published>2015-08-08T12:11:21.000Z</published>
    <updated>2015-08-08T12:12:19.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Core_Image入门教程(swift)">Core Image入门教程(swift)</h2><blockquote>
<ul>
<li>原文链接 : <a href="http://www.raywenderlich.com/76285/beginning-core-image-swift" target="_blank" rel="external">Core Image Tutorial: Getting Started</a></li>
<li>原文作者 : <a href="http://www.raywenderlich.com/u/nicklockwood" target="_blank" rel="external">Nick Lockwood</a></li>
<li>译文出自 :<a href="http://www.devtf.cn" target="_blank" rel="external">开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/samlaudev" target="_blank" rel="external">Sam Lau</a> </li>
<li>校对者: <a href="https://github.com/mrchenhao" target="_blank" rel="external">Harries Chen</a>  </li>
<li>状态 :  校正完</li>
</ul>
</blockquote>
<p>Core Image是一个强大的框架，它能够让你轻松地对图像进行过滤。你能够通过修改图像的饱和度、色调或曝光率来获取各种特效。你也可以使用CPU或GPU更快地来处理图像数据，快到能够实时处理视频帧数据(video frame)。</p>
<p>Core Image过滤器能够以链式的方式结合将多个特效应用到一个图像或视频帧数据。多个过滤器能够组合成单个过滤器应用在一个图像。通过每次与每个过滤器比较，这使它非常有效地处理图像。</p>
<p>在这个教程中，你将会亲手实践如何使用Core Image.通过使用几个不同的过滤器，你会看到实时使用各种炫酷的特效是多么容易。</p>
<h1 id="基础">基础</h1><p>在你开始之前，让我们先讨论在Core Image框架中几个很重要的类：</p>
<ul>
<li><strong>CIContext</strong>. 所有处理core image的工作都在CIContext完成。这个与Core Graphics或OpenGL context有几分相似。</li>
<li><strong>CIImage</strong>. 这个类保存图像数据，它能够从UIImage，图像文件或像素数据等方式来创建。</li>
<li><strong>CIFilter</strong>. CIFilter类有一个字典(dictionary)来定义特定属性的过滤器，比如常用过滤器有饱和度，颜色翻转，裁剪等属性，还有很多没列出来。</li>
</ul>
<h3 id="CoreImageFun">CoreImageFun</h3><p>打开Xcode并使用<strong>iOS \ Application \ Single View Application</strong>模板来创建一个新工程。输入<strong>CoreImageFun</strong>作为Product Name，选择iPhone为Devices option和确定使用<strong>swift</strong>作为编程语言。</p>
<p>下载<a href="http://cdn5.raywenderlich.com/downloads/CIResources.zip" target="_blank" rel="external">教程的资源</a>，并添加图片<strong>image.png</strong>到工程</p>
<p>下一步，打开<strong>Main.storyboard</strong>你文件，拖拽一个image view到已存在的view，image view作为view的子视图。在Attributes Inspector中，设置image view的content mode属性为Aspect Fit，这样它就不会拉伸图片。</p>
<p>下一步，确定Document Outline(在Interface Builder里canvas左边)是可见的 - 你可以从menu中<strong>Editor \ Show Document Outline</strong>来启用。</p>
<p>按着control键从image view拖动到它的superview三次来添加三个约束(constraint)：</p>
<ol>
<li>添加一个Top Space to Layout Guide的约束，如果有必要的话，使用Size Inspector来设置约束的constant为0 </li>
<li>添加一个Center Horizontally in Container的约束(同样也需要设置constant为0)</li>
<li>添加一个Equal Width约束</li>
</ol>
<p>最后，为了约束image view的高度，按着control键从image view拖动到本身，然后添加一个Aspect Ratio约束，使用Size Inspector来设置它的multiplier的值为8:5对应宽高比和constant factor为0。最后，选择<strong>Editor \ Resolve Auto Layout Issues \ All Views in View Controller \ Update Frames</strong>，那么Interface Builder会根据这些约束来更新布局</p>
<p>下一步，打开Assistant Editor，然后确保它显示<strong>ViewController.swift</strong>。按着control键从UIImageView拖动到刚刚打开的<strong>ViewController</strong>类的大括号。命名outlet为<strong>imageView</strong>，然后点击connect。</p>
<p>编译和运行这个项目来确保目前进展顺利 - 你应该看到一个空屏。初始化设置完成，现在进入Core Image的世界。</p>
<a id="more"></a>
<h1 id="基本图片过滤器">基本图片过滤器</h1><p>你将会通过使用<strong>CIFilter</strong>应用到图像和显示到屏幕来入门。每次你想将CIFilter应用到一个图像，都需要做四件事：</p>
<ol>
<li><strong>创建一个CIImage对象</strong>。CIImage有几个初始化方法，其中包括：CIImage(contentsOfURL:), CIImage(data:), CIImage(CGImage:), CIImage(bitmapData:bytesPerRow:size:format:colorSpace:)等，大多数你都会使用CIImage(contentsOfURL:)方法。</li>
<li><strong>创建一个CIContext对象</strong>。一个CIContext是基于CPU或CPU，在初始化它时比较耗资源，所以需要复用它而不是多次创建。当你输出CIImage对象时，你会经常需要CIContext对象。</li>
<li><strong>创建CIFilter对象</strong>。当你创建一个filter时，你需要配置多个属性来决定你使用的filter。</li>
<li><strong>获取filter的输出</strong>。filter会输出一个CIImage类型的image给你 - 你可以使用CIContext将它转换为UIImage类型image。</li>
</ol>
<p>让我们看看它是如何工作。添加以下代码到<strong>ViewController.swift</strong>的viewDidLoad():方法</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">let fileURL = NSBundle.<span class="function"><span class="title">mainBundle</span><span class="params">()</span></span>.<span class="function"><span class="title">URLForResource</span><span class="params">(<span class="string">"image"</span>, withExtension: <span class="string">"png"</span>)</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">let beginImage = <span class="function"><span class="title">CIImage</span><span class="params">(contentsOfURL: fileURL)</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">let <span class="attribute">filter</span> = <span class="function"><span class="title">CIFilter</span><span class="params">(name: <span class="string">"CISepiaTone"</span>)</span></span></span><br><span class="line"><span class="attribute">filter</span>.<span class="function"><span class="title">setValue</span><span class="params">(beginImage, forKey: kCIInputImageKey)</span></span></span><br><span class="line"><span class="attribute">filter</span>.<span class="function"><span class="title">setValue</span><span class="params">(<span class="number">0.5</span>, forKey: kCIInputIntensityKey)</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line">let newImage = <span class="function"><span class="title">UIImage</span><span class="params">(CIImage: filter.outputImage)</span></span></span><br><span class="line">self<span class="class">.imageView</span><span class="class">.image</span> = newImage</span><br></pre></td></tr></table></figure>
<p>让我们逐段分析以上代码：</p>
<ol>
<li>这行代码创建一个NSURL对象，它保存image文件的路径</li>
<li>通过CIImage(contentsOfURL:)构造器来创建CIImage对象</li>
<li>创建CIFilter对象。CIFilter构造器将name作为参数，然后用dictionary来指定filter的键值对。每个filter都拥有唯一的键和多个有效值。<strong>CISepiaTone</strong> filter只接收两个值<strong>kCIInputImageKey</strong>(CIImage)和<strong>kCIInputIntensityKey</strong>(在0到1之间的一个浮点数)。这里你设置它的值为0.5。如果没有值提供的话，大多数filters都有默认值。但CIImage没有默认值，它必须要提供。</li>
<li>通过使用filter的<strong>outputImage</strong>属性能够轻松地获取CIImage。一旦你有个输出的CIImage，你需要将它转换为UIImage。使用<strong>UIImage(CIImage:)</strong>构造器来创建UIImage。如果你已经将CIImage转换为UIImage，你就能将image显示到image view</li>
</ol>
<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/07/CI-Sepia-Crop.jpg" alt=""></p>
<h1 id="把它放进Context">把它放进Context</h1><p>在你向前看之前，有个优化建议你应该需要知道。</p>
<p>之前我曾提及过，你需要有个<strong>CIContext</strong>来使用CIFilter，但以上例子都没有提及过这个对象。结果变成了由<strong>UIImage(CIImage:)</strong> 构造器来为你处理所有的工作。UIImage它创建一个<strong>CIContext</strong>，然后用它来执行所有过滤图像的操作，这让你更加容易地使用Core Image的API。</p>
<p>但这种方式有一个主要缺点就是每次使用时都创建一个新的<strong>CIContext</strong>对象。<strong>CIContext</strong>对象是为了复用来提高性能。如果你想用一个slider来更新filter的值，是以每次创建一个新的CIContext来实现更新filter的方式，那么运行速度将会很慢。</p>
<p>让我们以恰当的方式来实现。在<strong>viewDidLoad()</strong>里删除步骤4的代码，然后用一下代码来代替：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">let context = <span class="function"><span class="title">CIContext</span><span class="params">(options:nil)</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">let cgimg = context.<span class="function"><span class="title">createCGImage</span><span class="params">(filter.outputImage, fromRect: filter.outputImage.extent()</span></span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">let newImage = <span class="function"><span class="title">UIImage</span><span class="params">(CGImage: cgimg)</span></span></span><br><span class="line">self<span class="class">.imageView</span><span class="class">.image</span> = newImage</span><br></pre></td></tr></table></figure>
<p>我们再一次逐段分析代码：</p>
<ol>
<li>你设置CIContext对象，然后用它来画一个CGImage。<strong>CIContext(options:)</strong>构造器以NSDictionary为参数，它指定一些选项，比如：颜色格式，或者context是否运行在CPU或GPU。对于这个app来说，默认值是可以的，所以你可以传递nil这个值进去。</li>
<li>context调用<strong>createCGImage(outputImage:fromRect:)</strong>方法在给定CIImage参数并返回一个新的CGImage示例。</li>
<li>你根据刚刚获取的CIImage，使用<strong>UIImage(CGImage:)</strong>构造器来创建一个UIImage对象。注意，当我们使用CIImage对象之后，没有必要显式地释放它，虽然在Objective-C需要这样做。但在Swift中，ARC会自动释放Core Foundation的对象。</li>
</ol>
<p>编译和运行，确保项目进展顺利</p>
<p>在这个例子中，自己创建CIContext与不创建没什么不同。但下个部分中，你会看到当你动态地修改filter时，为什么CIContext对性能影响很大。</p>
<h1 id="修改Filter值">修改Filter值</h1><p>目前还不错，但这只是使用Core Image filters的入门方式。让我们添加一个slider，然后设置它以便你能够实时调整filter的设置</p>
<p>打开<strong>Main.storyboard</strong>，选取一个slider，将它拖放到image view的上面，并水平对齐。选中view，然后点击<strong>Editor \ Resolve Auto Layout Issues \ Selected Views \ Reset to Suggested Constraints</strong>，添加需要的宽约束。</p>
<p>确保Assistant Editor可见和显示<strong>ViewController.swift</strong>，然后按着control键从slider拖动到之前添加的@IBOutlet下面，设置name为<strong>amountSlider</strong>，然后点击<strong>Connect</strong>。</p>
<p>当你还选中slider时，也让我们连接slider到一个action method。再一次按着control键从slider拖动到ViewController类的}上面。设置Connection为<strong>Action</strong>，name为<strong>amountSliderValueChanged</strong>，确保Event设置为<strong>Value Changed</strong>，然后点击<strong>Connect</strong>。</p>
<p>每次slider改变时，你需要根据不同的值来重新创建image filter。然而，你不想重复整个耗时且没效率的过程。你需要在你的类改变几样东西，那么你就要在viewDidLoad方法中创建一些对象并保存。</p>
<p>最重要的一件事就是当你需要使用CIContext时，你只需复用它。如果你每次都重新创建它，你的程序将会变得很慢。另一件事就是保存CIFilter和CIImage，CIImage主要保存原始的图像。每次输出都会产生新的CIImage，但你刚开始使用的图像都会保持不变。</p>
<p>你需要添加几个实例变量来完成这个任务。添加以下三个属性到你的ViewController类：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">var</span> context: CIContext!</span><br><span class="line"><span class="tag">var</span> <span class="attribute">filter</span>: CIFilter!</span><br><span class="line"><span class="tag">var</span> beginImage: CIImage!</span><br></pre></td></tr></table></figure>
<p>请注意，你已经用!语法来声明那些值为implicitly-unwrapped optionals，因为直到<strong>viewDidLoad</strong>才初始化它们。你也可以用？，但采用那种方式是为了当你使用那几个实例变量时，防止optionals为nil。implicitly-unwrapped语法由于不用到处使用!标识来访问变量，它让代码更加易读。</p>
<p>在<strong>viewDidLoad</strong>改变代码，那么它使用这些属性而不是使用新的局部变量，代码如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">beginImage = <span class="function"><span class="title">CIImage</span><span class="params">(contentsOfURL: fileURL)</span></span></span><br><span class="line"> </span><br><span class="line"><span class="attribute">filter</span> = <span class="function"><span class="title">CIFilter</span><span class="params">(name: <span class="string">"CISepiaTone"</span>)</span></span></span><br><span class="line"><span class="attribute">filter</span>.<span class="function"><span class="title">setValue</span><span class="params">(beginImage, forKey: kCIInputImageKey)</span></span></span><br><span class="line"><span class="attribute">filter</span>.<span class="function"><span class="title">setValue</span><span class="params">(<span class="number">0.5</span>, forKey: kCIInputIntensityKey)</span></span></span><br><span class="line"> </span><br><span class="line">let outputImage = <span class="attribute">filter</span><span class="class">.outputImage</span></span><br><span class="line"> </span><br><span class="line">context = <span class="function"><span class="title">CIContext</span><span class="params">(options:nil)</span></span></span><br><span class="line">let cgimg = context.<span class="function"><span class="title">createCGImage</span><span class="params">(outputImage, fromRect: outputImage.extent()</span></span>)</span><br></pre></td></tr></table></figure>
<p>现在你将会实现changeValue方法。你在这个方法需要做的是修改CIFilter dictionary的inputIntentsity键对应的值。</p>
<p>一旦你修改这个值，你需要重复这几个步骤：</p>
<ul>
<li>从CIFilter获取输出的CIImage</li>
<li>将CIImage转换为CGImage</li>
<li>将CGImage转换为UIImage，然后将它显示在image view</li>
</ul>
<p>用以下代码代替amountSliderValueChanged(sender:)方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">amountSliderValueChanged</span><span class="params">(sender: UISlider)</span></span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">let</span> sliderValue = sender.value</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">filter</span>.setValue(sliderValue, forKey: kCIInputIntensityKey)</span><br><span class="line">    <span class="keyword">let</span> outputImage = <span class="built_in">filter</span>.outputImage</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">let</span> cgimg = context.createCGImage(outputImage, fromRect: outputImage.extent())</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">let</span> newImage = <span class="type">UIImage</span>(<span class="type">CGImage</span>: cgimg)</span><br><span class="line">    <span class="keyword">self</span>.imageView.image = newImage</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你会注意到，你已经将方法定义中参数类型从<strong>AnyObject</strong>转换为<strong>UISlider</strong>。你只用这个方法来从<strong>UISlider</strong>获取值，以便你改变值。如果你不管它，默认是<strong>AnyObject</strong>，你需要将它转换为<strong>UISlider</strong>，否则下一行代码就会抛出错误。</p>
<p>你可以从slider获取<strong>浮点数</strong>的值。你的slider默认设置为0.5，最小值为0，最大值为1。通过slider设置CIFilter是多么方便。</p>
<p>CIFilter有多个方法允许你在dictionary根据不同键来设置多个值。而这里，你刚设置<strong>inputIntensity</strong>键对应的值，而这个值是从slider获取。Swift自动将CGFloat值转换为NSNumber对象，来符合<strong>setValue(value:forKey:)</strong>方法的使用。</p>
<p>剩下的代码看起来很熟悉，因为它与<strong>viewDidLoad</strong>方法的逻辑一样。你将会多次使用这段代码。从现在起，你会用<strong>amountSliderValueChanged(sender:)</strong>方法来将CIFilter输出的图像渲染到ImageView。</p>
<p>编译和运行，你可以修改slider值来实时地改变图像。</p>
<h1 id="从相册获取图片">从相册获取图片</h1><p>现在你可以改变filter的值，事情也开始变得有趣。但是，如果你不喜欢这张花朵的图片。你可以设置<strong>UIImagePickerController</strong>来从相册选取图片放进你的app来使用。</p>
<p>你需要创建一个button来跳转到相册视图，所以打开<strong>Main.storyboard</strong>，拖动一个button到scene的右底部，并改变按钮文字为”Photo Album”。像之前一样，使用Auto Layout来Reset to Suggested Constraints。button应该在slider的右下边。</p>
<p>确保Assistant Editor是可见和显示<strong>ViewController.swift</strong>，然后按着control键从button拖动到}的上面。设置Connection为<strong>Action</strong>，name为<strong>loadPhoto</strong>，确保Event设置为<strong>Touch Up Inside</strong>，最后点击<strong>Connect</strong>。</p>
<p>loadPhoto方法实现如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">loadPhoto</span><span class="params">(sender : AnyObject)</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> pickerC = <span class="type">UIImagePickerController</span>()</span><br><span class="line">  pickerC.delegate = <span class="keyword">self</span></span><br><span class="line">  <span class="keyword">self</span>.presentViewController(pickerC, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一行代码主要是创建一个<strong>UIImagePickerController</strong>对象。然后设置image picker的delegate为self(ViewController)</p>
<p>你会这里得到一个警告。你需要声明<strong>ViewController</strong>遵循<strong>UIImagePickerControllerDelegate</strong>和<strong>UINavigationControllerDelegate</strong>协议。</p>
<p>仍在ViewController.swift文件，在文件顶部改变类的定义，代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="typename">UIViewController</span>, <span class="typename">UINavigationControllerDelegate</span>, <span class="typename">UIImagePickerControllerDelegate &#123;</span></span></span><br></pre></td></tr></table></figure>
<p>而方法实现如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">imagePickerController</span><span class="params">(picker: UIImagePickerController!, didFinishPickingMediaWithInfo info: NSDictionary!)</span></span> &#123;</span><br><span class="line">  <span class="keyword">self</span>.dismissViewControllerAnimated(<span class="literal">true</span>, completion: <span class="literal">nil</span>);</span><br><span class="line">  <span class="built_in">println</span>(info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>UIImagePickerControllerDelegate</strong>方法还没完成 - 它只是一个占位符来打印被选择图片的信息。注意，不管你怎样实现UIImagePickerControllerDelegate这个方法，你必须在实现中显式地dimiss UIImagePickerController。如果你不这样做的话，你就会永远地盯着image picker。</p>
<p>编译和运行这个app，点击button。它会跳转到相册任你选择图片。</p>
<blockquote>
<p>如果你在模拟器运行app，你可以不会有图片。在模拟器(或在没有摄像头的设备)，你可以使用Safari来保存图片到相册。打开Safari，查找一张图片，点着并长按，你就会有一个选项来保存图片。下一次你运行你app，它将会出现在你图片库。</p>
</blockquote>
<p>在控制台中，你选择完一张图片之后，就看到类似以下的打印信息：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">UIImagePickerControllerMediaType = "public.image"<span class="comment">;</span></span><br><span class="line">UIImagePickerControllerOriginalImage = " size &#123;1165, 770&#125; orientation 0 scale <span class="number">1.000000</span>"<span class="comment">;</span></span><br><span class="line">UIImagePickerControllerReferenceURL = "assets-library://asset/asset.PNG?id=DCFE<span class="number">1435-2C01</span>-<span class="number">4820-9182</span>-40A69B48EA67&amp;ext=PNG"<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，它有一个dictionary入口，对应就是用户选择的“原始图片”。这个就是你想拽取和过滤的东西。</p>
<p>现在你已经有方法选取图片了，你怎样使用它作为你的<strong>beginImage</strong>呢？</p>
<p>很简答，只需将delegate方法修改成以下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">imagePickerController</span><span class="params">(picker: UIImagePickerController!, didFinishPickingMediaWithInfo info: NSDictionary!)</span></span> &#123;</span><br><span class="line">  <span class="keyword">self</span>.dismissViewControllerAnimated(<span class="literal">true</span>, completion: <span class="literal">nil</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">let</span> gotImage = info[<span class="type">UIImagePickerControllerOriginalImage</span>] <span class="keyword">as</span> <span class="type">UIImage</span></span><br><span class="line"> </span><br><span class="line">  beginImage = <span class="type">CIImage</span>(image:gotImage)</span><br><span class="line">  <span class="built_in">filter</span>.setValue(beginImage, forKey: kCIInputImageKey)</span><br><span class="line">  <span class="keyword">self</span>.amountSliderValueChanged(amountSlider)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你需要从你选择的图片来创建一个新的<strong>CIImage</strong>。你可以通过在dictionary的<strong>UIImagePickerControllerOriginalImage</strong>键获取值，从而获取<strong>UIImage</strong>的表示。注意，最好就是用UIImagePickerControllerOriginalImage这个常量，而不是硬编码的字符串，因为Apple可能在将来会改变这个键的名字。</p>
<p>你需要通过<strong>CIImage(image:)</strong>构造器将image转换为<strong>CIImage</strong>对象。然后在filter dictionary设置键，那么就可以创建新的CIImage。</p>
<p>最后一行代码看起来有点奇怪。还记得我说过，怎样运行<strong>changeValue</strong>方法，最新的值被设置在filter，然后更新image view。</p>
<p>好，你需要再做一次，所以你只是调用<strong>changeValue</strong>方法。即使slider的值还没改变，你仍然可以使用那个方法的代码来完成工作。你可以分解那段代码到自己的方法(如果你想做得更加复杂来避免混淆)，但这种情况下，你的目的是为了复用amountSliderValueChanged方法。传递<strong>amountSlider</strong>作为sender以致它有正确的值使用。</p>
<p>编译和运行，你能从相册中更新任何图片。</p>
<p>如果你创建完美的深褐色图片，你怎样才能保存它。你可以截图，但最恰当的方式就是保存已过滤的图片到相册。</p>
<h1 id="保存到相册">保存到相册</h1><p>为了保存到相册，你需要使用<strong>AssetsLibrary</strong> framework。在<strong>ViewController.swift</strong>文件顶部添加以下导入语句：</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"><span class="keyword">import</span> AssetsLibrary</span></span><br></pre></td></tr></table></figure>
<p>有一件你需要知道的事就是当你保存图片到相册,它需要花费几秒时间，即使在你关闭app之后仍在继续处理图片。</p>
<p>由于当你切换到另一个app的时候，GPU就停止处理，这将变成一个问题。如果图片还没完成保存，当你迟点找到它的时候，它将不在那里。</p>
<p>有一个解决方案就是使用基于CPU的<strong>CIContext</strong>来渲染。默认选择就是使用GPU，因为它处理速度更快，但你不想为了添加保存功能而降低过滤性能。而现在，你会创建另一个<strong>CIContext</strong>来保存image。注意，软件渲染将不会在模拟器正常工作。</p>
<p>添加一个新button到你的app，这个button会让你保存修改后的图片。打开<strong>Main.storyboard</strong>，添加一个新的button，修改button标题为“Save to Album”。将button放在slider的左边，然后添加相应的约束。</p>
<p>然后像上一次一样，连接button到一个新方法<strong>savePhoto(sender:)</strong>，方法实现如下：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@IBAction func savePhoto<span class="params">(sender: AnyObject)</span> &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">let</span> imageToSave = filter.outputImage</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">let</span> softwareContext = CIContext<span class="params">(options:[kCIContextUseSoftwareRenderer: <span class="literal">true</span>])</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">let</span> cgimg = softwareContext.createCGImage<span class="params">(imageToSave, fromRect:imageToSave.extent<span class="params">()</span>)</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    <span class="built_in">let</span> library = ALAssetsLibrary<span class="params">()</span></span><br><span class="line">    library.writeImageToSavedPhotosAlbum<span class="params">(cgimg,</span><br><span class="line">      metadata:imageToSave.properties<span class="params">()</span>,</span><br><span class="line">      completionBlock:nil)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码块中：</p>
<ol>
<li>从filter获取CIImage的输出。</li>
<li>创建一个新的，基于软件的，使用CPU渲染器的CIContext对象。</li>
<li>生成CGImage。</li>
<li>保存CIImage到photo library。</li>
</ol>
<p>编译和运行app(记住要运行在实际设备，因为你已经使用软件渲染)，现在你可以永久地保存完美的图像到你的photo library。</p>
<h1 id="Image元数据是什么？">Image元数据是什么？</h1><p>让我们讨论一下关于image元数据。用手机拍照出来的图片有很多关联它的数据，例如GPS坐标，图片格式，和方向。</p>
<p>方向是一样特殊的东西你需要保存。加载UIImage变成CIImage，渲染成CGImage，然后转换回一个UIImage这个过程是为了从image抓取元数据。为了保存方向，你需要保存它然后传递它作为UIImage构造器参数。</p>
<p>添加一个新属性到<strong>ViewController</strong>类定义：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> orientation</span>: UIImageOrientation = .Up</span><br></pre></td></tr></table></figure>
<p>下一步，添加下面代码到<strong>imagePickerController(picker:didFinishPickingMediaWithInfo:)</strong>方法里，设置<strong>beginImage</strong>代码行的上面：</p>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">orientation </span>=<span class="string"> gotImage.imageOrientation</span></span><br></pre></td></tr></table></figure>
<p>这样就会保存原始image方向的属性。</p>
<p>最后，修改在<strong>amountSliderValueChanged</strong>方法里，那段创建UIImage来设置imageView对象的代码：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let newImage = UIImage(<span class="string">CGImage:</span> cgimg, <span class="string">scale:</span><span class="number">1</span>, <span class="string">orientation:</span>orientation)</span><br></pre></td></tr></table></figure>
<p>现在，如果你拍一张照片而不是默认方向，它将会默认保存。</p>
<h1 id="还有哪些Filters是可用的？">还有哪些Filters是可用的？</h1><p>CIFilter API在Mac OS有超过160个，在iOS 8有126个关于filters的API。</p>
<p>为了查找有哪些filters在给定的设备是可用的，你可以使用CIFilter的<strong>filterNamesInCategory(kCICategoryBuiltIn)</strong>方法。这个方法会返回一个关于filter名字的数组。</p>
<p>除此之外，每个filter有一个<strong>attributes()</strong>方法返回一个dictionary，dictionary包含关于filter的信息。这些信息包括filter的名字，分类，filter接受哪些输入，默认输入，和这些输入接受哪些值。</p>
<p>让我们将所有东西放在一个类的方法，这个方法记录当前所有可用的filters信息。添加这个方法到ViewController类的定义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">logAllFilters</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> properties = <span class="type">CIFilter</span>.filterNamesInCategory(kCICategoryBuiltIn)</span><br><span class="line">  <span class="built_in">println</span>(properties)</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> filterName: <span class="type">AnyObject</span> <span class="keyword">in</span> properties &#123;</span><br><span class="line">    <span class="keyword">let</span> fltr = <span class="type">CIFilter</span>(name:filterName <span class="keyword">as</span> <span class="type">String</span>)</span><br><span class="line">    <span class="built_in">println</span>(fltr.attributes())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法仅仅通过<strong>filterNamesInCategory()</strong>方法来获取filters的数组。首先，它打印名字的列表。然后，遍历列表获取每个名字，根据名字实例化filter和打印它的属性dictionary。</p>
<p>在<strong>viewDidLoad()</strong>方法最后调用这个方法：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.<span class="function"><span class="title">logAllFilters</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>你会看到很多filters在控制台被列出：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">CIAttributeFilterDisplayName</span>: Color Monochrome, inputColor: &#123;</span><br><span class="line">    <span class="built_in">CIAttributeClass</span> = <span class="built_in">CIColor</span>;</span><br><span class="line">    <span class="built_in">CIAttributeDefault</span> = <span class="string">"(0.6 0.45 0.3 1)"</span>;</span><br><span class="line">    <span class="built_in">CIAttributeType</span> = <span class="built_in">CIAttributeTypeColor</span>;</span><br><span class="line">&#125;, inputImage: &#123;</span><br><span class="line">    <span class="built_in">CIAttributeClass</span> = <span class="built_in">CIImage</span>;</span><br><span class="line">    <span class="built_in">CIAttributeType</span> = <span class="built_in">CIAttributeTypeImage</span>;</span><br><span class="line">&#125;, <span class="built_in">CIAttributeFilterCategories</span>: (</span><br><span class="line">    <span class="built_in">CICategoryColorEffect</span>,</span><br><span class="line">    <span class="built_in">CICategoryVideo</span>,</span><br><span class="line">    <span class="built_in">CICategoryInterlaced</span>,</span><br><span class="line">    <span class="built_in">CICategoryNonSquarePixels</span>,</span><br><span class="line">    <span class="built_in">CICategoryStillImage</span>,</span><br><span class="line">    <span class="built_in">CICategoryBuiltIn</span></span><br><span class="line">), inputIntensity: &#123;</span><br><span class="line">    <span class="built_in">CIAttributeClass</span> = <span class="built_in">NSNumber</span>;</span><br><span class="line">    <span class="built_in">CIAttributeDefault</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">CIAttributeIdentity</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">CIAttributeSliderMax</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">CIAttributeSliderMin</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">CIAttributeType</span> = <span class="built_in">CIAttributeTypeScalar</span>;</span><br><span class="line">&#125;, <span class="built_in">CIAttributeFilterName</span>: <span class="built_in">CIColorMonochrome</span>]</span><br></pre></td></tr></table></figure>
<p>哇，有很多的filters！它会给你一些灵感在你自己的app中尝试其他filters。</p>
<h1 id="更加复杂的Filter链">更加复杂的Filter链</h1><p>现在我们已经知道在iOS平台有哪些可用的filter，是时候创建更加复杂的filter链了。为了做到这样，你会创建一个专门的方法来处理CIImage。它会接受一个CIImage作为参数，过滤它，让它看起来像一张老旧的图片，然后返回一个已经修改的CIImage。</p>
<p>添加以下方法到ViewController：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">func oldPhoto<span class="params">(img: CIImage, withAmount intensity: Float)</span> -&gt; CIImage &#123;</span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">let</span> sepia = CIFilter<span class="params">(name:<span class="string">"CISepiaTone"</span>)</span></span><br><span class="line">  sepia.setValue<span class="params">(img, forKey:kCIInputImageKey)</span></span><br><span class="line">  sepia.setValue<span class="params">(intensity, forKey:<span class="string">"inputIntensity"</span>)</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="built_in">let</span> random = CIFilter<span class="params">(name:<span class="string">"CIRandomGenerator"</span>)</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  <span class="built_in">let</span> lighten = CIFilter<span class="params">(name:<span class="string">"CIColorControls"</span>)</span></span><br><span class="line">  lighten.setValue<span class="params">(random.outputImage, forKey:kCIInputImageKey)</span></span><br><span class="line">  lighten.setValue<span class="params">(<span class="number">1</span> - intensity, forKey:<span class="string">"inputBrightness"</span>)</span></span><br><span class="line">  lighten.setValue<span class="params">(<span class="number">0</span>, forKey:<span class="string">"inputSaturation"</span>)</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 4</span></span><br><span class="line">  <span class="built_in">let</span> croppedImage = lighten.outputImage.imageByCroppingToRect<span class="params">(beginImage.extent<span class="params">()</span>)</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 5</span></span><br><span class="line">  <span class="built_in">let</span> composite = CIFilter<span class="params">(name:<span class="string">"CIHardLightBlendMode"</span>)</span></span><br><span class="line">  composite.setValue<span class="params">(sepia.outputImage, forKey:kCIInputImageKey)</span></span><br><span class="line">  composite.setValue<span class="params">(croppedImage, forKey:kCIInputBackgroundImageKey)</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 6</span></span><br><span class="line">  <span class="built_in">let</span> vignette = CIFilter<span class="params">(name:<span class="string">"CIVignette"</span>)</span></span><br><span class="line">  vignette.setValue<span class="params">(composite.outputImage, forKey:kCIInputImageKey)</span></span><br><span class="line">  vignette.setValue<span class="params">(intensity * <span class="number">2</span>, forKey:<span class="string">"inputIntensity"</span>)</span></span><br><span class="line">  vignette.setValue<span class="params">(intensity * <span class="number">30</span>, forKey:<span class="string">"inputRadius"</span>)</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 7</span></span><br><span class="line">  return vignette.outputImage</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会逐段讲解：</p>
<ol>
<li><p>以相同的方式设置深褐色的filter。你在这个方法传递一个浮点数来设置深褐色效果的强度。这个值是由slider提供。</p>
</li>
<li><p>设置一个创建随机噪音模式的filter，filter效果如下：</p>
</li>
</ol>
<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2012/09/CIRandomGenerator.gif" alt=""></p>
<p>   它好像没有接受任何参数。你会使用这个噪音模式来添加纹理到你的最终“老旧相片”的外观。</p>
<ol>
<li><p>修改随机噪音生成器的输出。你想改变的它的灰度和减轻它一点以至于效果没有那么炫酷。你会注意到，输入image的键被设置到随机filter的outputImage属性。这是一种传递一个filter的输出作为下个输入的方便方式。</p>
</li>
<li><p><strong>imageByCroppingToRect()</strong>接受被裁剪的rect作为参数，然后返回CIImage。在这种情况下，你需要裁剪CIRandomGenerator filter的输出，因为它无限地碎片化。在某种情况下，如果你不裁剪它，你会得到一个错误信息，说filters有‘an infinite extent’。CIImages实际上是不包含image数据，它们创建它时将它描述成一个’recipe’。直到你在CIContext调用一个方法时数据才实际被处理。</p>
</li>
<li><p>将深褐色filter的输出和CIRandomGenerator filter的输出结合起来。这个filter执行像在photoshop层‘Hard Light’设置完全一样的操作。大多数在photoshop(但不是全部)的filter选项都可以通过使用Core Image来实现。</p>
</li>
<li><p>在这个合成的输出中，运行一个vignette filter，它会使你的图片边缘变暗。你使用从slider获取的值来设置半径和效果的强度。</p>
</li>
<li><p>最后，返回最后filter的输出。</p>
</li>
</ol>
<p>关于filter chain讲到这里。你现在应该有一个如何形成复杂filter chain的想法。通过组合多个Core Image filters成各种各样的chains，你就能实现无穷多种的特效。</p>
<p>下一件事就是在<strong>amountSliderValueChanged()</strong>方法实现。改变这两行代码：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">filter</span>.<span class="function"><span class="title">setValue</span><span class="params">(sliderValue, forKey: <span class="string">"inputIntensity"</span>)</span></span></span><br><span class="line">let outputImage = <span class="attribute">filter</span>.outputImage</span><br></pre></td></tr></table></figure>
<p>成这行代码：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let outputImage = self.<span class="function"><span class="title">oldPhoto</span><span class="params">(beginImage, withAmount: sliderValue)</span></span></span><br></pre></td></tr></table></figure>
<p>这只是用新的，更复杂的filter方法来代替之前深褐色效果。你可以传递slder的值给强度，和你使用在viewDidLoad方法中被设置的beginImage作为输入的CIImage。编译和运行，你应该得到一个更加完善的旧图片效果，这种效果会是深褐色，有一点噪音和一点渐晕。</p>
<p>这种噪音效果会是更加微妙，但我会留给你自行试验。现在你完全有能力随意操纵Core Image，尽管去尝试吧！</p>
<h1 id="下一步">下一步</h1><p>这个是<a href="http://cdn4.raywenderlich.com/wp-content/uploads/2014/07/CoreImageFun.zip" target="_blank" rel="external">示例工程</a>包含这个教程所有的代码。</p>
<p>它包含了如何使用Core Image filters的基本方法。这是一个很容易上手的技术，所以你应该很快就能使用它来应用到一些优雅的filters。</p>
<p>记住，这个示例app在一开始的时候打印出所有可用的filters列表到控制台。为什么不尝试使用这些filters呢？你可以在<a href="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Reference/CoreImageFilterReference/Reference/reference.html" target="_blank" rel="external">Core Image filter reference documentation</a>查看更多关于filters的详细信息。</p>
<p>如果你在这个教程中有任何问题或评论，请加入这个论坛来讨论。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Core_Image入门教程(swift)">Core Image入门教程(swift)</h2><blockquote>
<ul>
<li>原文链接 : <a href="http://www.raywenderlich.com/76285/beginning-core-image-swift">Core Image Tutorial: Getting Started</a></li>
<li>原文作者 : <a href="http://www.raywenderlich.com/u/nicklockwood">Nick Lockwood</a></li>
<li>译文出自 :<a href="http://www.devtf.cn">开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/samlaudev">Sam Lau</a> </li>
<li>校对者: <a href="https://github.com/mrchenhao">Harries Chen</a>  </li>
<li>状态 :  校正完</li>
</ul>
</blockquote>
<p>Core Image是一个强大的框架，它能够让你轻松地对图像进行过滤。你能够通过修改图像的饱和度、色调或曝光率来获取各种特效。你也可以使用CPU或GPU更快地来处理图像数据，快到能够实时处理视频帧数据(video frame)。</p>
<p>Core Image过滤器能够以链式的方式结合将多个特效应用到一个图像或视频帧数据。多个过滤器能够组合成单个过滤器应用在一个图像。通过每次与每个过滤器比较，这使它非常有效地处理图像。</p>
<p>在这个教程中，你将会亲手实践如何使用Core Image.通过使用几个不同的过滤器，你会看到实时使用各种炫酷的特效是多么容易。</p>
<h1 id="基础">基础</h1><p>在你开始之前，让我们先讨论在Core Image框架中几个很重要的类：</p>
<ul>
<li><strong>CIContext</strong>. 所有处理core image的工作都在CIContext完成。这个与Core Graphics或OpenGL context有几分相似。</li>
<li><strong>CIImage</strong>. 这个类保存图像数据，它能够从UIImage，图像文件或像素数据等方式来创建。</li>
<li><strong>CIFilter</strong>. CIFilter类有一个字典(dictionary)来定义特定属性的过滤器，比如常用过滤器有饱和度，颜色翻转，裁剪等属性，还有很多没列出来。</li>
</ul>
<h3 id="CoreImageFun">CoreImageFun</h3><p>打开Xcode并使用<strong>iOS \ Application \ Single View Application</strong>模板来创建一个新工程。输入<strong>CoreImageFun</strong>作为Product Name，选择iPhone为Devices option和确定使用<strong>swift</strong>作为编程语言。</p>
<p>下载<a href="http://cdn5.raywenderlich.com/downloads/CIResources.zip">教程的资源</a>，并添加图片<strong>image.png</strong>到工程</p>
<p>下一步，打开<strong>Main.storyboard</strong>你文件，拖拽一个image view到已存在的view，image view作为view的子视图。在Attributes Inspector中，设置image view的content mode属性为Aspect Fit，这样它就不会拉伸图片。</p>
<p>下一步，确定Document Outline(在Interface Builder里canvas左边)是可见的 - 你可以从menu中<strong>Editor \ Show Document Outline</strong>来启用。</p>
<p>按着control键从image view拖动到它的superview三次来添加三个约束(constraint)：</p>
<ol>
<li>添加一个Top Space to Layout Guide的约束，如果有必要的话，使用Size Inspector来设置约束的constant为0 </li>
<li>添加一个Center Horizontally in Container的约束(同样也需要设置constant为0)</li>
<li>添加一个Equal Width约束</li>
</ol>
<p>最后，为了约束image view的高度，按着control键从image view拖动到本身，然后添加一个Aspect Ratio约束，使用Size Inspector来设置它的multiplier的值为8:5对应宽高比和constant factor为0。最后，选择<strong>Editor \ Resolve Auto Layout Issues \ All Views in View Controller \ Update Frames</strong>，那么Interface Builder会根据这些约束来更新布局</p>
<p>下一步，打开Assistant Editor，然后确保它显示<strong>ViewController.swift</strong>。按着control键从UIImageView拖动到刚刚打开的<strong>ViewController</strong>类的大括号。命名outlet为<strong>imageView</strong>，然后点击connect。</p>
<p>编译和运行这个项目来确保目前进展顺利 - 你应该看到一个空屏。初始化设置完成，现在进入Core Image的世界。</p>]]>
    
    </summary>
    
      <category term="Core Image" scheme="http://ytlvy.com/tags/Core-Image/"/>
    
      <category term="Swift" scheme="http://ytlvy.com/categories/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS Continuous Integration & Deployment]]></title>
    <link href="http://ytlvy.com/2015/08/08/iOS-Continuous-Integration-Deployment/"/>
    <id>http://ytlvy.com/2015/08/08/iOS-Continuous-Integration-Deployment/</id>
    <published>2015-08-08T12:09:55.000Z</published>
    <updated>2015-08-08T12:10:39.000Z</updated>
    <content type="html"><![CDATA[<h2 id="iOS项目的持续集成与管理">iOS项目的持续集成与管理</h2><blockquote>
<ul>
<li>原文链接 : <a href="https://medium.com/ribot-labs/continuous-integration-deployment-for-ios-projects-7358b72ca2e9" target="_blank" rel="external">Continuous Integration &amp; Deployment for iOS Projects</a></li>
<li>原文作者 : <a href="https://medium.com/@matto1990" target="_blank" rel="external">Matt Oakes</a></li>
<li><a href="http://www.devtf.cn" target="_blank" rel="external">译文出自 :  开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/samlaudev" target="_blank" rel="external">Sam Lau</a> </li>
<li>校对者: <a href="https://github.com/bboyfeiyu" target="_blank" rel="external">Mr.Simple</a>  </li>
<li>状态 :  校正完 </li>
</ul>
</blockquote>
<p>当实现新功能时，如果忽略可维护性而引入<a href="http://en.wikipedia.org/wiki/Technical_debt" target="_blank" rel="external">技术债务</a>，那将会需要延迟解决它或导致增加维护成本。</p>
<p>最近我们已经思考通过哪些方式来提高代码的质量：</p>
<ul>
<li>当代码的质量下降时，通过设置一些工具来马上提醒开发者</li>
<li>文档化一些编码规范和思考在过去的几个项目中如何避免维护性差的问题</li>
</ul>
<p><strong>我将会简单地概括我们需要设置什么才能自动监控代码质量.</strong></p>
<h1 id="基础">基础</h1><p>我们选择一个持续集成工具<a href="https://jenkins-ci.org/" target="_blank" rel="external">Jenkins</a>，让它运行在一台放在我们工作室的Mac Mini。其实我不怎么喜欢Jenkins，但到目前为止，它是最稳定和最适合的工具来完成这些工作。</p>
<p>我们已经通过<a href="https://brew.sh/" target="_blank" rel="external">Homebrew</a>和<a href="https://github.com/sstephenson/rbenv" target="_blank" rel="external">rbenv</a>来分别安装Jenkins和Ruby，而rbenv能够为我们提供一个最新和稳定的<a href="https://rubygems.org/" target="_blank" rel="external">Ruby Gems</a>环境。有个Homebrew和Ruby Gems两个包管理工具之后，我们就几乎能够安装所有我们需要的工具，但很少会破坏与原有OS X系统更新提供的Ruby。</p>
<a id="more"></a>
<h1 id="单元测试">单元测试</h1><p>我们使用<a href="https://github.com/specta/specta" target="_blank" rel="external">Specta</a>和<a href="https://github.com/specta/expecta" target="_blank" rel="external">Expecta</a>来测试我们的iOS项目。</p>
<p>Specta让我们采用行为驱动开发(BDD)风格的语法来编写测试，相比于<em>XCTest</em>的语法，它更加易读。它还有一个强大的分组测试功能，在测试之前或之后运行一些代码块，这样的话，能够极大地减少重复代码。</p>
<p>Expecta是一个匹配器框架，我们可以在测试中使用它来创建断言。它的语法非常强大，与此同时，它比内建的<em>XCAssert</em>套件更加易读。例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">expect</span>(<span class="at_rule">@<span class="keyword">"foo").to.equal(@"foo");</span></span><br><span class="line"><span class="function">expect</span>(foo).notTo.<span class="function">equal</span>(<span class="number">1</span>)</span>;</span><br><span class="line"><span class="tag">expect</span>(<span class="attr_selector">[bar isBar]</span>)<span class="class">.to</span><span class="class">.equal</span>(<span class="tag">YES</span>);</span><br><span class="line"><span class="tag">expect</span>(<span class="tag">baz</span>)<span class="class">.to</span><span class="class">.equal</span>(3<span class="class">.14159</span>);</span><br></pre></td></tr></table></figure>
<p>我们在开发时，通过XCode来运行测试；而使用通过Homebrew来安装的Jenkins时，会借助<a href="https://github.com/facebook/xctool" target="_blank" rel="external">XCTool</a>。XCTool是一个可代替的选择来<em>xcodebuild</em>，它能让你通过命令行的方式来非常轻松地运行测试套件和生成JUnit风格的测试报告。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xctool -workspace Project<span class="class">.xcworkspace</span> -scheme Project -reporter junit:junit-report<span class="class">.xml</span> test</span><br></pre></td></tr></table></figure>
<p>这些测试报告会发布在Jenkins上，而Jenkins会使用<a href="https://wiki.jenkins-ci.org/display/JENKINS/JUnit+Plugin" target="_blank" rel="external">JUnit Plugin</a>来根据时间的推移提供单元测试结果的图表，同时会向我们显示我们的测试是否稳定。</p>
<div align="center"><br><br><img src="https://d262ilb51hltx0.cloudfront.net/max/1600/1*YXbjsC43-eVvMPPw2CXn6A.png"><br></div>

<h1 id="Pull_Request测试">Pull Request测试</h1><p>我们想我们的测试尽可能运行以至于如果我们破坏什么东西，我们就会马上知道。我们在<a href="https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow/" target="_blank" rel="external">feature branches</a>做些修改，然后提交一个pull request到Github，那么代码就会被另一个开发者审查。只要被打开，我们就能运行所有的测试来确保没有任何东西被破坏。</p>
<p>当新的pull requst是开放状态时，为了管理这些，我们安装<a href="https://wiki.jenkins-ci.org/display/JENKINS/GitHub+pull+request+builder+plugin" target="_blank" rel="external">Github Pull Request plugin</a>来将信息从Github发送到Jenkins。如果有任何测试失败，它将会显示在Github，然后我们就不将代码合并，直到代码被修复为止。</p>
<h1 id="代码覆盖率">代码覆盖率</h1><p>我们也会用<a href="http://gcovr.com/" target="_blank" rel="external">Gcovr</a>工具来生成代码覆盖率报告，Gcovr的安装方式也是Homebrew。你需要针对main target的debug congfiguration改变两个构建设置来配置项目。将<em>Generate Test Coverage Files</em>和<em>Instrument Program Flow</em>都设置为<em>YES</em>。</p>
<div align="center"><br><br><img src="https://d262ilb51hltx0.cloudfront.net/max/1200/1*Aq8ClxmME0tcpf747uPguQ.png"><br></div>

<p>当我们运行单元测试来生成代码覆盖率报告时，我们需要将<em>OBJROOT=./build</em>添加到XCTool命令行的尾部。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcovr -r . — object-directory build/<span class="keyword">Project</span>.build/Debug-iphonesimulator/<span class="keyword">Project</span>.build/Objects-normal/x86_64 — exclude ‘.*Tests.*’ — xml &gt; coverage.xml</span><br></pre></td></tr></table></figure>
<p>Gcovr输出的代码覆盖率报告也会被插件<a href="https://wiki.jenkins-ci.org/display/JENKINS/Cobertura+Plugin" target="_blank" rel="external">Cobertura Jenkins plugin</a>发布，这个插件会提供一种可视化的方式来根据时间的推移来显示代码覆盖率。</p>
<p>现在我们不仅可以看到测试是否通过，还可以看到代码的测试覆盖范围。</p>
<h1 id="静态分析">静态分析</h1><p>在工具集中，其中一个强大并能够保持高质量的代码的工具就是静态分析工具。这些工具会扫描你的代码，然后生成一个报告，这个报告会告诉你破坏代码风格规则的代码位置。举几个规则的例子：</p>
<ul>
<li>未使用的变量或参数</li>
<li>长变量名，方法名或代码行</li>
<li>覆盖一个方法，但没有在这个方法调用<em>super</em></li>
<li>方法太长或方法过于复杂</li>
<li>还更多的规格…</li>
</ul>
<p>我们使用<a href="http://oclint.org/" target="_blank" rel="external">OCLint</a>静态分析工具，这个工具能够支持C，C++和Objective-C语言。OCLint通过结合XCTool使用来生成<strong>json-compilation-database</strong> reporter<br>，从而提供<a href="http://docs.oclint.org/en/dev/guide/xctool.html" target="_blank" rel="external">great integration</a>特性。我们首先添加另一个reporter到我们的XCTool命令行，然后将那个report传递到OCLint来执行静态分析。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ xctool -workspace Project<span class="class">.xcworkspace</span> -scheme Project -reporter junit:junit-report<span class="class">.xml</span> -reporter json-compilation-database:compile_commands<span class="class">.json</span> test</span><br><span class="line">$ oclint-json-compilation-database -e Pods -report-type pmd -o oclint-pmd.xml</span><br></pre></td></tr></table></figure>
<p>这个report以<a href="http://pmd.sourceforge.net/" target="_blank" rel="external">PMD</a>的方式来生成，然后使用<a href="https://wiki.jenkins-ci.org/display/JENKINS/PMD+Plugin" target="_blank" rel="external">PMD Plugin</a>被发布到Jenkins。有了这些插件之后，你也可以在测试失败之前，设置每个警告的优先级(底，中，高)中一些限制。最初，我们设置这些限制为低，那么只要我们引入代码，就会被提醒，从而提高代码质量。</p>
<div align="center"><br><br><img src="https://d262ilb51hltx0.cloudfront.net/max/1600/1*fkHdHqA_WGoWATdAs6or0A.png"><br></div>


<h1 id="自动部署">自动部署</h1><p>最后一个问题不是如何提高代码质量，而是如何节省时间。开发者通常都会将编译好的代码通过<a href="https://www.crashlytics.com/" target="_blank" rel="external">Crashlytics</a>发送到设计师来设计审查，或在sprint结束演示时发给用户。发送一个已经编译好的app通常花一个开发者的10分钟左右时间，但它需要他们来切换任务和干扰他们的心流。</p>
<p>最近我们已经配置一个在夜晚构建系统，它会在早上自动发送一个新版本的app给每个人。</p>
<p>为了做到这样，我们使用<a href="http://fastlane.tools/" target="_blank" rel="external">fastlane</a>。fastlane是一个定义<strong>lanes</strong>的一些操作来执行的强大工具集。现在我们有三个已经定义好的lanes，一个是用来发布给ribot开发者，一个是用来发布给在ribot的每个人，最后一个是发布给用户。</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">before_all <span class="keyword">do</span> |lane|</span><br><span class="line"> cert</span><br><span class="line"> sigh</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">desc</span> “Deploy a <span class="keyword">new</span> build <span class="keyword">to</span> ribot iOS developers over crashlytics”</span><br><span class="line">lane :dev <span class="keyword">do</span></span><br><span class="line"> ipa</span><br><span class="line"> crashlytics(<span class="comment">&#123; groups: ‘ribot-developers’ &#125;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">desc</span> “Deploy a <span class="keyword">new</span> build <span class="keyword">to</span> people at ribot over crashlytics”</span><br><span class="line">lane :internal <span class="keyword">do</span></span><br><span class="line"> ensure_git_status_clean</span><br><span class="line"> append_build_time</span><br><span class="line"> ipa</span><br><span class="line"> crashlytics(<span class="comment">&#123; groups: ‘ribot’ &#125;</span>)</span><br><span class="line"> reset_git_repo</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">desc</span> “Deploy a <span class="keyword">new</span> build <span class="keyword">to</span> everyone over crashlytics”</span><br><span class="line">lane :<span class="keyword">external</span> <span class="keyword">do</span></span><br><span class="line"> ensure_git_status_clean</span><br><span class="line"> increment_build_number</span><br><span class="line"> ipa</span><br><span class="line"> crashlytics(<span class="comment">&#123; groups: [‘ribot’, ‘client’] &#125;</span>)</span><br><span class="line"> commit_version_bump</span><br><span class="line"> add_git_tag</span><br><span class="line"> push_to_git_remote</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">after_all <span class="keyword">do</span> |lane|</span><br><span class="line"> clean_build_artifacts</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>通过使用<strong>fastlane</strong>工具(通过Ruby Gems来安装)来运行一个lane。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastlane <span class="keyword">internal</span></span><br></pre></td></tr></table></figure>
<p>在开始使用所有的<em>lanes</em>之前，我们应该自动确保我们有一个有效的signing certificate和最新的provisioning profile。所有我们的配置都放在一个<em>.env</em>文件，它让我们有些默认配置，但当我们运行<em>fastlane</em>根据需要来覆盖它们。</p>
<p>在将来，我们会通过使用<em>deliver</em>操作来自动化app store提交过程。</p>
<h1 id="最后总结">最后总结</h1><p>到目前为止，我们已经尝试这些过程，并在工程中呈现出好的结果。我们期望看到只要适当地使用这些工具，就能提高代码的质量，这些报告将会让我们随着时间推移来量化代码质量。我们期待在下一个工程中适当地使用这些工具会发生什么。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="iOS项目的持续集成与管理">iOS项目的持续集成与管理</h2><blockquote>
<ul>
<li>原文链接 : <a href="https://medium.com/ribot-labs/continuous-integration-deployment-for-ios-projects-7358b72ca2e9">Continuous Integration &amp; Deployment for iOS Projects</a></li>
<li>原文作者 : <a href="https://medium.com/@matto1990">Matt Oakes</a></li>
<li><a href="http://www.devtf.cn">译文出自 :  开发技术前线 www.devtf.cn</a></li>
<li>译者 : <a href="https://github.com/samlaudev">Sam Lau</a> </li>
<li>校对者: <a href="https://github.com/bboyfeiyu">Mr.Simple</a>  </li>
<li>状态 :  校正完 </li>
</ul>
</blockquote>
<p>当实现新功能时，如果忽略可维护性而引入<a href="http://en.wikipedia.org/wiki/Technical_debt">技术债务</a>，那将会需要延迟解决它或导致增加维护成本。</p>
<p>最近我们已经思考通过哪些方式来提高代码的质量：</p>
<ul>
<li>当代码的质量下降时，通过设置一些工具来马上提醒开发者</li>
<li>文档化一些编码规范和思考在过去的几个项目中如何避免维护性差的问题</li>
</ul>
<p><strong>我将会简单地概括我们需要设置什么才能自动监控代码质量.</strong></p>
<h1 id="基础">基础</h1><p>我们选择一个持续集成工具<a href="https://jenkins-ci.org/">Jenkins</a>，让它运行在一台放在我们工作室的Mac Mini。其实我不怎么喜欢Jenkins，但到目前为止，它是最稳定和最适合的工具来完成这些工作。</p>
<p>我们已经通过<a href="https://brew.sh/">Homebrew</a>和<a href="https://github.com/sstephenson/rbenv">rbenv</a>来分别安装Jenkins和Ruby，而rbenv能够为我们提供一个最新和稳定的<a href="https://rubygems.org/">Ruby Gems</a>环境。有个Homebrew和Ruby Gems两个包管理工具之后，我们就几乎能够安装所有我们需要的工具，但很少会破坏与原有OS X系统更新提供的Ruby。</p>]]>
    
    </summary>
    
      <category term="Deployment" scheme="http://ytlvy.com/tags/Deployment/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS UITableviewCell Swipeable]]></title>
    <link href="http://ytlvy.com/2015/08/08/iOS-UITableviewCell-Swipeable/"/>
    <id>http://ytlvy.com/2015/08/08/iOS-UITableviewCell-Swipeable/</id>
    <published>2015-08-08T12:03:02.000Z</published>
    <updated>2015-08-08T12:04:14.000Z</updated>
    <content type="html"><![CDATA[<h2 id="iOS开发-可滑动的单元格"><code>iOS开发-可滑动的单元格</code></h2><blockquote>
<ul>
<li>原文链接 : <a href="https://medium.com/ios-os-x-development/swipeable-table-view-cells-in-ios-apps-472da0af1935" target="_blank" rel="external">Swipeable table view cells in iOS apps</a></li>
<li>译者 : <a href="https://github.com/mrchenhao" target="_blank" rel="external">Harries Chen</a> </li>
<li>校对者: <a href="https://github.com/mrchenhao" target="_blank" rel="external">Mr.Simple</a>  </li>
</ul>
</blockquote>
<p>我在过去的一个月里致力于开发我的创业项目，其中有一个功能就是我想让用户通过左右滑动表格来显示更多的选项（就像系统自带的邮件程序现实更多和删除一样，在这篇文章中我将讨论一些关于这方面的方法，以及如何动手实现它）</p>
<p>首先，让我们来看一下现有的解决方法。</p>
<ul>
<li>UITableViewRowAction (new in iOS 8)</li>
</ul>
<p>这是最好的方法如果你只是希望加一些从左滑到右才会出现的按钮。</p>
<ul>
<li><a href="https://github.com/CEWendel/SWTableViewCell" target="_blank" rel="external">SWTableViewCell</a></li>
</ul>
<p>这是一个功能很全的按钮库，支持左滑和右滑，同时也可以在iOS8以前的版本中使用</p>
<ul>
<li><a href="https://github.com/MortimerGoro/MGSwipeTableCell" target="_blank" rel="external">MGSwipeTableCell</a></li>
</ul>
<p>如果你想要实现表格的左右滑动功能，你可以从上面的解决方按照找到你需要的。但是为什么我们还要自己来实现呢？就我而言，我需要MGSwipeTableCell的一些功能，但是有的功能它对我并没有用，如果你想要自己来实现它，或者仅仅只是想要知道它的原理，那么接下去看。</p>
<a id="more"></a>
<h2 id="原理剖析">原理剖析</h2><p>制作一个可滑动的UITableViewCell其实是一件非常简单的事情，它的要点就是在contentView里面包含了UIScrollView，在UIScrollView里面有两个UIView，一个用于放置按钮，一个用于放置单元格的内容，难点在于如何配置滑动页面，下面是一张图片来展示UIScrollView里的主要内容。</p>
<p><img src="http://img.blog.csdn.net/20150420235653232" alt="这里写图片描述"></p>
<ul>
<li>frame</li>
</ul>
<p>视图的大小，（也就是实际在屏幕上显示的面积），在上图中，外面的高度看起来会比UIScrollView的高度高很多，实际上在代码中他们的高度是一样的，只是为了更好的展示。</p>
<ul>
<li>contentSize</li>
</ul>
<p>在可滚动的视图中，显示的大小和常常与实际内容的大小不同，当实际内容比显示的内容要大的时候，就可以进行滚动，以便让用户看到所有的内容。这个属性代表了在scrollview实际内容的宽和高。在这个例子中，我们实际上会保持它和视图大小相同，这要归功于一个叫做contentInset属性</p>
<ul>
<li>contentInset</li>
</ul>
<p>这个属性将使我们的扩大内容区域之外的可滚动范围。通常，当contentSize属性被设置为与frame相同的（或更小）的尺寸作为视图本身，视图并不会产生滚动的效果。然而，contentInset将延长使内容产生滚动，让你可以滚动至内容边界的区域。这有什么用吗？例如，它可以用在显示上拉刷新的加载画面之中。在这个例子中，我们将使用它来腾出空间已显示额外的按钮。</p>
<ul>
<li>contentOffset</li>
</ul>
<p>这个值代表当前滚动视图的滚动量，当用户滚动的时候，这个值将会被改变，你也可以通过程序来改变它的值，我们随后将会通过改变这个值来控制按钮的出现。</p>
<p>Implementing the cell, step by step<br>This section will demonstrate how to actually make the cell display buttons when swiping on it. The code examples will be simplified to focus on the concept. At the end I will provide a full implementation.</p>
<p>First, let’s subclass UITableViewCell to begin implementing our swipeable table cell.</p>
<p>The easiest way to subclass classes is to go to File &gt; New &gt; File… (⌘N). Pick UITableViewCell as the class to subclass.</p>
<h2 id="一步步实现">一步步实现</h2><p>本节将展示如何通过滑动来使单元格显示按钮。代码将被简化以便更好的理解这一概念。最后我将提供<a href="https://github.com/blixt/SwipeableTableViewCell" target="_blank" rel="external">完整的代码</a>。</p>
<p>第一步，子类化UITableViewCell</p>
<p><img src="http://img.blog.csdn.net/20150420235749907" alt="这里写图片描述"></p>
<p>子类化最简单的方法就是文件&gt;新建&gt;文件…（⌘N）。选择的UITableViewCell作为类的子类。</p>
<p>因为我们希望实现对滚动控制，所以我们需要指定我们的类实现UIScrollViewDelegate协议。方法是后面加上尖括号，在里面写上需要实现的协议</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="class"><span class="keyword">interface</span>  <span class="title">SwipeableTableViewCell</span>：<span class="title">UITableViewCell</span> &lt;<span class="title">UIScrollViewDelegate</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接下来，我们将在单元格初始化的时候配置滚动视图。选择你想要的初始化方式，可以是<code>initWithCoder：</code>也可以是 <code>initWithStyle：reuseIdentifier：</code> 。我建议创建一个common方法来配置单元格，以便从不同的初始化放来调用。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个可以横向滚动的滚动视图</span></span><br><span class="line"><span class="built_in">UIScrollView</span> *scrollView = [[<span class="built_in">UIScrollView</span> alloc] initWithFrame:<span class="keyword">self</span><span class="variable">.bounds</span>];</span><br><span class="line">scrollView<span class="variable">.autoresizingMask</span> = <span class="built_in">UIViewAutoresizingFlexibleWidth</span> | <span class="built_in">UIViewAutoresizingFlexibleHeight</span>;</span><br><span class="line">scrollView<span class="variable">.contentSize</span> = <span class="keyword">self</span><span class="variable">.bounds</span><span class="variable">.size</span>;</span><br><span class="line">scrollView<span class="variable">.contentInset</span> = <span class="built_in">UIEdgeInsetsMake</span>(<span class="number">0</span>, <span class="number">160</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">scrollView<span class="variable">.delegate</span> = <span class="keyword">self</span>;</span><br><span class="line">scrollView<span class="variable">.scrollsToTop</span> = <span class="literal">NO</span>;</span><br><span class="line">scrollView<span class="variable">.showsHorizontalScrollIndicator</span> = <span class="literal">NO</span>;</span><br><span class="line">scrollView<span class="variable">.showsVerticalScrollIndicator</span> = <span class="literal">NO</span>;</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.contentView</span> addSubview:scrollView];</span><br><span class="line"><span class="keyword">self</span><span class="variable">.scrollView</span> = scrollView;</span><br></pre></td></tr></table></figure>
<p>当我们我们创建滚动视图后，我们需要做一些事情。首先，我们设置它的大小的。这意味着在父视图大小发生改变的时候应该怎样改变。我们希望滚动视图填充整个单元格当它运行时改变大小的时候（这很可能发生，因为在iPhone 5，6和6 plus都具有不同的屏幕宽度）。然后我们设置与滚动视图相同大小的内容，在左边插入与我们所需要添加的按钮宽度相同的视图。关闭scrollsToTop事件，因为我们不关心这个状态栏是否被点击（这个功能通常用于滚动视图顶部）。这将让我们的表视图利用这特性，而不是打破这一行为。同时我们也关掉水平和垂直滚动栏，这样，当我们滚动的时候半透明的黑条不会出现。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置内容大小</span></span><br><span class="line"><span class="built_in">UIView</span> *contentView = [[<span class="built_in">UIView</span> alloc] initWithFrame:scrollView<span class="variable">.bounds</span>];</span><br><span class="line">contentView<span class="variable">.autoresizingMask</span> = <span class="built_in">UIViewAutoresizingFlexibleWidth</span> | <span class="built_in">UIViewAutoresizingFlexibleHeight</span>;</span><br><span class="line">contentView<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">[scrollView addSubview:contentView];</span><br><span class="line"><span class="keyword">self</span><span class="variable">.scrollViewContentView</span> = contentView;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">UILabel</span> *label = [[<span class="built_in">UILabel</span> alloc] initWithFrame:<span class="built_in">CGRectInset</span>(contentView<span class="variable">.bounds</span>, <span class="number">10</span>, <span class="number">0</span>)];</span><br><span class="line">label<span class="variable">.autoresizingMask</span> = <span class="built_in">UIViewAutoresizingFlexibleWidth</span> | <span class="built_in">UIViewAutoresizingFlexibleHeight</span>;</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.scrollViewContentView</span> addSubview:label];</span><br><span class="line"><span class="keyword">self</span><span class="variable">.scrollViewLabel</span> = label;</span><br></pre></td></tr></table></figure>
<p>不必惊讶于上述代码，我们只是增加了必要的部分呈现的表格单元格的主要区域</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建按钮的容器.</span></span><br><span class="line"><span class="built_in">UIView</span> *buttonsView = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">160</span>, <span class="keyword">self</span><span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.height</span>)];</span><br><span class="line">buttonsView<span class="variable">.autoresizingMask</span> = <span class="built_in">UIViewAutoresizingFlexibleHeight</span>;</span><br><span class="line"><span class="keyword">self</span><span class="variable">.buttonsView</span> = buttonsView;</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.scrollView</span> insertSubview:buttonsView atIndex:<span class="number">0</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 创建两个按钮并放入容器.</span></span><br><span class="line"><span class="built_in">UIButton</span> *yesButton = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeCustom</span>];</span><br><span class="line">yesButton<span class="variable">.autoresizingMask</span> = <span class="built_in">UIViewAutoresizingFlexibleHeight</span>;</span><br><span class="line">yesButton<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> greenColor];</span><br><span class="line">yesButton<span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">80</span>, <span class="keyword">self</span><span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.height</span>);</span><br><span class="line">[yesButton setTitle:<span class="string">@"Yes"</span> forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">[yesButton setTitleColor:[<span class="built_in">UIColor</span> whiteColor] forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.buttonsView</span> addSubview:yesButton];</span><br><span class="line"> </span><br><span class="line"><span class="built_in">UIButton</span> *noButton = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeCustom</span>];</span><br><span class="line">noButton<span class="variable">.autoresizingMask</span> = <span class="built_in">UIViewAutoresizingFlexibleHeight</span>;</span><br><span class="line">noButton<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">noButton<span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(<span class="number">80</span>, <span class="number">0</span>, <span class="number">80</span>, <span class="keyword">self</span><span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.height</span>);</span><br><span class="line">[noButton setTitle:<span class="string">@"No"</span> forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">[noButton setTitleColor:[<span class="built_in">UIColor</span> whiteColor] forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.buttonsView</span> addSubview:noButton];</span><br></pre></td></tr></table></figure>
<p>这将创建一个包含按钮的视图。这里需要注意的是，视图宽度应该是所有的按钮宽度的总和，它的需要插入在滚动视图之前（为了让显示在下面）。然后，我们只需要添加我们想要的按钮。为了使代码尽可能的简洁，我没有添加任何按钮的点击事件处理代码。</p>
<p>如果你此时运行程序，它可以滑动从而让按钮出现，但是如果你再iPhone6 或者更大的屏幕上运行的时候，将会遇到一个问题，我们稍后会解决它。另外一个需要解决的问题就是当我们在滑到一半就停止的时候会出现按钮显示一半的情况。我们先来修复它。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)scrollViewWillEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView withVelocity:(<span class="built_in">CGPoint</span>)velocity targetContentOffset:(<span class="keyword">inout</span> <span class="built_in">CGPoint</span> *)targetContentOffset &#123;</span><br><span class="line">    <span class="keyword">if</span> (scrollView<span class="variable">.contentOffset</span><span class="variable">.x</span> &lt; -scrollView<span class="variable">.contentInset</span><span class="variable">.left</span>) &#123;</span><br><span class="line">        targetContentOffset-&gt;x = -scrollView<span class="variable">.contentInset</span><span class="variable">.left</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *targetContentOffset = <span class="built_in">CGPointZero</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你的类得到用户停止滑动的通知（通过UIScrollViewDelegate协议）你需要将滚动视图滚动到按钮的最左端（如果滑动量超过按钮）或者重新隐藏按钮（如果滑动量不够）</p>
<p>到了这里我们完成了一些基本的工作。接下来我们来处理一些细节上的问题。继续往下看</p>
<p>接下来最大的问题就是就是来适应更大的屏幕，（例如iPhone6）我们可以通过一个简单的方法来修复这个问题（如果你有更好的方法，务必告诉我）。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)layoutSubviews &#123;</span><br><span class="line">    [<span class="keyword">super</span> layoutSubviews];</span><br><span class="line">    <span class="comment">// This is necessary to ensure that the content size scales with the view.</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.scrollView</span><span class="variable">.contentSize</span> = <span class="keyword">self</span><span class="variable">.contentView</span><span class="variable">.bounds</span><span class="variable">.size</span>;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.scrollView</span><span class="variable">.contentOffset</span> = <span class="built_in">CGPointZero</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的作用就是在单元格的面积发生变化的时候，修复内容大小和偏移量</p>
<p>这会避免图形出现问题。接下来，我们需要阻止滚动视图向另外一个方向滚动，（因为没有任何按钮来显示）。这非常简单：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView &#123;</span><br><span class="line">    <span class="keyword">if</span> (scrollView<span class="variable">.contentOffset</span><span class="variable">.x</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        scrollView<span class="variable">.contentOffset</span> = <span class="built_in">CGPointZero</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果用户向另外一个方向滑动，将偏移量设置为0来阻止它。</p>
<p>最后，你可能想让按钮安静的呆在原地，而不是与单元格一起移来移去。要做到这一点，我们将简单地移动按钮容器视图来抵消滚动偏移量。我们可以做到这一点，通过改变scrollViewDidScroll：上述方法如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView &#123;</span><br><span class="line">    <span class="keyword">if</span> (scrollView<span class="variable">.contentOffset</span><span class="variable">.x</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        scrollView<span class="variable">.contentOffset</span> = <span class="built_in">CGPointZero</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">self</span><span class="variable">.buttonsView</span><span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(scrollView<span class="variable">.contentOffset</span><span class="variable">.x</span>, <span class="number">0</span>, <span class="number">160</span>, <span class="keyword">self</span><span class="variable">.buttonsView</span><span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.height</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="还可以做些什么">还可以做些什么</h2><p>现在，我们已经制作了最基本功能，还有很多地方仍然可以提高。比如说：</p>
<ul>
<li>滚动表视图时自动隐藏按钮</li>
<li>在滑动一个单元格的时候自动隐藏其它的单元格按钮</li>
<li>允许在单元的两侧的按钮</li>
<li>启用在外部创建按钮（例如，在视图控制器）</li>
<li>动态计算按钮的大小</li>
<li>改进开启和关闭的动画效果</li>
</ul>
<p>最后，我实现上面的功能和所提供的代码在GitHub上：<a href="https://github.com/blixt/SwipeableTableViewCell" target="_blank" rel="external">GitHub</a><br>感谢您的阅读！如果有任何问题。最简单的方式就是在我Twitter下留言，我得名字叫做@blixt。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="iOS开发-可滑动的单元格"><code>iOS开发-可滑动的单元格</code></h2><blockquote>
<ul>
<li>原文链接 : <a href="https://medium.com/ios-os-x-development/swipeable-table-view-cells-in-ios-apps-472da0af1935">Swipeable table view cells in iOS apps</a></li>
<li>译者 : <a href="https://github.com/mrchenhao">Harries Chen</a> </li>
<li>校对者: <a href="https://github.com/mrchenhao">Mr.Simple</a>  </li>
</ul>
</blockquote>
<p>我在过去的一个月里致力于开发我的创业项目，其中有一个功能就是我想让用户通过左右滑动表格来显示更多的选项（就像系统自带的邮件程序现实更多和删除一样，在这篇文章中我将讨论一些关于这方面的方法，以及如何动手实现它）</p>
<p>首先，让我们来看一下现有的解决方法。</p>
<ul>
<li>UITableViewRowAction (new in iOS 8)</li>
</ul>
<p>这是最好的方法如果你只是希望加一些从左滑到右才会出现的按钮。</p>
<ul>
<li><a href="https://github.com/CEWendel/SWTableViewCell">SWTableViewCell</a></li>
</ul>
<p>这是一个功能很全的按钮库，支持左滑和右滑，同时也可以在iOS8以前的版本中使用</p>
<ul>
<li><a href="https://github.com/MortimerGoro/MGSwipeTableCell">MGSwipeTableCell</a></li>
</ul>
<p>如果你想要实现表格的左右滑动功能，你可以从上面的解决方按照找到你需要的。但是为什么我们还要自己来实现呢？就我而言，我需要MGSwipeTableCell的一些功能，但是有的功能它对我并没有用，如果你想要自己来实现它，或者仅仅只是想要知道它的原理，那么接下去看。</p>]]>
    
    </summary>
    
      <category term="UITableview" scheme="http://ytlvy.com/tags/UITableview/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS Background Modes Tutorial]]></title>
    <link href="http://ytlvy.com/2015/08/08/iOS-Background-Modes-Tutorial/"/>
    <id>http://ytlvy.com/2015/08/08/iOS-Background-Modes-Tutorial/</id>
    <published>2015-08-08T09:34:18.000Z</published>
    <updated>2015-08-08T09:34:55.000Z</updated>
    <content type="html"><![CDATA[<h1 id="iOS后台模式开发指南">iOS后台模式开发指南</h1><hr>
<blockquote>
<ul>
<li>原文链接 : <a href="http://www.raywenderlich.com/92428/background-modes-ios-swift-tutorial" target="_blank" rel="external">Background Modes Tutorial: Getting Started</a></li>
<li>原文作者 : <a href="http://www.raywenderlich.com/u/rayfix" target="_blank" rel="external"> Ray Fix </a></li>
<li>译者 : <a href="https://github.com/MollyMmm" target="_blank" rel="external">MollyMmm</a> </li>
<li>校对者:David Hu</li>
<li>状态 :  已完成</li>
</ul>
</blockquote>
<p>更新说明:这个教程被Ray Fix更新为关于iOS和Swift的.原著作者为<a href="http://www.raywenderlich.com/29948/backgrounding-for-ios" target="_blank" rel="external">Gustavo Ambrozio</a>.</p>
<p>自从古老的iOS4以来,当用户点击home建的时候,你可以使你的APP们在内存中处于suspended(挂起)状态.即使APP仍停留在内存中,它的所有操作是被暂停的直到用户再次运行它.</p>
<p>当然这个规则中有例外情况.在特定的情况下,这个APP仍然可以在后台中执行某些操作.这个教程会教你在什么时候怎么去用最常用的一些后台操作.</p>
<p>每一次iOS的发布都会在后台操作和细节上的放宽限制，以此提升用户体验和延长电池寿命.对于在iOS中实现”真正”的多任务来说,后台模式不是一个神奇的解决办法.当用户切换到其他的APP应用时,大多数的APP应用仍然会完全的暂停运行.你的应用只被允许在很特殊的情况下才能在后台中继续运行.例如,这些包括播放音频,获取位置更新,或者从服务器获取最新内容的情况.</p>
<p>iOS7之前,APP应用在真正暂停之前会有连续10分钟的时间去完成它们当前的操作.随着NSURLSession的出现,有了一种更为优雅的方式去应对大量的网络切换.因此,对于可用的后台运行时间已经减少到只有几分钟,而且不再必须为连续的.</p>
<p>这样的后台模式可能不适合你.但如果合适,请继续阅读!</p>
<p>接下来的学习中,将会有几个几个后台模式提供给你.在本教程中你将建立一个关于简单标签应用的工程,来探索从连续播放视频到周期性的获取更新内容的四种常见模式.</p>
<a id="more"></a>
<h1 id="开始">开始</h1><p>在深入这个工程之前,这里有一个iOS可用的基础后台模式的快速预览.在Xcode 6中,你通过点击目标程序的Capabilities(功能)选项卡能够看到如下列表:<br><img src="http://ww4.sinaimg.cn/mw690/a10328aatw1erntzxhxeuj21kw0rywls.jpg" alt="background_modes"></p>
<p>打开后台模式功能列表(1)在项目导航栏中选择项目(2)选择目标应用(3)选择功能选项卡(4)把后台模式开关打开.</p>
<p>在这个教程中,你会研究四种后台进程处理方式.</p>
<p>*视频播放:APP可以在后台播放或录制视频</p>
<p>*获取位置更新:该应用会随着设备位置的改变继续回调结果.</p>
<p>*执行一定的任务:通常在没有限制的情况下,这时APP会在有限的时间内运行任意的代码.</p>
<p>*后台获取:通过iOS的更新计划获取最细的内容.</p>
<p>这个教程将按照上面的顺序,在本教程的每个部分中介绍如何使用这四个模板.</p>
<p>从这个像观光车一样的工程开始，通过它熟悉一下iOS后台机制，首先下载这个上手工程.有个好消息：用户界面已经为你预配置好了.<br><img src="http://ww1.sinaimg.cn/mw690/a10328aatw1erntzwyr5jj20i306pt99.jpg" alt="Let’s keep backgrounding in the foreground!"></p>
<p>运行这个示例项目,检查一下你的四个选项卡.<br><img src="http://ww2.sinaimg.cn/mw690/a10328aatw1ernu00pcghj20i008l74d.jpg" alt="four_tabs"></p>
<p>这些选项卡是本教程剩余部分的路线图.第一站:后台视频</p>
<p>提示:为了使后台模式充分发挥作用,你应该使用一个真正的设备.根据我的经验,如果你忘记配置设置,该APP在模拟器的后台能很好的运行运行.然而,当你切换到真正的设备时,它将不会运行.</p>
<h1 id="音频播放">音频播放</h1><p>这里有iOS播放音频的几种方法,他们中的大部分需要实现回调函数去提供更多用来播放的音频数据.当用户使你的APP做某些事情,会调用回调函数(比如委托模型),在这种情况下,会把音波存储在内存缓存区中.</p>
<p>如果你想播放流数据中的音频,你可以开启一个网络连接,连接的这些回调函数提供连续的音频数据.</p>
<p>当你激活音频后台模式后,即使你的APP现在没在活动,iOS将继续执行这些回调函数.音频后台模式是自动的,这么说很正确.你只是激活它,恰好为管理它提供了基础设备.</p>
<p>对于我们这些有点小心思的人来说,如果你的APP确实为用户播放音频,你应该只使用后台音频模式.如果你尝试使用这个模式只是为了获取当程序安静运行的时候使用CPU的时长,苹果将拒绝你APP的运行.<br><img src="http://ww4.sinaimg.cn/mw690/a10328aatw1ernu07ttt7j20i306pglw.jpg" alt="Who_sneaky"></p>
<p>在这部分,你将在你的APP中添加一个音频播放器,打开后台模式,为你演示它的运行过程.</p>
<p>为了获取到音频播放装置,你需要学习 AV Foundation.打开AudioViewController.swift,在文件顶部import UIKit后面添加引用.</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"><span class="keyword">import</span> AVFoundation</span></span><br></pre></td></tr></table></figure>
<p>Override viewDidLoad() with the following implementation:<br>用下面的实现代码重写viewDidLoad()</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> error: <span class="type">NSError</span>?</span><br><span class="line"><span class="keyword">var</span> success = <span class="type">AVAudioSession</span>.sharedInstance().setCategory(</span><br><span class="line"><span class="type">AVAudioSessionCategoryPlayAndRecord</span>,</span><br><span class="line">withOptions: .<span class="type">DefaultToSpeaker</span>, error: &amp;error)</span><br><span class="line"><span class="keyword">if</span> !success &#123;</span><br><span class="line"><span class="type">NSLog</span>(<span class="string">"Failed to set audio session category.  Error: <span class="subst">\(error)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这使用了音频回话的单例模式sharedInstance()去设置播放的类别,也确保了声音是通过手机扬声器而不是通过手机听筒传播的.如果它执行了,他会检查调用是否失败并记录错误.一个真正的APP在发生错误后会显示一个队伍的对话框,作为对错误的回应,但是我们不需要因为这些小细节而纠结.</p>
<p>接下来,你要把播放器这个成员属性添加到AudioViewController中:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> player</span>: AVQueuePlayer!</span><br></pre></td></tr></table></figure>
<p>这是个隐式的可拓展的属性,最初为nil,你将在viewDidLoad()对它进行初始化.</p>
<p>这个上手项目包含来自主要收纳免版权税的音乐网站incompetech.com的音频文件.认证之后你可以免费的使用它上面的音乐.你这里使用的全部歌曲来自incompetech.com 上Kevin MacLeod的作品.谢谢Kevin!</p>
<p>返回viewDidLoad(),在此函数的末尾处添加如下方法:</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">songNames =</span> [<span class="string">"FeelinGood"</span>, <span class="string">"IronBacon"</span>, <span class="string">"WhatYouWant"</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="variable">songs =</span> songNames.<span class="built_in">map</span> &#123;</span><br><span class="line">AVPlayerItem(URL: NSBundle.mainBundle().URLForResource($<span class="number">0</span>, withExtension: <span class="string">"mp3"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">player =</span> AVQueuePlayer(items: songs)</span><br><span class="line">player.<span class="variable">actionAtItemEnd =</span> .Advance</span><br></pre></td></tr></table></figure>
<p>这样可以获取到歌曲的列表,把它们映射到主程序包的路径中并把它们转化为可以在AVQueuePlayer上播放的AVPlayerItems.此外,这个队列被设置为循环播放.</p>
<p>为了在队列进程中更新歌曲名字,你需要观察播放器中的currentItem.为了达到上述目的,需要在viewDidLoad()的末尾处添加如下代码:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">player.addObserver(self, <span class="string">forKeyPath:</span> <span class="string">"currentItem"</span>, <span class="string">options:</span> .New | .Initial , <span class="string">context:</span> nil)</span><br></pre></td></tr></table></figure>
<p>这使得每当播放器中currentItem改变,类观察者的回调被初始化.</p>
<p>现在你可以添加观察者模式方法.把下面代码放到viewDidLoad()下面.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">observeValueForKeyPath</span><span class="params">(keyPath: String, ofObject object: AnyObject, change: [NSObject : AnyObject], context: UnsafeMutablePointer&lt;Void&gt;)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> keyPath == <span class="string">"currentItem"</span>, <span class="keyword">let</span> player = object <span class="keyword">as</span>? <span class="type">AVPlayer</span>,</span><br><span class="line">currentItem = player.currentItem?.asset <span class="keyword">as</span>? <span class="type">AVURLAsset</span> &#123;</span><br><span class="line">songLabel.text = currentItem.<span class="type">URL</span>?.lastPathComponent ?? <span class="string">"Unknown"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当这个函数被调用的时候,你首先要确保这个被更新的属性是你所关注的.在这种情形下,它不是那么重要了因为只有一个属性被观察,但是在你之后添加更多的观察者的情况下去检查,是个不错的方法.如果它是currentItem键,你将使用它通过文件名更新songLabel.如果由于某些原因,当前项的URL不能获取到,它将使songLabel显示字符串”Unknown”.</p>
<p>你也需要一个去更新timeLabel的方法来显示当前播放项消耗的时间.使用addPeriodicTimeObserverForInterval(_:queue:usingBlock:)是达到当前目的最好的方法,该函数讲调用给定的队列当中提供的块.在viewDidLoad()的末尾处添加如下代码:</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">player.addPeriodicTimeObserverForInterval<span class="params">(CMTimeMake<span class="params">(<span class="number">1</span>, <span class="number">100</span>)</span>, queue: dispatch_get_main_queue<span class="params">()</span>)</span> &#123;</span><br><span class="line">[unowned self] time in</span><br><span class="line"><span class="built_in">let</span> timeString = String<span class="params">(format: <span class="string">"%02.2f"</span>, CMTimeGetSeconds<span class="params">(time)</span>)</span></span><br><span class="line"><span class="keyword">if</span> UIApplication.sharedApplication<span class="params">()</span>.applicationState == .Active &#123;</span><br><span class="line">self.timeLabel.<span class="built_in">text</span> = timeString</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">println<span class="params">(<span class="string">"Background: \(timeString)"</span>)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这添加给播放器一个周期性的观察者,如果这个APP在前台,这个观察者每一秒的1/100就会被调用一次并且更新UI.</p>
<blockquote>
<p>重要提示:由于你想在结束时更新UI,你必须确保这些代码在主队列中被调用.这就是你指定dispatch_get_main_queue()参数的原因.</p>
</blockquote>
<p>在这里暂停一下,思考应用的状态.</p>
<p>你的应用处于下面五个状态之一中.简单地说,他们是:</p>
<p>*未运行:你的APP在开启之前处于这个状态.</p>
<p>*激活:一旦你的APP被开启,它变成活跃状态.</p>
<p>*未激活:当你的APP正在运行,但是一些事情打断它的动作,比如有电话打进来,它变成inactive状态.休眠意味着这个APP仍然在前台运行,只是它没有接收事件.</p>
<p>*后台:在这个状态下,你的APP不在前台显示了但是它仍然在执行代码.</p>
<p>*挂起:你的APP进入不再运行代码的状态.</p>
<p>如果你想更深入的了解这些状态之间的区别,苹果网站的Execution States for Apps对此有很详细介绍.</p>
<p>你可以通过读取UIApplication.sharedApplication().applicationState来检查APP的转台.记住:你只能获取三种状态的返回值: .Active, .Inactive, and .Background.当你的APP在执行代码的时候,挂起状态和未运行状态很明显不可能出现.</p>
<p>让我们将目光继续放在之前代码上,如果该应用处于激活状态,你需要更新音乐标题栏.在后台中,你仍然能够更新这个label的文字,但是这点知识证明了当你APP在后台的时候继续接受回调.</p>
<p>现在,把剩余的代码添加到playPauseAction(<em>:)的实现中,让播放/暂停按钮工作.在AudioViewController中,把下面代码添加到playPauseAction(</em>:)的实现中:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">playPauseAction</span><span class="params">(sender: UIButton)</span></span> &#123;</span><br><span class="line">sender.selected = !sender.selected</span><br><span class="line"><span class="keyword">if</span> sender.selected &#123;</span><br><span class="line">player.play()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">player.pause()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很好,这是你全部的代码.创建并运行,你将看到下面的样子:<br><img src="http://ww2.sinaimg.cn/mw690/a10328aatw1ernu04oi3xj20o00y440j.jpg" alt="play_pause"></p>
<p>现在,点播放,音乐将开始.很好!</p>
<p>测试后台模式是否起作用.按home按钮(如果你正在使用模拟器,按Cmd-Shift-H).如果你在真正的设备上运行(不是Xcode 6.1的模拟器)音乐将停止.这是为什么呢?还有很重要的一块落下了!)</p>
<p>对于大多数的后台模式(“Whatever”模式除外)你需要在Info.plist中添加一个key用来指明APP在后台中运行的代码.幸运的是,在Xcode6可以通过复选框进行选择.</p>
<p>回到Xcode，按照以下步骤进行操作:</p>
<p>1.在项目管理器中点击工程</p>
<p>2.点击目标TheBackgrounder</p>
<p>3.点击功能标签</p>
<p>4.滑动背景模式并设置为ON</p>
<p>5.选中 Audio和AirPlay</p>
<p><img src="http://ww2.sinaimg.cn/mw690/a10328aatw1erntzwhj1kj21kw0sntg3.jpg" alt="audio_enabled"></p>
<p>重新编译并且运行.开始运行音乐并且点击home键，尽管这个APP在后台运行，这次你就会依旧能够听到音乐.</p>
<p>You should also see the time updates in your Console output in Xcode, proof that your code is still working even though the app is in the background. You can download the partially finished sample project up to this point.</p>
<p>在Xcode的输出里你也能够在控制台看到实时的更新，着就证明了虽然你的APP在后台运行，但是你的代码依旧在工作.现在你可以<a href="http://cdn4.raywenderlich.com/wpcontent/uploads/2015/04/TheBackgrounder2.zip" target="_blank" rel="external">下载部分完成的示例代码了.</a></p>
<p>以上第一个模式结束了,如果你想学完整个教程—那就继续往下读吧!</p>
<h1 id="接收位置更新">接收位置更新</h1><p>当在后台模式进行定位时，你的APP依旧会随着用户更新位置而接收到位置信息，甚至APP在后台的时候.你可以控制这些位置更新的准确性,甚至改变精度.</p>
<p>如果你的app真正需要这些信息来为用户提供价值，你只能使用后台模式.如果你使用这个模式并且Apple看到用户将要获得这些信息，你的应用程序将会被拒绝.有时苹果也将要求你向app添加一个警告的描述说明app将导致增加电量的使用.</p>
<p>第二步是为了位置更新，打开LocationViewController.swift并且向里面增加一些属性用来初始化LocationViewController.</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var locations = [<span class="link_label">MKPointAnnotation</span>](<span class="link_url"></span>)</span><br><span class="line"></span><br><span class="line">lazy var locationManager: CLLocationManager! = &#123;</span><br><span class="line">let manager = CLLocationManager()</span><br><span class="line">manager.desiredAccuracy = kCLLocationAccuracyBest</span><br><span class="line">manager.delegate = self</span><br><span class="line">manager.requestAlwaysAuthorization()</span><br><span class="line">return manager</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>你将使用locations来存储能够绘制在地图上的位置信息.CLLocationManager可以使你能够从设备上获取位置更新.你使用延迟的方法实例化它,所以当你第一次访问该属性被调用的函数时,它才被初始化.</p>
<p>代码可以设置位置管理器的精确度来实现最高的精确，你可以调节到你的app所需要的精确度.你会了解更多关于其他精度设置和它们的重要性.注意你也可以调用requestAlwaysAuthorization().这是在IOS8中的要求，并且为用户提供了接口来允许用户在后台使用位置.</p>
<p>现在你可以填写空的accuracyChanged(_:)的实现在LocationViewController里:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">accuracyChanged</span><span class="params">(sender: UISegmentedControl)</span></span> &#123;</span><br><span class="line"><span class="keyword">let</span> accuracyValues = [</span><br><span class="line">kCLLocationAccuracyBestForNavigation,</span><br><span class="line">kCLLocationAccuracyBest,</span><br><span class="line">kCLLocationAccuracyNearestTenMeters,</span><br><span class="line">kCLLocationAccuracyHundredMeters,</span><br><span class="line">kCLLocationAccuracyKilometer,</span><br><span class="line">kCLLocationAccuracyThreeKilometers]</span><br><span class="line"></span><br><span class="line">locationManager.desiredAccuracy = accuracyValues[sender.selectedSegmentIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>accuracyValues是由CLLocationManager的desiredAccuracy可能值构成的数组.这些变量控制了你的位置的精确度.</p>
<p>你可能认为这种方式是愚蠢的.为什么位置管理器不能够给你最精确的位置信息呢？最重要的原因是为了节省电量.低精确意味着耗电量较低.</p>
<p>这就意味着你应该选择最少的值实现你的app可以承受的最低限度的精确度.你随时可以修改这些值在你的需求.</p>
<p>另一个性能就是你可以控制你的app接收位置更新的频率，忽视desiredAccuracy: distanceFilter的值.当你的设备移动到了一定的值（以米计算）时，这个性能告诉位置管理器你只想接收位置更新.这个值应该最大限度的节省你的电池消耗.</p>
<p>现在你可以在enabledChanged(_:)中添加代码来实现获取位置更新：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">enabledChanged</span><span class="params">(sender: UISwitch)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> sender.on &#123;</span><br><span class="line">locationManager.startUpdatingLocation()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">locationManager.stopUpdatingLocation()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码示例有一个与动作相关的UISwitch，这个UISwitch实现了位置跟踪的开启与关闭.</p>
<p>下一步你可以通过添加一个CLLocationManagerDelegate方法来接收位置更新.添加以下方法到LocationViewController中.</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MARK: - CLLocationManagerDelegate</span></span><br><span class="line"></span><br><span class="line">func locationManager<span class="params">(manager: CLLocationManager!, didUpdateToLocation newLocation: CLLocation!, fromLocation oldLocation: CLLocation!)</span> &#123;</span><br><span class="line"><span class="comment">// Add another annotation to the map.</span></span><br><span class="line"><span class="built_in">let</span> annotation = MKPointAnnotation<span class="params">()</span></span><br><span class="line">annotation.coordinate = newLocation.coordinate</span><br><span class="line"></span><br><span class="line"><span class="comment">// Also add to our map so we can remove old values later</span></span><br><span class="line">locations.append<span class="params">(annotation)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove values if the array is too big</span></span><br><span class="line">while locations.count &gt; <span class="number">100</span> &#123;</span><br><span class="line"><span class="built_in">let</span> annotationToRemove = locations.first<span class="built_in">!</span></span><br><span class="line">locations.removeAtIndex<span class="params">(<span class="number">0</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Also remove from the map</span></span><br><span class="line">mapView.removeAnnotation<span class="params">(annotationToRemove)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> UIApplication.sharedApplication<span class="params">()</span>.applicationState == .Active &#123;</span><br><span class="line">mapView.showAnnotations<span class="params">(locations, animated: <span class="literal">true</span>)</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">NSLog<span class="params">(<span class="string">"App is backgrounded. New location is %@"</span>, newLocation)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果app的状态是激活状态，这些代码将更新地图.如果这个app在后台运行，你应该在xcode的控制台来看位置更新的log.</p>
<p>现在你已经知道了后台模式，现在你不应该犯以前的相同的错误了.现在你可以在Location updates中设置使得ios知道你的app想在后台运行时继续接受位置更新.</p>
<p><img src="http://ww3.sinaimg.cn/mw690/a10328aatw1erntzya0enj21kw0qntf6.jpg" alt="capabilities_location"></p>
<p>除了更改这个之外，你应该在你的Info.plist中设置一个关键词来允许你向使用者解释为什么后台更行数据是需要的.如果不被允许后台更新，位置更新就会慢慢地失败.</p>
<p>步骤如下：</p>
<p>1.选择Info.plist文件</p>
<p>2.点击+号来添加一个关键词</p>
<p>3.点击这个关键词的名字：NSLocationAlwaysUsageDescription</p>
<p>4.描述为什么你需要在后台位置更新，能够另使用者信服.</p>
<p><img src="http://ww4.sinaimg.cn/mw690/a10328aatw1ernu01b2izj21kw0qngxe.jpg" alt="Info_plist"></p>
<p>现在你可以编译并且运行你的程序了.切换到第二个选项卡并打开开关.</p>
<p>当你第一次运行的时候，你会看到你写入到Info.plist中的信息.点击allow出去走走，或者围绕你周围的建筑转一转.这时候你就开始看到位置信息的更新，在模拟器里也可以实现.</p>
<p><img src="http://ww3.sinaimg.cn/mw690/a10328aatw1ernu03btgzj20o0130jxz.jpg" alt="location_permission"></p>
<p>过一会，你将会看到如下的一些东西：</p>
<p><img src="http://ww3.sinaimg.cn/mw690/a10328aatw1ernu02otg4j20o0130q8m.jpg" alt="location_done"></p>
<p>如果你在后台运行你的app，你将会在你的控制台log看到你的app位置更新信息.重新打开你的app，你就会发现地图上有所有的位置点，这些就是你的app在后台 运行时候更新的数据.</p>
<p>如果你使用的是模拟器，你也可以使用这个app来模拟这个动作.打开菜单Debug \ Location：</p>
<p><img src="http://ww4.sinaimg.cn/mw690/a10328aatw1ernu042l2qj20te0hotes.jpg" alt="location_sim"></p>
<p>设置location选项为Freeway Drive然后点击home按钮.这时候你就会看到在控制台打印出你的程序运行的状态，就像你在模拟你开车在加利福尼亚的高速公路上.</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2014-12-21</span> <span class="number">20:05:13.33</span>4 TheBackgrounder[<span class="number">21591:67458</span>6] App is backgrounded. New location is &lt;+<span class="number">37.33482105</span>,-<span class="number">122.03350886</span>&gt; +/- 5.00m (speed 15.90 mps / course 255.94) @ 12/21/14, 8:05:13 PM Pacific Standard Time</span><br><span class="line"><span class="number">2014-12-21</span> <span class="number">20:05:14.81</span>3 TheBackgrounder[<span class="number">21591:67458</span>6] App is backgrounded. New location is &lt;+<span class="number">37.33477977</span>,-<span class="number">122.03369603</span>&gt; +/- 5.00m (speed 17.21 mps / course 255.59) @ 12/21/14, 8:05:14 PM Pacific Standard Time</span><br><span class="line"><span class="number">2014-12-21</span> <span class="number">20:05:15.32</span>0 TheBackgrounder[<span class="number">21591:67458</span>6] App is backgrounded. New location is &lt;+<span class="number">37.33474691</span>,-<span class="number">122.03389325</span>&gt; +/- 5.00m (speed 18.27 mps / course 257.34) @ 12/21/14, 8:05:15 PM Pacific Standard Time</span><br><span class="line"><span class="number">2014-12-21</span> <span class="number">20:05:16.33</span>0 TheBackgrounder[<span class="number">21591:67458</span>6] App is backgrounded. New location is &lt;+<span class="number">37.33470894</span>,-<span class="number">122.03411085</span>&gt; +/- 5.00m (speed 19.27 mps / course 257.70) @ 12/21/14, 8:05:16 PM Pacific Standard Time</span><br></pre></td></tr></table></figure>
<p>现在你可以<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2015/04/TheBackgrounder3.zip" target="_blank" rel="external">下载这个示例程序了</a>,到第三个选项卡和第三个后台模式.</p>
<h1 id="执行有限长任务等">执行有限长任务等</h1><p>下一个后台模式在可以正式的称为后台执行有限长的任务（Executing a Finite-Length Task in the Background）.</p>
<p>严格的说这并不是真正意义上的后台模式，因为你并没有在Info.plist中声明在你的app中使用这个模式（或者在复选框中使用Background Mode）.相反，它只是一个api你可以让你的任意代码运行有限的时间，当你的app在后台运行的时候.</p>
<p>在过去，这个模式只是在上传或者下载或者运行某一段时间来完成某一项任务.但是如果这个链接很缓慢或者这个进行一直不结束怎么办？它会让你的应用程序在一个奇怪的状态,你必须添加大量的代码来处理错误使得程序稳健地工作. 因为这样的原因，Apple介绍了NSURLSession.</p>
<p>NSURLSession在面对后台运行甚至设备重启时具有鲁棒性，并且以减少设备能耗的方式完成任务.如果你想处理大规模的下载，请查看我们的<a href="http://www.raywenderlich.com/51127/nsurlsession-tutorial" target="_blank" rel="external">NSURLSession tutorial</a>.</p>
<p>这种后台运行模式对完成一些长时间的任务还是一种非常有效的方法，比如在相机相册中进行渲染和写入一个视频.</p>
<p><img src="http://ww3.sinaimg.cn/mw690/a10328aatw1ernu07biyoj20i306paal.jpg" alt="Whatever_cheers"></p>
<p>但是这只是一个例子.你可以运行的代码是任意的,你可以用这个api来实现任意的事情：运行长时间的计算，将过滤器应用到图像处理，渲染一个复杂3 d网格…whatever！只要是你想在长时间运行你的程序你都可以用这个api.</p>
<p>你的app在后台运行的时间取决于ios系统.对于后台运行时间你可以在UIApplication中查询backgroundTimeRemaining，它将会告诉你剩余多长时间.</p>
<p>一般来说你会有3分钟时间来实现.但是在api文档中并没有给一个大约的时间，所以你不能依赖这个时间，可能是5分钟也可能是5秒.所以你的app需要准备发生的任何事情.</p>
<p>这里给一个计算机学生都熟悉的任务：斐波纳契数列.</p>
<p>这里的意义是,你会在后台计算这些数字!</p>
<p>打开WhateverViewController.swift并且在WhateverViewController里面添加属性.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> previous</span> = NSDecimalNumber.one()</span><br><span class="line"><span class="variable"><span class="keyword">var</span> current</span> = NSDecimalNumber.one()</span><br><span class="line"><span class="variable"><span class="keyword">var</span> position</span>: UInt = <span class="number">1</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> updateTimer</span>: NSTimer?</span><br><span class="line"><span class="variable"><span class="keyword">var</span> backgroundTask</span>: UIBackgroundTaskIdentifier = UIBackgroundTaskInvalid</span><br></pre></td></tr></table></figure>
<p>NSDecimalNumbers将保存序列中的前两个数的值.NSDecimalNumbers可以保存大的数据，因此非常适合你的目标.Position只是一个计数器来告诉你这个这个数在当前序列中的位置.</p>
<p>你将使用updateTimer证明甚至计时器继续使用这个API时,也稍微放慢速度的计算,这样你就可以观察他们.</p>
<p>在WhateverViewController中添加一些实用方法来重置斐波那契计算,启动和停止能够后台运行的任务:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">resetCalculation</span><span class="params">()</span></span> &#123;</span><br><span class="line">previous = <span class="type">NSDecimalNumber</span>.one()</span><br><span class="line">current = <span class="type">NSDecimalNumber</span>.one()</span><br><span class="line">position = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">registerBackgroundTask</span><span class="params">()</span></span> &#123;</span><br><span class="line">backgroundTask = <span class="type">UIApplication</span>.sharedApplication().beginBackgroundTaskWithExpirationHandler &#123;</span><br><span class="line">[<span class="keyword">unowned</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line"><span class="keyword">self</span>.endBackgroundTask()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">assert</span>(backgroundTask != <span class="type">UIBackgroundTaskInvalid</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">endBackgroundTask</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="type">NSLog</span>(<span class="string">"Background task ended."</span>)</span><br><span class="line"><span class="type">UIApplication</span>.sharedApplication().endBackgroundTask(backgroundTask)</span><br><span class="line">backgroundTask = <span class="type">UIBackgroundTaskInvalid</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在到了重要部分，在didTapPlayPause(_:)添加空的实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">didTapPlayPause</span><span class="params">(sender: UIButton)</span></span> &#123;</span><br><span class="line">sender.selected = !sender.selected</span><br><span class="line"><span class="keyword">if</span> sender.selected &#123;</span><br><span class="line">resetCalculation()</span><br><span class="line">updateTimer = <span class="type">NSTimer</span>.scheduledTimerWithTimeInterval(<span class="number">0.5</span>, target: <span class="keyword">self</span>,</span><br><span class="line">selector: <span class="string">"calculateNextNumber"</span>, userInfo: <span class="literal">nil</span>, repeats: <span class="literal">true</span>)</span><br><span class="line">registerBackgroundTask()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">updateTimer?.invalidate()</span><br><span class="line">updateTimer = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> backgroundTask != <span class="type">UIBackgroundTaskInvalid</span> &#123;</span><br><span class="line">endBackgroundTask()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按钮改变选择状态取决于计算已经停止，应该开始或者是计算已经开始，应该停止.</p>
<p>首先你必须设置斐波那契序列变量.然后你可以创建一个NSTimer，没秒启动两次，并且调用 calculateNextNumber()函数.</p>
<p>现在到了一个重要的时刻：调用registerBackgroundTask()函数，反过来调用beginBackgroundTaskWithExpirationHandler(_:).这个方法告诉了ISO你需要时间在后台运行你的app.这些调用完成之后，在你调用endBackgroundTask()之前你的app会一直获取cpu时间.</p>
<p>嗯,差不多.如果你的app在后台运行一段时间后没有调用endBackgroundTask()，IOS将调用关闭程序定义，这是在你调用beginBackgroundTaskWithExpirationHandler(_:)时给你机会来停止执行代码.所以调用endBackgroundTask()告诉IOS你已经完成工作了是非常好的一个主意.如果你不执行上面所说的而是继续执行你的代码，你的app将会终止.</p>
<p>第二部分关于if的语句是很简单的：它只是使定时器失效，并且调用endBackgroundTask()来告诉ios不再需要额外的CPU 时间.</p>
<p>在你每次调用beginBackgroundTaskWithExpirationHandler(<em>:)时调用endBackgroundTask()是非常重要的.如果你在一个任务里调用<br>beginBackgroundTaskWithExpirationHandler(</em>:)两次而只调用endBackgroundTask()一次，你将仍然获取cpu时间，直到你在运行第二次的后台任务是调用endBackgroundTask()才能结束.这就是为什么你需要backgroundTask.</p>
<p>现在你可以实现简单的计算机程序方法.在WhateverViewController添加以下的方法：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">func calculateNextNumber() &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="literal">result</span> = current.decimalNumberByAdding(previous)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bigNumber = <span class="type">NSDecimalNumber</span>(mantissa: <span class="number">1</span>, exponent: <span class="number">40</span>, isNegative: <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="literal">result</span>.compare(bigNumber) == .<span class="type">OrderedAscending</span> &#123;</span><br><span class="line">previous = current</span><br><span class="line">current = <span class="literal">result</span></span><br><span class="line">++position</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">// <span class="type">This</span> <span class="keyword">is</span> just too much.... <span class="type">Start</span> over.</span><br><span class="line">resetCalculation()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> resultsMessage = <span class="string">"Position \(position) = \(current)"</span></span><br><span class="line"></span><br><span class="line">switch <span class="type">UIApplication</span>.sharedApplication().applicationState &#123;</span><br><span class="line"><span class="keyword">case</span> .<span class="type">Active</span>:</span><br><span class="line">resultsLabel.text = resultsMessage</span><br><span class="line"><span class="keyword">case</span> .<span class="type">Background</span>:</span><br><span class="line"><span class="type">NSLog</span>(<span class="string">"App is backgrounded. Next number = %@"</span>, resultsMessage)</span><br><span class="line"><span class="type">NSLog</span>(<span class="string">"Background time remaining = %.1f seconds"</span>, <span class="type">UIApplication</span>.sharedApplication().backgroundTimeRemaining)</span><br><span class="line"><span class="keyword">case</span> .<span class="type">Inactive</span>:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再一次，我们将展示另一个方法即使你的app在后台运行依旧能够显示结果.在这种情形下，还有一个有趣的信息: backgroundTimeRemaining的数值.只有当ios调用添加调用beginBackgroundTaskWithExpirationHandler(_:)的时才会停止.</p>
<p>编译并且运行，然后切换到第三个选项卡.</p>
<p><img src="http://ww2.sinaimg.cn/mw690/a10328aatw1ernu006twnj20o00y4mz1.jpg" alt="fib"></p>
<p>点击play并且你将会看到app计算出的值.现在点击home键然后查看xcode控制台.你应该会看到app依旧会更新数字，与此同时时间依旧在向前走.</p>
<p>在大多数情况下，这个时间将从第180秒开始并且延续5秒钟.如果你等待重新回到你的app，定时器将重新开始启动并且所有的错误行为将继续.</p>
<p>在代码里只有一个bug，它给我机会来解释关于后台通知.假设你或太运行app并且等待分配的时间到期.在这种情况下，你app将调用？？并且调用endBackgroundTask()，也就是终结后台运行时间的需求.</p>
<p>如果你继续返回你的app，定时器将继续激活.但是如果你离开app，你将不会得到或太运行时间.Why？因为在超时和回到后台期间app没有间隙来调用beginBackgroundTaskWithExpirationHandler(_:).</p>
<p>你怎么解决这个问题呢？有许多方法能够解决这个问题，并且其中一个是使用一种状态来改变通知.</p>
<p>有两种你可以得到通知并且你的app可以改变它的状态的方法：第一种是通过你的主app委托方法；第二种是通过监听ios发送给你的app的通知.</p>
<p>*<br>当你的app将要进入不活跃的状态，UIApplicationWillResignActiveNotification和applicationWillResignActive(_:)将会被发送和调用.在这种情况下，你的app不是在后台运行，它依旧在前台运行，但是它将不会接收到任何UI事件.</p>
<p>*<br>当app进入到后台状态，UIApplicationDidEnterBackgroundNotification 和applicationDidEnterBackground(<em>:)将会被发送和调用.在这种情况下，你的app将不会是在激活状态，并且它是你最后的机会运行你的代码.如果你想得到更多的CPU时刻，这是一个调用beginBackgroundTaskWithExpirationHandler(</em>:)非常完美的时机.</p>
<p>*<br>当app返回激活状态，UIApplicationWillEnterForegroundNotification 和applicationWillEnterForeground(<em>:)将会被发送和调用.这是app依旧在后台运行，你已经可以启动任何你想做的事.当你真正进入后台运行是如果你只调用了beginBackgroundTaskWithExpirationHandler(</em>:)，此时将是一个好的时机调用endBackgroundTask().</p>
<p>*<br>以防你的app从后台运行状态返回，在前一个通知完成后UIApplicationDidBecomeActiveNotification和applicationDidBecomeActive(_:)将会被发送和调用.如果你的app只是临时的中断也会被调用-举例—如果你的app没有真正的进入到后台，但是你依旧会收到UIApplicationWillResignActiveNotification.</p>
<p>你可以在<a href="https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/TheAppLifeCycle/TheAppLifeCycle.html#//apple_ref/doc/uid/TP40007072-CH2-SW3" target="_blank" rel="external">Apple’s documentation for App States for Apps</a>中看到所有的图像化描述（文章—有着许多非常棒的图表）</p>
<p>现在是解决这个bug的时间了.首先要重写viewDidLoad()并且订阅UIApplicationDidBecomeActiveNotification.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"><span class="type">NSNotificationCenter</span>.defaultCenter().addObserver(<span class="keyword">self</span>, selector: <span class="type">Selector</span>(<span class="string">"reinstateBackgroundTask"</span>), name: <span class="type">UIApplicationDidBecomeActiveNotification</span>, object: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不管何时这app变成激活状态，指定的选择器reinstateBackgroundTask将被调用.</p>
<p>不管何时你订阅了一个通知你也应该想到这个订阅的通知哪里不应该被订阅.使用deinit来完成这个功能.按照下面的代码加入到WhateverViewController.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deinit &#123;</span><br><span class="line"><span class="built_in">NSNotificationCenter</span><span class="variable">.defaultCenter</span>()<span class="variable">.removeObserver</span>(<span class="keyword">self</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后实现reinstateBackgroundTask().</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">reinstateBackgroundTask</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> updateTimer != <span class="literal">nil</span> &amp;&amp; (backgroundTask == <span class="type">UIBackgroundTaskInvalid</span>) &#123;</span><br><span class="line">registerBackgroundTask()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果定时器依然运行但是后台任务没有运行，你只需要恢复就可以了.</p>
<p>把你的代码分解成小的实用的代码只需要做一件事就可以.当一个后台任务不是在当前的定时器下你只需要调用registerBackgroundTask()即可.</p>
<p>然后你可以使用了.你可以<a href="http://cdn3.raywenderlich.com/wp-content/uploads/2015/04/TheBackgrounder4.zip" target="_blank" rel="external">下载</a>这个程序.</p>
<p>这个课程的最后的一节是：Background Fetching.</p>
<h1 id="后台获取">后台获取</h1><p>后台获取是iOS7中推出的让你的APP在最大限度减少对电池损耗的时候总是展现最新的信息.举个例子,假设你正在给你的APP填充信息.你可以通过viewWillAppear(_:).获取最新数据来预先通知后台模式.这个方案可以解决在新数据刷新过来之前你的用户正在浏览前几秒的数据.当用户打开你APP的同时,最新的数据同时被神奇的展现了,这种情况再好不过了.这是后台模式能够为你实现的操作.</p>
<p>当APP被激活的时候,系统会使用惯用模式去决定什么时候执行后台获取.比如,如果用户每天都在早上9点打开改APP,后台获取在这个时间点之前预先执行是很可能的.系统决定什么时候是安排后台获取的最好时间,因此你不应该用它去做紧急的更新.</p>
<p>这里有你为了实现后台获取必须做的三件事情:</p>
<p>*<br>检查你APPCapabilities选项中后台模式的后台获取选项框是否被选中.</p>
<p>*<br>使用setMinimumBackgroundFetchInterval(_:) 为你的APP创建一个合适的时间间隔.</p>
<p>*<br>在你APP委托中实现application(_:performFetchWithCompletionHandler:)去管理后台获取.</p>
<p>后台获取就像他名字表示的一样,他通常涉及到从外源,比如网络服务,中获取信息.就这个教程的意图,你将不会使用网络而仅仅获取现在的时间.这样简化讲让你理解在不同担心外在的服务的时候操作并测试后台模式所需要的每一样东西.</p>
<p>对于有限长度的任务,你只有以按秒为单位的时间去执行操作,公认的时间是不超过30秒，但越短越好.如果您需要下载大量资源最为获取的部分，这就是你需要使用NSURLSession的背景传输服务的地方.</p>
<p>开始的时间到了.首先,打开FetchViewController.swift,并将下面的属性和方法添加到FetchViewController中.</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attribute">time</span>: NSDate?</span><br><span class="line"></span><br><span class="line">func fetch<span class="function"><span class="params">(completion: () -&gt; Void)</span> &#123;</span><br><span class="line"><span class="title">time</span> = <span class="title">NSDate</span><span class="params">()</span></span><br><span class="line"><span class="title">completion</span><span class="params">()</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这些代码是代替你真正的从外源(json或XML RESTful 服务)中获取数据的一种简化.因为它可能需要几秒钟来获取和分析数据，你传递一个完成的handler,这个handler在进程完成后被调用.你待会儿会看到为什么很很重要.</p>
<p>接下来,完成view controller的代码.将下面的方法添加到FetchViewController中.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">updateUI</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> time = time &#123;</span><br><span class="line"><span class="keyword">let</span> formatter = <span class="type">NSDateFormatter</span>()</span><br><span class="line">formatter.dateStyle = .<span class="type">ShortStyle</span></span><br><span class="line">formatter.timeStyle = .<span class="type">LongStyle</span></span><br><span class="line">updateLabel?.text = formatter.stringFromDate(time)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">updateLabel?.text = <span class="string">"Not yet updated"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">updateUI()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">didTapUpdate</span><span class="params">(sender: UIButton)</span></span> &#123;</span><br><span class="line">fetch &#123; <span class="keyword">self</span>.updateUI() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>updateUI()格式化这个时间并显示它.它是一个可选的类型,所以如果它没有被创建,他将展示至今没有更新的信息.当这个view初次被加载时(在 viewDidLoad()中)你不能获取到,但是直接调用updateUI()函数,将会有“Not yet updated”的字样在开始时显示.最后,当更新按钮被监听的时候,它运行获取的代码并且会完成对UI的更新.</p>
<p>就这一点而言,该view controller正在工作.</p>
<p><img src="http://ww2.sinaimg.cn/mw690/a10328aatw1erntzzir82j20o00y4jt6.jpg" alt="fetch_working"></p>
<p>然而,后台获取没有起作用.</p>
<p>启用后台获取的第一步是在Capabilities选项栏里选中Background fetch.到现在这个操作已经是老一套的了,直接找到它并选中.</p>
<p><img src="http://ww2.sinaimg.cn/mw690/a10328aatw1erntzyx5m1j21kw0qn450.jpg" alt="capability_fetch"></p>
<p>接下来,打开AppDelegate.swift,通过在 application(_:didFinishLaunchingWithOptions:)中设置最小的后台获取时间间隔来请求后台获取操作.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">application</span><span class="params">(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"><span class="type">UIApplication</span>.sharedApplication().setMinimumBackgroundFetchInterval(</span><br><span class="line"><span class="type">UIApplicationBackgroundFetchIntervalMinimum</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认的时间间隔是你想切换回去的UIApplicationBackgroundFetchIntervalNever,比如,你的用户日志和不需要更新的内容.你也可以设置一个精确到秒的时间间隔.系统在开始执行后台获取之前将等待一段时间.</p>
<p>要小心,,不要将时间间隔设置过短,因为它会多余的消耗电池和损害服务器.结束获取信息的确切时间是由系统决定的,但是在执行它之前将会等待一段时间.通常,UIApplicationBackgroundFetchIntervalMinimum是很好用的默认值.</p>
<p>最后,为了启用后台程序,你必须实现application(_:performFetchWithCompletionHandler:).将下列方法添加到AppDelegate.swift中.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Support for background fetch</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">application</span><span class="params">(application: UIApplication, performFetchWithCompletionHandler completionHandler: <span class="params">(UIBackgroundFetchResult)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> tabBarController = window?.rootViewController <span class="keyword">as</span>? <span class="type">UITabBarController</span>,</span><br><span class="line">viewControllers = tabBarController.viewControllers <span class="keyword">as</span>? [<span class="type">UIViewController</span>] &#123;</span><br><span class="line"><span class="keyword">for</span> viewController <span class="keyword">in</span> viewControllers &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> fetchViewController = viewController <span class="keyword">as</span>? <span class="type">FetchViewController</span> &#123;</span><br><span class="line">fetchViewController.fetch &#123;</span><br><span class="line">fetchViewController.updateUI()</span><br><span class="line">completionHandler(.<span class="type">NewData</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先你需要获取FetchViewContoller.然后,因为rootViewController在每个APP中不是必须的UITabBarController,所以它是可以选择创建的,不过它在这个APP中,所以它绝不会出现问题.</p>
<p>接下来,你在选项卡控制器中循环添加所有的视图控制器,并且将它们成功的放到FetchViewController中.在这个APP中,你知道它是最后的控制器,所以你不能对它进行硬编码,但是在你决定以后添加或删除选项卡的时候循环创建会提高程序的健壮性.</p>
<p>最后,你可以调用fetch(_:).当它执行完后,你会更新UI,然后调用将completionHandler作为参数传递的函数.你在这个操作的最后调用这个完成处理的程序是很重要的.你指定在获取过程中获取的结果作为以一个参数.它的可能值为.NewData, .NoData或者.Failed.</p>
<p>为了简单起见,该教程总是指定.NewData作为永远成功获取时间的返回值,并且这个值和上一次的结果总是不同的.在这之后,iOS可以使用更好的时间间隔来执行后台获取.该系统知道在这个时间点上的系统快照,所以它可以在应用程序切换卡中显示.以上是为了实现后台获取所需要的所有的操作.</p>
<blockquote>
<p>提示:不是沿着信息传递完成对属性的调用,而是保存一个属性变量,并且在你获取完成后调用它是很有诱惑力的.不这样做的话,如果你多次调用 application(_:performFetchWithCompletionHandler:),先前的处理程序将会被覆盖,永远不会被调用.最好通过传递处理程序,并且在它不会造成这种编程错误的时候调用它.</p>
</blockquote>
<h1 id="测试后台获取">测试后台获取</h1><p>测试后台获取的一个方法是停下来等着系统决定去执行它.这需要大量的等待.幸运的是,Xcode体统了模拟后台获取的方法.有两种你需要测试的情况,一种是当你的APP在后台中时,另一种是你的APP处于从被挂起到继续运行的情况.第一种方法最简单,仅仅是一个选择菜单.</p>
<p>*<br>在真正的设备上运行(不是模拟器);</p>
<p>*<br>在Xcode调试菜单中选择模拟后台获取;</p>
<p><img src="http://ww1.sinaimg.cn/mw690/a10328aatw1ernu05aqtgj206v0c4myd.jpg" alt="Screen Shot 2015-01-16 at 9.57.24 PM"></p>
<p>重新打开这个APP,注意被送到后台的数据.</p>
<p>切换到Fetch选项卡,(注意当你模拟后台获取而且不是显示“Not yet updated”的时候时间)</p>
<p>另一种方法是在从挂起状态回复的时候测试后台获取.这里有一个启动项让你APP一运行就直接进入挂起状态.因为你可能要测试这种临界状态,用这个选项始终建立新的Scheme是最好的.Xcode使这种情况很容易实现.</p>
<p>首先选择Manage Schemes选项.</p>
<p><img src="http://ww3.sinaimg.cn/mw690/a10328aatw1ernu06bewpj20c705q75h.jpg" alt="Screen Shot 2015-01-16 at 10.10.42 PM"><br><img src="http://ww1.sinaimg.cn/mw690/a10328aatw1ernu06v7lwj20bq04t0tp.jpg" alt="Screen Shot 2015-01-16 at 10.42.12 PM"></p>
<p>接下来,选择列表里仅有的方案,然后点击齿轮图标,选择Duplicate Scheme.</p>
<p><img src="http://ww4.sinaimg.cn/mw690/a10328aatw1ernu05qy3cj20la0btwfi.jpg" alt="Screen Shot 2015-01-16 at 10.08.58 PM"></p>
<p>最后,用合理的名字重命名你的方案,比如 “Background Fetch”,并选中 Launch due to background fetch event的复选框.</p>
<p><img src="http://ww1.sinaimg.cn/mw690/a10328aatw1ernu01yfwoj21kw0wln6c.jpg" alt="launch_suspended"></p>
<p>需要注意的是在Xcode6.1中,在模拟器上这并不能可靠的运行.我自己测试的时候,我需要使用真正的设备正确的从启动进去到挂起状态.</p>
<p>用这个方案运行你的APP.你会发现,该APP没有真正的打开,而是直接运行到了挂起状态.现在,手动开启它,并进入Fetch选项.你会看到,当你运行该APP时,时间会更新,而不会显示“Not yet updated”.</p>
<p>使用后台获取能够有效地让你的用户们流畅的一直获取最新的内容.</p>
<h1 id="何去何从?">何去何从?</h1><p>你可以<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2015/04/TheBackgrounder.zip" target="_blank" rel="external">在这里下载完整的示例工程</a>.</p>
<p>如果你想读我们这里涉及到苹果文档里的内容,最佳开始地点是 <a href="https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/BackgroundExecution/BackgroundExecution.html#//apple_ref/doc/uid/TP40007072-CH4-SW1" target="_blank" rel="external">Background Execution</a>.该文档介绍了每一个后台模式,并为每个模式链接到相应的位置.</p>
<p>该文档有趣的部分谈论了如何构建一个可靠的APP.你应该知道释放正在后台运行的APP中的一些细节或多或少会涉及到你到APP.</p>
<p>最后,如果你打算做大型网络信息传输,确保检查<a href="http://www.raywenderlich.com/51127/nsurlsession-tutorial" target="_blank" rel="external">NSURLSession</a>.</p>
<p>我们希望你能享受这个课程,如果你有任何疑问或意见, 请加入下面的论坛讨论.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="iOS后台模式开发指南">iOS后台模式开发指南</h1><hr>
<blockquote>
<ul>
<li>原文链接 : <a href="http://www.raywenderlich.com/92428/background-modes-ios-swift-tutorial">Background Modes Tutorial: Getting Started</a></li>
<li>原文作者 : <a href="http://www.raywenderlich.com/u/rayfix"> Ray Fix </a></li>
<li>译者 : <a href="https://github.com/MollyMmm">MollyMmm</a> </li>
<li>校对者:David Hu</li>
<li>状态 :  已完成</li>
</ul>
</blockquote>
<p>更新说明:这个教程被Ray Fix更新为关于iOS和Swift的.原著作者为<a href="http://www.raywenderlich.com/29948/backgrounding-for-ios">Gustavo Ambrozio</a>.</p>
<p>自从古老的iOS4以来,当用户点击home建的时候,你可以使你的APP们在内存中处于suspended(挂起)状态.即使APP仍停留在内存中,它的所有操作是被暂停的直到用户再次运行它.</p>
<p>当然这个规则中有例外情况.在特定的情况下,这个APP仍然可以在后台中执行某些操作.这个教程会教你在什么时候怎么去用最常用的一些后台操作.</p>
<p>每一次iOS的发布都会在后台操作和细节上的放宽限制，以此提升用户体验和延长电池寿命.对于在iOS中实现”真正”的多任务来说,后台模式不是一个神奇的解决办法.当用户切换到其他的APP应用时,大多数的APP应用仍然会完全的暂停运行.你的应用只被允许在很特殊的情况下才能在后台中继续运行.例如,这些包括播放音频,获取位置更新,或者从服务器获取最新内容的情况.</p>
<p>iOS7之前,APP应用在真正暂停之前会有连续10分钟的时间去完成它们当前的操作.随着NSURLSession的出现,有了一种更为优雅的方式去应对大量的网络切换.因此,对于可用的后台运行时间已经减少到只有几分钟,而且不再必须为连续的.</p>
<p>这样的后台模式可能不适合你.但如果合适,请继续阅读!</p>
<p>接下来的学习中,将会有几个几个后台模式提供给你.在本教程中你将建立一个关于简单标签应用的工程,来探索从连续播放视频到周期性的获取更新内容的四种常见模式.</p>]]>
    
    </summary>
    
      <category term="Background" scheme="http://ytlvy.com/tags/Background/"/>
    
      <category term="IOS" scheme="http://ytlvy.com/categories/IOS/"/>
    
  </entry>
  
</feed>