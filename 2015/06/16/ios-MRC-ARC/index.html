<!doctype html>
<html class="theme-next use-motion ">
<head>
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">


<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.3"/>


    <meta name="description" content="notes for study" />



  <meta name="keywords" content="mrc arc," />



  <link rel="alternate" href="/atom.xml" title="Yt's Blog" type="application/atom+xml" />



  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.3" />



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    analytics: {
      google: ''
    },
    sidebar: 'post'
  };
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?b8a916e09c6b39221eb089c8ad75ede9";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <title> ios MRC && ARC // Yt's Blog </title>
</head>

<body>
<!--[if lte IE 8]> <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'> <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode"><img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820" alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari." style='margin-left:auto;margin-right:auto;display: block;'/></a></div> <![endif]-->
  <div class="container one-column page-post-detail">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">Yt's Blog</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>


  <ul id="menu" class="menu">
     
    
      
      <li class="menu-item menu-item-home">
        <a href="/">
          <i class="menu-item-icon icon-home"></i> <br />
          首頁
        </a>
      </li>
    
      
      <li class="menu-item menu-item-categories">
        <a href="/categories">
          <i class="menu-item-icon icon-categories"></i> <br />
          分類
        </a>
      </li>
    
      
      <li class="menu-item menu-item-about">
        <a href="/about">
          <i class="menu-item-icon icon-about"></i> <br />
          關於
        </a>
      </li>
    
      
      <li class="menu-item menu-item-archives">
        <a href="/archives">
          <i class="menu-item-icon icon-archives"></i> <br />
          歸檔
        </a>
      </li>
    
      
      <li class="menu-item menu-item-tags">
        <a href="/tags">
          <i class="menu-item-icon icon-tags"></i> <br />
          標籤
        </a>
      </li>
    
  </ul>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          

  <div id="posts" class="posts-expand">
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              ios MRC && ARC
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2015-06-16
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/IOS/">IOS</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/06/16/ios-MRC-ARC/#comments" >
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/06/16/ios-MRC-ARC/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        <h2 id="ARC">ARC</h2><h3 id="MRC">MRC</h3><h4 id="MRC内存管理原则">MRC内存管理原则</h4><p>􏰀1. You have ownership of any objects you create.<br>2.􏰀 You can take ownership of an object using retain.<br>􏰀3. When no longer needed, you must relinquish ownership of an object you own.<br>􏰀4. You must not relinquish ownership of an object you don’t own.</p>
<table>
<thead>
<tr>
<th>Action for Objective-C Object</th>
<th>Objective-C Method</th>
</tr>
</thead>
<tbody>
<tr>
<td>Create and have ownership of it</td>
<td>alloc/new/copy/mutableCopy group</td>
</tr>
<tr>
<td>Take ownership of it</td>
<td>retian</td>
</tr>
<tr>
<td>Relinquish it</td>
<td>release</td>
</tr>
<tr>
<td>Dispose of it</td>
<td>dealloc</td>
</tr>
</tbody>
</table>
<h4 id="调用者持有">调用者持有</h4><p>Relinquishing Ownership of a Retained Object. 下面的例子将函数将自己持有的obj, 通过return传递给了调用者,由调用者来来持有此变量<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (id)allocObject</span><br><span class="line">&#123;</span><br><span class="line">  /*</span><br><span class="line">  - <span class="type">You</span> create an <span class="keyword">object</span> <span class="keyword">and</span> have ownership. */</span><br><span class="line">  id obj = [[<span class="type">NSObject</span> alloc] init];</span><br><span class="line">  /*</span><br><span class="line">  - <span class="type">At</span> this moment, this <span class="keyword">method</span> has ownership <span class="keyword">of</span> the <span class="keyword">object</span>. */</span><br><span class="line">  <span class="keyword">return</span> obj; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h4 id="调用者不持有">调用者不持有</h4><p>通过autorelease, 可以让调用者不持有该对象. Autorelease offers a mechanism to relinquish objects properly when the lifetime of the objects has ended.自动释放提供了一种, 当对象生命周期结束时,自动释放的机制.<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (id)<span class="keyword">object</span></span><br><span class="line">&#123;</span><br><span class="line">  id obj = [[<span class="type">NSObject</span> alloc] init];</span><br><span class="line">  /*</span><br><span class="line">  - <span class="type">At</span> this moment, this <span class="keyword">method</span> has ownership <span class="keyword">of</span> the <span class="keyword">object</span>. */</span><br><span class="line">  [obj autorelease];</span><br><span class="line">  /*</span><br><span class="line">  - <span class="type">The</span> <span class="keyword">object</span> exists, <span class="keyword">and</span> you don’t have ownership <span class="keyword">of</span> it. */</span><br><span class="line">  <span class="keyword">return</span> obj; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="autorelease">autorelease</h4><p>通过autorelease将对象注册到 最近的autoReleasePool中,当pool调用<code>drain</code>时, 该对象的release被调用.</p>
<h4 id="不要释放,_非你持有的对象">不要释放, 非你持有的对象</h4><p>app crash<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id obj = <span class="comment">[<span class="comment">[NSObject alloc]</span> init]</span>;</span><br><span class="line"><span class="comment">[obj release]</span>;</span><br><span class="line"><span class="comment">[obj release]</span>;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id obj1 = [obj0 object]<span class="comment">;</span></span><br><span class="line">[obj1 release]<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h4 id="GNUstep_—_The_alloc_Method">GNUstep — The alloc Method</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> obj_layout &#123;</span><br><span class="line">  <span class="built_in">NSUInteger</span> retained; </span><br><span class="line">&#125;;</span><br><span class="line">+ (<span class="keyword">id</span>) alloc &#123;</span><br><span class="line">  <span class="keyword">int</span> size = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> obj_layout) + size_of_the_object; </span><br><span class="line">  <span class="keyword">struct</span> obj_layout *p = (<span class="keyword">struct</span> obj_layout *)calloc(<span class="number">1</span>, size); </span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">id</span>)(p + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>动态分配地址, 并将第一个字节, 转换为引用计数.</p>
<h5 id="GNUstep_—_malloc_&amp;&amp;_calloc">GNUstep —  malloc &amp;&amp; calloc</h5><p>malloc 分配的空间没有初始化为0, calloc分配的空间初始化为0; calloc可以分配多个</p>
<h4 id="GNUstep_—_The_retain_Method">GNUstep —  The retain Method</h4><p>The alloc method returns a memory block filled with zero containing a struct obj_layout header, which has a variable “retained” to store the number of references. This number is called the reference count</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init]; </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"retainCount=%d"</span>, [obj retainCount]); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSUInteger</span>) retainCount &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NSExtraRefCount</span>(<span class="keyword">self</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="built_in">NSUInteger</span> <span class="built_in">NSExtraRefCount</span>(<span class="keyword">id</span> anObject)&#123;</span><br><span class="line">  <span class="keyword">return</span> ((<span class="keyword">struct</span> obj_layout *)anObject)[-<span class="number">1</span>]<span class="variable">.retained</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>) retain &#123;</span><br><span class="line">  <span class="built_in">NSIncrementExtraRefCount</span>(<span class="keyword">self</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="built_in">NSIncrementExtraRefCount</span>(<span class="keyword">id</span> anObject) &#123;</span><br><span class="line">  <span class="keyword">if</span> (((<span class="keyword">struct</span> obj_layout *)anObject)[-<span class="number">1</span>]<span class="variable">.retained</span> == <span class="built_in">UINT_MAX</span> - <span class="number">1</span>)</span><br><span class="line">      [<span class="built_in">NSException</span> raise: <span class="built_in">NSInternalInconsistencyException</span></span><br><span class="line">                  format: <span class="string">@"NSIncrementExtraRefCount() asked to increment too far"</span>];</span><br><span class="line"> </span><br><span class="line">  ((<span class="keyword">struct</span> obj_layout *)anObject)[-<span class="number">1</span>]<span class="variable">.retained</span>++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="GNUstep_—_The_release_Method">GNUstep — The release Method</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) release &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">NSDecrementExtraRefCountWasZero</span>(<span class="keyword">self</span>))</span><br><span class="line">    [<span class="keyword">self</span> dealloc];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">BOOL</span> <span class="built_in">NSDecrementExtraRefCountWasZero</span>(<span class="keyword">id</span> anObject) &#123;</span><br><span class="line">  <span class="keyword">if</span> (((<span class="keyword">struct</span> obj_layout *)anObject)[-<span class="number">1</span>]<span class="variable">.retained</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    ((<span class="keyword">struct</span> obj_layout *)anObject)[-<span class="number">1</span>]<span class="variable">.retained</span>--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="GNUstep_—_The_dealloc_Method">GNUstep — The dealloc Method</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) dealloc </span><br><span class="line">  <span class="built_in">NSDeallocateObject</span> (<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="built_in">NSDeallocateObject</span>(<span class="keyword">id</span> anObject) &#123;</span><br><span class="line">  <span class="keyword">struct</span> obj_layout *o = &amp;((<span class="keyword">struct</span> obj_layout *)anObject)[-<span class="number">1</span>];</span><br><span class="line">  free(o); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="GNUstep_—_总结">GNUstep — 总结</h4><p>􏰀1. All Objective-C objects have an integer value called the reference count.<br>􏰀2. The reference count is incremented by one when one of alloc/new/copy/mutableCopy or retain is called.<br>􏰀3. It is decremented by one when release is called.<br>􏰀4. Dealloc is called when the integer counter becomes zero.</p>
<h4 id="Apple’s_Implementation">Apple’s Implementation</h4><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">retainCount </span><br><span class="line"></span>  __CFDoExternRefOperation</span><br><span class="line">  CFBasicHashGetCountOfKey</span><br><span class="line"></span><br><span class="line">-<span class="ruby">retain </span><br><span class="line"></span>  __CFDoExternRefOperation </span><br><span class="line">  CFBasicHashAddValue</span><br><span class="line"></span><br><span class="line">-<span class="ruby">release </span><br><span class="line"></span>  __CFDoExternRefOperation </span><br><span class="line">  CFBasicHashRemoveValue</span><br></pre></td></tr></table></figure>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __CFDoExternRefOperation(uintptr_t op, id obj) &#123; </span><br><span class="line">  CFBasicHashRef table = get hashtable <span class="keyword">from</span> obj; <span class="keyword">int</span> <span class="keyword">count</span>;</span><br><span class="line">  <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> OPERATION_retainCount:</span><br><span class="line">      <span class="keyword">count</span> = CFBasicHashGetCountOfKey(table, obj); </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">count</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> OPERATION_retain: </span><br><span class="line">      CFBasicHashAddValue(table, obj); </span><br><span class="line">      <span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> OPERATION_release:</span><br><span class="line">      <span class="keyword">count</span> = CFBasicHashRemoveValue(table, obj);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span> == <span class="keyword">count</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在GUNstep的实现中, 引用计数存放在每个obj的header部分, 而Apple的实现, 将所有的对象的引用计数存放在一个HashTable中,</p>
<p>GUNstep实现的好处:</p>
<ul>
<li>更少的代码</li>
<li>很容易控制生命周期, 因为计数, 本身包含在每个对象中</li>
</ul>
<p>Apple实现的好处:</p>
<ul>
<li>每个对象不必有header部分, 从而不需要考虑对齐的问题</li>
<li>计数统一管理, 每个对象的计数都可以访问到, 便于系统批量处理.</li>
<li>当每个对象的内存出问题的时候, 可以通过hashTable来定位到该对象</li>
</ul>
<h4 id="Autorelease">Autorelease</h4><h5 id="Automatic_Variables">Automatic Variables</h5><p>当一个自动变量, 超出其作用域时, 会自动释放.<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="keyword">int</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>With autorelease, you can use objects in the same manner as automatic variables, meaning that when execution leaves a code block, the “release” method is called on the object automatically. You can control the block itself as well.</p>
<p>The following steps</p>
<ol>
<li>Create an NSAutoreleasePool object.</li>
<li>Call “autorelease” to allocated objects.</li>
<li>Discard the NSAutoreleasePool object</li>
</ol>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSAutoreleasePool *pool = <span class="comment">[<span class="comment">[NSAutoreleasePool alloc]</span> init]</span>; id obj = <span class="comment">[<span class="comment">[NSObject alloc]</span> init]</span>;</span><br><span class="line"><span class="comment">[obj autorelease]</span>;</span><br><span class="line"><span class="comment">[pool drain]</span>;</span><br></pre></td></tr></table></figure>
<p>In the Cocoa Framework, NSAutoreleasePool objects are created, owned, or disposed of all over the place, such as NSRunLoop, which is the main loop of the application </p>
<p>But when there are too many autoreleased objects, application memory becomes short (Figure 1–14). It happens because the objects still exist until the NSAutoreleasePool object is discarded. A typical example of this is loading and resizing many images. Many autoreleased objects, such as NSData objects for reading files, UImage objects for the data, and resized images exist at the same time.</p>
<p>当有太多autorelease对象时, 程序的可用内存会急剧减少. 因为这些对象会一直存在, 直到pool被结束时.<br>典型应用场景: 加载或调整大量图片的时候.<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numberOfImages; ++i) &#123;</span><br><span class="line">  <span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span><br><span class="line">  * Loading images, etc.</span><br><span class="line">  * Too many autoreleased objects exist. </span><br><span class="line">  */</span></span><br><span class="line"></span><br><span class="line">  [pool drain];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Implementing_autorelease">Implementing autorelease</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">[obj autorelease]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (id) <span class="tag">autorelease</span> &#123;</span><br><span class="line">  <span class="attr_selector">[NSAutoreleasePool addObject:self]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>) addObject: (<span class="keyword">id</span>)anObj &#123;</span><br><span class="line">  <span class="built_in">NSAutoreleasePool</span> *pool = getting active <span class="built_in">NSAutoreleasePool</span>; </span><br><span class="line">  <span class="keyword">if</span> (pool != <span class="literal">nil</span>) &#123;</span><br><span class="line">    [pool addObject:anObj]; </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"autorelease is called without active NSAutoreleasePool."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Apple’s_Implementation_of_autorelease">Apple’s Implementation of autorelease</h4><p>runtime/NSObject.mm  #493<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="name">NSAutoreleasePool</span> *<span class="atom">pool</span> = [[<span class="name">NSAutoreleasePool</span> <span class="atom">alloc</span>] <span class="atom">init</span>];</span><br><span class="line"><span class="comment">/* equivalent to objc_autoreleasePoolPush() */</span></span><br><span class="line"></span><br><span class="line"><span class="atom">id</span> <span class="atom">obj</span> = [[<span class="name">NSObject</span> <span class="atom">alloc</span>] <span class="atom">init</span>];</span><br><span class="line">[<span class="atom">obj</span> <span class="atom">autorelease</span>];</span><br><span class="line"><span class="comment">/* equivalent to objc_autorelease(obj) */</span></span><br><span class="line"></span><br><span class="line">[<span class="atom">pool</span> <span class="atom">drain</span>];</span><br><span class="line"><span class="comment">/* equivalent to objc_autoreleasePoolPop(pool) */</span></span><br></pre></td></tr></table></figure></p>
<h3 id="ARC_Rules">ARC Rules</h3><h4 id="Ownership_qualifiers">Ownership qualifiers</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">􏰀__<span class="keyword">strong</span></span><br><span class="line">􏰀__<span class="keyword">weak</span></span><br><span class="line">􏰀__unsafe_unretained</span><br><span class="line">__autoreleasing</span><br></pre></td></tr></table></figure>
<h4 id="__strong_ownership_qualifier_—_作用域情况">__strong ownership qualifier — 作用域情况</h4><p><code>__strong</code>是默认的修饰符. </p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id obj = <span class="comment">[<span class="comment">[NSObject alloc]</span> init]</span>;</span><br></pre></td></tr></table></figure>
<p>等同于<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br></pre></td></tr></table></figure></p>
<p>在ARC环境中<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="comment">/*ARC*/</span></span><br><span class="line">  <span class="keyword">id</span> __<span class="keyword">strong</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当超出变量作用域时, ARC在编译期会自动添加release操作, 以达到和非ARC一致的目的<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">&#123;/*non-ARC*/</span><br><span class="line">  id obj = <span class="collection">[<span class="collection">[NSObject alloc]</span> init]</span><span class="comment">;</span></span><br><span class="line">  <span class="collection">[obj release]</span><span class="comment">; </span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Assigning_to___strong_ownership_qualified_variables_—_赋值情况">Assigning to __strong ownership qualified variables — 赋值情况</h4><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  /<span class="keyword">*</span> 持有一个非自己创建的obj <span class="keyword">*</span>/</span><br><span class="line">  id __strong obj = [NSMutableArray array];</span><br><span class="line">&#125; /<span class="keyword">*</span> 超出作用域, 变量不再使用,  自动添加release<span class="keyword">*</span>/</span><br><span class="line">/<span class="keyword">*</span>obj被自动释放<span class="keyword">*</span>/</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj0 = [[<span class="built_in">NSObject</span> alloc] init]; <span class="comment">//objA</span></span><br><span class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj1 = [[<span class="built_in">NSObject</span> alloc] init]; <span class="comment">//objB</span></span><br><span class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj2 = <span class="literal">nil</span>;</span><br><span class="line">obj0 = obj1;  <span class="comment">//objA 不再有人持有,自动添加release, objB引用计数+1</span></span><br><span class="line">obj2 = obj0;  <span class="comment">//objB 引用计数+1</span></span><br><span class="line"></span><br><span class="line">obj1 = <span class="literal">nil</span>;   <span class="comment">//objB引用计数-1</span></span><br><span class="line">obj0 = <span class="literal">nil</span>;   <span class="comment">//objB引用计数-1</span></span><br><span class="line">obj2 = <span class="literal">nil</span>;   <span class="comment">//objB引用计数-1 当前计数为0 调用dealloc</span></span><br></pre></td></tr></table></figure>
<p>ownership is properly managed not only by variable scope, but also by assignments between variables, which are qualified with <strong>strong. Of course, a </strong>strong qualifier can be used as a member variable of Objective-C class or any argument of methods.<br>持有关系,不仅可以通过作用域来自动判定, 也可以通过给strong类型的变量赋值来自动判定</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Test</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">id</span> __<span class="keyword">strong</span> obj_;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span> __<span class="keyword">strong</span>)obj; </span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Test</span> - (<span class="title">id</span>)<span class="title">init</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span> __<span class="keyword">strong</span>)obj&#123;</span><br><span class="line">  obj_ = obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="atom">id</span> <span class="name">__strong</span> <span class="atom">test</span> = [[<span class="name">Test</span> <span class="atom">alloc</span>] <span class="atom">init</span>];</span><br><span class="line">  <span class="comment">/*test 持有Test obj*/</span></span><br><span class="line"></span><br><span class="line">  [<span class="atom">test</span> <span class="atom">setObject</span>:[[<span class="name">NSObject</span> <span class="atom">alloc</span>] <span class="atom">init</span>]]; </span><br><span class="line">  <span class="comment">/*test的属性obj_持有Object*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*超出作用域, 因为test不再被使用, 自动添加release, test调用release释放Test obj, 因为obj_也讲被销毁 其所持有的Object也会调用release方法 */</span></span><br><span class="line"><span class="comment">/* 变量自动释放完毕*/</span></span><br></pre></td></tr></table></figure>
<h4 id="__weak_ownership_qualifier">__weak ownership qualifier</h4><p>避免循环引用.<br>循环引用的案例: 两个对象同时持有对方, 或者一个对象持有自身.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br></pre></td></tr></table></figure>
<p>变量在赋值后, 马上自动释放,因为没有任何变量, 持有新生成的obj.</p>
<h4 id="Weak_Reference_Disappears">Weak Reference Disappears</h4><p>当weak变量所指向的变量被释放时, 此weak变量自动指向nil.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> obj1 = <span class="literal">nil</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">id</span> __<span class="keyword">strong</span> obj0 = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">  obj1 = obj0;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"A: %@"</span>, obj1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"B: %@"</span>, obj1); <span class="comment">// (null)</span></span><br></pre></td></tr></table></figure>
<h4 id="__unsafe_unretained_ownership_qualifier">__unsafe_unretained ownership qualifier</h4><p><code>__unsafe_unretained</code> 和<code>__weak</code>相似不持有对象.但是当此标示符的变量指向的对象被释放后, 系统不会自动设置该变量为nil.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> __unsafe_unretained obj1 = <span class="literal">nil</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">id</span> __<span class="keyword">strong</span> obj0 = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">  obj1 = obj0;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"A: %@"</span>, obj1);    <span class="comment">//&lt;NSObject: 0x753e180&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"B: %@"</span>, obj1);      <span class="comment">//&lt;NSObject: 0x753e180&gt;</span></span><br><span class="line"><span class="comment">/* 此处输出的其实乱指针,因为 生成的对象已经被释放, 但是猜测,由于目前还没有回收该内存, 只是做了标记, 所以暂时指向的地址还是正确的.*/</span></span><br></pre></td></tr></table></figure>
<p>此标示符不建议使用, 除非是为了在ios4等低版本系统中, 为了替换<code>__weak</code>.</p>
<h4 id="__autoreleasing_ownership_qualifier">__autoreleasing ownership qualifier</h4><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* non-ARC */</span></span><br><span class="line"><span class="name">NSAutoreleasePool</span> *<span class="atom">pool</span> = [[<span class="name">NSAutoreleasePool</span> <span class="atom">alloc</span>] <span class="atom">init</span>];</span><br><span class="line"><span class="atom">id</span> <span class="atom">obj</span> = [[<span class="name">NSObject</span> <span class="atom">alloc</span>] <span class="atom">init</span>];</span><br><span class="line">[<span class="atom">obj</span> <span class="atom">autorelease</span>];</span><br><span class="line">[<span class="atom">pool</span> <span class="atom">drain</span>];</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ARC */</span></span><br><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">  <span class="keyword">id</span> __autoreleasing obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>__autoreleasing</code>标示符,相当于非ARC环境下调用<code>autorelease</code><br>但是实际中, 只有非常罕见的情况下才需要设置此标示符.下面解释为什么不需要设置</p>
<h5 id="Compiler_Cares___autoreleasing_Automatically">Compiler Cares __autoreleasing Automatically</h5><p>To obtain an object without creation, you use some methods not in the alloc/new/copy/mutableCopy method group. In this case, the object is automatically registered to the autoreleasepool. It is same as obtaining an autoreleased object. When an object is returned from a method, the compiler checks if the method begins with alloc/new/copy/mutableCopy, and if not, the returned object is automatically registered to the autorelease pool. Exceptionally, any method whose name begins with init, doesn’t register the return value to autoreleasepool. Please see below for more about this new rule: the naming rule for methods related to object creation must be followed<br>当不是使用alloc/new/copy/mutableCopy之外方法, 来获得的对象时, 系统自动将该对象注册到autoreleasepool中,<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line"></span><br><span class="line">  id __strong obj = [<span class="type">NSMutableArray</span> <span class="type">array</span>];</span><br><span class="line">  /*</span><br><span class="line">  * <span class="type">The</span> variable obj <span class="keyword">is</span> qualified <span class="keyword">with</span> __strong.</span><br><span class="line">  * <span class="type">Which</span> means, it has ownership <span class="keyword">of</span> the <span class="keyword">object</span>.</span><br><span class="line">  * <span class="type">And</span> the <span class="keyword">object</span> <span class="keyword">is</span> registered <span class="keyword">in</span> autoreleasepool,</span><br><span class="line">  * because the compiler decides it by checking the <span class="keyword">method</span> name. </span><br><span class="line">  */</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">* <span class="type">Leaving</span> the scope <span class="keyword">of</span> variable obj, its strong reference disappears.</span><br><span class="line">* <span class="type">The</span> <span class="keyword">object</span> <span class="keyword">is</span> released automatically. *</span><br><span class="line">* <span class="type">Leaving</span> @autoreleasepool <span class="keyword">block</span>,</span><br><span class="line">* all the objects registered <span class="keyword">in</span> the autoreleasepool are released automatically. *</span><br><span class="line">* <span class="type">The</span> <span class="keyword">object</span> <span class="keyword">is</span> discarded because no one has ownership.</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+<span class="function"> (</span>id<span class="function">)</span><span class="instruction"> array </span>&#123;</span><br><span class="line">  id obj = <span class="keyword">[</span><span class="keyword">[</span>NSMutableArray alloc] init];</span><br><span class="line"> <span class="instruction"> return </span>obj; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“id obj” does not have a qualifier. So it is qualified with __strong. When the “return” sentence is executed, the variable scope is left and the strong reference disappears. Therefore the object will be released automatically. Before that, if the compiler detects that the object will be passed to the caller, the object is registered in autoreleasepool</p>
<p>When a variable with a <code>__weak</code> qualifier is used, <strong><em>the object is always registered in autoreleasepool</em></strong><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> obj1 = obj0; </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"class=%@"</span>, [obj1 class]);</span><br></pre></td></tr></table></figure></p>
<p>等同下面<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> obj1 = obj0;</span><br><span class="line"><span class="keyword">id</span> __autoreleasing tmp = obj1; </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"class=%@"</span>, [tmp class]);</span><br></pre></td></tr></table></figure></p>
<p>weak修饰的变量, 因为不持有对象, 为了安全的释放, weak对象自动注册到autoreleasepool中.</p>
<h4 id="weak对象的调用">weak对象的调用</h4><p>通过编译代码可以看出, 获取一个weak变量指向的对象, 需要调用<code>objc_loadWeak</code>方法,<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id objc_loadWeak(id *<span class="class"><span class="keyword">object</span>) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> objc_autorelease(objc_loadWeakRetained(<span class="class"><span class="keyword">object</span>));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">[weakObject doSomething]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>ARC转换为:<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">Object</span> *<span class="keyword">strongObject </span>= objc_autorelease(objc_loadWeakRetained(weakObject))<span class="comment">;</span></span><br><span class="line">[<span class="keyword">strongObject </span>doSomething]<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="__autoreleasing_默认修饰符">__autoreleasing 默认修饰符</h4><p><code>id *obj</code>             &lt;==&gt;  <code>id __autoreleasing *obj</code><br><code>NSObject **obj</code>      &lt;==&gt;  <code>NSObject * __autoreleasing *obj</code><br>Any pointers to ‘id’ or object types are qualified with __autoreleasing as default.</p>
<h4 id="Returning_a_Result_as_the_Argument">Returning a Result as the Argument</h4><p>NSError作为参数, 返回结果时. 满足非通过alloc/new/copy/mutableCopy生成的对象, 不持有该对象原则.所以此对象需要自动注册到autoreleasepoool中, 来进行自动释放.<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>) performOperationWithError:(<span class="built_in">NSError</span> * __autoreleasing *)error &#123;</span><br><span class="line">  <span class="comment">/* Error occurred. Set errorCode */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NO</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>By assigning to <em>error, which is NSError </em> __autoreleasing * type, an object can be passed to its caller after being registered in autoreleasepool.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *error = <span class="literal">nil</span>;       <span class="comment">//strong</span></span><br><span class="line"><span class="built_in">NSError</span> **pError = &amp;error;  <span class="comment">//weak   编译报错,不能将strong对象 赋值给weak</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">NSError</span> * __<span class="keyword">strong</span> *pError = &amp;error;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSError</span> __<span class="keyword">weak</span> *error = <span class="literal">nil</span>; </span><br><span class="line"><span class="built_in">NSError</span> * __<span class="keyword">weak</span> *pError = &amp;error;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSError</span> __unsafe_unretained *unsafeError = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">NSError</span> * __unsafe_unretained *pUnsafeError = &amp;unsafeError;</span><br></pre></td></tr></table></figure>
<p>NSRunLoop has autoreleasepool to release all the objects once in each loop.<br><code>_objc_autoreleasePoolPrint();</code>打印注册的所有对象</p>
<h4 id="Rules">Rules</h4><ul>
<li>Forget about using retain, release, retainCount, and autorelease.</li>
<li>Forget about using NSAllocateObject and NSDeallocateObject.</li>
<li>Follow the naming rule for methods related to object creation. (alloc/new/copy/mutablecopy/init)</li>
<li>Forget about calling dealloc explicitly.</li>
<li>Use @autoreleasepool instead of NSAutoreleasePool.</li>
<li>Forget about using Zone (NSZone).</li>
<li>Object type variables can’t be members of struct or union in C language.</li>
<li>‘id’ and ‘void*’ have to be cast explicitly.</li>
</ul>
<p>in many cases, dealloc is a suitable place to remove the object from delegate or observers.<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (void) <span class="tag">dealloc</span> &#123;</span><br><span class="line">  <span class="comment">/*</span><br><span class="line">  - Write here to be disposed of properly.</span><br><span class="line">  */</span></span><br><span class="line">  <span class="attr_selector">[[NSNotificationCenter defaultCenter]</span> <span class="tag">removeObserver</span><span class="pseudo">:self</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ARC环境下不需显示调用<code>[super dealloc]</code>了.</p>
<h4 id="Object_Type_Variables_Cannot_Be_Members_of_struct_or_union_in_C_Language">Object Type Variables Cannot Be Members of struct or union in C Language</h4><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">  NSMutableArray *array;   <span class="comment">//error</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为ARC环境下, 编译器需要掌握对象的生命周期, 来进行内存管理,但是C结构体, 没有这些信息,没有被ARC所覆盖.可以通过<code>__unsafe_unretained</code>修饰符暂时停止该对象的ARC管理来解决<br><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">  NSMutableArray __unsafe_unretained *array; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="‘id’_and_‘void*’_Have_to_Be_Cast_Explicitly">‘id’ and ‘void*’ Have to Be Cast Explicitly</h4><h5 id="__bridge_cast">__bridge cast</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init]; </span><br><span class="line"><span class="keyword">void</span> *p = (__bridge <span class="keyword">void</span> *)obj;    <span class="comment">//more dangerous than an __unsafe_unretained, 需要手动管理内存</span></span><br><span class="line"><span class="keyword">id</span> o = (__bridge <span class="keyword">id</span>)p;</span><br></pre></td></tr></table></figure>
<h5 id="__bridge_retained_cast">__bridge_retained cast</h5><p>__bridge_retained cast works as if the assigned variable has ownership of the object.<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="keyword">void</span> *p = (__bridge_retained <span class="keyword">void</span> *)obj;</span><br></pre></td></tr></table></figure></p>
<p>__bridge_retained的名称是因为, (void *)为C语言实现,不再ARC的管理范围, 所以该次赋值, 需要将对象的计数器+1, 以实现转换后的变量, 对此对象的持有操作.</p>
<p>Non ARC<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="keyword">void</span> *p = obj; </span><br><span class="line">[(<span class="keyword">id</span>)p retain];</span><br></pre></td></tr></table></figure></p>
<p>在非ARC环境下, 变量在转换后, 需要执行retain操作.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p = <span class="number">0</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">  p = (__bridge_retained <span class="keyword">void</span> *)obj; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"class=%@"</span>, [(__bridge <span class="keyword">id</span>)p class]);</span><br></pre></td></tr></table></figure>
<p>obj在离开作用域后, 由于不再使用,自动调用release释放, 而此时由于p仍然持有对象, 所以对象没有被销毁.</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span> non-ARC <span class="keyword">*</span>/ void <span class="keyword">*</span>p = 0;</span><br><span class="line">&#123;</span><br><span class="line">  id obj = [[NSObject alloc] init];    /<span class="keyword">*</span> [obj retainCount] -&gt; 1 <span class="keyword">*</span>/</span><br><span class="line">  p = [obj retain];                    /<span class="keyword">*</span> [obj retainCount] -&gt; 2 <span class="keyword">*</span>/</span><br><span class="line">  [obj release];                       /<span class="keyword">*</span> [obj retainCount] -&gt; 1 <span class="keyword">*</span>/</span><br><span class="line">&#125;</span><br><span class="line">NSLog(<span class="comment">@"class=%@", [(__bridge id)p class]);</span></span><br></pre></td></tr></table></figure>
<h4 id="__bridge_transfer_cast">__bridge_transfer cast</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="property">id</span> obj = (__bridge_transfer <span class="property">id</span>)p;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* non-ARC */</span></span><br><span class="line"><span class="keyword">id</span> obj = (<span class="keyword">id</span>)p; </span><br><span class="line">[obj retain]; </span><br><span class="line">[(<span class="keyword">id</span>)p release];</span><br></pre></td></tr></table></figure>
<p>As <code>__bridge_retained</code> cast is replaced with <code>retain</code>, <code>__bridge_transfer</code> cast is replaced with <code>release</code>. </p>
<p>The variable obj is retained because it is qualified with __strong. With these two casts, you can create, own, and release any objects without using ‘id’ or object type variables. But it is not recommended</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p = (__bridge_retained <span class="keyword">void</span> *)[[<span class="built_in">NSObject</span> alloc] init]; </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"class=%@"</span>, [(__bridge <span class="keyword">id</span>)p class]); </span><br><span class="line">(<span class="keyword">void</span>)(__bridge_transfer <span class="keyword">id</span>)p;</span><br></pre></td></tr></table></figure>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* non-ARC */</span></span><br><span class="line"><span class="atom">id</span> <span class="atom">p</span> = [[<span class="name">NSObject</span> <span class="atom">alloc</span>] <span class="atom">init</span>];</span><br><span class="line"><span class="name">NSLog</span>(@<span class="string">"class=%@"</span>, [<span class="atom">p</span> <span class="atom">class</span>]);</span><br><span class="line">[<span class="atom">p</span> <span class="atom">release</span>];</span><br></pre></td></tr></table></figure>
<h4 id="CoreFoundation_Object_&amp;&amp;_Objective-C_Object">CoreFoundation Object &amp;&amp; Objective-C Object</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFTypeRef</span> <span class="built_in">CFBridgingRetain</span>(<span class="keyword">id</span> X) &#123;</span><br><span class="line">  <span class="keyword">return</span> (__bridge_retained <span class="built_in">CFTypeRef</span>)X; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">CFBridgingRelease</span>(<span class="built_in">CFTypeRef</span> X) &#123;</span><br><span class="line">  <span class="keyword">return</span> (__bridge_transfer <span class="keyword">id</span>)X; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CFBridgingRetain_function">CFBridgingRetain function</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFMutableArrayRef</span> cfObject = <span class="literal">NULL</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">id</span> obj = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">  cfObject = <span class="built_in">CFBridgingRetain</span>(obj);</span><br><span class="line">  <span class="built_in">CFShow</span>(cfObject);</span><br><span class="line">  printf(<span class="string">"retain count = %d\n"</span>, <span class="built_in">CFGetRetainCount</span>(cfObject));</span><br><span class="line">&#125;</span><br><span class="line">printf(<span class="string">"retain count after the scope = %d\n"</span>, <span class="built_in">CFGetRetainCount</span>(cfObject)); </span><br><span class="line"><span class="built_in">CFRelease</span>(cfObject);</span><br></pre></td></tr></table></figure>
<p>换成<code>__bridge</code>会造成空指针</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFMutableArrayRef</span> cfObject = <span class="literal">NULL</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">id</span> obj = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">  <span class="comment">/*variable obj has a strong reference to the object */</span></span><br><span class="line"></span><br><span class="line">  cfObject = (__bridge <span class="built_in">CFMutableArrayRef</span>)obj; </span><br><span class="line">  <span class="built_in">CFShow</span>(cfObject);</span><br><span class="line">  printf(<span class="string">"retain count = %d\n"</span>, <span class="built_in">CFGetRetainCount</span>(cfObject));</span><br><span class="line">  <span class="comment">/*</span><br><span class="line">   * __bridge cast does not touch ownership status.</span><br><span class="line">   * Reference count is one because of variable obj's strong reference.</span><br><span class="line">   */</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * Leaving the scope of variable obj, its strong reference disappears.</span><br><span class="line"> * The object is released automatically.</span><br><span class="line"> * Because no one has ownership, the object is discarded. </span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* From here, any access to the object is invalid! (dangling pointer) */</span></span><br><span class="line">printf(<span class="string">"retain count after the scope = %d\n"</span>, <span class="built_in">CFGetRetainCount</span>(cfObject)); </span><br><span class="line"><span class="built_in">CFRelease</span>(cfObject);</span><br></pre></td></tr></table></figure>
<h4 id="CFBridgingRelease_function">CFBridgingRelease function</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  CFMutableArrayRef cfObject =</span><br><span class="line">      CFArrayCreateMutable(kCFAllocatorDefault, <span class="number">0</span>, NULL);</span><br><span class="line">  printf(<span class="string">"retain count = %d\n"</span>, CFGetRetainCount(cfObject));</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">   * The object <span class="keyword">is</span> created <span class="keyword">with</span> ownership <span class="keyword">by</span> Core Foundation Framework API. </span><br><span class="line">   * The retain <span class="command">count</span> <span class="keyword">is</span> one.</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">  <span class="property">id</span> obj = CFBridgingRelease(cfObject);</span><br><span class="line">  /*</span><br><span class="line">  * By assignment <span class="keyword">after</span> CFBridgingRelease,</span><br><span class="line">  * variable obj has a strong <span class="keyword">reference</span> <span class="keyword">and</span> <span class="keyword">then</span> * <span class="keyword">the</span> object <span class="keyword">is</span> released <span class="keyword">by</span> CFRelease.</span><br><span class="line">  */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  printf(<span class="string">"retain count after the cast = %d\n"</span>, CFGetRetainCount(cfObject));</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">  * Only <span class="keyword">the</span> variable obj has a strong <span class="keyword">reference</span> <span class="keyword">to</span></span><br><span class="line">  * <span class="keyword">the</span> object, so <span class="keyword">the</span> retain <span class="command">count</span> <span class="keyword">is</span> one. *</span><br><span class="line">  * And, <span class="keyword">after</span> being cast <span class="keyword">by</span> CFBridgingRelease,</span><br><span class="line">  * pointer stored <span class="keyword">in</span> variable cfObject <span class="keyword">is</span> still valid. </span><br><span class="line">  */</span><br><span class="line"></span><br><span class="line">  NSLog(@<span class="string">"class=%@"</span>, obj);</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">* Leaving <span class="keyword">the</span> scope <span class="keyword">of</span> variable obj, <span class="keyword">its</span> strong <span class="keyword">reference</span> disappears.</span><br><span class="line">* The object <span class="keyword">is</span> released automatically.</span><br><span class="line">* Because no one has ownership, <span class="keyword">the</span> object <span class="keyword">is</span> discarded. </span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>如果换成<code>__bridge</code>会造成内存泄露</p>
<h4 id="Property">Property</h4><table>
<thead>
<tr>
<th>Property modifier</th>
<th>Ownership qualifier</th>
</tr>
</thead>
<tbody>
<tr>
<td>assign</td>
<td>__unsafe_unretained</td>
</tr>
<tr>
<td>copy</td>
<td>__strong (note: new copied object is assigned.)</td>
</tr>
<tr>
<td>retain</td>
<td>__strong</td>
</tr>
<tr>
<td>strong</td>
<td>__strong</td>
</tr>
<tr>
<td>unsafe_unretained</td>
<td>__unsafe_unretained</td>
</tr>
<tr>
<td>weak</td>
<td>__weak</td>
</tr>
</tbody>
</table>
<h4 id="Array">Array</h4><p>By the way, any variables qualified with <strong>strong, </strong>weak, or <strong>autoreleasing other than </strong>unsafe_unretained, are initialized with nil.<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">&#123;</span><br><span class="line">  id objs<span class="collection">[<span class="number">2</span>]</span><span class="comment">;</span></span><br><span class="line">  objs<span class="collection">[<span class="number">0</span>]</span> = <span class="collection">[<span class="collection">[NSObject alloc]</span> init]</span><span class="comment">;</span></span><br><span class="line">  objs<span class="collection">[<span class="number">1</span>]</span> = <span class="collection">[NSMutableArray array]</span><span class="comment">; </span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>When the control flow leaves the scope of the array, all the variables that have strong references in the array disappear. The assigned objects are released automatically. It is identical to variables not in arrays</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSObject * __strong *array = nil;<span class="instruction"></span><br><span class="line">array </span>=<span class="function"> (</span>id __strong<span class="function"> *)calloc(</span>entries,<span class="function"> sizeof(</span>id<span class="function">)</span><span class="function">)</span>;</span><br><span class="line"></span><br><span class="line">//or<span class="instruction"></span><br><span class="line">array </span>=<span class="function"> (</span>id __strong<span class="function"> *)malloc(</span>entries *<span class="function"> sizeof(</span>id<span class="function">)</span><span class="function">)</span>; </span><br><span class="line">memset(array, 0, entries *<span class="function"> sizeof(</span>id<span class="function">)</span><span class="function">)</span>;</span><br></pre></td></tr></table></figure>
<p>C语音创建的数组需要手动释放<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (NSUInteger i = <span class="number">0</span>; i &lt; entries; ++i)&#123;</span><br><span class="line">  <span class="built_in">array</span>[i] = nil; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(<span class="built_in">array</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="ARC_Implementation">ARC Implementation</h3><blockquote>
<p>Automatic Reference Counting (ARC) in Objective-C makes memory management the job of the compiler</p>
</blockquote>
<p>but the truth is, ARC isn’t the only job of the compiler. The objective-C runtime needs to help as well</p>
<h4 id="__strong_ownership_qualifier">__strong ownership qualifier</h4><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">&#123;</span><br><span class="line">  id __strong obj = <span class="collection">[<span class="collection">[NSObject alloc]</span> init]</span><span class="comment">;</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>pseudo code by the compiler<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id obj = objc_msgSend<span class="list">(<span class="keyword">NSObject</span>, @selector<span class="list">(<span class="keyword">alloc</span>)</span>)</span><span class="comment">; </span></span><br><span class="line">objc_msgSend<span class="list">(<span class="keyword">obj</span>, @selector<span class="list">(<span class="keyword">init</span>)</span>)</span><span class="comment">; </span></span><br><span class="line">objc_release<span class="list">(<span class="keyword">obj</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Calling_the_array_method">Calling the array method</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">id</span> __<span class="keyword">strong</span> obj = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pseudo code by the compiler<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id obj = objc_msgSend<span class="list">(<span class="keyword">NSMutableArray</span>, @selector<span class="list">(<span class="keyword">array</span>)</span>)</span><span class="comment">; objc_retainAutoreleasedReturnValue(obj); </span></span><br><span class="line">objc_release<span class="list">(<span class="keyword">obj</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p><code>objc_retainAutoreleasedReturnValue</code> function is for performance optimization. It is inserted because the NSMutableArray class method array is not in the alloc/new/copy/mutableCopy method group. The compiler inserts this function every time just after the invocation of a method if the method is not in the group. As the name suggests, it retains an object returned from a method or function <strong><em>after the object is added in autorelease pool</em></strong>.</p>
<h4 id="Inside_the_array_Method">Inside the array Method</h4><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+<span class="function"> (</span>id<span class="function">)</span><span class="instruction"> array </span>&#123;</span><br><span class="line"> <span class="instruction"> return </span><span class="keyword">[</span><span class="keyword">[</span>NSMutableArray alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pseudo code<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+<span class="function"> (</span>id<span class="function">)</span><span class="instruction"> array </span>&#123;</span><br><span class="line">  id obj =<span class="function"> objc_msgSend(</span>NSMutableArray,<span class="function"> @selector(</span>alloc<span class="function">)</span><span class="function">)</span>; </span><br><span class="line"> <span class="function"> objc_msgSend(</span>obj,<span class="function"> @selector(</span>init<span class="function">)</span><span class="function">)</span>;</span><br><span class="line"> <span class="instruction"> return </span>objc_autoreleaseReturnValue(obj<span class="function">)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>in reality, <code>objc_autoreleaseReturnValue</code> doesn’t register it to autorelease pool all the time. 如果之前的代码已经调用了<code>objc_retainAutoreleasedReturnValue</code>,该函数将不再调用,因为此对象已经注册到pool中.</p>
<h4 id="__weak_ownership_qualifier-1">__weak ownership qualifier</h4><p>weak特性:</p>
<ul>
<li><strong>Nil</strong> is assigned to any variables qualified with __weak when referencing object is discarded.</li>
<li>When an object is accessed through a <strong>__weak</strong> qualified variable, the object is <strong><em>added to the autorelease pool</em></strong>.</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> obj1 = obj; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pseudo code<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id obj1<span class="comment">;</span></span><br><span class="line">objc_initWeak<span class="list">(<span class="keyword">&amp;obj1</span>, obj)</span><span class="comment">; </span></span><br><span class="line">objc_destroyWeak<span class="list">(<span class="keyword">&amp;obj1</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p><code>objc_initWeak</code> 实现</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj1 = 0<span class="comment">; </span></span><br><span class="line">objc_storeWeak(&amp;obj1, obj)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><code>objc_destroyWeak</code></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id obj1<span class="comment">;</span></span><br><span class="line">obj1 = 0<span class="comment">;</span></span><br><span class="line">objc_storeWeak(&amp;obj1, obj)<span class="comment">; </span></span><br><span class="line">objc_storeWeak(&amp;obj1, 0)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>objc_storeWeak function registers a <code>key-value</code> to a <code>table</code>, called a <code>weak table</code>. The key is the second argument, the address of the object to be assigned. The value is the first argument, the address of a variable that qualified with __weak. <strong>If the second argument is zero, the entry is removed from the table.</strong></p>
<p>The weak table is implemented as a hash table as a reference count table (see Chapter 1, Section “The Implementation by Apple”). With that, variables qualified with <strong>weak can be searched from a disposing object with reasonable performance. When the function is called with the same object for key, multiple </strong>weak qualified variables will be registered for the same object.</p>
<h4 id="Looking_Under_the_Hood_When_an_Object_Is_Discarded_对象销毁">Looking Under the Hood When an Object Is Discarded 对象销毁</h4><p>对象销毁流程</p>
<ol>
<li>objc_release.</li>
<li>dealloc is called because retain count becomes zero</li>
<li>_objc_rootDealloc</li>
<li>object_dispose</li>
<li>objc_destructInstance</li>
<li>objc_clear_deallocating</li>
</ol>
<p>objc_clear_deallocating 作用</p>
<ol>
<li>From the weak table, get an entry of which the key is the object to be discarded.</li>
<li>Set nil to all the __weak ownership qualified variables in the entry</li>
<li>Remove the entry from the table</li>
<li>For the object to be disposed of, remove its key from the reference table</li>
</ol>
<h4 id="Assigning_a_Newly_Created_Object">Assigning a Newly Created Object</h4><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">&#123;</span><br><span class="line">  id __weak obj = <span class="collection">[<span class="collection">[NSObject alloc]</span> init]</span><span class="comment">;</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>pseudo code<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">id obj<span class="comment">;</span></span><br><span class="line">id tmp = objc_msgSend<span class="list">(<span class="keyword">NSObject</span>, @selector<span class="list">(<span class="keyword">alloc</span>)</span>)</span><span class="comment">; </span></span><br><span class="line">objc_msgSend<span class="list">(<span class="keyword">tmp</span>, @selector<span class="list">(<span class="keyword">init</span>)</span>)</span><span class="comment">; </span></span><br><span class="line">objc_initWeak<span class="list">(<span class="keyword">&amp;obj</span>, tmp)</span><span class="comment">;</span></span><br><span class="line">objc_release<span class="list">(<span class="keyword">tmp</span>)</span><span class="comment">;</span></span><br><span class="line">objc_destroyWeak<span class="list">(<span class="keyword">&amp;object</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Immediate_Disposal_of_Objects">Immediate Disposal of Objects</h4><p>声明后马上释放的对象, 不影响方法的调用<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">void</span>)</span><span class="collection">[<span class="collection">[<span class="collection">[NSObject alloc]</span> init]</span> hash]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id tmp = objc_msgSend<span class="list">(<span class="keyword">NSObject</span>, @selector<span class="list">(<span class="keyword">alloc</span>)</span>)</span><span class="comment">; </span></span><br><span class="line">objc_msgSend<span class="list">(<span class="keyword">tmp</span>, @selector<span class="list">(<span class="keyword">init</span>)</span>)</span><span class="comment">; </span></span><br><span class="line">objc_msgSend<span class="list">(<span class="keyword">tmp</span>, @selector<span class="list">(<span class="keyword">hash</span>)</span>)</span><span class="comment">; </span></span><br><span class="line">objc_release<span class="list">(<span class="keyword">tmp</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h4 id="Adding_to_autorelease_pool_Automatically">Adding to autorelease pool Automatically</h4><p>when an object is accessed through a __weak qualified variable, the object has been added to the autorelease pool.<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">id</span> __<span class="keyword">weak</span> obj1 = obj;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, obj1); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>pseudo code by the compiler<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">id obj1<span class="comment">;</span></span><br><span class="line">objc_initWeak<span class="list">(<span class="keyword">&amp;obj1</span>, obj)</span><span class="comment">;</span></span><br><span class="line">id tmp = objc_loadWeakRetained<span class="list">(<span class="keyword">&amp;obj1</span>)</span><span class="comment">; </span></span><br><span class="line">objc_autorelease<span class="list">(<span class="keyword">tmp</span>)</span><span class="comment">;</span></span><br><span class="line">NSLog<span class="list">(@<span class="string">"%@"</span>, tmp)</span><span class="comment">; </span></span><br><span class="line">objc_destroyWeak<span class="list">(<span class="keyword">&amp;obj1</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p><code>objc_loadWeakRetained</code> and <code>objc_autorelease</code> function calls are newly inserted.</p>
<ul>
<li>objc_loadWeakRetained function retains the object referenced by the variable qualified with __weak</li>
<li>objc_autorelease function adds the object to the autorelease pool.<br>(自我猜测) </li>
</ul>
<ol>
<li>weak只是一个标示, 不能针对weak的变量直接进行方法调用</li>
<li>基于线程安全的考虑, 在weak变量在调用方法时, 先将对象retain, 以保证对象不被其他线程释放.</li>
</ol>
<h4 id="weak变量使用优化">weak变量使用优化</h4><p><strong><em>由于weak对象每次调用都需要注册到autoreleasepool中, 如果此类变量太多会加重pool的负担, 所以在使用时,应将weak变量, 重新赋值到一个strong变量中来操作</em></strong><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> o = obj; </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"1 %@"</span>, o); </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"2 %@"</span>, o);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"3 %@"</span>, o); </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"4 %@"</span>, o); </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"5 %@"</span>, o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="不支持weak的情况">不支持weak的情况</h4><p>第一种旧系统不支持, 第二种情况某些类由于重写了retain/release, 并拥有独立的引用计数机制.这些类有<code>objc_arc_weak_reference_unavailable</code>标示.</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- <span class="list">(<span class="keyword">BOOL</span>)</span>allowsWeakReference<span class="comment">; </span></span><br><span class="line">- <span class="list">(<span class="keyword">BOOL</span>)</span>retainWeakReference<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyObject</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">  <span class="built_in">NSUInteger</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyObject</span> - (<span class="title">id</span>)<span class="title">init</span> </span>&#123;</span><br><span class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">BOOL</span>)retainWeakReference &#123;</span><br><span class="line">    <span class="keyword">if</span> (++count &gt; <span class="number">3</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> retainWeakReference];</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj = [[MyObject alloc] init];</span><br><span class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> o = obj;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"1 %@"</span>, o);   <span class="comment">// &lt;MyObject: 0x753e180&gt;</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"2 %@"</span>, o);   <span class="comment">// &lt;MyObject: 0x753e180&gt;</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"3 %@"</span>, o);   <span class="comment">// &lt;MyObject: 0x753e180&gt;</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"4 %@"</span>, o);   <span class="comment">// (null)</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"5 %@"</span>, o);   <span class="comment">// (null)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="__autoreleasing_ownership_qualifier-1">__autoreleasing ownership qualifier</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"><span class="keyword">id</span> __autoreleasing obj = [[<span class="built_in">NSObject</span> alloc] init]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* pseudo code by the compiler */</span><br><span class="line">id pool = objc_autoreleasePoolPush<span class="list">()</span><span class="comment">;</span></span><br><span class="line">id obj = objc_msgSend<span class="list">(<span class="keyword">NSObject</span>, @selector<span class="list">(<span class="keyword">alloc</span>)</span>)</span><span class="comment">; </span></span><br><span class="line">objc_msgSend<span class="list">(<span class="keyword">obj</span>, @selector<span class="list">(<span class="keyword">init</span>)</span>)</span><span class="comment">; </span></span><br><span class="line">objc_autorelease<span class="list">(<span class="keyword">obj</span>)</span><span class="comment">; </span></span><br><span class="line">objc_autoreleasePoolPop<span class="list">(<span class="keyword">pool</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>非持有变量<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">  <span class="keyword">id</span> __autoreleasing obj = [<span class="built_in">NSMutableArray</span> array]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* pseudo code by the compiler */</span><br><span class="line">id pool = objc_autoreleasePoolPush<span class="list">()</span><span class="comment">;</span></span><br><span class="line">id obj = objc_msgSend<span class="list">(<span class="keyword">NSMutableArray</span>, @selector<span class="list">(<span class="keyword">array</span>)</span>)</span><span class="comment">; objc_retainAutoreleasedReturnValue(obj); </span></span><br><span class="line">objc_autorelease<span class="list">(<span class="keyword">obj</span>)</span><span class="comment">;</span></span><br><span class="line">objc_autoreleasePoolPop<span class="list">(<span class="keyword">pool</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h4 id="__unsafe_unretained_ownership_qualifier-1">__unsafe_unretained ownership qualifier</h4><p> Unlike the other ownership qualifiers, the compiler does nothing special for the qualifier. It just works as an assignment in C language. ARC不对其进行操作优化.</p>
<h4 id="Reference_Count">Reference Count</h4><p>可以通过<code>_objc_rootRetainCount</code> 来获取当前计数<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">&#123;</span><br><span class="line">id __strong obj = <span class="collection">[<span class="collection">[NSObject alloc]</span> init]</span><span class="comment">;</span></span><br><span class="line">NSLog<span class="list">(@<span class="string">"retain count = %d"</span>, _objc_rootRetainCount<span class="list">(<span class="keyword">obj</span>)</span>)</span><span class="comment">; </span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> o = obj;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"retain count = %d"</span>, _objc_rootRetainCount(obj));  <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">  <span class="keyword">id</span> __<span class="keyword">strong</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">  <span class="keyword">id</span> __autoreleasing o = obj;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"retain count = %d"</span>, _objc_rootRetainCount(obj));  <span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">&#123;</span><br><span class="line">id __strong obj = <span class="collection">[<span class="collection">[NSObject alloc]</span> init]</span><span class="comment">; </span></span><br><span class="line">@autoreleasepool <span class="collection">&#123;</span><br><span class="line">  id __autoreleasing o = obj;</span><br><span class="line">  NSLog<span class="list">(@<span class="string">"retain count = %d in @autoreleasepool"</span>, _objc_rootRetainCount<span class="list">(<span class="keyword">obj</span>)</span>)</span><span class="comment">; //2</span></span><br><span class="line">&#125;</span></span><br><span class="line">  NSLog<span class="list">(@<span class="string">"retain count = %d"</span>, _objc_rootRetainCount<span class="list">(<span class="keyword">obj</span>)</span>)</span><span class="comment">; //1</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">_objc_autoreleasePoolPrint();</span><br><span class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> o = obj;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"before using __weak: retain count = %d"</span>, _objc_rootRetainCount(obj)); <span class="built_in">NSLog</span>(<span class="string">@"class = %@"</span>, [o class]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"after using __weak: retain count = %d"</span>, _objc_rootRetainCount(obj)); _objc_autoreleasePoolPrint();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/mrc-arc/"> #mrc arc </a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/06/16/Valar-Morghulis-Valar-Dohaeris/">Valar Morghulis Valar Dohaeris</a>
            
          </div>

          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/06/15/ios-gcd/">ios gcd</a>
            
          </div>
        </div>
      

      
      
    </div>
  </div>



    
      <div class="comments" id="comments">
        
          <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
          </div>
        
      </div>
    
  </div>


        </div>

        
      </div>


      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目錄
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            本站概覽
          </li>
        </ul>
      

      <div class="site-overview">
        <div class="site-author motion-element">
          <img class="site-author-image" src="/avatar.png" alt="Yt" />
          <p class="site-author-name">Yt</p>
        </div>
        <p class="site-description motion-element">notes for study</p>
        <div class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">145</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">25</span>
              <span class="site-state-item-name">分類</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">68</span>
              <span class="site-state-item-name">標籤</span>
              </a>
          </div>

        </div>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml">
              <i class="menu-item-icon icon-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
              <a href="https://github.com/ytlvy" target="_blank">GitHub</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="https://twitter.com/ytlvy" target="_blank">Twitter</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://nshipster.com" target="_blank">NSHipster</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://www.mikeash.com/pyblog" target="_blank">NSBlog</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://www.objc.io" target="_blank">objcio</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://www.raywenderlich.com" target="_blank">raywenderlich</a>
            </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

      </div>

      
        <div class="post-toc-wrap sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator"></div>
          <div class="post-toc">
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#ARC"><span class="nav-number">1.</span> <span class="nav-text">ARC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MRC"><span class="nav-number">1.1.</span> <span class="nav-text">MRC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MRC内存管理原则"><span class="nav-number">1.1.1.</span> <span class="nav-text">MRC内存管理原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#调用者持有"><span class="nav-number">1.1.2.</span> <span class="nav-text">调用者持有</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#调用者不持有"><span class="nav-number">1.1.3.</span> <span class="nav-text">调用者不持有</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#autorelease"><span class="nav-number">1.1.4.</span> <span class="nav-text">autorelease</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不要释放,_非你持有的对象"><span class="nav-number">1.1.5.</span> <span class="nav-text">不要释放, 非你持有的对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GNUstep_—_The_alloc_Method"><span class="nav-number">1.1.6.</span> <span class="nav-text">GNUstep — The alloc Method</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#GNUstep_—_malloc_&&_calloc"><span class="nav-number">1.1.6.1.</span> <span class="nav-text">GNUstep —  malloc && calloc</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GNUstep_—_The_retain_Method"><span class="nav-number">1.1.7.</span> <span class="nav-text">GNUstep —  The retain Method</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GNUstep_—_The_release_Method"><span class="nav-number">1.1.8.</span> <span class="nav-text">GNUstep — The release Method</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GNUstep_—_The_dealloc_Method"><span class="nav-number">1.1.9.</span> <span class="nav-text">GNUstep — The dealloc Method</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GNUstep_—_总结"><span class="nav-number">1.1.10.</span> <span class="nav-text">GNUstep — 总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Apple’s_Implementation"><span class="nav-number">1.1.11.</span> <span class="nav-text">Apple’s Implementation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Autorelease"><span class="nav-number">1.1.12.</span> <span class="nav-text">Autorelease</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Automatic_Variables"><span class="nav-number">1.1.12.1.</span> <span class="nav-text">Automatic Variables</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Implementing_autorelease"><span class="nav-number">1.1.13.</span> <span class="nav-text">Implementing autorelease</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Apple’s_Implementation_of_autorelease"><span class="nav-number">1.1.14.</span> <span class="nav-text">Apple’s Implementation of autorelease</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ARC_Rules"><span class="nav-number">1.2.</span> <span class="nav-text">ARC Rules</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Ownership_qualifiers"><span class="nav-number">1.2.1.</span> <span class="nav-text">Ownership qualifiers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#__strong_ownership_qualifier_—_作用域情况"><span class="nav-number">1.2.2.</span> <span class="nav-text">__strong ownership qualifier — 作用域情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Assigning_to___strong_ownership_qualified_variables_—_赋值情况"><span class="nav-number">1.2.3.</span> <span class="nav-text">Assigning to __strong ownership qualified variables — 赋值情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#__weak_ownership_qualifier"><span class="nav-number">1.2.4.</span> <span class="nav-text">__weak ownership qualifier</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Weak_Reference_Disappears"><span class="nav-number">1.2.5.</span> <span class="nav-text">Weak Reference Disappears</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#__unsafe_unretained_ownership_qualifier"><span class="nav-number">1.2.6.</span> <span class="nav-text">__unsafe_unretained ownership qualifier</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#__autoreleasing_ownership_qualifier"><span class="nav-number">1.2.7.</span> <span class="nav-text">__autoreleasing ownership qualifier</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Compiler_Cares___autoreleasing_Automatically"><span class="nav-number">1.2.7.1.</span> <span class="nav-text">Compiler Cares __autoreleasing Automatically</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#weak对象的调用"><span class="nav-number">1.2.8.</span> <span class="nav-text">weak对象的调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#__autoreleasing_默认修饰符"><span class="nav-number">1.2.9.</span> <span class="nav-text">__autoreleasing 默认修饰符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Returning_a_Result_as_the_Argument"><span class="nav-number">1.2.10.</span> <span class="nav-text">Returning a Result as the Argument</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Rules"><span class="nav-number">1.2.11.</span> <span class="nav-text">Rules</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object_Type_Variables_Cannot_Be_Members_of_struct_or_union_in_C_Language"><span class="nav-number">1.2.12.</span> <span class="nav-text">Object Type Variables Cannot Be Members of struct or union in C Language</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#‘id’_and_‘void*’_Have_to_Be_Cast_Explicitly"><span class="nav-number">1.2.13.</span> <span class="nav-text">‘id’ and ‘void*’ Have to Be Cast Explicitly</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#__bridge_cast"><span class="nav-number">1.2.13.1.</span> <span class="nav-text">__bridge cast</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#__bridge_retained_cast"><span class="nav-number">1.2.13.2.</span> <span class="nav-text">__bridge_retained cast</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#__bridge_transfer_cast"><span class="nav-number">1.2.14.</span> <span class="nav-text">__bridge_transfer cast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CoreFoundation_Object_&&_Objective-C_Object"><span class="nav-number">1.2.15.</span> <span class="nav-text">CoreFoundation Object && Objective-C Object</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CFBridgingRetain_function"><span class="nav-number">1.2.16.</span> <span class="nav-text">CFBridgingRetain function</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CFBridgingRelease_function"><span class="nav-number">1.2.17.</span> <span class="nav-text">CFBridgingRelease function</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Property"><span class="nav-number">1.2.18.</span> <span class="nav-text">Property</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Array"><span class="nav-number">1.2.19.</span> <span class="nav-text">Array</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ARC_Implementation"><span class="nav-number">1.3.</span> <span class="nav-text">ARC Implementation</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#__strong_ownership_qualifier"><span class="nav-number">1.3.1.</span> <span class="nav-text">__strong ownership qualifier</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Calling_the_array_method"><span class="nav-number">1.3.2.</span> <span class="nav-text">Calling the array method</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Inside_the_array_Method"><span class="nav-number">1.3.3.</span> <span class="nav-text">Inside the array Method</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#__weak_ownership_qualifier-1"><span class="nav-number">1.3.4.</span> <span class="nav-text">__weak ownership qualifier</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Looking_Under_the_Hood_When_an_Object_Is_Discarded_对象销毁"><span class="nav-number">1.3.5.</span> <span class="nav-text">Looking Under the Hood When an Object Is Discarded 对象销毁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Assigning_a_Newly_Created_Object"><span class="nav-number">1.3.6.</span> <span class="nav-text">Assigning a Newly Created Object</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Immediate_Disposal_of_Objects"><span class="nav-number">1.3.7.</span> <span class="nav-text">Immediate Disposal of Objects</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Adding_to_autorelease_pool_Automatically"><span class="nav-number">1.3.8.</span> <span class="nav-text">Adding to autorelease pool Automatically</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#weak变量使用优化"><span class="nav-number">1.3.9.</span> <span class="nav-text">weak变量使用优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不支持weak的情况"><span class="nav-number">1.3.10.</span> <span class="nav-text">不支持weak的情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#__autoreleasing_ownership_qualifier-1"><span class="nav-number">1.3.11.</span> <span class="nav-text">__autoreleasing ownership qualifier</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#__unsafe_unretained_ownership_qualifier-1"><span class="nav-number">1.3.12.</span> <span class="nav-text">__unsafe_unretained ownership qualifier</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Reference_Count"><span class="nav-number">1.3.13.</span> <span class="nav-text">Reference Count</span></a></li></ol></li></ol></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator"></div>
        </div>
      

    </div>
  </div>


    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp; 
  2015
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">Yt</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>



<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<div class="theme-info">
  <span id="busuanzi_container_site_uv">
    &nbsp&nbsp&nbsp&nbsp|&nbsp&nbsp Total <span id="busuanzi_value_site_pv"><i class="fa fa-spinner fa-spin"></i></span> views.
您是本站的第<span id="busuanzi_value_site_uv"><i class="fa fa-spinner fa-spin"></i></span>个小伙伴
<span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span> Hits
  </span>
<div>
      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js"></script>


  <script type="text/javascript" src="/js/helpers.js"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js" id="motion.global"></script>




  
  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var $sidebarInner = $('.sidebar-inner');
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.didShow', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;
          var self = this;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      $(indicator).velocity('stop').velocity({
        opacity: action === 'show' ? 0.4 : 0
      }, { duration: 100 });
    }

  });
</script>


  <script type="text/javascript" id="sidebar.nav">
    $(document).ready(function () {
      var html = $('html');

      $('.sidebar-nav li').on('click', function () {
        var item = $(this);
        var activeTabClassName = 'sidebar-nav-active';
        var activePanelClassName = 'sidebar-panel-active';
        if (item.hasClass(activeTabClassName)) {
          return;
        }

        var currentTarget = $('.' + activePanelClassName);
        var target = $('.' + item.data('target'));

        currentTarget.velocity('transition.slideUpOut', 200, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', 200)
            .addClass(activePanelClassName);
        });

        item.siblings().removeClass(activeTabClassName);
        item.addClass(activeTabClassName);
      });

      $('.post-toc a').on('click', function (e) {
        e.preventDefault();
        var offset = $(escapeSelector(this.getAttribute('href'))).offset().top;
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        });
      });

      // Expand sidebar on post detail page by default, when post has a toc.
      var $tocContent = $('.post-toc-content');
      if (isDesktop() && CONFIG.sidebar === 'post') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          displaySidebar();
        }
      }
    });
  </script>




  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
    });
  </script>

  

  
  
  

  

    
      
    

    <script type="text/javascript">
      var disqus_shortname = 'ytlvy';
      var disqus_identifier = '2015/06/16/ios-MRC-ARC/';
      var disqus_title = 'ios MRC && ARC';
      var disqus_url = 'http://ytlvy.com/2015/06/16/ios-MRC-ARC/';

      (function(){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }());
    </script>
  




  
  

</body>
</html>
