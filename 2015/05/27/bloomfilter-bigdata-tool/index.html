<!doctype html>
<html class="theme-next use-motion ">
<head>
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">


<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.3"/>


    <meta name="description" content="notes for study" />



  <meta name="keywords" content="Hexo,next" />



  <link rel="alternate" href="/atom.xml" title="Yt's Blog" type="application/atom+xml" />



  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.3" />



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    analytics: {
      google: ''
    },
    sidebar: 'post'
  };
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?b8a916e09c6b39221eb089c8ad75ede9";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <title> BloomFilter–大规模数据处理利器(解决空查问题) // Yt's Blog </title>
</head>

<body>
<!--[if lte IE 8]> <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'> <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode"><img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820" alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari." style='margin-left:auto;margin-right:auto;display: block;'/></a></div> <![endif]-->
  <div class="container one-column page-post-detail">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">Yt's Blog</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>


  <ul id="menu" class="menu">
     
    
      
      <li class="menu-item menu-item-home">
        <a href="/">
          <i class="menu-item-icon icon-home"></i> <br />
          首頁
        </a>
      </li>
    
      
      <li class="menu-item menu-item-categories">
        <a href="/categories">
          <i class="menu-item-icon icon-categories"></i> <br />
          分類
        </a>
      </li>
    
      
      <li class="menu-item menu-item-about">
        <a href="/about">
          <i class="menu-item-icon icon-about"></i> <br />
          關於
        </a>
      </li>
    
      
      <li class="menu-item menu-item-archives">
        <a href="/archives">
          <i class="menu-item-icon icon-archives"></i> <br />
          歸檔
        </a>
      </li>
    
      
      <li class="menu-item menu-item-tags">
        <a href="/tags">
          <i class="menu-item-icon icon-tags"></i> <br />
          標籤
        </a>
      </li>
    
  </ul>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          

  <div id="posts" class="posts-expand">
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              BloomFilter–大规模数据处理利器(解决空查问题)
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2015-05-27
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/Bigdata/">Bigdata</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/05/27/bloomfilter-bigdata-tool/#comments" >
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/05/27/bloomfilter-bigdata-tool/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        <h2 id="BloomFilter–大规模数据处理利器">BloomFilter–大规模数据处理利器</h2><p>Bloom Filter是由Bloom在1970年提出的一种多哈希函数映射的快速查找算法。通常应用在一些需要快速判断某个元素是否属于集合，但是并不严格要求100%正确的场合</p>
<hr>
<h3 id="一-_实例">一. 实例</h3><p>为了说明Bloom Filter存在的重要意义，举一个实例：</p>
<blockquote>
<p>假设要你写一个网络爬虫程序（web crawler）。由于网络间的链接错综复杂，爬虫在网络间爬行很可能会形成“环”。为了避免形成“环”，就需要知道爬虫程序已经访问过那些URL。给一个URL，怎样知道爬虫程序是否已经访问过呢？稍微想想，就会有如下几种方案：</p>
</blockquote>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 将访问过的<span class="keyword">URL</span>保存到数据库。</span><br><span class="line"><span class="number">2.</span> 用HashSet将访问过的<span class="keyword">URL</span>保存起来。那只需接近<span class="keyword">O</span>(<span class="number">1</span>)的代价就可以查到一个<span class="keyword">URL</span>是否被访问过了。</span><br><span class="line"><span class="number">3.</span> <span class="keyword">URL</span>经过MD5或SHA-<span class="number">1</span>等单向哈希后再保存到HashSet或数据库。</span><br><span class="line"><span class="number">4.</span> Bit-<span class="keyword">Map</span>方法。建立一个<span class="keyword">BitSet</span>，将每个<span class="keyword">URL</span>经过一个哈希函数映射到某一位。</span><br></pre></td></tr></table></figure>
<p>方法1~3都是将访问过的URL完整保存，方法4则只标记URL的一个映射位。</p>
<h4 id="缺点">缺点</h4><p>以上方法在数据量较小的情况下都能完美解决问题，但是当数据量变得非常庞大时问题就来了。<br>　　方法1的缺点：数据量变得非常庞大后关系型数据库查询的效率会变得很低。而且每来一个URL就启动一次数据库查询是不是太小题大做了？<br>　　方法2的缺点：太消耗内存。随着URL的增多，占用的内存会越来越多。就算只有1亿个URL，每个URL只算50个字符，就需要5GB内存。<br>　　方法3：由于字符串经过MD5处理后的信息摘要长度只有128Bit，SHA-1处理后也只有160Bit，因此方法3比方法2节省了好几倍的内存。<br>　　方法4消耗内存是相对较少的，但缺点是单一哈希函数发生冲突的概率太高。还记得数据结构课上学过的Hash表冲突的各种解决方法么？若要降低冲突发生的概率到1%，就要将BitSet的长度设置为URL个数的100倍。</p>
<h3 id="二-_Bloom_Filter的算法">二. Bloom Filter的算法</h3><blockquote>
<p>废话说到这里，下面引入本篇的主角–Bloom Filter。其实上面方法4的思想已经很接近Bloom Filter了。方法四的致命缺点是冲突概率高，为了降低冲突的概念，Bloom Filter使用了多个哈希函数，而不是一个。</p>
</blockquote>
<h4 id="Bloom_Filter算法如下：">Bloom Filter算法如下：</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">创建一个<span class="keyword">m</span>位BitSet，先将所有位初始化为0，然后选择k个不同的哈希函数。第i个哈希函数对字符串str哈希的结果记为<span class="keyword">h</span>（i，str），且<span class="keyword">h</span>（i，str）的范围是0到<span class="keyword">m</span>-1 。</span><br></pre></td></tr></table></figure>
<h4 id="(1)_加入字符串过程">(1) 加入字符串过程</h4><p>　　下面是每个字符串处理的过程，首先是将字符串str“记录”到BitSet中的过程：</p>
<blockquote>
<p>对于字符串str，分别计算h（1，str），h（2，str）…… h（k，str）。然后将BitSet的第h（1，str）、h（2，str）…… h（k，str）位设为1。<br> <img src="http://www.dbafree.net/wp-content/uploads/2011/05/clip_image0012-300x115.jpg" alt=""></p>
</blockquote>
<p>很简单吧？这样就将字符串str映射到BitSet中的k个二进制位了。</p>
<h4 id="(2)_检查字符串是否存在的过程">(2) 检查字符串是否存在的过程</h4><p>下面是检查字符串str是否被BitSet记录过的过程：</p>
<blockquote>
<p>对于字符串str，分别计算h（1，str），h（2，str）…… h（k，str）。然后检查BitSet的第h（1，str）、h（2，str）…… h（k，str）位是否为1，若其中任何一位不为1则可以判定str一定没有被记录过。若全部位都是1，则“认为”字符串str存在。</p>
<p>若一个字符串对应的Bit不全为1，则可以肯定该字符串一定没有被Bloom Filter记录过。（这是显然的，因为字符串被记录过，其对应的二进制位肯定全部被设为1了）</p>
<p>但是若一个字符串对应的Bit全为1，实际上是不能100%的肯定该字符串被Bloom Filter记录过的。（因为有可能该字符串的所有位都刚好是被其他字符串所对应）这种将该字符串划分错的情况，称为false positive 。</p>
</blockquote>
<h4 id="(3)_删除字符串过程">(3) 删除字符串过程</h4><blockquote>
<p>字符串加入了就被不能删除了，因为删除会影响到其他字符串。实在需要删除字符串的可以使用Counting bloomfilter(CBF)，这是一种基本Bloom Filter的变体，CBF将基本Bloom Filter每一个Bit改为一个计数器，这样就可以实现删除字符串的功能了。</p>
</blockquote>
<p>Bloom Filter跟单哈希函数Bit-Map不同之处在于：Bloom Filter使用了k个哈希函数，每个字符串跟k个bit对应。从而降低了冲突的概率。</p>
<h3 id="三-_Bloom_Filter参数选择">三. Bloom Filter参数选择</h3><h4 id="(1)哈希函数选择">(1)哈希函数选择</h4><blockquote>
<p>哈希函数的选择对性能的影响应该是很大的，一个好的哈希函数要能近似等概率的将字符串映射到各个Bit。选择k个不同的哈希函数比较麻烦，一种简单的方法是选择一个哈希函数，然后送入k个不同的参数。</p>
</blockquote>
<h4 id="(2)_m,n,k值，我们如何取值">(2) m,n,k值，我们如何取值</h4><p>我们定义：</p>
<blockquote>
<p>可能把不属于这个集合的元素误认为属于这个集合（False Positive）<br>不会把属于这个集合的元素误认为不属于这个集合（False Negative）。</p>
<p>哈希函数的个数k、位数组大小m、加入的字符串数量n的关系。哈希函数个数k取10，位数组大小m设为字符串个数n的20倍时，false positive发生的概率是0.0000889 ，即10万次的判断中，会存在9次误判，对于一天1亿次的查询，误判的次数为9000次。 </p>
</blockquote>
<h4 id="算法分析：">算法分析：</h4><blockquote>
<p>我们假设 <code>kn&lt;m</code> 且各个哈希函数是完全随机的。当集合<code>S={x1, x2,…,xn}</code>的所有元素都被k个哈希函数映射到m位的位数组中时，这个位数组中某一位还是0的概率是：<br><img src="http://www.dbafree.net/wp-content/uploads/2011/05/1.jpg" alt=""></p>
<p>False Positive的概率是：<br><img src="http://www.dbafree.net/wp-content/uploads/2011/05/2-300x62.jpg" alt=""></p>
<p>p’表示1的概率,k次方表示8次hash都为1的概率。<br> 当 k = ln 2 * m/n 时，右边的等式值最小，此时等式转变成:<br><img src="http://www.dbafree.net/wp-content/uploads/2011/05/3.jpg" alt=""> </p>
</blockquote>
<h3 id="四-_Bloom_Filter实现代码（简易版）">四. Bloom Filter实现代码（简易版）</h3><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">package org.magnus.utils;</span><br><span class="line"><span class="keyword">import</span> java.util.<span class="type">BitSet</span>;</span><br><span class="line">//传统的<span class="type">Bloom</span> filter 不支持从集合中删除成员。</span><br><span class="line">//<span class="type">Counting</span> <span class="type">Bloom</span> filter由于采用了计数，因此支持remove操作。</span><br><span class="line">//基于<span class="type">BitSet</span>来实现，性能上可能存在问题</span><br><span class="line">public class <span class="type">SimpleBloomFilter</span> &#123;</span><br><span class="line">    //<span class="type">DEFAULT_SIZE</span>为<span class="number">2</span>的<span class="number">25</span>次方</span><br><span class="line">    private <span class="keyword">static</span> final <span class="type">int</span> <span class="type">DEFAULT_SIZE</span> = <span class="number">2</span> &lt;&lt; <span class="number">24</span>;</span><br><span class="line">    /* 不同哈希函数的种子，一般应取质数,seeds数据共有<span class="number">7</span>个值，则代表采用<span class="number">7</span>种不同的<span class="type">HASH</span>算法 */</span><br><span class="line">    private <span class="keyword">static</span> final <span class="type">int</span>[] seeds = new <span class="type">int</span>[] &#123; <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">61</span> &#125;;</span><br><span class="line">    //<span class="type">BitSet</span>实际是由“二进制位”构成的一个<span class="type">Vector</span>。假如希望高效率地保存大量“开－关”信息，就应使用<span class="type">BitSet</span>.</span><br><span class="line">    //<span class="type">BitSet</span>的最小长度是一个长整数（<span class="type">Long</span>）的长度：<span class="number">64</span>位</span><br><span class="line">    private <span class="type">BitSet</span> bits = new <span class="type">BitSet</span>(<span class="type">DEFAULT_SIZE</span>);</span><br><span class="line">    /* 哈希函数对象 */</span><br><span class="line">    private <span class="type">SimpleHash</span>[] func = new <span class="type">SimpleHash</span>[seeds.length];</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> <span class="type">void</span> main(<span class="type">String</span>[] args) &#123;</span><br><span class="line">       <span class="type">String</span> value = <span class="string">"stone2083@yahoo.cn"</span>;</span><br><span class="line">       //定义一个filter，定义的时候会调用构造函数，即初始化七个hash函数对象所需要的信息。</span><br><span class="line">       <span class="type">SimpleBloomFilter</span> filter = new <span class="type">SimpleBloomFilter</span>();</span><br><span class="line">       //判断是否包含在里面。因为没有调用add方法，所以肯定是返回<span class="literal">false</span></span><br><span class="line">       <span class="type">System</span>.<span class="keyword">out</span>.println(filter.contains(value));</span><br><span class="line">       filter.add(value);</span><br><span class="line">       <span class="type">System</span>.<span class="keyword">out</span>.println(filter.contains(value));</span><br><span class="line">    &#125;</span><br><span class="line">    //构造函数</span><br><span class="line">    public <span class="type">SimpleBloomFilter</span>() &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; seeds.length; i++) &#123;</span><br><span class="line">           //给出所有的hash值，共计seeds.length个hash值。共<span class="number">7</span>位。</span><br><span class="line">           //通过调用<span class="type">SimpleHash</span>.hash(),可以得到根据<span class="number">7</span>种hash函数计算得出的hash值。</span><br><span class="line">           //传入<span class="type">DEFAULT_SIZE</span>(最终字符串的长度），seeds[i](一个指定的质数)即可得到需要的那个hash值的位置。</span><br><span class="line">           func[i] = new <span class="type">SimpleHash</span>(<span class="type">DEFAULT_SIZE</span>, seeds[i]);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将字符串标记到bits中，即设置字符串的<span class="number">7</span>个hash值函数为<span class="number">1</span></span><br><span class="line">    public <span class="type">void</span> add(<span class="type">String</span> value) &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">SimpleHash</span> f : func) &#123;</span><br><span class="line">           bits.<span class="type">set</span>(f.hash(value), <span class="literal">true</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //判断字符串是否已经被bits标记</span><br><span class="line">    public boolean contains(<span class="type">String</span> value) &#123;</span><br><span class="line">       //确保传入的不是空值</span><br><span class="line">       <span class="keyword">if</span> (value == null) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       boolean ret = <span class="literal">true</span>;</span><br><span class="line">       //计算<span class="number">7</span>种hash算法下各自对应的hash值，并判断</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">SimpleHash</span> f : func) &#123;</span><br><span class="line">           //&amp;&amp;是boolen运算符，只要有一个为<span class="number">0</span>，则为<span class="number">0</span>。即需要所有的位都为<span class="number">1</span>，才代表包含在里面。</span><br><span class="line">           //f.hash(value)返回hash对应的位数值</span><br><span class="line">           //bits.get函数返回bitset中对应position的值。即返回hash值是否为<span class="number">0</span>或<span class="number">1</span>。</span><br><span class="line">           ret = ret &amp;&amp; bits.get(f.hash(value));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    /* 哈希函数类 */</span><br><span class="line">    public <span class="keyword">static</span> class <span class="type">SimpleHash</span> &#123;</span><br><span class="line">       //cap为<span class="type">DEFAULT_SIZE</span>的值，即用于结果的最大的字符串长度。</span><br><span class="line">       //seed为计算hash值的一个给定key，具体对应上面定义的seeds数组</span><br><span class="line">       private <span class="type">int</span> cap;</span><br><span class="line">       private <span class="type">int</span> seed;</span><br><span class="line"></span><br><span class="line">       public <span class="type">SimpleHash</span>(<span class="type">int</span> cap, <span class="type">int</span> seed) &#123;</span><br><span class="line">           this.cap = cap;</span><br><span class="line">           this.seed = seed;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       //计算hash值的具体算法,hash函数，采用简单的加权和hash</span><br><span class="line">       public <span class="type">int</span> hash(<span class="type">String</span> value) &#123;</span><br><span class="line">           //<span class="type">int</span>的范围最大是<span class="number">2</span>的<span class="number">31</span>次方减<span class="number">1</span>，或超过值则用负数来表示</span><br><span class="line">           <span class="type">int</span> <span class="literal">result</span> = <span class="number">0</span>;</span><br><span class="line">           <span class="type">int</span> len = value.length();</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">              //数字和字符串相加，字符串转换成为<span class="type">ASCII</span>码</span><br><span class="line">              <span class="literal">result</span> = seed * <span class="literal">result</span> + value.charAt(i);</span><br><span class="line">              //<span class="type">System</span>.<span class="keyword">out</span>.println(<span class="literal">result</span>+<span class="string">"--"</span>+seed+<span class="string">"*"</span>+<span class="literal">result</span>+<span class="string">"+"</span>+value.charAt(i));</span><br><span class="line">           &#125;</span><br><span class="line">       //  <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"result="</span>+<span class="literal">result</span>+<span class="string">";"</span>+((cap - <span class="number">1</span>) &amp; <span class="literal">result</span>));</span><br><span class="line">       //  <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="number">414356308</span>*<span class="number">61</span>+'h');  执行此运算结果为负数，为什么？</span><br><span class="line">           //&amp;是java中的位逻辑运算，用于过滤负数（负数与进算转换成反码进行）。</span><br><span class="line">           <span class="keyword">return</span> (cap - <span class="number">1</span>) &amp; <span class="literal">result</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="五：Bloom_Filter的优点及应用">五：Bloom Filter的优点及应用</h3><h4 id="优点：">优点：</h4><ul>
<li>节约缓存空间（空值的映射），不再需要空值映射。</li>
<li>减少数据库或缓存的请求次数。</li>
<li>提升业务的处理效率以及业务隔离性。</li>
</ul>
<h4 id="缺点：">缺点：</h4><ul>
<li>存在误判的概率。</li>
<li>传统的Bloom Filter不能作删除操作。</li>
</ul>
<h4 id="使用场景">使用场景</h4><p>适用于特定场景，能够有效的解决数据库空查问题。</p>
<blockquote>
<p>以公司的某小表查询为例，该表每天查询量20亿次左右，且数据库中存在大量的下面的空查:<br>目前表中的记录为8w,即n的值为8w, m=20*n=160w，占用空间大小195KB。以type||CONTENT复合键作为key值，假设HASH次数k取值为6,误判率为:0.0303%(10000次中存在3次误判)。HASH次数的最优解为14，当k=14时，误判率为：0.014%(10000次中存在1-2次误判)。</p>
</blockquote>
<p>测试过程及结果如下（源代码见附件）：</p>
<blockquote>
<p>测试场景1：m=1600000;n=80000;最优解k=14;m/n=20;k的次数为:6;对1000w数据进行判定:<br><img src="http://www.dbafree.net/wp-content/uploads/2011/05/4-300x174.jpg" alt=""><br>测试结果：<br>2000w数据误判的记录为：3035，误判率约为0.03035%（和理论值0.0303%相差不大）。判断2000万数据的时间为25秒。平均一次判断时间为:2.5微秒。平均一次hash时间为0.417微秒。</p>
</blockquote>
<hr>
<blockquote>
<p>测试场景2：m=1600000;n=80000;最优解k=14;m/n=20;k的次数为:6;对2000w数据进行判定:<br><img src="http://www.dbafree.net/wp-content/uploads/2011/05/5-300x176.jpg" alt=""><br>测试结果：2000w数据误判的记录为：5839，误判率约为0.029%（理论值为0. 0303%）。判断1000万数据的时间为51秒。平均一次判断时间为:2.55微秒。平均一次hash时间为0.425微秒。</p>
</blockquote>
<hr>
<blockquote>
<p>测试场景3：m=1600000;n=80000;最优解k=14;m/n=20;k的次数为:14;对1000w数据进行判定 :<br><img src="http://www.dbafree.net/wp-content/uploads/2011/05/61-300x174.jpg" alt=""><br>测试结果：1000w数据误判的记录为：605，误判率约为0.00605%（和理论值0. 014%相差不大）。判断1000万数据的时间为37秒。平均一次判断时间为:3.7微秒。平均一次hash时间为0.265微秒。 </p>
</blockquote>
<hr>
<blockquote>
<p>测试场景4：m=1600000;n=80000;最优解k=14;m/n=20;k的次数为:14;对2000w数据进行判定:<br><img src="http://www.dbafree.net/wp-content/uploads/2011/05/7-300x172.jpg" alt=""><br>测试结果：2000w数据误判的记录为：1224，误判率约为0.00612%（理论值为0.014%）。判断1000万数据的时间为84秒。平均一次判断时间为:4.2微秒。平均一次hash时间为0.3微秒。</p>
</blockquote>
<h3 id="六：实施方案思考">六：实施方案思考</h3><blockquote>
<p>适用于一些黑名单,垃圾邮件等的过滤。<br>当位数组较小时，可以作本地jvm缓存。<br>当位数组较大时，可以做基于tair的缓存，此时可能需要开辟单独的应用来提供查询支持。<br>此方案，适用的应用场景需要能够容忍，位数组和的延时。</p>
</blockquote>

      
    </div>

    <div class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/05/27/alibaba-miao-sha-xi-tong-bi-ji/">阿里巴巴秒杀系统笔记</a>
            
          </div>

          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/05/27/objective-c-and-core-foundation-memory-managment/">Objective-C 和 Core Foundation 对象相互转换的内存管理总结</a>
            
          </div>
        </div>
      

      
      
    </div>
  </div>



    
      <div class="comments" id="comments">
        
          <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
          </div>
        
      </div>
    
  </div>


        </div>

        
      </div>


      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目錄
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            本站概覽
          </li>
        </ul>
      

      <div class="site-overview">
        <div class="site-author motion-element">
          <img class="site-author-image" src="/avatar.png" alt="Yt" />
          <p class="site-author-name">Yt</p>
        </div>
        <p class="site-description motion-element">notes for study</p>
        <div class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">93</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">21</span>
              <span class="site-state-item-name">分類</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">11</span>
              <span class="site-state-item-name">標籤</span>
              </a>
          </div>

        </div>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml">
              <i class="menu-item-icon icon-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
              <a href="https://github.com/ytlvy" target="_blank">GitHub</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="https://twitter.com/ytlvy" target="_blank">Twitter</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://nshipster.com" target="_blank">NSHipster</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://www.mikeash.com/pyblog" target="_blank">NSBlog</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://www.objc.io" target="_blank">objcio</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://www.raywenderlich.com" target="_blank">raywenderlich</a>
            </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

      </div>

      
        <div class="post-toc-wrap sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator"></div>
          <div class="post-toc">
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#BloomFilter–大规模数据处理利器"><span class="nav-number">1.</span> <span class="nav-text">BloomFilter–大规模数据处理利器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一-_实例"><span class="nav-number">1.1.</span> <span class="nav-text">一. 实例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#缺点"><span class="nav-number">1.1.1.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二-_Bloom_Filter的算法"><span class="nav-number">1.2.</span> <span class="nav-text">二. Bloom Filter的算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Bloom_Filter算法如下："><span class="nav-number">1.2.1.</span> <span class="nav-text">Bloom Filter算法如下：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#(1)_加入字符串过程"><span class="nav-number">1.2.2.</span> <span class="nav-text">(1) 加入字符串过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#(2)_检查字符串是否存在的过程"><span class="nav-number">1.2.3.</span> <span class="nav-text">(2) 检查字符串是否存在的过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#(3)_删除字符串过程"><span class="nav-number">1.2.4.</span> <span class="nav-text">(3) 删除字符串过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三-_Bloom_Filter参数选择"><span class="nav-number">1.3.</span> <span class="nav-text">三. Bloom Filter参数选择</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#(1)哈希函数选择"><span class="nav-number">1.3.1.</span> <span class="nav-text">(1)哈希函数选择</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#(2)_m,n,k值，我们如何取值"><span class="nav-number">1.3.2.</span> <span class="nav-text">(2) m,n,k值，我们如何取值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#算法分析："><span class="nav-number">1.3.3.</span> <span class="nav-text">算法分析：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四-_Bloom_Filter实现代码（简易版）"><span class="nav-number">1.4.</span> <span class="nav-text">四. Bloom Filter实现代码（简易版）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五：Bloom_Filter的优点及应用"><span class="nav-number">1.5.</span> <span class="nav-text">五：Bloom Filter的优点及应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#优点："><span class="nav-number">1.5.1.</span> <span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺点："><span class="nav-number">1.5.2.</span> <span class="nav-text">缺点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景"><span class="nav-number">1.5.3.</span> <span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#六：实施方案思考"><span class="nav-number">1.6.</span> <span class="nav-text">六：实施方案思考</span></a></li></ol></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator"></div>
        </div>
      

    </div>
  </div>


    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp; 
  2015
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">Yt</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>



<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<div class="theme-info">
  <span id="busuanzi_container_site_uv">
    &nbsp&nbsp&nbsp&nbsp|&nbsp&nbsp Total <span id="busuanzi_value_site_pv"><i class="fa fa-spinner fa-spin"></i></span> views.
您是本站的第<span id="busuanzi_value_site_uv"><i class="fa fa-spinner fa-spin"></i></span>个小伙伴
<span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span> Hits
  </span>
<div>
      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js"></script>


  <script type="text/javascript" src="/js/helpers.js"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js" id="motion.global"></script>




  
  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var $sidebarInner = $('.sidebar-inner');
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.didShow', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;
          var self = this;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      $(indicator).velocity('stop').velocity({
        opacity: action === 'show' ? 0.4 : 0
      }, { duration: 100 });
    }

  });
</script>


  <script type="text/javascript" id="sidebar.nav">
    $(document).ready(function () {
      var html = $('html');

      $('.sidebar-nav li').on('click', function () {
        var item = $(this);
        var activeTabClassName = 'sidebar-nav-active';
        var activePanelClassName = 'sidebar-panel-active';
        if (item.hasClass(activeTabClassName)) {
          return;
        }

        var currentTarget = $('.' + activePanelClassName);
        var target = $('.' + item.data('target'));

        currentTarget.velocity('transition.slideUpOut', 200, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', 200)
            .addClass(activePanelClassName);
        });

        item.siblings().removeClass(activeTabClassName);
        item.addClass(activeTabClassName);
      });

      $('.post-toc a').on('click', function (e) {
        e.preventDefault();
        var offset = $(escapeSelector(this.getAttribute('href'))).offset().top;
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        });
      });

      // Expand sidebar on post detail page by default, when post has a toc.
      var $tocContent = $('.post-toc-content');
      if (isDesktop() && CONFIG.sidebar === 'post') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          displaySidebar();
        }
      }
    });
  </script>




  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
    });
  </script>

  

  
  
  

  

    
      
    

    <script type="text/javascript">
      var disqus_shortname = 'ytlvy';
      var disqus_identifier = '2015/05/27/bloomfilter-bigdata-tool/';
      var disqus_title = 'BloomFilter–大规模数据处理利器(解决空查问题)';
      var disqus_url = 'http://ytlvy.com/2015/05/27/bloomfilter-bigdata-tool/';

      (function(){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }());
    </script>
  




  
  

</body>
</html>
