<!doctype html>
<html class="theme-next use-motion ">
<head>
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">


<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.3"/>


    <meta name="description" content="notes for study" />



  <meta name="keywords" content="Hexo,next" />



  <link rel="alternate" href="/atom.xml" title="Yt's Blog" type="application/atom+xml" />



  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.3" />



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    analytics: {
      google: ''
    },
    sidebar: 'post'
  };
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?b8a916e09c6b39221eb089c8ad75ede9";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <title> Yt's Blog </title>
</head>

<body>
<!--[if lte IE 8]> <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'> <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode"><img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820" alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari." style='margin-left:auto;margin-right:auto;display: block;'/></a></div> <![endif]-->
  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">Yt's Blog</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>


  <ul id="menu" class="menu">
     
    
      
      <li class="menu-item menu-item-home">
        <a href="/">
          <i class="menu-item-icon icon-home"></i> <br />
          首頁
        </a>
      </li>
    
      
      <li class="menu-item menu-item-categories">
        <a href="/categories">
          <i class="menu-item-icon icon-categories"></i> <br />
          分類
        </a>
      </li>
    
      
      <li class="menu-item menu-item-about">
        <a href="/about">
          <i class="menu-item-icon icon-about"></i> <br />
          關於
        </a>
      </li>
    
      
      <li class="menu-item menu-item-archives">
        <a href="/archives">
          <i class="menu-item-icon icon-archives"></i> <br />
          歸檔
        </a>
      </li>
    
      
      <li class="menu-item menu-item-tags">
        <a href="/tags">
          <i class="menu-item-icon icon-tags"></i> <br />
          標籤
        </a>
      </li>
    
  </ul>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <div id="posts" class="posts-expand">
    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/07/28/sqlite-insert-replace/">
                sqlite insert replace
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2015-07-28
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/Sqlite/">Sqlite</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/07/28/sqlite-insert-replace/#comments" >
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/07/28/sqlite-insert-replace/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="Sqlite_insert_&amp;&amp;_replace">Sqlite insert &amp;&amp; replace</h2><p>Assuming 3 columns in the table.. ID, NAME, ROLE</p>
<h3 id="BAD:_This_will_insert_or_replace_all_columns_with_new_values_for_ID=1:">BAD: This will insert or replace all columns with new values for ID=1:</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">INSERT</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">INTO</span> Employee (id, name, role) </span><br><span class="line">  <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'John Foo'</span>, <span class="string">'CEO'</span>);</span></span><br></pre></td></tr></table></figure>
<h3 id="BAD:_This_will_insert_or_replace_2_of_the_columns…_the_NAME_column_will_be_set_to_NULL_or_the_default_value:">BAD: This will insert or replace 2 of the columns… the NAME column will be set to NULL or the default value:</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">INSERT</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">INTO</span> Employee (id, role) </span><br><span class="line">  <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'code monkey'</span>);</span></span><br></pre></td></tr></table></figure>
<h3 id="GOOD:_This_will_update_2_of_the_columns-_When_ID=1_exists,_the_NAME_will_be_unaffected-_When_ID=1_does_not_exist,_the_name_will_be_default_(NULL)-">GOOD: This will update 2 of the columns. When ID=1 exists, the NAME will be unaffected. When ID=1 does not exist, the name will be default (NULL).</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">INSERT</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">INTO</span> Employee (id, role, name) </span><br><span class="line">  <span class="keyword">VALUES</span> (  <span class="number">1</span>, </span><br><span class="line">            <span class="string">'code monkey'</span>,</span><br><span class="line">            (<span class="keyword">SELECT</span> name <span class="keyword">FROM</span> Employee <span class="keyword">WHERE</span> id = <span class="number">1</span>)</span><br><span class="line">          );</span></span><br></pre></td></tr></table></figure>
<h3 id="GOOD:_This_will_update_2_of_the_columns-_When_ID=1_exists,_the_ROLE_will_be_unaffected-_When_ID=1_does_not_exist,_the_role_will_be_set_to_‘Benchwarmer’_instead_of_the_default_value-">GOOD: This will update 2 of the columns. When ID=1 exists, the ROLE will be unaffected. When ID=1 does not exist, the role will be set to ‘Benchwarmer’ instead of the default value.</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">INSERT</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">INTO</span> Employee (id, name, role) </span><br><span class="line">  <span class="keyword">VALUES</span> (  <span class="number">1</span>, </span><br><span class="line">            <span class="string">'Susan Bar'</span>,</span><br><span class="line">            <span class="keyword">COALESCE</span>((<span class="keyword">SELECT</span> role <span class="keyword">FROM</span> Employee <span class="keyword">WHERE</span> id = <span class="number">1</span>), <span class="string">'Benchwarmer'</span>)</span><br><span class="line">          );</span></span><br></pre></td></tr></table></figure>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/07/28/xcode-condition-breakpoint-non-ascii/">
                xcode condition breakpoint non-ascii
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2015-07-28
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/IOS/">IOS</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/07/28/xcode-condition-breakpoint-non-ascii/#comments" >
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/07/28/xcode-condition-breakpoint-non-ascii/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h4 id="设置变量">设置变量</h4><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">expr</span> username = @<span class="string">"username"</span></span><br><span class="line"><span class="type">expr</span> password = @<span class="string">"badpassword"</span></span><br></pre></td></tr></table></figure>
<h4 id="条件断点">条件断点</h4><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">BOOL</span>)</span><span class="list">[<span class="keyword">item</span> isEqualToString:@<span class="string">"three"</span>]</span><br><span class="line"></span><br><span class="line">//非 ASCII 码写法</span><br><span class="line"><span class="list">(<span class="keyword">BOOL</span>)</span><span class="list">[<span class="list">(<span class="keyword">NSString*</span>)</span>titleName isEqualToString:<span class="list">[<span class="keyword">NSString</span> stringWithUTF8String:<span class="string">"消息"</span>]]</span></span></span></span><br></pre></td></tr></table></figure>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/07/26/iOS-static-library-architectures/">
                iOS static library architectures
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2015-07-26
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/IOS/">IOS</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/07/26/iOS-static-library-architectures/#comments" >
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/07/26/iOS-static-library-architectures/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="iOS_static_library_architectures">iOS static library architectures</h2><p>最近入职, 刚接手需要参与的工程, 调试了半天, 发现由于32\64位的问题, 不能在模拟器调试, 很郁闷. 后来google 到答案记录如下:</p>
<p>静态库编译支持<code>arm64,armv7 armv7s, i386, x86_64</code>.</p>
<p>1) 分别在设备和模拟器编译<br>2) 找到<code>Build/Products</code>目录, 下有两个目录 <code>Release-iphoneos</code>  <code>Release-iphonesimulator</code></p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/Users/</span>kappe<span class="regexp">/Library/</span>Developer<span class="regexp">/Xcode/</span>DerivedData<span class="regexp">/zbar-gyozyrpbqzvslmfoadhqkwskcesd/</span>Build<span class="regexp">/Products</span></span><br></pre></td></tr></table></figure>
<p>3) 合并<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lipo -<span class="built_in">create</span> Release-iphoneos/libzbar.<span class="operator">a</span> Release-iphonesimulator/libzbar.<span class="operator">a</span> -o libzbar.<span class="operator">a</span></span><br></pre></td></tr></table></figure></p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/07/21/iOS-wild-pointer-crash/">
                iOS wild pointer crash
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2015-07-21
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/IOS/">IOS</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/07/21/iOS-wild-pointer-crash/#comments" >
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/07/21/iOS-wild-pointer-crash/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p><a href="http://bugly.qq.com/blog/?p=200" target="_blank" rel="external">转自</a></p>
<h2 id="先提高野指针Crash率">先提高野指针Crash率</h2><p>写c、c++代码的同学应该都清楚，crash最多的原因通常有两种，一种是多线程，一种是野指针。这两种crash都带随机性，而且这两种crash有相当一部分都很难区分，甚至大量的crash只有系统栈，如果不能根据日志重现，几乎是无解，让人非常蛋疼。</p>
<p>本文主要讨论的方向是objc的野指针。objc的野指针最常见的一种栈是<code>objc_msgSend</code>，从Bugly上报的Crash数据来看，objc_msgSend的量占了五分之一，这其中大多数是objc野指针。当然也有相当多的objc野指针不是这种表现，所以野指针的crash体量很惊人</p>
<h3 id="为什么Obj-C野指针的Crash那么多？">为什么Obj-C野指针的Crash那么多？</h3><p>我们有这么多自动化和人工测试流程，而且还有几轮的灰度过程，其实很多crash场景都应该已经覆盖到了，但随机性意味着，测试的时候它没有问题，等用户用了才有问题，这种情况该怎么办？！</p>
<p>我觉得关键在于它的随机性，随机性问题我初略地分为两类：</p>
<p>第一类是跑不进出错的逻辑，执行不到出错的代码，这种可以提高测试场景覆盖度来解决。</p>
<p>第二类是跑进了有问题的逻辑，但是野指针指向的地址并不一定会导致crash，这好像要看人品了？<br>一说到人品就头疼啊有木有，由于上辈子做了太多善事，人品太好每次自测的时候根本不crash有木有！</p>
<h3 id="先来分析分析">先来分析分析</h3><p><strong>野指针是指指向一个已删除的对象或未申请访问受限内存区域的指针</strong>。本文说的objc野指针，说的是objc对象释放之后指针未置空，导致的野指针（objc里面一般不会出现为初始化对象的常识性错误）。</p>
<p>既然是访问已经释放的对象为什么不是必现crash呢？<br><strong>因为dealloc执行后只是告诉系统，这片内存我不用了，而系统并没有就让这片内存不能访问</strong>。</p>
<p>现实大概是下面几种可能的情况：</p>
<ol>
<li>对象释放后内存没被改动过，原来的内存保存完好，可能不crash或者出现逻辑错误（随机crash）。</li>
<li>对象释放后内存没被改动过，但是它自己析构的时候已经删掉某些必要的东西，可能不crash、crash在访问依赖的对象比如类成员上、出现逻辑错误（随机crash）。</li>
<li>对象释放后内存被改动过，写上了不可访问的数据，直接就出错了很可能crash在objc_msgSend上面（必现crash，常见）。</li>
<li>对象释放后内存被改动过，写上了可以访问的数据，可能不crash、出现逻辑错误、间接访问到不可访问的数据（随机crash）。</li>
<li>对象释放后内存被改动过，写上了可以访问的数据，但是再次访问的时候执行的代码把别的数据写坏了，遇到这种crash只能哭了（随机crash，难度大，概率低）！！</li>
<li>对象释放后再次release（几乎是必现crash，但也有例外，很常见）。</li>
</ol>
<p>参考下面的这张图：<br><img src="http://7jpswx.com1.z0.glb.clouddn.com/ios%20wild%20pointer%20crash.png" alt=""></p>
<p>看看下面的代码，明显有问题，但是大部分时候是不会crash的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UIView* <span class="built_in">test</span>Obj=[[UIView alloc] init];</span><br><span class="line">[<span class="built_in">test</span>Obj release];</span><br><span class="line">[<span class="built_in">test</span>Obj <span class="built_in">set</span>NeedsLayout];</span><br></pre></td></tr></table></figure>
<h3 id="让随机变成不随机">让随机变成不随机</h3><p>从上面列的情况来看，出现随机Crash的情况有很多种！这是得多蛋疼呢！或许最好的办法让他们全都立马crash，然后把野指针都找出来！<br>仔细看看上面的关键路径只有出现被随机填入的数据是不可访问的时候才会必现crash。</p>
<p>这个地方我们可以做一下手脚，把这一随机的过程变成不随机的过程。对象释放后在内存上填上不可访问的数据，其实这种技术其实一直都有，xcode的Enable Scribble就是这个作用。<br><img src="http://7jpswx.com1.z0.glb.clouddn.com/ios%20wild%20pointer%20crash1.png" alt=""></p>
<p>下面我们就拿刚刚的代码试一下。</p>
<p>scheme=&gt;run=&gt;diagnostics=&gt;Enable Scribble</p>
<p>果然，必现了，0x5555561！！</p>
<p><img src="http://bugly.qq.com/blog/wp-content/uploads/2015/05/3.png" alt=""></p>
<p>但是有个问题：这货不能放在测试同学那边用！因为总不能让测试同学装了xcode来测试吧？</p>
<p>于是我们自己动手实现一个，这个过程中我们要解决几个问题：</p>
<ol>
<li>怎么在内存释放后填上不可访问的数据？内存释放很可能不在我们的代码中。为此我们需要hook对象释放的接口，内存释放之后马上执行我们的破坏工作。</li>
<li>我们要重写对象释放的接口，重写哪个呢？NSObject的dealloc、runtime的 object_dispose，c的free应该都是可以，但是各有优点，我选择的是覆盖面最广的free，free是c的函数，重写了它之后还可以顺带解决一部分c的野指针问题。</li>
<li>怎么重写？重写c的接口场景的有两种： a. 替换系统动态库 b.hook . 替换动态库太麻烦，还不知道行不行得通；hook我们就找现成的<code>fishhook</code>，github里面找的，但现成的代码需要防止代码冲突。</li>
<li>填充的不可访问的数据的长度怎么确定？获取内存长度的接口不在标准库中，好在在Mac和iOS中可以用<code>malloc_size</code>就可以。</li>
<li>填什么？和xcode一样，填0x55</li>
</ol>
<p>上hook后的free代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">safe_free</span><span class="params">(<span class="keyword">void</span>* p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> memSiziee=malloc_size(p);</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0x55</span>, memSiziee);</span><br><span class="line">    orig_free(p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试一下，出现了和Enable Scribble一样的crash！<br><img src="http://bugly.qq.com/blog/wp-content/uploads/2015/05/4.png" alt=""></p>
<p>重复造了这个xcode的轮子之后，以后编包给测试，终于在某些情况下不需要那么拼人品了。但是这仅仅覆盖了众多野指针中的一部分，还有大量的疑问等着继续解答。比如：</p>
<ol>
<li>由于内存已经被释放了，很可能我们的0x55又被别的数据覆盖，这种情况还是无能为力。</li>
<li>为什么我们的0x55555555变成了0x55555561。</li>
<li>如果释放后访问野指针的是系统代码，虽然提前发现了crash，但是离解决问题还是很远。</li>
<li>如果野指针指向的数据没有被当成指针使用，还是可能不立即crash。</li>
</ol>
<h2 id="让非必现Crash变成必现">让非必现Crash变成必现</h2><blockquote>
<p>注：本文主要介绍一种延迟内在释放的技术，继续上一篇提到的如何提高野指针Crash的概率（可以文章底部点击“阅读原文”，查看上一篇文章）。另外，本文探讨的环境是在非arc情况下</p>
</blockquote>
<h3 id="只有小概率Crash肿么办？">只有小概率Crash肿么办？</h3><p>之前介绍了一种在内存释放后填充0x55使野指针后数据不能访问，从而使某些野指针从不必现Crash变成了必现。然而，我们早就看穿了一切，这个事情不会那么顺利的。</p>
<p>加上上次的代码之后，再试试下面的代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIView</span>* testObj=[[<span class="built_in">UIView</span> alloc] init]; </span><br><span class="line">[testObj release]; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123; </span><br><span class="line">    <span class="built_in">UIView</span>* testView=[[[<span class="built_in">UIView</span> alloc] </span><br><span class="line">        initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>,<span class="number">200</span>,<span class="built_in">CGRectGetWidth</span>(<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.bounds</span>), <span class="number">60</span>)] autorelease]; </span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span> addSubview:testView]; </span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> mainRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:<span class="literal">nil</span>]; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">[testObj setNeedsLayout];</span><br></pre></td></tr></table></figure>
<p>依然有大概率不会Crash！难道是我们的实现有问题？我试了一下xcode的Enable Scribble，但一样是大概率不Crash！</p>
<p>其实这就是上一篇文中留下了几个问题之一，如果我们填充0x55后内存又被别的内存覆盖了，最终还是会出现随机Crash。而在真实环境中，这种情况是非常常见的。</p>
<p>我们再梳理一下这个过程：</p>
<ol>
<li>我们在即将要释放的填了0x55，之后调用了free真正释放，内存被系统回收。</li>
<li>这个时候系统随时可能把这片内存给别的代码使用，也就是说我们的0x55被再次写上随机的数据（在这里再强调一下，访问野指针是不会Crash的，只有野指针指向的地址被写上了有问题的数据才会引发Crash）。</li>
<li>假如释放的内存上又填上了另一个对象的指针，而那个对象也有同样的一个方法，那很可能只是逻辑上有问题，并不会直接Crash，甚至悄无声息地像什么事情都没发生一样。（这个地方可能会发生多种情况，可以参考之上一篇文章中的图）</li>
</ol>
<p>没有发生Crash可不是好事，因为这种情况如果后续再Crash，问题就非常难查，因为你看到的Crash栈很可能和出错的代码完全没有关联。既然这个问题这么棘手，最好还是和之前一样，让这个Crash提前暴露。</p>
<h3 id="继续提高Crash率">继续提高Crash率</h3><p>沿着上次的思路，首先，我们要解决的问题就是怎么让系统不再往这片释放的内存上乱放东西。</p>
<p>要控制底层内存管理机制让它不使用这些内存可能很困难。但是，我们变通一下，简单粗暴地，我们干脆就不释放这片内存了。也就是当free被调用的时候我们不真的调用free，而是自己保留着内存，这样系统不知道这片内存已经不需要用了，自然就不会被再次写上别的数据（偷笑)。</p>
<p>为了防止系统内存过快耗尽，还需要额外多做几件事：</p>
<ol>
<li>自己保留的内存大于一定值的时候就释放一部分，防止被系统杀死。</li>
<li>系统内存警告的时候，也要释放一部分内存。</li>
</ol>
<p>主要代码还是很简单的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">DSQueue* _unfreeQueue = NULL;<span class="comment">//用来保存自己偷偷保留的内存:1这个队列要线程安全或者自己加锁;2这个队列内部应该尽量少申请和释放堆内存。 </span></span><br><span class="line"><span class="keyword">int</span> unfreeSize=<span class="number">0</span>;<span class="comment">//用来记录我们偷偷保存的内存的大小 </span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAX_STEAL_MEM_SIZE 1024*1024*100<span class="comment">//最多存这么多内存，大于这个值就释放一部分 </span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MAX_STEAL_MEM_NUM 1024*1024*10<span class="comment">//最多保留这么多个指针，再多就释放一部分 </span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> BATCH_FREE_NUM 100<span class="comment">//每次释放的时候释放指针数量 </span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//系统内存警告的时候调用这个函数释放一些内存 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_some_mem</span><span class="params">(size_t freeNum)</span></span>&#123; </span><br><span class="line">    <span class="keyword">size_t</span> count = ds_queue_length(_unfreeQueue); </span><br><span class="line">    freeNum = freeNum &gt; count ? count : freeNum; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;freeNum;  i++) &#123; </span><br><span class="line">        <span class="keyword">void</span>* unfreePoint=ds_queue_get(_unfreeQueue); </span><br><span class="line">        <span class="keyword">size_t</span> memSiziee=malloc_size(unfreePoint); </span><br><span class="line">        __sync_fetch_and_sub(&amp;unfreeSize,memSiziee);</span><br><span class="line">        orig_free(unfreePoint); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">safe_free</span><span class="params">(<span class="keyword">void</span>* p)</span></span>&#123; </span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> 0<span class="comment">//之前的代码我们先注释掉 </span></span></span><br><span class="line">    <span class="keyword">size_t</span> memSiziee=malloc_size(p); </span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0x55</span>, memSiziee); </span><br><span class="line">    orig_free(p); </span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span> </span></span><br><span class="line">    <span class="keyword">int</span> unFreeCount=ds_queue_length(_unfreeQueue); </span><br><span class="line">    <span class="keyword">if</span> (unFreeCount&gt;MAX_STEAL_MEM_NUM*<span class="number">0.9</span> || unfreeSize&gt;MAX_STEAL_MEM_SIZE) &#123; </span><br><span class="line">        free_some_mem(BATCH_FREE_NUM); </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">        <span class="keyword">size_t</span> memSiziee=malloc_size(p); </span><br><span class="line">        <span class="built_in">memset</span>(p, <span class="number">0x55</span>, memSiziee);   </span><br><span class="line">        __sync_fetch_and_add(&amp;unfreeSize,memSiziee); </span><br><span class="line">        ds_queue_put(_unfreeQueue, p); </span><br><span class="line">    &#125; </span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span> </span></span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">init_safe_free</span><span class="params">()</span> </span><br><span class="line"></span>&#123; </span><br><span class="line">    _unfreeQueue=ds_queue_create(MAX_STEAL_MEM_NUM); </span><br><span class="line">    orig_free=(<span class="keyword">void</span>(*)(<span class="keyword">void</span>*))dlsym(RTLD_DEFAULT, <span class="string">"free"</span>); </span><br><span class="line">    rebind_symbols1((<span class="keyword">struct</span> rebinding[])&#123;&#123;<span class="string">"free"</span>, (<span class="keyword">void</span>*)safe_free&#125;&#125;, <span class="number">1</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)applicationDidReceiveMemoryWarning:(UIApplication *)application </span><br><span class="line">&#123; </span><br><span class="line">    free_some_mem(<span class="number">1024</span>*<span class="number">1024</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里需要注意一下：</p>
<ol>
<li>在safe_free以及它调用的函数里面尽量不要再用带锁的函数，不然很容易导致死锁。</li>
<li>加上这个代码之后APP的内存占用会增大不少，拿过来测试可以，但万万不能放在正式的发布版本中。</li>
<li>关于性能问题，我的机器是iPhone5，跑在App里面运行，还算流畅（不同App性能可能会有些不同）。</li>
<li>可能由于锁的存在，会使cpu线程切换变得频繁，这样多线程的问题Crash率也可能会提升（最近遇到一个多线程引起的Crash很难重现，但我加了这个代码后就变成了必现Crash）</li>
</ol>
<p>做完这些之后拿到项目中实际验证一下，验证的版本可以是经过测试，且遗留Crash问题已经很少，但还没有对外灰度或发布的版本。</p>
<p>现在来看一下效果：<br><img src="http://bugly.qq.com/blog/wp-content/uploads/2015/06/1.png" alt=""></p>
<p>终于出现了我们熟悉的Crash了！并且，我们做了更多的尝试之后，Crash还是以高概率重现！<br><img src="http://bugly.qq.com/blog/wp-content/uploads/2015/06/2.png" alt=""></p>
<p>但以上代码只是雏形，其实还有很多地方可以优化，大家在试用时可以参考着优化：</p>
<ol>
<li>最好是根据机器的情况来决定偷偷保留内存的数量。</li>
<li>由于内存申请太过频繁，其实我们保留的内存很快就会耗尽，对于大片的内存，可以适当放过，这样可以提高保存指针的数量，防止消耗的内存过多。</li>
<li>有的APP自己写的都是Obj-C代码，想忽略c、c++对象的话可以过滤掉（会有办法判断的）。</li>
<li>如果觉得某些Obj-C类有问题，可以只保留指定的类对象，如果数量不是特别大，甚至可以干脆不释放。</li>
<li>……</li>
</ol>
<h2 id="加点黑科技让Crash自报家门">加点黑科技让Crash自报家门</h2><p>虽然说的是iOS下的野指针问题，但其实在各种平台都是通用的，本文终于可以利用OC Runtime的特性，让OC野指针对象主动抛出自己的信息，某些情况下秒杀某些全系统栈Crash。</p>
<h3 id="为什么错误地址是0x55555561？">为什么错误地址是0x55555561？</h3><p>前文（前文链接）介绍了在内存释放后填充0x55使野指针出现后数据不能访问，从而使野指针变成了必现的方法，那这里会有一个比较奇怪的问题：我们在释放的内存上填上了0x55，但为什么大部分时候野指针Crash了，出错的地址却是0x55555561？</p>
<p>为了解答这个问题，我们可以先看看Crash栈，就会发现这些Crash都是在objc_msgSend上。我们知道Obj-C的对象方法调用是通过objc_msgSend进行的，我们通过野指针访问一个对象的方法也一样，其实是通过objc_msgSend给已经释放的对象发了一条消息。</p>
<p>而objc_msgSend的函数签名是这样：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_msgSend(<span class="keyword">id</span> <span class="keyword">self</span>, SEL op, ...)</span><br></pre></td></tr></table></figure></p>
<p>我们再来看看objc_msgSend的代码:<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">libobjc.A.dylib</span>`objc_msgSend:</span><br><span class="line"> <span class="number">0x2f879f40</span> &lt;+<span class="number">0</span>&gt;: <span class="keyword">cbz </span><span class="literal">r0</span>, <span class="number">0x2f879f7e</span> <span class="comment">; &lt;+62&gt;</span></span><br><span class="line"> <span class="number">0x2f879f42</span> &lt;+<span class="number">2</span>&gt;: <span class="keyword">ldr.w </span><span class="literal">r9</span>, [<span class="literal">r0</span>]</span><br><span class="line"> <span class="number">0x2f879f46</span> &lt;+<span class="number">6</span>&gt;: <span class="keyword">ldrh.w </span><span class="literal">r12</span>, [<span class="literal">r9</span>, <span class="number">#0xc</span>]</span><br><span class="line"> <span class="number">0x2f879f4a</span> &lt;+<span class="number">10</span>&gt;: <span class="keyword">ldr.w </span><span class="literal">r9</span>, [<span class="literal">r9</span>, <span class="number">#0x8</span>]</span><br><span class="line"> <span class="number">0x2f879f4e</span> &lt;+<span class="number">14</span>&gt;: <span class="keyword">and.w </span><span class="literal">r12</span>, <span class="literal">r12</span>, <span class="literal">r1</span></span><br><span class="line"> <span class="number">0x2f879f52</span> &lt;+<span class="number">18</span>&gt;: <span class="keyword">add.w </span><span class="literal">r9</span>, <span class="literal">r9</span>, <span class="literal">r12</span>, <span class="keyword">lsl </span><span class="number">#3</span></span><br><span class="line"> <span class="number">0x2f879f56</span> &lt;+<span class="number">22</span>&gt;: <span class="keyword">ldr.w </span><span class="literal">r12</span>, [<span class="literal">r9</span>]</span><br><span class="line"> <span class="number">0x2f879f5a</span> &lt;+<span class="number">26</span>&gt;: <span class="keyword">teq.w </span><span class="literal">r12</span>, <span class="literal">r1</span></span><br><span class="line"> <span class="number">0x2f879f5e</span> &lt;+<span class="number">30</span>&gt;: <span class="keyword">bne </span><span class="number">0x2f879f66</span> <span class="comment">; &lt;+38&gt;</span></span><br><span class="line"> <span class="number">0x2f879f60</span> &lt;+<span class="number">32</span>&gt;: <span class="keyword">ldr.w </span><span class="literal">r12</span>, [<span class="literal">r9</span>, <span class="number">#0x4</span>]</span><br><span class="line"> <span class="number">0x2f879f64</span> &lt;+<span class="number">36</span>&gt;: <span class="keyword">bx </span><span class="literal">r12</span></span><br><span class="line"> <span class="number">0x2f879f66</span> &lt;+<span class="number">38</span>&gt;: <span class="keyword">cmp.w </span><span class="literal">r12</span>, <span class="number">#0x1</span></span><br><span class="line"> <span class="number">0x2f879f6a</span> &lt;+<span class="number">42</span>&gt;: <span class="keyword">blo </span><span class="number">0x2f879f78</span> <span class="comment">; &lt;+56&gt;</span></span><br><span class="line"> <span class="number">0x2f879f6c</span> &lt;+<span class="number">44</span>&gt;: <span class="keyword">it </span>eq</span><br><span class="line"> <span class="number">0x2f879f6e</span> &lt;+<span class="number">46</span>&gt;: <span class="keyword">ldreq.w </span><span class="literal">r9</span>, [<span class="literal">r9</span>, <span class="number">#0x4</span>]</span><br><span class="line"> <span class="number">0x2f879f72</span> &lt;+<span class="number">50</span>&gt;: <span class="keyword">ldr </span><span class="literal">r12</span>, [<span class="literal">r9</span>, <span class="number">#8</span>]!</span><br><span class="line"> <span class="number">0x2f879f76</span> &lt;+<span class="number">54</span>&gt;: <span class="keyword">b </span><span class="number">0x2f879f5a</span> <span class="comment">; &lt;+26&gt;</span></span><br><span class="line"> <span class="number">0x2f879f78</span> &lt;+<span class="number">56</span>&gt;: <span class="keyword">ldr.w </span><span class="literal">r9</span>, [<span class="literal">r0</span>]</span><br><span class="line"> <span class="number">0x2f879f7c</span> &lt;+<span class="number">60</span>&gt;: <span class="keyword">b </span><span class="number">0x2f87a1c0</span> <span class="comment">; _objc_msgSend_uncached</span></span><br><span class="line"> <span class="number">0x2f879f7e</span> &lt;+<span class="number">62</span>&gt;: <span class="keyword">mov.w </span><span class="literal">r1</span>, <span class="number">#0x0</span></span><br><span class="line"> <span class="number">0x2f879f82</span> &lt;+<span class="number">66</span>&gt;: <span class="keyword">bx </span><span class="literal">lr</span></span><br></pre></td></tr></table></figure></p>
<p>我们可以结合Obj-C类的内存布局再来解读一下上面的汇编代码（节选于Obj-C类的源代码）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</span><br><span class="line"> <span class="comment">// Class ISA;</span></span><br><span class="line"> Class superclass;</span><br><span class="line"> <span class="keyword">cache_t</span> cache;</span><br><span class="line"> <span class="keyword">uintptr_t</span> data_NEVER_USE; <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">class_rw_t</span> *data() &#123;</span><br><span class="line"> <span class="keyword">return</span> (<span class="keyword">class_rw_t</span> *)(data_NEVER_USE &amp; ~CLASS_FAST_FLAG_MASK);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">setData</span><span class="params">(class_rw_t *newData)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">uintptr_t</span> flags = (<span class="keyword">uintptr_t</span>)data_NEVER_USE &amp; CLASS_FAST_FLAG_MASK;</span><br><span class="line"> data_NEVER_USE = (<span class="keyword">uintptr_t</span>)newData | flags;</span><br><span class="line"> &#125;</span><br><span class="line">……..</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="keyword">cache_t</span> &#123;</span><br><span class="line"> <span class="keyword">struct</span> <span class="keyword">bucket_t</span> *buckets;</span><br><span class="line"> <span class="keyword">mask_t</span> shiftmask;</span><br><span class="line"> <span class="keyword">mask_t</span> occupied;</span><br><span class="line">……..</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="keyword">bucket_t</span> &#123;</span><br><span class="line"> <span class="keyword">cache_key_t</span> key;</span><br><span class="line"> IMP imp;</span><br><span class="line">…...</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uintptr_t</span> <span class="keyword">cache_key_t</span>;</span><br></pre></td></tr></table></figure>
<p>根据苹果的函数调用约定，objc_msgSend被调用的时候，寄存器对应关系：r0是对象本身self，r1是sel，r2和r3是参数。根据objc_class的声明，我们可以知道：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x2f879f40</span> &lt;+<span class="number">0</span>&gt;: cbz <span class="literal">r0</span>, <span class="number">0x2f879f7e</span> //如果self为<span class="number">0</span>就跳转到<span class="number">0x2f879f7e</span>。给nil发消息的话就什么都不做</span><br><span class="line"><span class="number">0x2f879f42</span> &lt;+<span class="number">2</span>&gt;: ldr.w <span class="literal">r9</span>, [<span class="literal">r0</span>] //取对象的类到<span class="literal">r9</span></span><br><span class="line"><span class="number">0x2f879f46</span> &lt;+<span class="number">6</span>&gt;: ldrh.w <span class="literal">r12</span>, [<span class="literal">r9</span>, #<span class="number">0xc</span>] //取类的偏移#<span class="number">0xc</span>的数据到<span class="literal">r12</span>，也就是shiftmask的值</span><br><span class="line"><span class="number">0x2f879f4a</span> &lt;+<span class="number">10</span>&gt;: ldr.w <span class="literal">r9</span>, [<span class="literal">r9</span>, #<span class="number">0x8</span>] //取类的偏移#<span class="number">0x8</span>的成员到<span class="literal">r9</span>，也即是cache</span><br><span class="line"><span class="number">0x2f879f4e</span> &lt;+<span class="number">14</span>&gt;: <span class="keyword">and</span>.w <span class="literal">r12</span>, <span class="literal">r12</span>, <span class="literal">r1</span> //<span class="literal">r1</span>和shiftmask与，放到<span class="literal">r12</span>,<span class="literal">r1</span>是参数一，也就是sel，用来计算sel的index</span><br><span class="line"><span class="number">0x2f879f52</span> &lt;+<span class="number">18</span>&gt;: <span class="keyword">add</span>.w <span class="literal">r9</span>, <span class="literal">r9</span>, <span class="literal">r12</span>, <span class="keyword">lsl</span> #<span class="number">3</span> //左移<span class="number">3</span>位就是乘<span class="number">8</span>，<span class="number">8</span>是索引项 bucket_t的宽度，<span class="literal">r12</span>是cache索引，<span class="literal">r9</span>就cache的位置，<span class="literal">r9</span>+<span class="literal">r12</span>*<span class="number">8</span>，就是当前sel对应的bucket_t缓存</span><br><span class="line"><span class="number">0x2f879f56</span> &lt;+<span class="number">22</span>&gt;: ldr.w <span class="literal">r12</span>, [<span class="literal">r9</span>] //取缓存bucket_t</span><br><span class="line"><span class="number">0x2f879f5a</span> &lt;+<span class="number">26</span>&gt;: teq.w <span class="literal">r12</span>, <span class="literal">r1</span> //判断缓存项是不是要找的sel key==sel？</span><br><span class="line"><span class="number">0x2f879f5e</span> &lt;+<span class="number">30</span>&gt;: bne <span class="number">0x2f879f66</span> //不是的话就要查找sel</span><br><span class="line"><span class="number">0x2f879f60</span> &lt;+<span class="number">32</span>&gt;: ldr.w <span class="literal">r12</span>, [<span class="literal">r9</span>, #<span class="number">0x4</span>] //是的话就取出imp</span><br><span class="line"><span class="number">0x2f879f64</span> &lt;+<span class="number">36</span>&gt;: <span class="number">bx</span> <span class="literal">r12</span> //调sel的实现，跳到imp里面去执行</span><br></pre></td></tr></table></figure></p>
<p>其实上面的代码就是从缓存中找sel的实现的过程，而错误地址之所以是0x55555561是因为ldrh.w r12, [r9, #0xc]这行指令。我们用0x55555555覆盖了对象的isa指针，当发生OC调用查找缓存0x55555555+0xc取shiftmask的时候，发现这个地址不可读，于是CPU抛出了异常。</p>
<h3 id="怎么获取野指针的更多异常数据？">怎么获取野指针的更多异常数据？</h3><p>弄清楚上述问题后，又有一个问题：既然0x55555555是被当成了类的指针使用，那假如我们用指定的类覆盖这个指针，是不是就可以执行我们指定类的方法呢？</p>
<p>进一步说就是在发生野指针调用的时候，我们是不是可以控制CPU的行为？说起来有点像溢出攻击，利用shellcode覆盖函数返回值，一旦我们在出错的时候控制了CPU就可以获取更多异常信息，比如是哪个类，调了什么方法，对象的地址之类。</p>
<p>先解决几个关键问题：</p>
<ol>
<li>覆盖成什么？<br>我们需要自己写一个类，用它的isa来替换已经释放的对象的isa。如果不出我们所料，我们用自己的类覆盖之后，之前调用的sel就换成了调用我们自己的类的某个sel。这样，只要我们指定的类也实现这个方法，就可以执行我们需要执行的代码，然后在里面获取我们需要的信息。当然，我们无法预料野指针对象会在调用哪个函数时发生Crash，好在我们可以利用runtime的重定向特性了转到我们自己的代码里面去。</li>
<li>怎么覆盖isa？<br>object_setClass可以替换一个类的isa，但是试了一下，发生死锁！根据Obj-C对象的内存布局，对象的第一个数据就是isa，这里我们可以直接用自己的类指针替换它，反正是已经释放的内存，随便我们怎么玩。</li>
</ol>
<p>总之，还是很简单，这个类就是下面这样:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DPCatcher</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>,<span class="keyword">assign</span>,<span class="keyword">nonatomic</span>) Class origClass;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DPCatcher</span></span></span><br><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@"发现objc野指针:%s::%p=&gt;%@"</span>,class_getName(<span class="keyword">self</span><span class="variable">.origClass</span>),<span class="keyword">self</span>,<span class="built_in">NSStringFromSelector</span>(aSelector));</span><br><span class="line"> abort();</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="keyword">void</span>)dealloc&#123;</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@"发现objc野指针:%s::%p=&gt;%@"</span>,class_getName(<span class="keyword">self</span><span class="variable">.origClass</span>),<span class="keyword">self</span>,<span class="string">@"dealloc"</span>);</span><br><span class="line"> abort();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">oneway</span> <span class="keyword">void</span>)release&#123;</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@"发现objc野指针:%s::%p=&gt;%@"</span>,class_getName(<span class="keyword">self</span><span class="variable">.origClass</span>),<span class="keyword">self</span>,<span class="string">@"release"</span>);</span><br><span class="line"> abort();</span><br><span class="line">&#125;</span><br><span class="line">- (instancetype)autorelease&#123;</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@"发现objc野指针:%s::%p=&gt;%@"</span>,class_getName(<span class="keyword">self</span><span class="variable">.origClass</span>),<span class="keyword">self</span>,<span class="string">@"autorelease"</span>);</span><br><span class="line"> abort();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：对象的release、dealloc等函数要特殊处理一下，因为任何对象都有这些方法，不会执行重定向。</p>
</blockquote>
<p>然后，我们的free函数改成下面这样（去掉了一些多余代码）：<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static void DPFree<span class="params">(void* p)</span>&#123;</span><br><span class="line"> </span><br><span class="line"> size_t memSiziee=malloc_size<span class="params">(p)</span>;</span><br><span class="line"> <span class="keyword">if</span> <span class="params">(memSiziee&gt;sDPCatchSize)</span> &#123;<span class="comment">//有足够的空间才覆盖</span></span><br><span class="line"> id obj=<span class="params">(id)</span>p;</span><br><span class="line"> Class origClass=object_getClass<span class="params">(obj)</span>; <span class="comment">//判断是不是objc对象 ，registeredClasses里面有所有的类，如果可以查到，说明是objc类</span></span><br><span class="line"> <span class="keyword">if</span> <span class="params">(origClass &amp;&amp; CFSetContainsValue<span class="params">(registeredClasses, origClass)</span>)</span> &#123;</span><br><span class="line"> memset<span class="params">(obj, <span class="number">0</span>x55, memSiziee)</span>;</span><br><span class="line"> memcpy<span class="params">(obj, &amp;sDPCatchIsa, sizeof<span class="params">(void*)</span>)</span>;<span class="comment">//把我们自己的类的isa复制过去</span></span><br><span class="line"> </span><br><span class="line"> DPCatcher<span class="built_in">*</span> bug=<span class="params">(DPCatcher*)</span>p;</span><br><span class="line"> bug.origClass=origClass;</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> memset<span class="params">(p, <span class="number">0</span>x55, memSiziee)</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> memset<span class="params">(p, <span class="number">0</span>x55, memSiziee)</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>初始化的时候获取所有类信息，获取填充类的的大小:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">registeredClasses = <span class="built_in">CFSetCreateMutable</span>(<span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"> Class *classes = objc_copyClassList(&amp;count);</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line"> <span class="built_in">CFSetAddValue</span>(registeredClasses, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(classes[i]));</span><br><span class="line"> &#125;</span><br><span class="line"> free(classes);</span><br><span class="line"> classes=<span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"> sDPCatchIsa=objc_getClass(<span class="string">"DPCatcher"</span>);</span><br><span class="line"> </span><br><span class="line"> sDPCatchSize=class_getInstanceSize(sDPCatchIsa);</span><br></pre></td></tr></table></figure>
<p>用下面简单的代码试一下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UIView* <span class="built_in">test</span>Obj=[[UIView alloc] init];</span><br><span class="line"> [<span class="built_in">test</span>Obj release];</span><br><span class="line"> [<span class="built_in">test</span>Obj <span class="built_in">set</span>NeedsLayout];</span><br></pre></td></tr></table></figure></p>
<p>发生野指针的类、对象地址和访问的方法就这样可以被打印出来！<br><img src="http://bugly.qq.com/blog/wp-content/uploads/2015/06/12.jpg" alt=""></p>
<p>再看看下面这几个让人头疼的传说中的全系统栈Crash，你是否熟悉？<br>栈1：<br><img src="http://bugly.qq.com/blog/wp-content/uploads/2015/06/22.jpg" alt=""></p>
<p>栈2：<br><img src="http://bugly.qq.com/blog/wp-content/uploads/2015/06/32.jpg" alt=""></p>
<p>上面这两个Crash如果不能重现几乎是无解！但是，加上我们的野指针定位神器之后再看看，类名和地址都可以打出来了，解决起来就不是什么问题了。<br>栈1被捕获后的信息：<br><img src="http://bugly.qq.com/blog/wp-content/uploads/2015/06/42.jpg" alt=""></p>
<p>栈2被捕获后的信息：<br><img src="http://bugly.qq.com/blog/wp-content/uploads/2015/06/52.jpg" alt=""></p>
<p>说明：</p>
<ol>
<li>我们打印出了野指针对象的名字和地址，当这个类的对象比较少时，对查找问题有很大的用处（如果是自定义的类出现野指针，一般还是比较容易找到问题），但是如果是一些经常出现的类，比如nsarray，定位起来还是比较麻烦。这个时候建议试一下xcode的malloc history工具，或者可以自己实现一个类似记录内存使用记录的工具，因为有内存申请和释放的记录，只要重现一次就可以精确定位野指针。</li>
<li>如果出现dealloc的使用错误，例如先[super dealloc]，然后release成员变量，那么就会出现崩溃的现象，且此时对象的地址为0x55555555。这是因为[super dealloc]只会释放对应的内存，但其成员的内存不会被release而变成了0x555555。 这种问题场景比较简单，一旦发生绝对是必现的，修复也比较容易。</li>
</ol>
<h2 id="后记">后记</h2><p>写到这里，关于iOS野指针随机问题定位的三篇文章就写完了，特别说一下，文中提到的方法虽然可以提高野指针的曝光率和定位精度，但并不是万能，比如下面这几种情况，可能并不一定适用：</p>
<ol>
<li>未触发出现野指针的逻辑：比如说一个有问题的代码，只有在特殊的逻辑下才会有野指针问题，如果我们没有触发这个逻辑，肯定也是无法暴露出这个问题的。这种情况建议还是提高测试的场景覆盖。</li>
<li>产生野指针和使用野指针的时间间隔太长：时间太长的话，很可能我们保留的指针已经被释放了。</li>
<li>APP内存消耗大，会降低曝光率。因为内存消耗大的时候，我们保留的指针数量必然减少，而且保留的时间也会更短。</li>
<li>之前也收到了很多同学的反馈，感谢大家对这个系列文的关注！在这里先回答一下大家提出的一些疑问。</li>
<li>free之前先填上 0x55 ，这个0x55有什么具体含义吗？<br>答：实际上填写数据的关键在于填写数据后其地址指向不可读的内存。而填写0x55，和前面提到的出现异常情况的对象地址0x555555连接起来被当成指针使用的话，就会被识别为0x55555555，而CPU访问这个地址就会抛出异常。<br>另外一点，就是方便区分野指针，例如在Xcode启用Enable Scribble时，指定alloc之后填写的地址为0xaa，防止内存初始化就使用，也是为了方便和free之后的内存做区分。</li>
<li>这个方法对于arc和非arc是否都可以用？<br>答：都可以，不过都是arc的话应该比较少出现野指针吧。</li>
</ol>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/07/19/iOS-CoreText-Advance/">
                iOS CoreText Advance
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2015-07-19
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/IOS/">IOS</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/07/19/iOS-CoreText-Advance/#comments" >
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/07/19/iOS-CoreText-Advance/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="版权说明">版权说明</h2><p>原创文章，转载请保留以下信息：</p>
<p>本文节选自我的图书：《iOS 开发进阶 》。<br>本文涉及的 Demo 工程在这里：<a href="https://github.com/tangqiaoboy/iOS-Pro。" target="_blank" rel="external">https://github.com/tangqiaoboy/iOS-Pro。</a><br>扫码关注我的「iOS 开发」微信公众帐号：<br><img src="http://blog.devtang.com/images/weixin-qr.jpg" alt=""></p>
<hr>
<h2 id="基于_CoreText_的排版引擎：进阶">基于 CoreText 的排版引擎：进阶</h2><h3 id="本章前言">本章前言</h3><p>在上一篇《基于 CoreText 的排版引擎：基础》中，我们学会了排版的基础知识，现在我们来增加复杂性，让我们的排版引擎支持图片和链接的点击。</p>
<h3 id="支持图文混排的排版引擎">支持图文混排的排版引擎</h3><h4 id="改造模版文件">改造模版文件</h4><p>下面我们来进一步改造，让排版引擎支持对于图片的排版。在上一小节中，我们在设置模版文件的时候，就专门在模板文件里面留了一个名为<code>type</code>的字段，用于表示内容的类型。之前的<code>type</code>的值都是txt，这次，我们增加一个值为<code>img</code>的值，用于表示图片。</p>
<p>我们将上一节的<code>content.json</code>文件修改为如下内容，增加了 2 个<code>type</code>值为<code>img</code>的配置项。由于是图片的配置项，所以我们不需要设置颜色，字号这些图片不具有的属性，但是，我们另外增加了 3 个图片的配置属性：</p>
<ol>
<li>一个名为width的属性，用于设置图片显示的宽度。</li>
<li>一个名为height的属性，用于设置图片显示的高度。</li>
<li>一个名为name的属性，用于设置图片的资源名。</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[ &#123;</span><br><span class="line">    "<span class="attribute">type</span>" : <span class="value"><span class="string">"img"</span></span>,</span><br><span class="line">    "<span class="attribute">width</span>" : <span class="value"><span class="number">200</span></span>,</span><br><span class="line">    "<span class="attribute">height</span>" : <span class="value"><span class="number">108</span></span>,</span><br><span class="line">    "<span class="attribute">name</span>" : <span class="value"><span class="string">"coretext-image-1.jpg"</span></span><br><span class="line">  </span>&#125;,</span><br><span class="line">  &#123; "<span class="attribute">color</span>" : <span class="value"><span class="string">"blue"</span></span>,</span><br><span class="line">    "<span class="attribute">content</span>" : <span class="value"><span class="string">" 更进一步地，实际工作中，我们更希望通过一个排版文件，来设置需要排版的文字的 "</span></span>,</span><br><span class="line">    "<span class="attribute">size</span>" : <span class="value"><span class="number">16</span></span>,</span><br><span class="line">    "<span class="attribute">type</span>" : <span class="value"><span class="string">"txt"</span></span><br><span class="line">  </span>&#125;,</span><br><span class="line">  &#123; "<span class="attribute">color</span>" : <span class="value"><span class="string">"red"</span></span>,</span><br><span class="line">    "<span class="attribute">content</span>" : <span class="value"><span class="string">" 内容、颜色、字体 "</span></span>,</span><br><span class="line">    "<span class="attribute">size</span>" : <span class="value"><span class="number">22</span></span>,</span><br><span class="line">    "<span class="attribute">type</span>" : <span class="value"><span class="string">"txt"</span></span><br><span class="line">  </span>&#125;,</span><br><span class="line">  &#123; "<span class="attribute">color</span>" : <span class="value"><span class="string">"black"</span></span>,</span><br><span class="line">    "<span class="attribute">content</span>" : <span class="value"><span class="string">" 大小等信息。\n"</span></span>,</span><br><span class="line">    "<span class="attribute">size</span>" : <span class="value"><span class="number">16</span></span>,</span><br><span class="line">    "<span class="attribute">type</span>" : <span class="value"><span class="string">"txt"</span></span><br><span class="line">  </span>&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    "<span class="attribute">type</span>" : <span class="value"><span class="string">"img"</span></span>,</span><br><span class="line">    "<span class="attribute">width</span>" : <span class="value"><span class="number">200</span></span>,</span><br><span class="line">    "<span class="attribute">height</span>" : <span class="value"><span class="number">130</span></span>,</span><br><span class="line">    "<span class="attribute">name</span>" : <span class="value"><span class="string">"coretext-image-2.jpg"</span></span><br><span class="line">  </span>&#125;,</span><br><span class="line">  &#123; "<span class="attribute">color</span>" : <span class="value"><span class="string">"default"</span></span>,</span><br><span class="line">    "<span class="attribute">content</span>" : <span class="value"><span class="string">" 我在开发猿题库应用时，自己定义了一个基于 UBB 的排版模版，但是实现该排版文件的解析器要花费大量的篇幅，考虑到这并不是本章的重点，所以我们以一个较简单的排版文件来讲解其思想。"</span></span>,</span><br><span class="line">    "<span class="attribute">type</span>" : <span class="value"><span class="string">"txt"</span></span><br><span class="line">  </span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>按理说，图片本身的内容信息中，是包含宽度和高度信息的，为什么我们要在这里指定图片的宽高呢？这主要是因为，在真实的开发中，应用的模版和图片通常是通过服务器获取的，模版是纯文本的内容，获取速度比图片快很多，而图片不但获取速度慢，而且为了省流量，通常的做法是直到需要显示图片的时候，再加载图片内容。</p>
<p>如果我们不将图片的宽度和高度信息设置在模板里面，那么 CoreText 在排版的时候就无法知道绘制所需要的高度，我们就无法设置<code>CoreTextData</code>类中的<code>height</code>信息，没有高度信息，就会对 <code>UITableView</code> 一类的控件排版造成影响。所以，除非你的应用图片能够保证在绘制前都能全部在本地，否则就应该另外提前提供图片宽度和高度信息。</p>
<p>在完成模板文件修改后，我们选取两张测试用的图片，分别将其命名为<code>coretext-image-1.jpg</code>和<code>coretext-image-2.jpg</code>（和模板中的值一致），将其拖动增加到工程中。向 Xcode 工程增加图片资源是基础知识，在此就不详细介绍过程了。</p>
<h4 id="CTLine_与_CTRun">CTLine 与 CTRun</h4><p>接下来我们需要改造的是<code>CTFrameParser</code>类，让解析模板文件的方法支持type为img的配置。</p>
<p>在改造前，我们先来了解一下<code>CTFrame</code>内部的组成。通过之前的例子，我们可以看到，我们首先通过<code>NSAttributeString</code>和配置信息创建 <code>CTFrameSetter</code>， 然后，再通过<code>CTFrameSetter</code>来创建<code>CTFrame</code>。</p>
<p>在<code>CTFrame</code>内部，是由多个<code>CTLine</code>来组成的，每个<code>CTLine</code>代表一行，每个<code>CTLine</code>又是由多个<code>CTRun</code>来组成，每个<code>CTRun</code>代表一组显示风格一致的文本。我们不用手工管理<code>CTLine</code>和<code>CTRun</code>的创建过程。</p>
<p>下图是一个<code>CTLine</code>和<code>CTRun</code>的示意图，可以看到，第三行的<code>CTLine</code>是由 2 个<code>CTRun</code>构成的，第一个<code>CTRun</code>为红色大字号的左边部分，第二个<code>CTRun</code>为右边字体较小的部分。</p>
<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-ctline.jpg" alt=""></p>
<p>虽然我们不用管理<code>CTRun</code>的创建过程，但是我们可以设置某一个具体的<code>CTRun</code>的<code>CTRunDelegate</code>来指定该文本在绘制时的高度、宽度、排列对齐方式等信息。</p>
<p>对于图片的排版，其实 <code>CoreText</code>本质上不是直接支持的，但是，我们可以在要显示文本的地方，用一个特殊的空白字符代替，同时设置该字体的<code>CTRunDelegate</code>信息为要显示的图片的宽度和高度信息，这样最后生成的<code>CTFrame</code>实例，就会在绘制时将图片的位置预留出来。</p>
<p>因为我们的<code>CTDisplayView</code>的绘制代码是在<code>drawRect</code>里面的，所以我们可以方便地把需要绘制的图片，用<code>CGContextDrawImage</code>方法直接绘制出来就可以了。</p>
<h4 id="改造模版解析类">改造模版解析类</h4><p>在了解了以上原理后，我们就可以开始进行改造了。</p>
<p>我们需要做的工作包括：</p>
<ol>
<li>改造CTFrameParser的parseTemplateFile:(NSString <em>)path config:(CTFrameParserConfig</em>)config;方法，使其支持对type为img的节点解析。并且对type为img的节点，设置其CTRunDelegate信息，使其在绘制时，为图片预留相应的空白位置。</li>
<li>改造CoreTextData类，增加图片相关的信息，并且增加计算图片绘制区域的逻辑。</li>
<li>改造CTDisplayView类，增加绘制图片相关的逻辑。</li>
</ol>
<p>首先介绍对于<code>CTFrameParser</code>的改造：</p>
<p>我们修改了<code>parseTemplateFile</code>方法，增加了一个名为<code>imageArray</code>的参数来保存解析时的图片信息。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (CoreTextData *)<span class="string">parseTemplateFile:</span>(NSString *)path <span class="string">config:</span>(CTFrameParserConfig*)config &#123;</span><br><span class="line">    NSMutableArray *imageArray = [NSMutableArray array];</span><br><span class="line">    NSAttributedString *content = [self <span class="string">loadTemplateFile:</span>path <span class="string">config:</span>config <span class="string">imageArray:</span>imageArray];</span><br><span class="line">    CoreTextData *data = [self <span class="string">parseAttributedContent:</span>content <span class="string">config:</span>config];</span><br><span class="line">    data.imageArray = imageArray;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着我们修改<code>loadTemplateFile</code>方法，增加了对于type是img的节点处理逻辑，该逻辑主要做 2 件事情：</p>
<ol>
<li>保存当前图片节点信息到imageArray变量中</li>
<li>新建一个空白的占位符。</li>
</ol>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> (<span class="type">NSAttributedString</span> *)loadTemplateFile:(<span class="type">NSString</span> *)path</span><br><span class="line">                                  config:(<span class="type">CTFrameParserConfig</span>*)config</span><br><span class="line">                              imageArray:(<span class="type">NSMutableArray</span> *)imageArray &#123;</span><br><span class="line">    <span class="type">NSData</span> *data = [<span class="type">NSData</span> dataWithContentsOfFile:path];</span><br><span class="line">    <span class="type">NSMutableAttributedString</span> *<span class="literal">result</span> = [[<span class="type">NSMutableAttributedString</span> alloc] init];</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        <span class="type">NSArray</span> *<span class="type">array</span> = [<span class="type">NSJSONSerialization</span> <span class="type">JSONObjectWithData</span>:data</span><br><span class="line">                             options:<span class="type">NSJSONReadingAllowFragments</span></span><br><span class="line">                               error:<span class="keyword">nil</span>];</span><br><span class="line">        <span class="keyword">if</span> ([<span class="type">array</span> isKindOfClass:[<span class="type">NSArray</span> class]]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">NSDictionary</span> *dict <span class="keyword">in</span> <span class="type">array</span>) &#123;</span><br><span class="line">                <span class="type">NSString</span> *<span class="keyword">type</span> = dict[@<span class="string">"type"</span>];</span><br><span class="line">                <span class="keyword">if</span> ([<span class="keyword">type</span> isEqualToString:@<span class="string">"txt"</span>]) &#123;</span><br><span class="line">                    <span class="type">NSAttributedString</span> *<span class="keyword">as</span> =</span><br><span class="line">                        [self parseAttributedContentFromNSDictionary:dict</span><br><span class="line">                                                              config:config];</span><br><span class="line">                    [<span class="literal">result</span> appendAttributedString:<span class="keyword">as</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">type</span> isEqualToString:@<span class="string">"img"</span>]) &#123;</span><br><span class="line">                    // 创建 <span class="type">CoreTextImageData</span></span><br><span class="line">                    <span class="type">CoreTextImageData</span> *imageData = [[<span class="type">CoreTextImageData</span> alloc] init];</span><br><span class="line">                    imageData.name = dict[@<span class="string">"name"</span>];</span><br><span class="line">                    imageData.position = [<span class="literal">result</span> length];</span><br><span class="line">                    [imageArray addObject:imageData];</span><br><span class="line">                    // 创建空白占位符，并且设置它的 <span class="type">CTRunDelegate</span> 信息</span><br><span class="line">                    <span class="type">NSAttributedString</span> *<span class="keyword">as</span> = [self parseImageDataFromNSDictionary:dict config:config];</span><br><span class="line">                    [<span class="literal">result</span> appendAttributedString:<span class="keyword">as</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们新建一个最关键的方法：<code>parseImageDataFromNSDictionary</code>，生成图片空白的占位符，并且设置其<code>CTRunDelegate</code>信息。其代码如下：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">CGFloat</span> ascentCallback(<span class="type">void</span> *<span class="keyword">ref</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> [(<span class="type">NSNumber</span>*)[(__bridge <span class="type">NSDictionary</span>*)<span class="keyword">ref</span> objectForKey:@<span class="string">"height"</span>] floatValue];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">CGFloat</span> descentCallback(<span class="type">void</span> *<span class="keyword">ref</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">CGFloat</span> widthCallback(<span class="type">void</span>* <span class="keyword">ref</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> [(<span class="type">NSNumber</span>*)[(__bridge <span class="type">NSDictionary</span>*)<span class="keyword">ref</span> objectForKey:@<span class="string">"width"</span>] floatValue];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">NSAttributedString</span> *)parseImageDataFromNSDictionary:(<span class="type">NSDictionary</span> *)dict</span><br><span class="line">                                                config:(<span class="type">CTFrameParserConfig</span>*)config &#123;</span><br><span class="line">    <span class="type">CTRunDelegateCallbacks</span> callbacks;</span><br><span class="line">    memset(&amp;callbacks, <span class="number">0</span>, sizeof(<span class="type">CTRunDelegateCallbacks</span>));</span><br><span class="line">    callbacks.version = kCTRunDelegateVersion1;</span><br><span class="line">    callbacks.getAscent = ascentCallback;</span><br><span class="line">    callbacks.getDescent = descentCallback;</span><br><span class="line">    callbacks.getWidth = widthCallback;</span><br><span class="line">    <span class="type">CTRunDelegateRef</span> delegate = <span class="type">CTRunDelegateCreate</span>(&amp;callbacks, (__bridge <span class="type">void</span> *)(dict));</span><br><span class="line"></span><br><span class="line">    // 使用 <span class="number">0xFFFC</span> 作为空白的占位符</span><br><span class="line">    unichar objectReplacementChar = <span class="number">0xFFFC</span>;</span><br><span class="line">    <span class="type">NSString</span> * content = [<span class="type">NSString</span> stringWithCharacters:&amp;objectReplacementChar length:<span class="number">1</span>];</span><br><span class="line">    <span class="type">NSDictionary</span> * attributes = [self attributesWithConfig:config];</span><br><span class="line">    <span class="type">NSMutableAttributedString</span> * space =</span><br><span class="line">       [[<span class="type">NSMutableAttributedString</span> alloc] initWithString:content</span><br><span class="line">                                              attributes:attributes];</span><br><span class="line">    <span class="type">CFAttributedStringSetAttribute</span>((<span class="type">CFMutableAttributedStringRef</span>)space,</span><br><span class="line">              <span class="type">CFRangeMake</span>(<span class="number">0</span>, <span class="number">1</span>), kCTRunDelegateAttributeName, delegate);</span><br><span class="line">    <span class="type">CFRelease</span>(delegate);</span><br><span class="line">    <span class="keyword">return</span> space;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着我们对<code>CoreTextData</code>进行改造，增加了<code>imageArray</code>成员变量，用于保存图片绘制时所需的信息。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"CoreTextImageData.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CoreTextData</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) CTFrameRef ctFrame;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> height;</span><br><span class="line"><span class="comment">// 新增加的成员</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSArray</span> * imageArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>在设置<code>imageArray</code>成员时，我们还会调一个新创建的fillImagePosition方法，用于找到每张图片在绘制时的位置。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setImageArray:(<span class="built_in">NSArray</span> *)imageArray &#123;</span><br><span class="line">    _imageArray = imageArray;</span><br><span class="line">    [<span class="keyword">self</span> fillImagePosition];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)fillImagePosition &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.imageArray</span><span class="variable">.count</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSArray</span> *lines = (<span class="built_in">NSArray</span> *)CTFrameGetLines(<span class="keyword">self</span><span class="variable">.ctFrame</span>);</span><br><span class="line">    <span class="keyword">int</span> lineCount = [lines count];</span><br><span class="line">    <span class="built_in">CGPoint</span> lineOrigins[lineCount];</span><br><span class="line">    CTFrameGetLineOrigins(<span class="keyword">self</span><span class="variable">.ctFrame</span>, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="number">0</span>), lineOrigins);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> imgIndex = <span class="number">0</span>;</span><br><span class="line">    CoreTextImageData * imageData = <span class="keyword">self</span><span class="variable">.imageArray</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lineCount; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (imageData == <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        CTLineRef line = (__bridge CTLineRef)lines[i];</span><br><span class="line">        <span class="built_in">NSArray</span> * runObjArray = (<span class="built_in">NSArray</span> *)CTLineGetGlyphRuns(line);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> runObj <span class="keyword">in</span> runObjArray) &#123;</span><br><span class="line">            CTRunRef run = (__bridge CTRunRef)runObj;</span><br><span class="line">            <span class="built_in">NSDictionary</span> *runAttributes = (<span class="built_in">NSDictionary</span> *)CTRunGetAttributes(run);</span><br><span class="line">            CTRunDelegateRef delegate = (__bridge CTRunDelegateRef)[runAttributes valueForKey:(<span class="keyword">id</span>)kCTRunDelegateAttributeName];</span><br><span class="line">            <span class="keyword">if</span> (delegate == <span class="literal">nil</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSDictionary</span> * metaDic = CTRunDelegateGetRefCon(delegate);</span><br><span class="line">            <span class="keyword">if</span> (![metaDic isKindOfClass:[<span class="built_in">NSDictionary</span> class]]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">CGRect</span> runBounds;</span><br><span class="line">            <span class="built_in">CGFloat</span> ascent;</span><br><span class="line">            <span class="built_in">CGFloat</span> descent;</span><br><span class="line">            runBounds<span class="variable">.size</span><span class="variable">.width</span> = CTRunGetTypographicBounds(run, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="number">0</span>), &amp;ascent, &amp;descent, <span class="literal">NULL</span>);</span><br><span class="line">            runBounds<span class="variable">.size</span><span class="variable">.height</span> = ascent + descent;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">CGFloat</span> xOffset = CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run)<span class="variable">.location</span>, <span class="literal">NULL</span>);</span><br><span class="line">            runBounds<span class="variable">.origin</span><span class="variable">.x</span> = lineOrigins[i]<span class="variable">.x</span> + xOffset;</span><br><span class="line">            runBounds<span class="variable">.origin</span><span class="variable">.y</span> = lineOrigins[i]<span class="variable">.y</span>;</span><br><span class="line">            runBounds<span class="variable">.origin</span><span class="variable">.y</span> -= descent;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">CGPathRef</span> pathRef = CTFrameGetPath(<span class="keyword">self</span><span class="variable">.ctFrame</span>);</span><br><span class="line">            <span class="built_in">CGRect</span> colRect = <span class="built_in">CGPathGetBoundingBox</span>(pathRef);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">CGRect</span> delegateBounds = <span class="built_in">CGRectOffset</span>(runBounds, colRect<span class="variable">.origin</span><span class="variable">.x</span>, colRect<span class="variable">.origin</span><span class="variable">.y</span>);</span><br><span class="line"></span><br><span class="line">            imageData<span class="variable">.imagePosition</span> = delegateBounds;</span><br><span class="line">            imgIndex++;</span><br><span class="line">            <span class="keyword">if</span> (imgIndex == <span class="keyword">self</span><span class="variable">.imageArray</span><span class="variable">.count</span>) &#123;</span><br><span class="line">                imageData = <span class="literal">nil</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                imageData = <span class="keyword">self</span><span class="variable">.imageArray</span>[imgIndex];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加对图片的点击支持">添加对图片的点击支持</h3><h4 id="实现方式">实现方式</h4><p>为了实现对图片的点击支持，我们需要给<code>CTDisplayView</code>类增加用户点击操作的检测函数，在检测函数中，判断当前用户点击的区域是否在图片上，如果在图片上，则触发点击图片的逻辑。苹果提供的<code>UITapGestureRecognizer</code>可以很好的满足我们的要求，所以我们这里用它来检测用户的点击操作。</p>
<p>我们这里实现的是点击图片后，先用NSLog打印出一行日志。实际应用中，读者可以根据业务需求自行调整点击后的效果。</p>
<p>我们先为CTDisplayView类增加<code>UITapGestureRecognizer</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithCoder:aDecoder];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> setupEvents];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setupEvents &#123;</span><br><span class="line">    <span class="built_in">UIGestureRecognizer</span> * tapRecognizer =</span><br><span class="line">          [[<span class="built_in">UITapGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span></span><br><span class="line">                    action:<span class="keyword">@selector</span>(userTapGestureDetected:)];</span><br><span class="line">    tapRecognizer<span class="variable">.delegate</span> = <span class="keyword">self</span>;</span><br><span class="line">    [<span class="keyword">self</span> addGestureRecognizer:tapRecognizer];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.userInteractionEnabled</span> = <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后增加<code>UITapGestureRecognizer</code>的回调函数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)userTapGestureDetected:(<span class="built_in">UIGestureRecognizer</span> *)recognizer &#123;</span><br><span class="line">    <span class="built_in">CGPoint</span> point = [recognizer locationInView:<span class="keyword">self</span>];</span><br><span class="line">    <span class="keyword">for</span> (CoreTextImageData * imageData <span class="keyword">in</span> <span class="keyword">self</span><span class="variable">.data</span><span class="variable">.imageArray</span>) &#123;</span><br><span class="line">        <span class="comment">// 翻转坐标系，因为 imageData 中的坐标是 CoreText 的坐标系</span></span><br><span class="line">        <span class="built_in">CGRect</span> imageRect = imageData<span class="variable">.imagePosition</span>;</span><br><span class="line">        <span class="built_in">CGPoint</span> imagePosition = imageRect<span class="variable">.origin</span>;</span><br><span class="line">        imagePosition<span class="variable">.y</span> = <span class="keyword">self</span><span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.height</span> - imageRect<span class="variable">.origin</span><span class="variable">.y</span></span><br><span class="line">                          - imageRect<span class="variable">.size</span><span class="variable">.height</span>;</span><br><span class="line">        <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(imagePosition<span class="variable">.x</span>, imagePosition<span class="variable">.y</span>, imageRect<span class="variable">.size</span><span class="variable">.width</span>, imageRect<span class="variable">.size</span><span class="variable">.height</span>);</span><br><span class="line">        <span class="comment">// 检测点击位置 Point 是否在 rect 之内</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">CGRectContainsPoint</span>(rect, point)) &#123;</span><br><span class="line">            <span class="comment">// 在这里处理点击后的逻辑</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"bingo"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="事件处理">事件处理</h4><p>在界面上，<code>CTDisplayView</code>通常在UIView的树形层级结构中，一个 UIView 可能是最外层 View Controller 的 View 的孩子的孩子的孩子（如下图所示）。在这种多级层次结构中，很难通过delegate模式将图片点击的事件一层一层往外层传递，所以最好使用NSNotification，来处理图片点击事件。</p>
<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-uiview-tree.png" alt=""></p>
<p>在 Demo 中，我们在最外层的 <code>View Controller</code>中监听图片点击的通知，当收到通知后，进入到一个新的界面来显示图片点击内容。</p>
<p>注：读者可以将 demo 工程切换到image_click分支，查看示例代码。</p>
<h4 id="添加对链接的点击支持">添加对链接的点击支持</h4><h5 id="修改模板文件">修改模板文件</h5><p>我们修改模版文件，增加一个名为 link 的类型，用于表示链接内容。如下所示：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; "<span class="attribute">color</span>" : <span class="value"><span class="string">"default"</span></span>,</span><br><span class="line">    "<span class="attribute">content</span>" : <span class="value"><span class="string">" 这在这里尝试放一个参考链接："</span></span>,</span><br><span class="line">    "<span class="attribute">type</span>" : <span class="value"><span class="string">"txt"</span></span><br><span class="line">  </span>&#125;,</span><br><span class="line">  &#123; "<span class="attribute">color</span>" : <span class="value"><span class="string">"blue"</span></span>,</span><br><span class="line">    "<span class="attribute">content</span>" : <span class="value"><span class="string">" 链接文字 "</span></span>,</span><br><span class="line">    "<span class="attribute">url</span>" : <span class="value"><span class="string">"http://blog.devtang.com"</span></span>,</span><br><span class="line">    "<span class="attribute">type</span>" : <span class="value"><span class="string">"link"</span></span><br><span class="line">  </span>&#125;,</span><br><span class="line">  &#123; "<span class="attribute">color</span>" : <span class="value"><span class="string">"default"</span></span>,</span><br><span class="line">    "<span class="attribute">content</span>" : <span class="value"><span class="string">" 大家可以尝试点击一下 "</span></span>,</span><br><span class="line">    "<span class="attribute">type</span>" : <span class="value"><span class="string">"txt"</span></span><br><span class="line">  </span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h5 id="解析模版中的链接信息">解析模版中的链接信息</h5><p>我们首先增加一个CoreTextLinkData类，用于记录解析 JSON 文件时的链接信息：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">CoreTextLinkData </span>: NSObject</span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span> (strong, nonatomic) NSString * title;</span><br><span class="line"><span class="variable">@property</span> (strong, nonatomic) NSString * url;</span><br><span class="line"><span class="variable">@property</span> (assign, nonatomic) NSRange range;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></p>
<p>然后我们修改 CTFrameParser 类，增加解析链接的逻辑：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">NSAttributedString</span> *)loadTemplateFile:(<span class="type">NSString</span> *)path</span><br><span class="line">                                  config:(<span class="type">CTFrameParserConfig</span>*)config</span><br><span class="line">                              imageArray:(<span class="type">NSMutableArray</span> *)imageArray</span><br><span class="line">                               linkArray:(<span class="type">NSMutableArray</span> *)linkArray &#123;</span><br><span class="line">    <span class="type">NSData</span> *data = [<span class="type">NSData</span> dataWithContentsOfFile:path];</span><br><span class="line">    <span class="type">NSMutableAttributedString</span> *<span class="literal">result</span> = [[<span class="type">NSMutableAttributedString</span> alloc] init];</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        <span class="type">NSArray</span> *<span class="type">array</span> = [<span class="type">NSJSONSerialization</span> <span class="type">JSONObjectWithData</span>:data</span><br><span class="line">                                        options:<span class="type">NSJSONReadingAllowFragments</span></span><br><span class="line">                                          error:<span class="keyword">nil</span>];</span><br><span class="line">        <span class="keyword">if</span> ([<span class="type">array</span> isKindOfClass:[<span class="type">NSArray</span> class]]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">NSDictionary</span> *dict <span class="keyword">in</span> <span class="type">array</span>) &#123;</span><br><span class="line">                <span class="type">NSString</span> *<span class="keyword">type</span> = dict[@<span class="string">"type"</span>];</span><br><span class="line">                <span class="keyword">if</span> ([<span class="keyword">type</span> isEqualToString:@<span class="string">"txt"</span>]) &#123;</span><br><span class="line">                    // 省略</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">type</span> isEqualToString:@<span class="string">"img"</span>]) &#123;</span><br><span class="line">                    // 省略</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">type</span> isEqualToString:@<span class="string">"link"</span>]) &#123;</span><br><span class="line">                    <span class="type">NSUInteger</span> startPos = <span class="literal">result</span>.length;</span><br><span class="line">                    <span class="type">NSAttributedString</span> *<span class="keyword">as</span> =</span><br><span class="line">                       [self parseAttributedContentFromNSDictionary:dict</span><br><span class="line">                                                             config:config];</span><br><span class="line">                    [<span class="literal">result</span> appendAttributedString:<span class="keyword">as</span>];</span><br><span class="line">                    // 创建 <span class="type">CoreTextLinkData</span></span><br><span class="line">                    <span class="type">NSUInteger</span> length = <span class="literal">result</span>.length - startPos;</span><br><span class="line">                    <span class="type">NSRange</span> linkRange = <span class="type">NSMakeRange</span>(startPos, length);</span><br><span class="line">                    <span class="type">CoreTextLinkData</span> *linkData = [[<span class="type">CoreTextLinkData</span> alloc] init];</span><br><span class="line">                    linkData.title = dict[@<span class="string">"content"</span>];</span><br><span class="line">                    linkData.url = dict[@<span class="string">"url"</span>];</span><br><span class="line">                    linkData.<span class="type">range</span> = linkRange;</span><br><span class="line">                    [linkArray addObject:linkData];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们增加一个 Utils 类来专门处理检测用户点击是否在链接上。主要的方法是使用 CTLineGetStringIndexForPosition 函数来获得用户点击的位置与 NSAttributedString 字符串上的位置的对应关系。这样就知道是点击的哪个字符了。然后判断该字符串是否在链接上即可。该 Util 在实现逻辑如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检测点击位置是否在链接上</span></span><br><span class="line">+ (CoreTextLinkData *)touchLinkInView:(<span class="built_in">UIView</span> *)view atPoint:(<span class="built_in">CGPoint</span>)point data:(CoreTextData *)data &#123;</span><br><span class="line">    CTFrameRef textFrame = data<span class="variable">.ctFrame</span>;</span><br><span class="line">    <span class="built_in">CFArrayRef</span> lines = CTFrameGetLines(textFrame);</span><br><span class="line">    <span class="keyword">if</span> (!lines) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">CFIndex</span> count = <span class="built_in">CFArrayGetCount</span>(lines);</span><br><span class="line">    CoreTextLinkData *foundLink = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得每一行的 origin 坐标</span></span><br><span class="line">    <span class="built_in">CGPoint</span> origins[count];</span><br><span class="line">    CTFrameGetLineOrigins(textFrame, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>,<span class="number">0</span>), origins);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 翻转坐标系</span></span><br><span class="line">    <span class="built_in">CGAffineTransform</span> transform =  <span class="built_in">CGAffineTransformMakeTranslation</span>(<span class="number">0</span>, view<span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.height</span>);</span><br><span class="line">    transform = <span class="built_in">CGAffineTransformScale</span>(transform, <span class="number">1.</span>f, -<span class="number">1.</span>f);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="built_in">CGPoint</span> linePoint = origins[i];</span><br><span class="line">        CTLineRef line = <span class="built_in">CFArrayGetValueAtIndex</span>(lines, i);</span><br><span class="line">        <span class="comment">// 获得每一行的 CGRect 信息</span></span><br><span class="line">        <span class="built_in">CGRect</span> flippedRect = [<span class="keyword">self</span> getLineBounds:line point:linePoint];</span><br><span class="line">        <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectApplyAffineTransform</span>(flippedRect, transform);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">CGRectContainsPoint</span>(rect, point)) &#123;</span><br><span class="line">            <span class="comment">// 将点击的坐标转换成相对于当前行的坐标</span></span><br><span class="line">            <span class="built_in">CGPoint</span> relativePoint = <span class="built_in">CGPointMake</span>(point<span class="variable">.x</span>-<span class="built_in">CGRectGetMinX</span>(rect),</span><br><span class="line">                                                point<span class="variable">.y</span>-<span class="built_in">CGRectGetMinY</span>(rect));</span><br><span class="line">            <span class="comment">// 获得当前点击坐标对应的字符串偏移</span></span><br><span class="line">            <span class="built_in">CFIndex</span> idx = CTLineGetStringIndexForPosition(line, relativePoint);</span><br><span class="line">            <span class="comment">// 判断这个偏移是否在我们的链接列表中</span></span><br><span class="line">            foundLink = [<span class="keyword">self</span> linkAtIndex:idx linkArray:data<span class="variable">.linkArray</span>];</span><br><span class="line">            <span class="keyword">return</span> foundLink;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">CGRect</span>)getLineBounds:(CTLineRef)line point:(<span class="built_in">CGPoint</span>)point &#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> ascent = <span class="number">0.0</span>f;</span><br><span class="line">    <span class="built_in">CGFloat</span> descent = <span class="number">0.0</span>f;</span><br><span class="line">    <span class="built_in">CGFloat</span> leading = <span class="number">0.0</span>f;</span><br><span class="line">    <span class="built_in">CGFloat</span> width = (<span class="built_in">CGFloat</span>)CTLineGetTypographicBounds(line, &amp;ascent, &amp;descent, &amp;leading);</span><br><span class="line">    <span class="built_in">CGFloat</span> height = ascent + descent;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGRectMake</span>(point<span class="variable">.x</span>, point<span class="variable">.y</span> - descent, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (CoreTextLinkData *)linkAtIndex:(<span class="built_in">CFIndex</span>)i linkArray:(<span class="built_in">NSArray</span> *)linkArray &#123;</span><br><span class="line">    CoreTextLinkData *link = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">for</span> (CoreTextLinkData *data <span class="keyword">in</span> linkArray) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">NSLocationInRange</span>(i, data<span class="variable">.range</span>)) &#123;</span><br><span class="line">            link = data;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> link;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后改造一下CTDisplayView，使其在检测到用户点击后，调用上面的 Util 方法即可。我们这里实现的是点击链接后，先用NSLog打印出一行日志。实际应用中，读者可以根据业务需求自行调整点击后的效果。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)userTapGestureDetected:(<span class="built_in">UIGestureRecognizer</span> *)recognizer &#123;</span><br><span class="line">    <span class="built_in">CGPoint</span> point = [recognizer locationInView:<span class="keyword">self</span>];</span><br><span class="line">    <span class="comment">// 此处省略上一节中介绍的，对图片点击检测的逻辑</span></span><br><span class="line"></span><br><span class="line">    CoreTextLinkData *linkData = [CoreTextUtils touchLinkInView:<span class="keyword">self</span> atPoint:point data:<span class="keyword">self</span><span class="variable">.data</span>];</span><br><span class="line">    <span class="keyword">if</span> (linkData) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"hint link!"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：在 Demo 中工程中，我们实现了点击链接跳转到一个新的界面，然后用 UIWebView 来显示链接内容的逻辑。读者可以将 demo 工程切换到link_click分支，查看示例代码。</p>
<p>Demo 工程的 Gif 效果图如下，读者可以将示例工程用git checkout image_support切换到当前章节状态，查看相关代码逻辑。</p>
<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-demo.gif" alt=""></p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/07/19/iOS-CoreText-Base/">
                iOS CoreText Base
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2015-07-19
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/IOS/">IOS</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/07/19/iOS-CoreText-Base/#comments" >
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/07/19/iOS-CoreText-Base/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p><a href="http://blog.devtang.com/blog/2015/06/27/using-coretext-1/" target="_blank" rel="external">转自</a></p>
<h2 id="转载声明">转载声明</h2><p>原创文章，转载请保留以下信息：</p>
<p>本文节选自我的图书：《iOS 开发进阶 》。<br>本文涉及的 Demo 工程在这里：<a href="https://github.com/tangqiaoboy/iOS-Pro。" target="_blank" rel="external">https://github.com/tangqiaoboy/iOS-Pro。</a><br>扫码关注我的「iOS 开发」微信公众帐号：<br><img src="http://blog.devtang.com/images/weixin-qr.jpg" alt=""></p>
<h2 id="基于_CoreText_的排版引擎：基础">基于 CoreText 的排版引擎：基础</h2><p>使用 CoreText 技术，我们可以对富文本进行复杂的排版。经过一些简单的扩展，我们还可以实现对于图片，链接的点击效果。CoreText 技术相对于 UIWebView，有着更少的内存占用，以及可以在后台渲染的优点，非常适合用于内容的排版工作。</p>
<p>本章我们将从最基本的开始，一步一步完成一个支持图文混排、支持图片和链接点击的排版引擎。</p>
<h3 id="CoreText_简介">CoreText 简介</h3><p>CoreText 是用于处理文字和字体的底层技术。它直接和 Core Graphics（又被称为 Quartz）打交道。Quartz 是一个 2D 图形渲染引擎，能够处理 OSX 和 iOS 中的图形显示。</p>
<p>Quartz 能够直接处理字体（font）和字形（glyphs），将文字渲染到界面上，它是基础库中唯一能够处理字形的模块。因此，CoreText 为了排版，需要将显示的文本内容、位置、字体、字形直接传递给 Quartz。相比其它 UI 组件，由于 CoreText 直接和 Quartz 来交互，所以它具有高速的排版效果。</p>
<p>下图是 CoreText 的架构图，可以看到，CoreText 处于非常底层的位置，上层的 UI 控件（包括 UILabel，UITextField 以及 UITextView）和 UIWebView 都是基于 CoreText 来实现的。</p>
<blockquote>
<p>注意：这个是 iOS7 之后的架构图，在 iOS7 以前，并没有图中的 Text Kit 类，不过 CoreText 仍然是处在最底层直接和 Core Graphics 打交道的模块。</p>
</blockquote>
<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext_arch.png" alt=""></p>
<p>UIWebView 也是处理复杂的文字排版的备选方案。对于排版，基于 CoreText 和基于 UIWebView 相比，前者有以下好处：</p>
<ul>
<li>CoreText 占用的内存更少，渲染速度快，UIWebView 占用的内存更多，渲染速度慢。</li>
<li>CoreText 在渲染界面前就可以精确地获得显示内容的高度（只要有了 CTFrame 即可），而 UIWebView 只有渲染出内容后，才能获得内容的高度（而且还需要用 javascript 代码来获取）</li>
<li>CoreText 的 CTFrame 可以在后台线程渲染，UIWebView 的内容只能在主线程（UI 线程）渲染。</li>
<li>基于 CoreText 可以做更好的原生交互效果，交互效果可以更细腻。而 UIWebView 的交互效果都是用 javascript 来实现的，在交互效果上会有一些卡顿存在。例如，在 UIWebView 下，一个简单的按钮按下效果，都无法做到原生按钮的即时和细腻的按下效果。</li>
</ul>
<p>当然，基于 CoreText 的排版方案也有一些劣势：</p>
<ul>
<li>CoreText 渲染出来的内容不能像 UIWebView 那样方便地支持内容的复制。</li>
<li>基于 CoreText 来排版需要自己处理很多复杂逻辑，例如需要自己处理图片与文字混排相关的逻辑，也需要自己实现链接点击操作的支持。</li>
</ul>
<p>在业界，很多应用都采用了基于 CoreText 技术的排版方案，例如：新浪微博客户端，多看阅读客户端。我所在的创业公司的猿题库，也使用了自己基于 CoreText 技术实现的排版引擎，下图是我们产品的一个图文混排的界面（其中所有公式都是用图片的方式呈现的），可以看到，图片和文字排版效果很好。</p>
<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-1.png" alt=""></p>
<h3 id="基于_CoreText_的基础排版引擎">基于 CoreText 的基础排版引擎</h3><h4 id="不带图片的排版引擎">不带图片的排版引擎</h4><p>下面我们来尝试完成一个基于 CoreText 的排版引擎。我们将从最简单的排版功能开始，然后逐步支持图文混排，链接点击等功能。</p>
<p>首先我们来尝试完成一个不支持图片内容的纯文字排版引擎。</p>
<p>注意 1：由于整个排版引擎的代码太多，为方便读者阅读，文章中只会列出最关键的核心代码，完整的代码请参考本书对应的 github 项目，项目地址是：<a href="https://github.com/tangqiaoboy/iOS-Pro" target="_blank" rel="external">https://github.com/tangqiaoboy/iOS-Pro</a></p>
<h4 id="能输出_Hello_World_的_CoreText_工程">能输出 Hello World 的 CoreText 工程</h4><h5 id="操作步骤">操作步骤</h5><ol>
<li>建立 <code>CoreTextDemo</code> 工程</li>
<li>新建 <code>UIView</code> 子类CTDisplayView</li>
<li>编码如下:</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"CTDisplayView.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"CoreText/CoreText.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CTDisplayView</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> drawRect:rect];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 1</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 2</span></span><br><span class="line">    <span class="built_in">CGContextSetTextMatrix</span>(context, <span class="built_in">CGAffineTransformIdentity</span>);</span><br><span class="line">    <span class="built_in">CGContextTranslateCTM</span>(context, <span class="number">0</span>, <span class="keyword">self</span><span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.height</span>);</span><br><span class="line">    <span class="built_in">CGContextScaleCTM</span>(context, <span class="number">1.0</span>, -<span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 3</span></span><br><span class="line">    <span class="built_in">CGMutablePathRef</span> path = <span class="built_in">CGPathCreateMutable</span>();</span><br><span class="line">    <span class="built_in">CGPathAddRect</span>(path, <span class="literal">NULL</span>, <span class="keyword">self</span><span class="variable">.bounds</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 4</span></span><br><span class="line">    <span class="built_in">NSAttributedString</span> *attString = [[<span class="built_in">NSAttributedString</span> alloc] initWithString:<span class="string">@"Hello World!"</span>];</span><br><span class="line">    CTFramesetterRef framesetter =</span><br><span class="line">    CTFramesetterCreateWithAttributedString((<span class="built_in">CFAttributedStringRef</span>)attString);</span><br><span class="line">    CTFrameRef frame =</span><br><span class="line">    CTFramesetterCreateFrame(framesetter,</span><br><span class="line">                             <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, [attString length]), path, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 5</span></span><br><span class="line">    CTFrameDraw(frame, context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 6</span></span><br><span class="line">    <span class="built_in">CFRelease</span>(frame);</span><br><span class="line">    <span class="built_in">CFRelease</span>(path);</span><br><span class="line">    <span class="built_in">CFRelease</span>(framesetter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<ol>
<li>打开 Storyboard 文件, 新建<code>UIView</code> 并更改类为<code>CTDisplayView</code></li>
</ol>
<h4 id="代码解释">代码解释</h4><p>下面解释一下drawRect方法主要的步骤：</p>
<ol>
<li>得到当前绘制画布的上下文，用于后续将内容绘制在画布上。</li>
<li>将坐标系上下翻转。对于底层的绘制引擎来说，屏幕的左下角是（0, 0）坐标。而对于上层的 UIKit 来说，左上角是 (0, 0) 坐标。所以我们为了之后的坐标系描述按 UIKit 来做，所以先在这里做一个坐标系的上下翻转操作。翻转之后，底层和上层的 (0, 0) 坐标就是重合的了</li>
<li>创建绘制的区域，CoreText 本身支持各种文字排版的区域，我们这里简单地将 UIView 的整个界面作为排版的区域。</li>
</ol>
<p>为了加深理解，我们将该步骤的代码替换成如下代码，测试设置不同的绘制区域带来的界面变化。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤 3</span></span><br><span class="line"><span class="built_in">CGMutablePathRef</span> path = <span class="built_in">CGPathCreateMutable</span>();</span><br><span class="line"><span class="built_in">CGPathAddEllipseInRect</span>(path, <span class="literal">NULL</span>, <span class="keyword">self</span><span class="variable">.bounds</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤 4</span></span><br><span class="line"><span class="built_in">NSAttributedString</span> *attString = [[<span class="built_in">NSAttributedString</span> alloc] initWithString:<span class="string">@"Hello World! "</span></span><br><span class="line">                                 <span class="string">" 创建绘制的区域，CoreText 本身支持各种文字排版的区域，"</span></span><br><span class="line">                                 <span class="string">" 我们这里简单地将 UIView 的整个界面作为排版的区域。"</span></span><br><span class="line">                                 <span class="string">" 为了加深理解，建议读者将该步骤的代码替换成如下代码，"</span></span><br><span class="line">                                 <span class="string">" 测试设置不同的绘制区域带来的界面变化。"</span>];</span><br></pre></td></tr></table></figure></p>
<p>执行结果如下图所示：<br><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-shape.png" alt=""></p>
<h4 id="代码基本的宏定义和_Category">代码基本的宏定义和 Category</h4><p>为了方便我们的代码编写，我在CoreTextDemo-Prefix.pch文件中增加了以下基本的宏定义，以方便我们使用 NSLog 和 UIColor<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="id">#ifdef</span> DEBUG</span><br><span class="line"><span class="hexcolor">#def</span>ine <span class="function"><span class="title">debugLog</span><span class="params">(...)</span></span> <span class="function"><span class="title">NSLog</span><span class="params">(__VA_ARGS__)</span></span></span><br><span class="line"><span class="hexcolor">#def</span>ine <span class="function"><span class="title">debugMethod</span><span class="params">()</span></span> <span class="function"><span class="title">NSLog</span><span class="params">(@<span class="string">"%s"</span>, __func__)</span></span></span><br><span class="line"><span class="id">#else</span></span><br><span class="line"><span class="hexcolor">#def</span>ine <span class="function"><span class="title">debugLog</span><span class="params">(...)</span></span></span><br><span class="line"><span class="hexcolor">#def</span>ine <span class="function"><span class="title">debugMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="id">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="hexcolor">#def</span>ine <span class="function"><span class="title">RGB</span><span class="params">(A, B, C)</span></span>    [UIColor colorWithRed:A/<span class="number">255.0</span> green:B/<span class="number">255.0</span> blue:C/<span class="number">255.0</span> alpha:<span class="number">1.0</span>]</span><br></pre></td></tr></table></figure></p>
<p>我也为 UIView 的 frame 调整增加了一些扩展，可以方便地调整 UIView 的 x, y, width, height 等值。部分关键代码如下（完整的代码请查看示例工程）</p>
<p>UIView+frameAdjust.h 文件:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIView</span> (<span class="title">frameAdjust</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGFloat</span>)x;</span><br><span class="line">- (<span class="keyword">void</span>)setX:(<span class="built_in">CGFloat</span>)x;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGFloat</span>)y;</span><br><span class="line">- (<span class="keyword">void</span>)setY:(<span class="built_in">CGFloat</span>)y;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGFloat</span>)height;</span><br><span class="line">- (<span class="keyword">void</span>)setHeight:(<span class="built_in">CGFloat</span>)height;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGFloat</span>)width;</span><br><span class="line">- (<span class="keyword">void</span>)setWidth:(<span class="built_in">CGFloat</span>)width;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>UIView+frameAdjust.m 文件：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIView</span> (<span class="title">frameAdjust</span>)</span></span><br><span class="line">- (<span class="built_in">CGFloat</span>)x &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.frame</span><span class="variable">.origin</span><span class="variable">.x</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setX:(<span class="built_in">CGFloat</span>)x &#123;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(x, <span class="keyword">self</span><span class="variable">.y</span>, <span class="keyword">self</span><span class="variable">.width</span>, <span class="keyword">self</span><span class="variable">.height</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGFloat</span>)y &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.frame</span><span class="variable">.origin</span><span class="variable">.y</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setY:(<span class="built_in">CGFloat</span>)y &#123;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(<span class="keyword">self</span><span class="variable">.x</span>, y, <span class="keyword">self</span><span class="variable">.width</span>, <span class="keyword">self</span><span class="variable">.height</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGFloat</span>)height &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.height</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)setHeight:(<span class="built_in">CGFloat</span>)height &#123;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(<span class="keyword">self</span><span class="variable">.x</span>, <span class="keyword">self</span><span class="variable">.y</span>, <span class="keyword">self</span><span class="variable">.width</span>, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGFloat</span>)width &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.width</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)setWidth:(<span class="built_in">CGFloat</span>)width &#123;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(<span class="keyword">self</span><span class="variable">.x</span>, <span class="keyword">self</span><span class="variable">.y</span>, width, <span class="keyword">self</span><span class="variable">.height</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>文章中的其余代码默认都#import 了以上提到的宏定义和 UIView Category。</p>
<h3 id="排版引擎框架">排版引擎框架</h3><p>上面的 Hello World 工程仅仅展示了 Core Text 排版的基本能力。但是要制作一个较完善的排版引擎，我们不能简单的将所有代码都放到 CTDisplayView 的drawRect方法里面。根据设计模式中的 “ 单一功能原则 ”(Single responsibility principle)，我们应该把功能拆分，把不同的功能都放到各自不同的类里面。</p>
<p>对于一个复杂的排版引擎来说，可以将其功能拆成以下几个类来完成：</p>
<ol>
<li>一个显示用的类，仅负责显示内容，不负责排版</li>
<li>一个模型类，用于承载显示所需要的所有数据</li>
<li>一个排版类，用于实现文字内容的排版</li>
<li>一个配置类，用于实现一些排版时的可配置项</li>
</ol>
<blockquote>
<p>注：” 单一功能原则 “(Single responsibility principle) 参考链接：<a href="http://zh.wikipedia.org/wiki/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99" target="_blank" rel="external">http://zh.wikipedia.org/wiki/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99</a></p>
</blockquote>
<p>按照以上原则，我们将CTDisplayView中的部分内容拆开，由 4 个类构成：</p>
<ol>
<li><code>CTFrameParserConfig</code>类，用于配置绘制的参数，例如：文字颜色，大小，行间距等。</li>
<li><code>CTFrameParser</code>类，用于生成最后绘制界面需要的CTFrameRef实例。</li>
<li><code>CoreTextData</code>类，用于保存由CTFrameParser类生成的CTFrameRef实例以及CTFrameRef实际绘制需要的高度。</li>
<li><code>CTDisplayView</code>类，持有CoreTextData类的实例，负责将CTFrameRef绘制到界面上。</li>
</ol>
<p>关于这 4 个类的关键代码如下：</p>
<p>1) CTFrameParserConfig类:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CTFrameParserConfig</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> width;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> fontSize;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> lineSpace;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *textColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="title">"CTFrameParserConfig.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CTFrameParserConfig</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _width = <span class="number">200.0</span>f;</span><br><span class="line">        _fontSize = <span class="number">16.0</span>f;</span><br><span class="line">        _lineSpace = <span class="number">8.0</span>f;</span><br><span class="line">        _textColor = RGB(<span class="number">108</span>, <span class="number">108</span>, <span class="number">108</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>2) CTFrameParser类:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"CoreTextData.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"CTFrameParserConfig.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CTFrameParser</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">+ (CoreTextData *)parseContent:(<span class="built_in">NSString</span> *)content config:(CTFrameParserConfig*)config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="title">"CTFrameParser.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"CTFrameParserConfig.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CTFrameParser</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSDictionary</span> *)attributesWithConfig:(CTFrameParserConfig *)config &#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> fontSize = config<span class="variable">.fontSize</span>;</span><br><span class="line">    CTFontRef fontRef = CTFontCreateWithName((<span class="built_in">CFStringRef</span>)<span class="string">@"ArialMT"</span>, fontSize, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">CGFloat</span> lineSpacing = config<span class="variable">.lineSpace</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">CFIndex</span> kNumberOfSettings = <span class="number">3</span>;</span><br><span class="line">    CTParagraphStyleSetting theSettings[kNumberOfSettings] = &#123;</span><br><span class="line">        &#123; kCTParagraphStyleSpecifierLineSpacingAdjustment, <span class="keyword">sizeof</span>(<span class="built_in">CGFloat</span>), &amp;lineSpacing &#125;,</span><br><span class="line">        &#123; kCTParagraphStyleSpecifierMaximumLineSpacing, <span class="keyword">sizeof</span>(<span class="built_in">CGFloat</span>), &amp;lineSpacing &#125;,</span><br><span class="line">        &#123; kCTParagraphStyleSpecifierMinimumLineSpacing, <span class="keyword">sizeof</span>(<span class="built_in">CGFloat</span>), &amp;lineSpacing &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    CTParagraphStyleRef theParagraphRef = CTParagraphStyleCreate(theSettings, kNumberOfSettings);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIColor</span> * textColor = config<span class="variable">.textColor</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> * dict = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    dict[(<span class="keyword">id</span>)kCTForegroundColorAttributeName] = (<span class="keyword">id</span>)textColor<span class="variable">.CGColor</span>;</span><br><span class="line">    dict[(<span class="keyword">id</span>)kCTFontAttributeName] = (__bridge <span class="keyword">id</span>)fontRef;</span><br><span class="line">    dict[(<span class="keyword">id</span>)kCTParagraphStyleAttributeName] = (__bridge <span class="keyword">id</span>)theParagraphRef;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CFRelease</span>(theParagraphRef);</span><br><span class="line">    <span class="built_in">CFRelease</span>(fontRef);</span><br><span class="line">    <span class="keyword">return</span> dict;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (CoreTextData *)parseContent:(<span class="built_in">NSString</span> *)content config:(CTFrameParserConfig*)config &#123;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *attributes = [<span class="keyword">self</span> attributesWithConfig:config];</span><br><span class="line">    <span class="built_in">NSAttributedString</span> *contentString =</span><br><span class="line">        [[<span class="built_in">NSAttributedString</span> alloc] initWithString:content</span><br><span class="line">                                        attributes:attributes];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 CTFramesetterRef 实例</span></span><br><span class="line">    CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((<span class="built_in">CFAttributedStringRef</span>)contentString);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得要绘制的区域的高度</span></span><br><span class="line">    <span class="built_in">CGSize</span> restrictSize = <span class="built_in">CGSizeMake</span>(config<span class="variable">.width</span>, <span class="built_in">CGFLOAT_MAX</span>);</span><br><span class="line">    <span class="built_in">CGSize</span> coreTextSize = CTFramesetterSuggestFrameSizeWithConstraints(framesetter, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>,<span class="number">0</span>), <span class="literal">nil</span>, restrictSize, <span class="literal">nil</span>);</span><br><span class="line">    <span class="built_in">CGFloat</span> textHeight = coreTextSize<span class="variable">.height</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成 CTFrameRef 实例</span></span><br><span class="line">    CTFrameRef frame = [<span class="keyword">self</span> createFrameWithFramesetter:framesetter config:config height:textHeight];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将生成好的 CTFrameRef 实例和计算好的绘制高度保存到 CoreTextData 实例中，最后返回 CoreTextData 实例</span></span><br><span class="line">    CoreTextData *data = [[CoreTextData alloc] init];</span><br><span class="line">    data<span class="variable">.ctFrame</span> = frame;</span><br><span class="line">    data<span class="variable">.height</span> = textHeight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">CFRelease</span>(frame);</span><br><span class="line">    <span class="built_in">CFRelease</span>(framesetter);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (CTFrameRef)createFrameWithFramesetter:(CTFramesetterRef)framesetter</span><br><span class="line">                                  config:(CTFrameParserConfig *)config</span><br><span class="line">                                  height:(<span class="built_in">CGFloat</span>)height &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGMutablePathRef</span> path = <span class="built_in">CGPathCreateMutable</span>();</span><br><span class="line">    <span class="built_in">CGPathAddRect</span>(path, <span class="literal">NULL</span>, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, config<span class="variable">.width</span>, height));</span><br><span class="line"></span><br><span class="line">    CTFrameRef frame = CTFramesetterCreateFrame(framesetter, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="number">0</span>), path, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">CFRelease</span>(path);</span><br><span class="line">    <span class="keyword">return</span> frame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>CoreTextData类:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CoreTextData</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) CTFrameRef ctFrame;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> height;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="title">"CoreTextData.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CoreTextData</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setCtFrame:(CTFrameRef)ctFrame &#123;</span><br><span class="line">    <span class="keyword">if</span> (_ctFrame != ctFrame) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_ctFrame != <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(_ctFrame);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">CFRetain</span>(ctFrame);</span><br><span class="line">        _ctFrame = ctFrame;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    <span class="keyword">if</span> (_ctFrame != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="built_in">CFRelease</span>(_ctFrame);</span><br><span class="line">        _ctFrame = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>CTDisplayView类：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"CoreTextData.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CTDisplayView</span> : <span class="title">UIView</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) CoreTextData * data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">import <span class="string">"CTDisplayView.h"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CTDisplayView</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> drawRect:rect];</span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    <span class="built_in">CGContextSetTextMatrix</span>(context, <span class="built_in">CGAffineTransformIdentity</span>);</span><br><span class="line">    <span class="built_in">CGContextTranslateCTM</span>(context, <span class="number">0</span>, <span class="keyword">self</span><span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.height</span>);</span><br><span class="line">    <span class="built_in">CGContextScaleCTM</span>(context, <span class="number">1.0</span>, -<span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.data</span>) &#123;</span><br><span class="line">        CTFrameDraw(<span class="keyword">self</span><span class="variable">.data</span><span class="variable">.ctFrame</span>, context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>以上 4 个类中的逻辑与之前 Hello World 那个项目的逻辑基本一致，只是分拆到了 4 个类中完成。另外，<code>CTFrameParser</code> 增加了方法来获得要绘制的区域的高度，并将高度信息保存到CoreTextData类的实例中。之所以要获得绘制区域的高度，是因为在很多实际使用场景中，我们需要先知道所要显示内容的高度，之后才可以进行绘制。</p>
<p>例如，在 UITableView 在渲染时，UITableView 首先会向 delegate 回调如下方法来获得每个将要渲染的 cell 的高度：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (<span class="tag">CGFloat</span>)<span class="rule"><span class="attribute">tableView</span>:<span class="value">(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>之后，UITableView 会计算当前滚动的位置具体需要绘制的 UITableViewCell 是哪些，然后对于那些需要绘制的 Cell，UITableView 才会继续向其 data source 回调如下方法来获得 UITableViewCell 实例：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (<span class="tag">UITableViewCell</span> *)<span class="rule"><span class="attribute">cellForRowAtIndexPath</span>:<span class="value">(NSIndexPath *)indexPath</span></span>;</span><br></pre></td></tr></table></figure>
<p>对于上面的情况，如果我们使用 CoreText 来作为 TableViewCell 的内容，那么就必须在每个 Cell 绘制之前，就知道其需要的绘制高度，否则 UITableView 将无法正常工作。</p>
<p>完成以上 4 个类之后，我们就可以简单地在<code>ViewController.m</code>文件中，加入如下代码来配置CTDisplayView的显示内容，位置，高度，字体，颜色等信息。代码如下所示。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> CTDisplayView *ctView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    CTFrameParserConfig *config = [[CTFrameParserConfig alloc] init];</span><br><span class="line">    config<span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    config<span class="variable">.width</span> = <span class="keyword">self</span><span class="variable">.ctView</span><span class="variable">.width</span>;</span><br><span class="line"></span><br><span class="line">    CoreTextData *data = [CTFrameParser parseContent:<span class="string">@" 按照以上原则，我们将`CTDisplayView`中的部分内容拆开。"</span> config:config];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.ctView</span><span class="variable">.data</span> = data;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.ctView</span><span class="variable">.height</span> = data<span class="variable">.height</span>;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.ctView</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> yellowColor];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>注意：从 Xcode4.0 开始，默认的界面编辑就开启了对于Use Autolayout的使用，但因为我们在代码中直接修改了变量ctView的 frame 信息，所以需要在Main_iPhone.storyboard中将Use Autolayout这一项取消勾选。如下图所示：</p>
<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-un-select-autolayout.png" alt=""></p>
<p>以下是本框架的 UML 示意图，从图中我们可以看出，这 4 个 Core Text 类的关系是这样的：</p>
<ol>
<li><code>CTFrameParser</code>通过<code>CTFrameparserConfig</code>实例来生成CoreTextData实例。</li>
<li><code>CTDisplayView</code>通过持有<code>CoreTextData</code>实例来获得绘制所需要的所有信息。</li>
<li>ViewController类通过配置<code>CTFrameparserConfig</code>实例，进而获得生成的<code>CoreTextData</code>实例，最后将其赋值给他的<code>CTDisplayView</code>成员，达到将指定内容显示在界面上的效果</li>
</ol>
<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-uml.png" alt=""></p>
<p>说明 1：整个工程代码在名为<code>basic_arch</code>的分支下，读者可以在示例的源代码工程中使用<code>git checkout basic_arch</code>来切换到当前讲解的工程示例代码。</p>
<p>说明 2：为了方便操作UIView的frame属性，项目中增加了一个名为UIView+frameAdjust.m文件，它通过Category来给UIView增加了直接设置height属性的方法。</p>
<h4 id="定制排版文件格式">定制排版文件格式</h4><p>对于上面的例子，我们给 <code>CTFrameParser</code> 使增加了一个将 NSString 转换为 <code>CoreTextData</code> 的方法。但这样的实现方式有很多局限性，因为整个内容虽然可以定制字体大小，颜色，行高等信息，但是却不能支持定制内容中的某一部分。例如，如果我们只想让内容的前三个字显示成红色，而其它文字显示成黑色，那么就办不到了。</p>
<p>解决的办法很简单，我们让<code>CTFrameParser</code>支持接受 <code>NSAttributeString</code> 作为参数，然后在ViewController类中设置我们想要的 NSAttributeString 信息。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    CTFrameParserConfig *config = [[CTFrameParserConfig alloc] init];</span><br><span class="line">    config<span class="variable">.width</span> = <span class="keyword">self</span><span class="variable">.ctView</span><span class="variable">.width</span>;</span><br><span class="line">    config<span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> blackColor];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *content =</span><br><span class="line">        <span class="string">@" 对于上面的例子，我们给 CTFrameParser 增加了一个将 NSString 转 "</span></span><br><span class="line">         <span class="string">" 换为 CoreTextData 的方法。"</span></span><br><span class="line">         <span class="string">" 但这样的实现方式有很多局限性，因为整个内容虽然可以定制字体 "</span></span><br><span class="line">         <span class="string">" 大小，颜色，行高等信息，但是却不能支持定制内容中的某一部分。"</span></span><br><span class="line">         <span class="string">" 例如，如果我们只想让内容的前三个字显示成红色，而其它文字显 "</span></span><br><span class="line">         <span class="string">" 示成黑色，那么就办不到了。"</span></span><br><span class="line">         <span class="string">"\n\n"</span></span><br><span class="line">         <span class="string">" 解决的办法很简单，我们让`CTFrameParser`支持接受 "</span></span><br><span class="line">         <span class="string">"NSAttributeString 作为参数，然后在 NSAttributeString 中设置好 "</span></span><br><span class="line">         <span class="string">" 我们想要的信息。"</span>;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *attr = [CTFrameParser attributesWithConfig:config];</span><br><span class="line">    <span class="built_in">NSMutableAttributedString</span> *attributedString =</span><br><span class="line">         [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:content</span><br><span class="line">                                                attributes:attr];</span><br><span class="line">    [attributedString addAttribute:<span class="built_in">NSForegroundColorAttributeName</span></span><br><span class="line">                             value:[<span class="built_in">UIColor</span> redColor]</span><br><span class="line">                             range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">7</span>)];</span><br><span class="line"></span><br><span class="line">    CoreTextData *data = [CTFrameParser parseAttributedContent:attributedString</span><br><span class="line">                                                        config:config];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.ctView</span><span class="variable">.data</span> = data;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.ctView</span><span class="variable">.height</span> = data<span class="variable">.height</span>;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.ctView</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> yellowColor];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>结果如下图所示，我们很方便就把前面 7 个字变成了红色。<br><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-attribute-string-as-argument.png" alt=""></p>
<p>更进一步地，实际工作中，我们更希望通过一个排版文件，来设置需要排版的文字的内容、颜色、字体大小等信息。我在开发猿题库应用时，自己定义了一个基于 UBB 的排版模版，但是实现该排版文件的解析器要花费大量的篇幅，考虑到这并不是本章的重点，所以我们以一个较简单的排版文件来讲解其思想。</p>
<p>我们规定排版的模版文件为 <code>JSON</code> 格式。JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，易于阅读和编写，同时也易于机器解析和生成。iOS 从 5.0 开始，提供了名为NSJSONSerialization的类库来方便开发者对 JSON 的解析。在 iOS5.0 之前，业界也有很多相关的 JSON 解析开源库，例如 JSONKit 可供大家使用。</p>
<p>我们的排版模版示例文件如下所示：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[ &#123; "<span class="attribute">color</span>" : <span class="value"><span class="string">"blue"</span></span>,</span><br><span class="line">    "<span class="attribute">content</span>" : <span class="value"><span class="string">" 更进一步地，实际工作中，我们更希望通过一个排版文件，来设置需要排版的文字的 "</span></span>,</span><br><span class="line">    "<span class="attribute">size</span>" : <span class="value"><span class="number">16</span></span>,</span><br><span class="line">    "<span class="attribute">type</span>" : <span class="value"><span class="string">"txt"</span></span><br><span class="line">  </span>&#125;,</span><br><span class="line">  &#123; "<span class="attribute">color</span>" : <span class="value"><span class="string">"red"</span></span>,</span><br><span class="line">    "<span class="attribute">content</span>" : <span class="value"><span class="string">" 内容、颜色、字体 "</span></span>,</span><br><span class="line">    "<span class="attribute">size</span>" : <span class="value"><span class="number">22</span></span>,</span><br><span class="line">    "<span class="attribute">type</span>" : <span class="value"><span class="string">"txt"</span></span><br><span class="line">  </span>&#125;,</span><br><span class="line">  &#123; "<span class="attribute">color</span>" : <span class="value"><span class="string">"black"</span></span>,</span><br><span class="line">    "<span class="attribute">content</span>" : <span class="value"><span class="string">" 大小等信息。\n"</span></span>,</span><br><span class="line">    "<span class="attribute">size</span>" : <span class="value"><span class="number">16</span></span>,</span><br><span class="line">    "<span class="attribute">type</span>" : <span class="value"><span class="string">"txt"</span></span><br><span class="line">  </span>&#125;,</span><br><span class="line">  &#123; "<span class="attribute">color</span>" : <span class="value"><span class="string">"default"</span></span>,</span><br><span class="line">    "<span class="attribute">content</span>" : <span class="value"><span class="string">" 我在开发猿题库应用时，自己定义了一个基于 UBB 的排版模版，但是实现该排版文件的解析器要花费大量的篇幅，考虑到这并不是本章的重点，所以我们以一个较简单的排版文件来讲解其思想。"</span></span>,</span><br><span class="line">    "<span class="attribute">type</span>" : <span class="value"><span class="string">"txt"</span></span><br><span class="line">  </span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>通过苹果提供的NSJSONSerialization类，我们可以将上面的模版文件转换成 NSArray 数组，每一个数组元素是一个 NSDictionary，代表一段相同设置的文字。为了简单，我们的配置文件只支持配置颜色和字号，但是读者可以依据同样的思想，很方便地增加其它配置信息。</p>
<p>接下来我们要为CTFrameParser增加一个方法，让其可以从如上格式的模版文件中生成CoreTextData。最终我们的实现代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">+ (CoreTextData *)parseTemplateFile:(<span class="built_in">NSString</span> *)path config:(CTFrameParserConfig*)config &#123;</span><br><span class="line">    <span class="built_in">NSAttributedString</span> *content = [<span class="keyword">self</span> loadTemplateFile:path config:config];</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> parseAttributedContent:content config:config];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line">+ (<span class="built_in">NSAttributedString</span> *)loadTemplateFile:(<span class="built_in">NSString</span> *)path config:(CTFrameParserConfig*)config &#123;</span><br><span class="line">    <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:path];</span><br><span class="line">    <span class="built_in">NSMutableAttributedString</span> *result = [[<span class="built_in">NSMutableAttributedString</span> alloc] init];</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *array = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data</span><br><span class="line">                                           options:<span class="built_in">NSJSONReadingAllowFragments</span></span><br><span class="line">                                             error:<span class="literal">nil</span>];</span><br><span class="line">        <span class="keyword">if</span> ([array isKindOfClass:[<span class="built_in">NSArray</span> class]]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *dict <span class="keyword">in</span> array) &#123;</span><br><span class="line">                <span class="built_in">NSString</span> *type = dict[<span class="string">@"type"</span>];</span><br><span class="line">                <span class="keyword">if</span> ([type isEqualToString:<span class="string">@"txt"</span>]) &#123;</span><br><span class="line">                    <span class="built_in">NSAttributedString</span> *as =</span><br><span class="line">                       [<span class="keyword">self</span> parseAttributedContentFrom<span class="built_in">NSDictionary</span>:dict</span><br><span class="line">                                                             config:config];</span><br><span class="line">                    [result appendAttributedString:as];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法三</span></span><br><span class="line">+ (<span class="built_in">NSAttributedString</span> *)parseAttributedContentFrom<span class="built_in">NSDictionary</span>:(<span class="built_in">NSDictionary</span> *)dict</span><br><span class="line">                                                        config:(CTFrameParserConfig*)config &#123;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *attributes = [<span class="keyword">self</span> attributesWithConfig:config];</span><br><span class="line">    <span class="comment">// set color</span></span><br><span class="line">    <span class="built_in">UIColor</span> *color = [<span class="keyword">self</span> colorFromTemplate:dict[<span class="string">@"color"</span>]];</span><br><span class="line">    <span class="keyword">if</span> (color) &#123;</span><br><span class="line">        attributes[(<span class="keyword">id</span>)kCTForegroundColorAttributeName] = (<span class="keyword">id</span>)color<span class="variable">.CGColor</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// set font size</span></span><br><span class="line">    <span class="built_in">CGFloat</span> fontSize = [dict[<span class="string">@"size"</span>] floatValue];</span><br><span class="line">    <span class="keyword">if</span> (fontSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        CTFontRef fontRef = CTFontCreateWithName((<span class="built_in">CFStringRef</span>)<span class="string">@"ArialMT"</span>, fontSize, <span class="literal">NULL</span>);</span><br><span class="line">        attributes[(<span class="keyword">id</span>)kCTFontAttributeName] = (__bridge <span class="keyword">id</span>)fontRef;</span><br><span class="line">        <span class="built_in">CFRelease</span>(fontRef);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSString</span> *content = dict[<span class="string">@"content"</span>];</span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">NSAttributedString</span> alloc] initWithString:content attributes:attributes];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法四</span></span><br><span class="line">+ (<span class="built_in">UIColor</span> *)colorFromTemplate:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    <span class="keyword">if</span> ([name isEqualToString:<span class="string">@"blue"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">UIColor</span> blueColor];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([name isEqualToString:<span class="string">@"red"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([name isEqualToString:<span class="string">@"black"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">UIColor</span> blackColor];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法五</span></span><br><span class="line">+ (CoreTextData *)parseAttributedContent:(<span class="built_in">NSAttributedString</span> *)content config:(CTFrameParserConfig*)config &#123;</span><br><span class="line">    <span class="comment">// 创建 CTFramesetterRef 实例</span></span><br><span class="line">    CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((<span class="built_in">CFAttributedStringRef</span>)content);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得要缓制的区域的高度</span></span><br><span class="line">    <span class="built_in">CGSize</span> restrictSize = <span class="built_in">CGSizeMake</span>(config<span class="variable">.width</span>, <span class="built_in">CGFLOAT_MAX</span>);</span><br><span class="line">    <span class="built_in">CGSize</span> coreTextSize = CTFramesetterSuggestFrameSizeWithConstraints(framesetter, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>,<span class="number">0</span>), <span class="literal">nil</span>, restrictSize, <span class="literal">nil</span>);</span><br><span class="line">    <span class="built_in">CGFloat</span> textHeight = coreTextSize<span class="variable">.height</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成 CTFrameRef 实例</span></span><br><span class="line">    CTFrameRef frame = [<span class="keyword">self</span> createFrameWithFramesetter:framesetter config:config height:textHeight];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将生成好的 CTFrameRef 实例和计算好的缓制高度保存到 CoreTextData 实例中，最后返回 CoreTextData 实例</span></span><br><span class="line">    CoreTextData *data = [[CoreTextData alloc] init];</span><br><span class="line">    data<span class="variable">.ctFrame</span> = frame;</span><br><span class="line">    data<span class="variable">.height</span> = textHeight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">CFRelease</span>(frame);</span><br><span class="line">    <span class="built_in">CFRelease</span>(framesetter);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法六</span></span><br><span class="line">+ (CTFrameRef)createFrameWithFramesetter:(CTFramesetterRef)framesetter</span><br><span class="line">                                  config:(CTFrameParserConfig *)config</span><br><span class="line">                                  height:(<span class="built_in">CGFloat</span>)height &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGMutablePathRef</span> path = <span class="built_in">CGPathCreateMutable</span>();</span><br><span class="line">    <span class="built_in">CGPathAddRect</span>(path, <span class="literal">NULL</span>, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, config<span class="variable">.width</span>, height));</span><br><span class="line"></span><br><span class="line">    CTFrameRef frame = CTFramesetterCreateFrame(framesetter, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="number">0</span>), path, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">CFRelease</span>(path);</span><br><span class="line">    <span class="keyword">return</span> frame;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码主要由 6 个子方法构成：</p>
<ul>
<li>方法一用于提供对外的接口，调用方法二实现从一个 JSON 的模版文件中读取内容，然后调用方法五生成CoreTextData。</li>
<li>方法二读取 JSON 文件内容，并且调用方法三获得从NSDictionary到NSAttributedString的转换结果。</li>
<li>方法三将NSDictionary内容转换为NSAttributedString。</li>
<li>方法四提供将NSString转为UIColor的功能。</li>
<li>方法五接受一个NSAttributedString和一个config参数，将NSAttributedString转换成CoreTextData返回。</li>
<li>方法六是方法五的一个辅助函数，供方法五调用。</li>
</ul>
<p>然后我们将ViewController中的调用代码作一下更改，使其从模版文件中加载内容，如下所示：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    CTFrameParserConfig *config = [[CTFrameParserConfig alloc] init];</span><br><span class="line">    config<span class="variable">.width</span> = <span class="keyword">self</span><span class="variable">.ctView</span><span class="variable">.width</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *path = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"content"</span> ofType:<span class="string">@"json"</span>];</span><br><span class="line">    CoreTextData *data = [CTFrameParser parseTemplateFile:path config:config];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.ctView</span><span class="variable">.data</span> = data;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.ctView</span><span class="variable">.height</span> = data<span class="variable">.height</span>;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.ctView</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>最后运行得到的结果如下所示，可以看到，通过一个简单的模板文件，我们已经可以很方便地定义排版的配置信息了。</p>
<p><img src="http://tangqiao.b0.upaiyun.com/coretext/coretext-load-from-json-template.png" alt=""></p>
<p>说明：读者可以在示例工程中使用git checkout json_template，查看可以运行的示例代码。b</p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/07/17/iOS-Super-init/">
                iOS Super init
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2015-07-17
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/IOS/">IOS</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/07/17/iOS-Super-init/#comments" >
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/07/17/iOS-Super-init/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p><a href="http://www.cocoawithlove.com/2009/04/what-does-it-mean-when-you-assign-super.html" target="_blank" rel="external">转自</a></p>
<h1 id="What_does_it_mean_when_you_assign_[super_init]_to_self?">What does it mean when you assign [super init] to self?</h1><p><code>self = [super init];</code> 是 Objctive-C 语法中很奇怪的一句.</p>
<h2 id="Converting_a_method_invocation">Converting a method invocation</h2><p>首先需要了解<code>self</code>参数, 编译器是如何处理的.当你输入下面代码时</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="name">MyClass</span> *<span class="atom">myObject</span> = [[<span class="name">MyClass</span> <span class="atom">alloc</span>] <span class="atom">initWithString</span>:@<span class="string">"someString"</span>];</span><br></pre></td></tr></table></figure>
<p>编译器会转换为大致如下的代码:</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">class</span> myClass = objc_getClass(<span class="string">"MyClass"</span>);</span><br><span class="line"><span class="title">SEL</span> allocSelector = <span class="variable">@selector</span>(alloc);</span><br><span class="line"><span class="title">MyClass</span> *myObject1 = objc_msgSend(myClass, allocSelector);</span><br><span class="line"></span><br><span class="line"><span class="title">SEL</span> initSelector = <span class="variable">@selector</span>(initWithString:);</span><br><span class="line"><span class="title">MyClass</span> *myObject2 = objc_msgSend(myObject1, initSelector, @<span class="string">"someString"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="So_what_is_“self”?">So what is “self”?</h2><p>每个方法都有两个隐藏参数: <code>self</code> and <code>_cmd</code>.</p>
<p>例如:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (<span class="tag">id</span>)<span class="rule"><span class="attribute">initWithString</span>:<span class="value">(NSString *)aString</span></span>;</span><br></pre></td></tr></table></figure>
<p>会转换为:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> initWithString(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="built_in">NSString</span> *aString);</span><br></pre></td></tr></table></figure>
<p>实际上<code>self</code> 只是在每个方法中都存在的隐藏参数, 像普通参数一样, 它通过函数调用来接收数值.</p>
<p>你可以尝试将下面的方法变更为<code>objc_msgSend</code>方式来调用</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">[myObject someMethodWithParameter:someValue]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>你可以直接调用</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SEL methodSelector = <span class="annotation">@selector</span>(someMethodWithParameter:);</span><br><span class="line">IMP someMethodFunction = <span class="keyword">class</span><span class="number">_</span>getMethodImplementation([myObject <span class="keyword">class</span>], methodSelector);</span><br><span class="line">someMethodFunction(myObject, methodSelector, someValue);</span><br></pre></td></tr></table></figure>
<p><code>self</code>正是由于接收了函数<code>someMethodFunction</code>传入的第一个参数, 才拥有了实际的数值, 如果<br>你此时传入其他的数值, 很可能会造成系统崩溃.</p>
<h2 id="Why_have_a_“self”_parameter_at_all?">Why have a “self” parameter at all?</h2><p>方法需要知道它操作的数据是什么, 而<code>self</code> 正是用来告诉类它要操作的数据是什么的. 因为在运行时, <code>self</code>也即是对象本身存贮了数据, 而方法使在类中存储的. 所以方法操作数据的时候, 需要通过 <code>self</code> 指针来获取数据的具体位置.例如:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> value;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)setValueToZero;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>方法:</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setValueToZero</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">value</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换为:</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> setValueToZero(id <span class="built_in">self</span>, SEL _cmd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">self</span><span class="subst">-&gt;</span>value <span class="subst">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="So_does_self_already_have_a_value_when_init_is_called?">So does self already have a value when init is called?</h2><p>从上面的分析看, <code>initWithString</code> 是 方法调用<code>[[MyClass alloc] initWithString:@&quot;someString&quot;]</code>的一部分.</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass *myObject2 = objc_msgSend<span class="list">(<span class="keyword">myObject1</span>, initSelector, @<span class="string">"someString"</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>所以当我们进入<code>initWithString</code>方法时, <code>self</code> 已经有值<code>myObject1</code>(通过 <code>[MyClass alloc]</code>  返回的), 因为没有<code>super</code>的调用是需要<code>self</code>的,<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">[super init]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>会转换为:</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct objc<span class="number">_</span><span class="keyword">super</span> <span class="keyword">super</span> = &#123;.receiver = self, .<span class="keyword">super</span><span class="number">_</span><span class="keyword">class</span> = <span class="number">0</span>xC<span class="number">0</span>FFEE&#125;;</span><br><span class="line">objc<span class="number">_m</span>sgSendSuper(&amp;<span class="keyword">super</span>, <span class="annotation">@selector</span>(otherMethodWithArgument:), arg);</span><br></pre></td></tr></table></figure>
<h2 id="So_why_assign_the_value_returned_from_[super_init]_to_self?">So why assign the value returned from [super init] to self?</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)initWithString:(<span class="built_in">NSString</span> *)aString</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        instanceString = [aString retain];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么需要将 <code>self</code> 重新赋值为 <code>[super init]</code>, 原因为<code>[super init]</code> 会发生下面3种情况之一:</p>
<ol>
<li>Return its own receiver (the self pointer doesn’t change) with inherited instance values initialized.</li>
<li>Return a different object with inherited instance values initialized.</li>
<li>Return nil, indicating failure.</li>
</ol>
<p>第一种情况, 赋值是没有意义的, 因为 self 没有改变,  <code>instanceString</code> 是作用在原来的对象上的.<br>第三种情况, 初始化失败返回<code>nil</code>, <code>self</code> 也被赋值为<code>nil</code>并返回, 不会发生更进一步的操作.<br>第二种情况, 才是重新赋值的意义所在. 因为返回的对象改变了.</p>
<h2 id="It’s_almost_never_required_to_initialize_self">It’s almost never required to initialize self</h2><p>所以重新赋值的意义在于<code>[super init]</code>可能会返回一个不同的对象.那什么时候 会返回不同对象呢, 情况如下:</p>
<ol>
<li>Singleton object (always returns the singleton instead of any subsequent allocation)</li>
<li>Other unique objects ([NSNumber numberWithInteger:0] always returns the global “zero” object)</li>
<li>Class clusters substitute private subclasses when you initialize an instance of the superclass.</li>
<li>Classes which choose to reallocate the same (or compatible) class based on parameters passed into the initializer.</li>
</ol>
<p>除了最后一种情况外, 如果继续初始化返回的对象, 其实是错误的, 因为这个对象已经被完全初始化完毕了.<br>所以上面说的<code>[super init]</code> 可能发生的情况, 可以扩充了4种:</p>
<ol>
<li>Return its own receiver (the self pointer doesn’t change) with inherited instance values initialized.</li>
<li>Return an object of the same class, requiring further initialization.</li>
<li>Return a different object that is already completely initialized.</li>
<li>Return nil, indicating failure.</li>
</ol>
<p>上面列表中, 第二种和第三种情况是冲突的, 我们原来典型的写法<code>self = [super init]</code> 可以解决1, 2, 4等情况.<br>而可以解决1, 3, 4情况的写法为:<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (id)initWithString:(<span class="type">NSString</span> *)aString</span><br><span class="line">&#123;</span><br><span class="line">    id <span class="literal">result</span> = [super init];</span><br><span class="line">    <span class="keyword">if</span> (self == <span class="literal">result</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        instanceString = [aString retain];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为类簇, 单例和唯一对象等情况都符合第三种情况, 如此以来, 系统中大量的类放入了这种情况, 我仅知道<code>NSManagedObject</code>符合第二种情况.奇怪的是, 适用范围更广的上面的写法反而不是标准写法.</p>
<h2 id="总结">总结</h2><p>大部分情况下, 你不需要将<code>[ super init]</code> 重新赋值给<code>self</code>, 在某些情况下, 这样做更是错误的.</p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/07/17/ARC-dealloc-cxx-destruct/">
                ARC dealloc cxx_destruct
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2015-07-17
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/IOS/">IOS</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/07/17/ARC-dealloc-cxx-destruct/#comments" >
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/07/17/ARC-dealloc-cxx-destruct/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p><a href="http://blog.sunnyxx.com/2014/04/02/objc_dig_arc_dealloc/" target="_blank" rel="external">转</a></p>
<h1 id="ARC下dealloc过程及-cxx_destruct的探究">ARC下dealloc过程及.cxx_destruct的探究</h1><h2 id="我是前言">我是前言</h2><p>这次探索源自于自己一直以来对ARC的一个疑问，在MRC时代，经常写下面的代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.array</span> = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.string</span> = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// ... //</span></span><br><span class="line">    <span class="comment">// 非Objc对象内存的释放，如CFRelease(...)</span></span><br><span class="line">    <span class="comment">// ... //</span></span><br><span class="line">    [<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象析构时将内部其他对象release掉，申请的非Objc对象的内存当然也一并处理掉，最后调用super，继续将父类对象做析构。而现如今到了ARC时代，只剩下了下面的代码：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (void)<span class="tag">dealloc</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ... //</span></span><br><span class="line">    <span class="comment">// 非Objc对象内存的释放，如CFRelease(...)</span></span><br><span class="line">    <span class="comment">// ... //</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题来了：</p>
<ol>
<li>这个对象实例变量（Ivars）的释放去哪儿了？</li>
<li>没有显示的调用[super dealloc]，上层的析构去哪儿了？</li>
</ol>
<h2 id="ARC文档中对dealloc过程的解释">ARC文档中对dealloc过程的解释</h2><p><a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#dealloc" target="_blank" rel="external">llvm官方的ARC文档</a> 中对ARC下的dealloc过程做了简单说明，从中还是能找出些有用的信息：</p>
<blockquote>
<p>A class may provide a method definition for an instance method named dealloc. This method will be called after the final release of the object but before it is deallocated or any of its instance variables are destroyed. The superclass’s implementation of dealloc will be called automatically when the method returns.</p>
</blockquote>
<p>大概意思是：dealloc方法在最后一次release后被调用，但此时实例变量（Ivars）并未释放，父类的dealloc的方法将在子类dealloc方法返回后自动调用</p>
<blockquote>
<p>The instance variables for an ARC-compiled class will be destroyed at some point after control enters the dealloc method for the root class of the class. The ordering of the destruction of instance variables is unspecified, both within a single class and between subclasses and superclasses.</p>
</blockquote>
<p>理解：ARC下对象的实例变量在根类[NSObject dealloc]中释放（通常root class都是NSObject），变量释放顺序各种不确定（一个类内的不确定，子类和父类间也不确定，也就是说不用care释放顺序）</p>
<p>所以，不用主调[super dealloc]是因为自动调了，后面再说如何实现的；ARC下实例变量在根类NSObject析构时析构，下面就探究下。</p>
<hr>
<h2 id="NSObject的析构过程">NSObject的析构过程</h2><p>通过apple的runtime源码，不难发现NSObject执行<code>dealloc</code>时调用<code>_objc_rootDealloc</code>继而调用<code>object_dispose</code>随后调用<code>objc_destructInstance</code>方法，前几步都是条件判断和简单的跳转，最后的这个函数如下：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void <span class="built_in">*</span>objc_destructInstance<span class="params">(id obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="params">(obj)</span> &#123;</span><br><span class="line">        Class isa_gen = _object_getClass<span class="params">(obj)</span>;</span><br><span class="line">        class_t <span class="built_in">*</span>isa = newcls<span class="params">(isa_gen)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read all of the flags at once for performance.</span></span><br><span class="line">        bool cxx = hasCxxStructors<span class="params">(isa)</span>;</span><br><span class="line">        bool assoc = <span class="built_in">!</span>UseGC &amp;&amp; _class_instancesHaveAssociatedObjects<span class="params">(isa_gen)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This order is important.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="params">(cxx)</span> object_cxxDestruct<span class="params">(obj)</span>;</span><br><span class="line">        <span class="keyword">if</span> <span class="params">(assoc)</span> _object_remove_assocations<span class="params">(obj)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="params">(!UseGC)</span> objc_clear_deallocating<span class="params">(obj)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单明确的干了三件事：</p>
<ol>
<li>执行一个叫<code>object_cxxDestruct</code>的东西干了点什么事</li>
<li>执行<code>_object_remove_assocations</code>去除和这个对象<code>assocate</code>的对象</li>
<li>执行<code>objc_clear_deallocating</code>，清空引用计数表并清除弱引用表，将所有<code>weak</code>引用指nil（这也就是weak变量能安全置空的所在）</li>
</ol>
<p>所以，所探寻的ARC自动释放实例变量的地方就在cxxDestruct这个东西里面没跑了。</p>
<hr>
<h2 id="探寻隐藏的-cxx_destruct">探寻隐藏的.cxx_destruct</h2><p>上面找到的名为<code>object_cxxDestruct</code>的方法最终成为下面的调用：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static void object_cxxDestructFromClass<span class="params">(id obj, Class cls)</span></span><br><span class="line">&#123;</span><br><span class="line">    void <span class="params">(*dtor)</span><span class="params">(id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call cls's dtor first, then superclasses's dtors.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="params">( ; cls != NULL; cls = _class_getSuperclass<span class="params">(cls)</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="params">(!_class_hasCxxStructors<span class="params">(cls)</span>)</span> return; </span><br><span class="line">        dtor = <span class="params">(void<span class="params">(*)</span><span class="params">(id)</span>)</span></span><br><span class="line">            lookupMethodInClassAndLoadCache<span class="params">(cls, SEL_cxx_destruct)</span>;</span><br><span class="line">        <span class="keyword">if</span> <span class="params">(dtor != <span class="params">(void<span class="params">(*)</span><span class="params">(id)</span>)</span>_objc_msgForward_internal)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="params">(PrintCxxCtors)</span> &#123;</span><br><span class="line">                _objc_inform<span class="params">(<span class="string">"CXX: calling C++ destructors for class %s"</span>, </span><br><span class="line">                             _class_getName<span class="params">(cls)</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="params">(*dtor)</span><span class="params">(obj)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码也不难理解，沿着继承链逐层向上搜寻SEL_cxx_destruct这个selector，找到函数实现(void (*)(id)(函数指针)并执行。<br>搜索这个selector的声明，发现是名为.cxx_destruct的方法，以点开头的名字，我想和unix的文件一样，是有隐藏属性的</p>
<p>从<a href="http://my.safaribooksonline.com/book/programming/objective-c/9780132908641/3dot-memory-management/ch03" target="_blank" rel="external">这篇文章</a>中：</p>
<blockquote>
<p>ARC actually creates a -.cxx_destruct method to handle freeing instance variables. This method was originally created for calling C++ destructors automatically when an object was destroyed.</p>
</blockquote>
<p>和《Effective Objective-C 2.0》中提到的：</p>
<blockquote>
<p>When the compiler saw that an object contained C++ objects, it would generate a method called .cxx_destruct. ARC piggybacks on this method and emits the required cleanup code within it.</p>
</blockquote>
<p>可以了解到，<code>.cxx_destruct</code>方法原本是为了C++对象析构的，ARC借用了这个方法插入代码实现了自动内存释放的工作</p>
<h2 id="通过实验找出-cxx_destruct">通过实验找出.cxx_destruct</h2><p>最好的办法还是写个测试代码把这个隐藏的方法找出来，其实在runtime中运行已经没什么隐藏可言了，简单的类结构如下：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">Father </span>: NSObject</span><br><span class="line"><span class="variable">@property</span> (nonatomic, copy) NSString *name;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">Son </span>: Father</span><br><span class="line"><span class="variable">@property</span> (nonatomic, copy) NSArray *toys;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<p>只有两个简单的属性，找个地方写简单的测试代码：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// before new</span></span><br><span class="line">    Son *son = [Son <span class="keyword">new</span>];</span><br><span class="line">    son.name = @<span class="string">"sark"</span>;</span><br><span class="line">    son.toys = @[@<span class="string">"sunny"</span>, @<span class="string">"xx"</span>];</span><br><span class="line">    <span class="comment">// after new</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// gone</span></span><br></pre></td></tr></table></figure>
<p>主要目的是为了让这个对象走<code>dealloc</code>方法，新建的son对象过了大括号作用域就会释放了，所以在<code>after new</code>这行son对象初始化完成，在<code>gone</code>这行son对象被dealloc</p>
<p>个人一直喜欢使用<a href="https://github.com/garnett/DLIntrospection" target="_blank" rel="external">NSObject+DLIntrospection</a>这个扩展作为调试工具，可以轻松打出一个类的方法，变量等等。</p>
<p>将这个扩展引入工程内，在<code>after new</code>处设置一个断点，run，trigger后使用lldb命令用这个扩展输出Son类所有的方法名：</p>
<p><img src="http://ww3.sinaimg.cn/large/51530583gw1ef27srhw7lj208b05ujrq.jpg" alt=""></p>
<p>发现了这个<code>.cxx_destruct</code>方法，经过几次试验，发现：</p>
<ol>
<li>只有在ARC下这个方法才会出现（试验代码的情况下）</li>
<li>只有当前类拥有实例变量时（不论是不是用property）这个方法才会出现，且父类的实例变量不会导致子类拥有这个方法</li>
<li>出现这个方法和变量是否被赋值，赋值成什么没有关系</li>
</ol>
<h2 id="使用watchpoint定位内存释放时刻">使用watchpoint定位内存释放时刻</h2><p>依然在after new断点处，输入lldb命令：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watchpoint <span class="built_in">set</span> <span class="built_in">variable</span> son<span class="subst">-&gt;</span>_name</span><br></pre></td></tr></table></figure></p>
<p>将name的变量加入<code>watchpoint</code>，当这个变量被修改时会触发trigger：</p>
<p><img src="http://ww3.sinaimg.cn/large/51530583gw1ef28rn41lcj20fs03aq3b.jpg" alt=""></p>
<p>从中可以看出，在这个时刻，<code>_name</code>从0x00006b98变成了0x0，也就是nil，赶紧看下调用栈：</p>
<p><img src="http://ww1.sinaimg.cn/large/51530583gw1ef2911o40zj20a605yweu.jpg" alt=""></p>
<p>发现果然跟到了<code>.cxx_destruct</code>方法，而且是在objc_storeStrong的过程中释放</p>
<h1 id="刨根问底-cxx_destruct">刨根问底.cxx_destruct</h1><p>知道了ARC下对象实例变量的释放过程在<code>.cxx_destruct</code>内完成，但这个函数内部发生了什么，是如何调用<code>objc_storeStrong</code>释放变量的呢？<br>从上面的探究中知道，<code>.cxx_destruct</code>是编译器生成的代码，那它很可能在clang前端编译时完成，这让我联想到clang的Code Generation，因为之前曾经使用<code>clang -rewrite-objc xxx.m</code>时查看过官方文档留下了些印象，于是google：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.cxx_destruct</span> site:clang<span class="class">.llvm</span><span class="class">.org</span></span><br></pre></td></tr></table></figure></p>
<p>结果发现clang的doxygen文档中<code>CodeGenModule</code>模块正是这部分的实现代码，cxx相关的代码生成部分源码在<br><a href="http://clang.llvm.org/doxygen/CodeGenModule_8cpp-source.html" target="_blank" rel="external">http://clang.llvm.org/doxygen/CodeGenModule_8cpp-source.html</a><br>位于1827行，删减掉离题部分如下：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// EmitObjCIvarInitializations - Emit information for ivar initialization</span></span><br><span class="line"><span class="comment">/// for an implementation.</span></span><br><span class="line">void CodeGenModule::EmitObjCIvarInitializations<span class="params">(ObjCImplementationDecl *D)</span> </span><br><span class="line">&#123;</span><br><span class="line">    DeclContext<span class="built_in">*</span> DC = const_cast&lt;DeclContext<span class="built_in">*</span>&gt;<span class="params">(dyn_cast&lt;DeclContext&gt;<span class="params">(D)</span>)</span>;</span><br><span class="line">    assert<span class="params">(DC &amp;&amp; <span class="string">"EmitObjCIvarInitializations - null DeclContext"</span>)</span>;</span><br><span class="line">    IdentifierInfo <span class="built_in">*</span>II = &amp;getContext<span class="params">()</span>.Idents.get<span class="params">(<span class="string">".cxx_destruct"</span>)</span>;</span><br><span class="line">    Selector cxxSelector = getContext<span class="params">()</span>.Selectors.getSelector<span class="params">(<span class="number">0</span>, &amp;II)</span>;</span><br><span class="line">    ObjCMethodDecl <span class="built_in">*</span>DTORMethod = ObjCMethodDecl::Create<span class="params">(getContext<span class="params">()</span>, </span><br><span class="line">                                                        D-&gt;getLocation<span class="params">()</span>,</span><br><span class="line">                                                        D-&gt;getLocation<span class="params">()</span>, cxxSelector,</span><br><span class="line">                                                        getContext<span class="params">()</span>.VoidTy, <span class="number">0</span>, </span><br><span class="line">                                                        DC, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>,</span><br><span class="line">                                                        ObjCMethodDecl::Required)</span>;</span><br><span class="line">   D-&gt;addInstanceMethod<span class="params">(DTORMethod)</span>;</span><br><span class="line">   CodeGenFunction<span class="params">(*this)</span>.GenerateObjCCtorDtorMethod<span class="params">(D, DTORMethod, <span class="literal">false</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数大概作用是：获取.<code>cxx_destruct</code>的selector，创建Method，并加入到这个Class的方法列表中，最后一行的调用才是真的创建这个方法的实现。这个方法位于<br><a href="http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html" target="_blank" rel="external">http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html</a></p>
<p>1354行，包含了构造和析构的cxx方法，继续跟随<code>.cxx_destruct</code>，最终调用<code>emitCXXDestructMethod</code>函数，代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> emitCXXDestructMethod(CodeGenFunction &amp;<span class="built_in">CGF</span>, Obj<span class="built_in">CImplementationDecl</span> *impl) </span><br><span class="line">&#123;</span><br><span class="line">   CodeGenFunction::RunCleanupsScope scope(<span class="built_in">CGF</span>);</span><br><span class="line"> </span><br><span class="line">   llvm::Value *<span class="keyword">self</span> = <span class="built_in">CGF</span><span class="variable">.LoadObjCSelf</span>();</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">const</span> Obj<span class="built_in">CInterfaceDecl</span> *iface = impl-&gt;getClassInterface();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">const</span> Obj<span class="built_in">CIvarDecl</span> *ivar = iface-&gt;all_declared_ivar_begin(); ivar; ivar = ivar-&gt;getNextIvar()) </span><br><span class="line">   &#123;</span><br><span class="line">     QualType type = ivar-&gt;getType();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Check whether the ivar is a destructible type.</span></span><br><span class="line">     QualType::DestructionKind dtorKind = type<span class="variable">.isDestructedType</span>();</span><br><span class="line">     <span class="keyword">if</span> (!dtorKind) <span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line">     CodeGenFunction::Destroyer *destroyer = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// Use a call to objc_storeStrong to destroy strong ivars, for the</span></span><br><span class="line">     <span class="comment">// general benefit of the tools.</span></span><br><span class="line">     <span class="keyword">if</span> (dtorKind == QualType::DK_objc_strong_lifetime) &#123;</span><br><span class="line">       destroyer = destroyARCStrongWithStore;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// Otherwise use the default for the destruction kind.</span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       destroyer = <span class="built_in">CGF</span><span class="variable">.getDestroyer</span>(dtorKind);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     CleanupKind cleanupKind = <span class="built_in">CGF</span><span class="variable">.getCleanupKind</span>(dtorKind);</span><br><span class="line">     <span class="built_in">CGF</span><span class="variable">.EHStack</span><span class="variable">.pushCleanup</span>&lt;DestroyIvar&gt;(cleanupKind, <span class="keyword">self</span>, ivar, destroyer,</span><br><span class="line">                                          cleanupKind &amp; EHCleanup);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   assert(scope<span class="variable">.requiresCleanups</span>() &amp;&amp; <span class="string">"nothing to do in .cxx_destruct?"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析这段代码以及其中调用后发现：它遍历当前对象所有的实例变量（Ivars)，调用<code>objc_storeStrong</code>，从clang的ARC文档上可以找到<code>objc_storeStrong</code>的示意代码实现如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">id <span class="title">objc_storeStrong</span>(<span class="params">id *<span class="keyword">object</span>, id <span class="keyword">value</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">value</span> = [<span class="keyword">value</span> retain];</span><br><span class="line">  id oldValue = *<span class="keyword">object</span>;</span><br><span class="line">  *<span class="keyword">object</span> = <span class="keyword">value</span>;</span><br><span class="line">  [oldValue release];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>.cxx_destruct</code>进行形如<code>objc_storeStrong(&amp;ivar, null)</code>的调用后，这个实例变量就被release和设置成nil了<br>注：真实的实现可以参考 <a href="http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html" target="_blank" rel="external">http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html</a> 2078行</p>
<h2 id="自动调用[super_dealloc]的实现">自动调用[super dealloc]的实现</h2><p>按照上面的思路，自动调用<code>[super dealloc]</code>也一定是CodeGen干的工作了<br>位于 <a href="http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html" target="_blank" rel="external">http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html</a> 492行<br><code>StartObjCMethod</code>方法中：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="params">(ident-&gt;isStr<span class="params">(<span class="string">"dealloc"</span>)</span>)</span></span><br><span class="line">   EHStack.pushCleanup&lt;FinishARCDealloc&gt;<span class="params">(getARCCleanupKind<span class="params">()</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码可以得知在调用<code>dealloc</code>方法时被插入了代码，由FinishARCDealloc结构定义：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="type">FinishARCDealloc</span> : <span class="type">EHScopeStack</span>::<span class="type">Cleanup</span> &#123;</span><br><span class="line">   <span class="type">void</span> <span class="type">Emit</span>(<span class="type">CodeGenFunction</span> &amp;<span class="type">CGF</span>, <span class="type">Flags</span> flags) override &#123;</span><br><span class="line">     <span class="keyword">const</span> <span class="type">ObjCMethodDecl</span> *<span class="keyword">method</span> = <span class="keyword">cast</span>&lt;<span class="type">ObjCMethodDecl</span>&gt;(<span class="type">CGF</span>.<span class="type">CurCodeDecl</span>);</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">const</span> <span class="type">ObjCImplDecl</span> *impl = <span class="keyword">cast</span>&lt;<span class="type">ObjCImplDecl</span>&gt;(<span class="keyword">method</span>-&gt;getDeclContext());</span><br><span class="line">     <span class="keyword">const</span> <span class="type">ObjCInterfaceDecl</span> *iface = impl-&gt;getClassInterface();</span><br><span class="line">     <span class="keyword">if</span> (!iface-&gt;getSuperClass()) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">     <span class="type">bool</span> isCategory = isa&lt;<span class="type">ObjCCategoryImplDecl</span>&gt;(impl);</span><br><span class="line"> </span><br><span class="line">     // <span class="type">Call</span> [super dealloc] <span class="keyword">if</span> we have a superclass.</span><br><span class="line">     llvm::<span class="type">Value</span> *self = <span class="type">CGF</span>.<span class="type">LoadObjCSelf</span>();</span><br><span class="line"> </span><br><span class="line">     <span class="type">CallArgList</span> args;</span><br><span class="line">     <span class="type">CGF</span>.<span class="type">CGM</span>.getObjCRuntime().<span class="type">GenerateMessageSendSuper</span>(<span class="type">CGF</span>, <span class="type">ReturnValueSlot</span>(),</span><br><span class="line">                                                       <span class="type">CGF</span>.getContext().<span class="type">VoidTy</span>,</span><br><span class="line">                                                       <span class="keyword">method</span>-&gt;getSelector(),</span><br><span class="line">                                                       iface,</span><br><span class="line">                                                       isCategory,</span><br><span class="line">                                                       self,</span><br><span class="line">                                                       /*<span class="keyword">is</span> class msg*/ <span class="literal">false</span>,</span><br><span class="line">                                                       args,</span><br><span class="line">                                                       <span class="keyword">method</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码基本上就是向父类转发dealloc的调用，实现了自动调用[super dealloc]方法。</p>
<h2 id="总结">总结</h2><ol>
<li>ARC下对象的成员变量于编译器插入的.cxx_desctruct方法自动释放</li>
<li>ARC下[super dealloc]方法也由编译器自动插入</li>
<li>所谓编译器插入代码过程需要进一步了解，还不清楚其运作方式</li>
<li>clang的CodeGen也值得深入研究一下</li>
</ol>
<h2 id="References：">References：</h2><p><a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html" target="_blank" rel="external">http://clang.llvm.org/docs/AutomaticReferenceCounting.html</a><br><a href="http://my.safaribooksonline.com/book/programming/objective-c/9780132908641/3dot-memory-management/ch03" target="_blank" rel="external">http://my.safaribooksonline.com/book/programming/objective-c/9780132908641/3dot-memory-management/ch03</a><br><a href="http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html" target="_blank" rel="external">http://clang.llvm.org/doxygen/CGObjC_8cpp_source.html</a></p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/07/17/ios-attribute-cleanup/">
                ios attribute cleanup
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2015-07-17
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/IOS/">IOS</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/07/17/ios-attribute-cleanup/#comments" >
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/07/17/ios-attribute-cleanup/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p><a href="http://blog.sunnyxx.com/2014/09/15/objc-attribute-cleanup/" target="_blank" rel="external">转自</a></p>
<h2 id="黑魔法attribute((cleanup))">黑魔法<strong>attribute</strong>((cleanup))</h2><p>编译器属性<strong>attribute</strong>用于向编译器描述特殊的标识、检查或优化，几个常用的用法看<a href="http://nshipster.com/__attribute__/" target="_blank" rel="external">mattt大神的文章</a>就好。今天发现一个名为cleanup的黑魔法属性，简单介绍下。</p>
<h3 id="基本用法">基本用法</h3><p><code>__attribute__((cleanup(...)))</code>，用于修饰一个变量，在它的作用域结束时可以自动执行一个指定的方法，如：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定一个cleanup方法，注意入参是所修饰变量的地址，类型要一样</span></span><br><span class="line"><span class="comment">// 对于指向objc对象的指针(id *)，如果不强制声明__strong默认是__autoreleasing，造成类型不匹配</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> stringCleanUp(__<span class="keyword">strong</span> <span class="built_in">NSString</span> **string) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, *string);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在某个方法中：</span></span><br><span class="line">&#123;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="built_in">NSString</span> *string __attribute__((cleanup(stringCleanUp))) = <span class="string">@"sunnyxx"</span>;</span><br><span class="line">&#125; <span class="comment">// 当运行到这个作用域结束时，自动调用stringCleanUp</span></span><br></pre></td></tr></table></figure>
<p>所谓作用域结束，包括大括号结束、return、goto、break、exception等各种情况。<br>当然，可以修饰的变量不止NSString，自定义Class或基本类型都是可以的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义的Class</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> sarkCleanUp(__<span class="keyword">strong</span> Sark **sark) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, *sark);</span><br><span class="line">&#125;</span><br><span class="line">__<span class="keyword">strong</span> Sark *sark __attribute__((cleanup(sarkCleanUp))) = [Sark new];</span><br><span class="line"><span class="comment">// 基本类型</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> intCleanUp(<span class="built_in">NSInteger</span> *integer) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, *integer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSInteger</span> integer __attribute__((cleanup(intCleanUp))) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>假如一个作用域内有若干个cleanup的变量，他们的调用顺序是先入后出的栈式顺序；<br>而且，cleanup是先于这个对象的dealloc调用的。</p>
<h3 id="进阶用法">进阶用法</h3><p>既然<code>__attribute__((cleanup(...)))</code>可以用来修饰变量，block当然也是其中之一，写一个block的cleanup函数非常有趣：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// <span class="type">void</span>(^<span class="keyword">block</span>)(<span class="type">void</span>)的指针是<span class="type">void</span>(^*<span class="keyword">block</span>)(<span class="type">void</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> blockCleanUp(__strong <span class="type">void</span>(^*<span class="keyword">block</span>)(<span class="type">void</span>)) &#123;</span><br><span class="line">    (*<span class="keyword">block</span>)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是在一个作用域里声明一个block：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 加了个`unused`的attribute用来消除`unused variable`的warning</span></span><br><span class="line">    __strong void<span class="params">(^block)</span><span class="params">(void)</span> __attribute__<span class="params">(<span class="params">(cleanup<span class="params">(blockCleanUp)</span>, unused)</span>)</span> = ^&#123;</span><br><span class="line">        NSLog<span class="params">(@<span class="string">"I'm dying..."</span>)</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="comment">// 这里输出"I'm dying..."</span></span><br></pre></td></tr></table></figure>
<p>这里不得不提万能的<code>Reactive Cocoa</code>中神奇的<code>@onExit</code>方法，其实正是上面的写法，简单定义个宏：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hexcolor">#def</span>ine onExit\</span><br><span class="line">    __strong <span class="function"><span class="title">void</span><span class="params">(^block)</span><span class="params">(void)</span></span> __attribute__((<span class="function"><span class="title">cleanup</span><span class="params">(blockCleanUp)</span></span>, unused)) = ^</span><br></pre></td></tr></table></figure>
<p>用这个宏就能将一段写在前面的代码最后执行：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    onExit &#123;</span><br><span class="line">        <span class="function">NSLog</span>(<span class="at_rule">@<span class="string">"yo"</span>);</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="comment">// Log "yo"</span></span><br></pre></td></tr></table></figure>
<p>这样的写法可以将成对出现的代码写在一起，比如说一个lock：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSRecursiveLock</span> *aLock = [[<span class="built_in">NSRecursiveLock</span> alloc] init];</span><br><span class="line">[aLock lock];</span><br><span class="line"><span class="comment">// 这里</span></span><br><span class="line"><span class="comment">//     有</span></span><br><span class="line"><span class="comment">//        100多万行</span></span><br><span class="line">[aLock unlock]; <span class="comment">// 看到这儿的时候早忘了和哪个lock对应着了</span></span><br></pre></td></tr></table></figure>
<p>用了<code>onExit</code>之后，代码更集中了：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSRecursiveLock</span> *aLock = [[<span class="built_in">NSRecursiveLock</span> alloc] init];</span><br><span class="line">[aLock lock];</span><br><span class="line">onExit &#123;</span><br><span class="line">    [aLock unlock]; <span class="comment">// 妈妈再也不用担心我忘写后半段了</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这里</span></span><br><span class="line"><span class="comment">//    爱多少行</span></span><br><span class="line"><span class="comment">//           就多少行</span></span><br></pre></td></tr></table></figure>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/07/17/ios-arc-dig/">
                ios arc dig
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2015-07-17
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/IOS/">IOS</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/07/17/ios-arc-dig/#comments" >
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/07/17/ios-arc-dig/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p><a href="http://blog.sunnyxx.com/2014/03/15/objc_arc_secret/" target="_blank" rel="external">转自</a></p>
<h2 id="objc_arc的简单探索">objc arc的简单探索</h2><h3 id="ARC_or_not？">ARC or not？</h3><p><code>Automatic Reference Counting</code>是objc发展以来相当重要的一个进步</p>
<blockquote>
<p>对于开发者，任何能降低开发难度，简化代码的功能，我们都应该去了解和使用。<br>我们应该利用一切“偷懒”的机会，将软件开发的复杂度分解并控制在一个个小的范围内，使得对于分解后的每一个小的任务，都能被新手掌握和维护。</p>
</blockquote>
<p>基于简化开发的思想来看，ARC绝对是一个<strong>没理由拒绝</strong>的技术进步。<br>ARC随着iOS5问世，到现在iOS8都快出了，你还在手动写retain，release么？除了固守思想外，对ARC的恐惧大都来自对它的未知。</p>
<p>比如我在公司尝试说服team使用ARC时被质疑的几个问题：</p>
<ol>
<li><p>ARC和Java的GC一样，会导致一部分性能损耗？<br>首先，ARC和GC是两码事，ARC是编译时编译器“帮你”插入了原本需要自己手写的内存管理代码，而非像GC一样运行时的垃圾回收系统</p>
</li>
<li><p>ARC内存不知道什么时候释放，导致不可控的内存涨落？<br>了解ARC的原理后，就知道，ARC下编译器插入的内存管理的代码是经过优化的，对于使用完的内存，多运行一行代码都不会浪费，可以这么说，手写的内存管理必须达到很严谨的水平才可能达到ARC自动生成的一样完整且没有疏漏</p>
</li>
<li><p>ARC下面自己不管理内存，很不爽，很没有安全感<br>这纯粹是习惯的问题了，开发者的目标是用最简化的手段完成一个最可靠的程序，进步需要改变的。好在编译选项中提供了<code>-fobjc-arc</code>和<code>-fno-objc-arc</code>来保证整个的变革的继续下去，就像社会主义中国里的港澳</p>
</li>
</ol>
<h3 id="ARC的约定">ARC的约定</h3><p>使用ARC之后一个费解的地方是，一个方法生成的对象，没有任何附加标示，ARC怎么知道生成的对象是不是<code>autorelease</code>的呢？</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@interface</span> <span class="string">Sark :</span> NSObject</span><br><span class="line">+ (instancetype)<span class="string">sarkWithMark:</span>(NSString *)mark; <span class="comment">// 1</span></span><br><span class="line">- (instancetype)<span class="string">initWithMark:</span>(NSString *)mark; <span class="comment">// 2</span></span><br><span class="line"><span class="annotation">@end</span></span><br></pre></td></tr></table></figure>
<p>这是非ARC时常用的手段，1生成autorelease对象，2生成普通对象，而现在ARC不能调用autorelease，使用时怎么能知道呢？</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">&#123;</span><br><span class="line">    // ...</span><br><span class="line">    Sark *sark1 = <span class="collection">[Sark sarkWithMark:@<span class="string">"萨萨萨"</span>]</span><span class="comment">;</span></span><br><span class="line">    Sark *sark2 = <span class="collection">[<span class="collection">[Sark alloc]</span> initWithMark:@<span class="string">"萨萨萨"</span>]</span><span class="comment">;</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>使用约定，NS定义了下面三个编译属性</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hexcolor">#def</span>ine NS_RETURNS_RETAINED __attribute__((ns_returns_retained))</span><br><span class="line"><span class="hexcolor">#def</span>ine NS_RETURNS_NOT_RETAINED __attribute__((ns_returns_not_retained))</span><br><span class="line"><span class="hexcolor">#def</span>ine NS_RETURNS_INNER_POINTER __attribute__((objc_returns_inner_pointer))</span><br></pre></td></tr></table></figure>
<p>这三个属性是Clang自己使用的标示，除非<strong>特殊情况</strong>不要自己使用，但是这些对理解ARC是很有帮助的。<br>这里还要介绍一个概念，<code>Method family</code></p>
<blockquote>
<p>An Objective-C method may fall into a method family, which is a conventional set of behaviors ascribed to it by the Cocoa conventions.</p>
</blockquote>
<p>指的是命名上表示一类型的方法，比如<code>- init</code>和<code>- initWithMark:</code>都属于init的family<br>于是乎，编译器约定，对于<code>alloc</code>, <code>init</code>, <code>copy</code>, <code>mutableCopy</code>, <code>new</code>这几个家族的方法，后面默认加<code>NS_RETURNS_RETAINED</code>标识；而其他不指名标识的family的方法默认添加<code>NS_RETURNS_NOT_RETAINED</code>标识<br>也就是说刚才的方法，在编译器看来是这样的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Sark</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (instancetype)sarkWithMark:(<span class="built_in">NSString</span> *)mark <span class="built_in">NS_RETURNS_NOT_RETAINED</span>; <span class="comment">// 1</span></span><br><span class="line">- (instancetype)initWithMark:(<span class="built_in">NSString</span> *)mark <span class="built_in">NS_RETURNS_RETAINED</span>; <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>这也就是为什么ARC下面，不能把一个属性定义成名字是这样的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *newString; <span class="comment">// 编译器不允许</span></span><br></pre></td></tr></table></figure>
<p><code>- newString</code>就成了new家族的方法，内存就不对了<br>对于<code>NS_RETURNS_INNER_POINTER</code>这货，主要使用在返回的是一个对象的内部C指针的情况，如NSString的方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (__<span class="keyword">strong</span> <span class="keyword">const</span> <span class="keyword">char</span> *)UTF8String <span class="built_in">NS_RETURNS_INNER_POINTER</span>;</span><br></pre></td></tr></table></figure>
<p>就使用了这个标识，这个就不深入研究了，直接上文档：</p>
<blockquote>
<p>An Objective-C method returning a non-retainable pointer may be annotated with the objc_returns_inner_pointer attribute to indicate that it returns a handle to the internal data of an object, and that this reference will be invalidated if the object is destroyed. When such a message is sent to an object, the object’s lifetime will be extended until at least the earliest of:<br>the last use of the returned pointer, or any pointer derived from it, in the calling function or<br>the autorelease pool is restored to a previous state.</p>
</blockquote>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
  </div>

  
  <div class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/">&laquo;</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/4/">&raquo;</a>
  </div>


        </div>

        
      </div>


      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <div class="site-overview">
        <div class="site-author motion-element">
          <img class="site-author-image" src="/avatar.png" alt="Yt" />
          <p class="site-author-name">Yt</p>
        </div>
        <p class="site-description motion-element">notes for study</p>
        <div class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">160</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">27</span>
              <span class="site-state-item-name">分類</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">73</span>
              <span class="site-state-item-name">標籤</span>
              </a>
          </div>

        </div>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml">
              <i class="menu-item-icon icon-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
              <a href="https://github.com/ytlvy" target="_blank">GitHub</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="https://twitter.com/ytlvy" target="_blank">Twitter</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://nshipster.com" target="_blank">NSHipster</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://www.mikeash.com/pyblog" target="_blank">NSBlog</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://www.objc.io" target="_blank">objcio</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://www.raywenderlich.com" target="_blank">raywenderlich</a>
            </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

      </div>

      

    </div>
  </div>


    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp; 
  2015
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">Yt</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>



<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<div class="theme-info">
  <span id="busuanzi_container_site_uv">
    &nbsp&nbsp&nbsp&nbsp|&nbsp&nbsp Total <span id="busuanzi_value_site_pv"><i class="fa fa-spinner fa-spin"></i></span> views.
您是本站的第<span id="busuanzi_value_site_uv"><i class="fa fa-spinner fa-spin"></i></span>个小伙伴
<span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span> Hits
  </span>
<div>
      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js"></script>


  <script type="text/javascript" src="/js/helpers.js"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js" id="motion.global"></script>




  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
    });
  </script>

  

  
  
  

  

    
      
    

    <script type="text/javascript">
      var disqus_shortname = 'ytlvy';
      var disqus_identifier = 'page/3/index.html';
      var disqus_title = '';
      var disqus_url = '';

      (function(){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }());
    </script>
  




  
  

</body>
</html>
